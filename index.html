<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Adam">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Adam">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Adam Blog">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Adam</title>
  <meta name="referrer" content="no-referrer" />
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Adam</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/26/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/26/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-26 01:04:54" itemprop="dateCreated datePublished" datetime="2021-04-26T01:04:54+08:00">2021-04-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/26/yuque/Tree-Shaking/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/26/yuque/Tree-Shaking/" class="post-title-link" itemprop="url">Tree-Shaking</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-26 01:04:35 / 修改时间：01:05:34" itemprop="dateCreated datePublished" datetime="2021-04-26T01:04:35+08:00">2021-04-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一-什么是-Tree-shaking"><a href="#一-什么是-Tree-shaking" class="headerlink" title="一. 什么是 Tree-shaking"></a>一. 什么是 Tree-shaking</h2><p><img src="1.jpg#alt=img"></p>
<p>先来看一下 Tree-shaking 原始的本意</p>
<p><img src="2.gif#alt=img"></p>
<p>上图形象的解释了 Tree-shaking 的本意，本文所说的前端中的 tree-shaking 可以理解为通过工具”摇”我们的 JS 文件，将其中用不到的代码”摇”掉，是一个性能优化的范畴。具体来说，在 webpack 项目中，有一个入口文件，相当于一棵树的主干，入口文件有很多依赖的模块，相当于树枝。实际情况中，虽然依赖了某个模块，但其实只使用其中的某些功能。通过 tree-shaking，将没有使用的模块摇掉，这样来达到删除无用代码的目的。</p>
<p><img src="3.jpg#alt=img"></p>
<p>Tree-shaking 较早由 Rich_Harris 的 rollup 实现，后来，webpack2 也增加了 tree-shaking 的功能。其实在更早，google closure compiler 也做过类似的事情。三个工具的效果和使用各不相同，使用方法可以通过官网文档去了解，三者的效果对比，后文会详细介绍。</p>
<h2 id="二-tree-shaking-的原理"><a href="#二-tree-shaking-的原理" class="headerlink" title="二. tree-shaking 的原理"></a>二. tree-shaking 的原理</h2><p><img src="4.jpg#alt=img"></p>
<p>Tree-shaking 的本质是消除无用的 js 代码。无用代码消除在广泛存在于传统的编程语言编译器中，编译器可以判断出某些代码根本不影响输出，然后消除这些代码，这个称之为 DCE（dead code elimination）。</p>
<p>Tree-shaking 是 DCE 的一种新的实现，Javascript 同传统的编程语言不同的是，javascript 绝大多数情况需要通过网络进行加载，然后执行，加载的文件大小越小，整体执行时间更短，所以去除无用代码以减少文件体积，对 javascript 来说更有意义。</p>
<p>Tree-shaking 和传统的 DCE 的方法又不太一样，传统的 DCE 消灭不可能执行的代码，而 Tree-shaking 更关注宇消除没有用到的代码。下面详细介绍一下 DCE 和 Tree-shaking。</p>
<p><strong>（1）先来看一下 DCE 消除大法</strong></p>
<p><img src="5.jpg#alt=img"></p>
<p>Dead Code 一般具有以下几个特征</p>
<p>•代码不会被执行，不可到达</p>
<p>•代码执行的结果不会被用到</p>
<p>•代码只会影响死变量（只写不读）</p>
<p>下面红框标示的代码就属于死码，满足以上特征</p>
<p><img src="6.jpg#alt=img"></p>
<p>图 4</p>
<p>传统编译型的语言中，都是由编译器将 Dead Code 从 AST（抽象语法树）中删除，那 javascript 中是由谁做 DCE 呢？</p>
<p>首先肯定不是浏览器做 DCE，因为当我们的代码送到浏览器，那还谈什么消除无法执行的代码来优化呢，所以肯定是送到浏览器之前的步骤进行优化。</p>
<p>其实也不是上面提到的三个工具，rollup，webpack，cc 做的，而是著名的代码压缩优化工具 uglify，uglify 完成了 javascript 的 DCE，下面通过一个实验来验证一下。</p>
<blockquote>
<p>以下所有的示例代码都能在我们的 github 中找到，欢迎戳 ❤</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/lin-xi/treeshaking/tree/master/rollup-webpack">https://github.com/lin-xi/treeshaking/tree/master/rollup-webpack</a></p>
<p><strong>分别用 rollup 和 webpack 将图 4 中的代码进行打包</strong></p>
<p><img src="7.jpg#alt=img"></p>
<p>图 5</p>
<p>中间是 rollup 打包的结果，右边是 webpack 打包的结果</p>
<p>可以发现，rollup 将无用的代码 foo 函数和 unused 函数消除了，但是仍然保留了不会执行到的代码，而 webpack 完整的保留了所有的无用代码和不会执行到的代码。</p>
<p><strong>分别用 rollup + uglify 和 webpack + uglify 将图 4 中的代码进行打包</strong></p>
<p><img src="8.jpg#alt=img"></p>
<p>图 6</p>
<p>中间是配置文件，右侧是结果</p>
<p>可以看到右侧最终打包结果中都去除了无法执行到的代码，结果符合我们的预期。</p>
<p><strong>(2) 再来看一下 Tree-shaking 消除大法</strong></p>
<p>前面提到了 tree-shaking 更关注于无用模块的消除，消除那些引用了但并没有被使用的模块。</p>
<p>先思考一个问题，为什么 tree-shaking 是最近几年流行起来了？而前端模块化概念已经有很多年历史了，其实 tree-shaking 的消除原理是依赖于 ES6 的模块特性。</p>
<p><img src="9.jpg#alt=img"></p>
<p>ES6 module 特点：</p>
<ul>
<li>只能作为模块顶层的语句出现</li>
<li>import 的模块名只能是字符串常量</li>
<li>import binding 是 immutable 的</li>
</ul>
<p>ES6 模块依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析，这就是 tree-shaking 的基础。</p>
<p>所谓静态分析就是不执行代码，从字面量上对代码进行分析，ES6 之前的模块化，比如我们可以动态 require 一个模块，只有执行后才知道引用的什么模块，这个就不能通过静态分析去做优化。</p>
<p>这是 ES6 modules 在设计时的一个重要考量，也是为什么没有直接采用 CommonJS，正是基于这个基础上，才使得 tree-shaking 成为可能，这也是为什么 rollup 和 webpack 2 都要用 ES6 module syntax 才能 tree-shaking。</p>
<p>我们还是通过例子来详细了解一下</p>
<p>面向过程编程函数和面向对象编程是 javascript 最常用的编程模式和代码组织方式，从这两个方面来实验：</p>
<ul>
<li>函数消除实验</li>
<li>类消除实验</li>
</ul>
<p><strong>先看下函数消除实验</strong></p>
<p>utils 中 get 方法没有被使用到，我们期望的是 get 方法最终被消除。</p>
<p><img src="10.jpg#alt=img"></p>
<p>注意，uglify 目前不会跨文件去做 DCE，所以上面这种情况，uglify 是不能优化的。</p>
<p><strong>先看看 rollup 的打包结果</strong></p>
<p><img src="11.jpg#alt=img"></p>
<p>完全符合预期，最终结果中没有 get 方法</p>
<p><strong>再看看 webpack 的结果</strong></p>
<p><img src="12.jpg#alt=img"></p>
<p>也符合预期，最终结果中没有 get 方法</p>
<p>可以看到 rollup 打包的结果比 webpack 更优化</p>
<blockquote>
<p>函数消除实验中，rollup 和 webpack 都通过，符合预期</p>
</blockquote>
<p><strong>再来看下类消除实验</strong></p>
<p>增加了对 menu.js 的引用，但其实代码中并没有用到 menu 的任何方法和变量，所以我们的期望是，最终代码中 menu.js 里的内容被消除</p>
<p><img src="13.jpg#alt=img"></p>
<p>main.js</p>
<p><img src="14.jpg#alt=img"></p>
<p>menu.js</p>
<p><strong>rollup 打包结果</strong></p>
<p><img src="15.jpg#alt=img"></p>
<p>包中竟然包含了 menu.js 的全部代码</p>
<p><strong>webpack 打包结果</strong></p>
<p><img src="16.jpg#alt=img"></p>
<p>包中竟然也包含了 menu.js 的全部代码</p>
<blockquote>
<p>类消除实验中，rollup，webpack 全军覆没，都没有达到预期</p>
</blockquote>
<p><img src="17.jpg#alt=img"></p>
<p>what happend？</p>
<p>这跟我们想象的完全不一样啊？为什么呢？无用的类不能消除，这还能叫做 tree-shaking 吗？我当时一度怀疑自己的 demo 有问题，后来各种网上搜索，才明白 demo 没有错。</p>
<p>下面摘取了 rollup 核心贡献者的的一些回答：</p>
<p><img src="18.jpg#alt=img"></p>
<p>图 7</p>
<ul>
<li>rollup 只处理函数和顶层的 import/export 变量，不能把没用到的类的方法消除掉</li>
<li>javascript 动态语言的特性使得静态分析比较困难</li>
<li>图 7 下部分的代码就是副作用的一个例子，如果静态分析的时候删除里 run 或者 jump，程序运行时就可能报错，那就本末倒置了，我们的目的是优化，肯定不能影响执行</li>
</ul>
<p>再举个例子说明下为什么不能消除 menu.js，比如下面这个场景</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Menu() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Menu.prototype.show &#x3D; function() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array.prototype.unique &#x3D; function() &#123;</span><br><span class="line">    &#x2F;&#x2F; 将 array 中的重复元素去除</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Menu;</span><br></pre></td></tr></table></figure>

<p>如果删除里 menu.js，那对 Array 的扩展也会被删除，就会影响功能。那也许你会问，难道 rollup，webpack 不能区分是定义 Menu 的 proptotype 还是定义 Array 的 proptotype 吗？当然如果代码写成上面这种形式是可以区分的，如果我写成这样呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Menu() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Menu.prototype.show &#x3D; function() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a &#x3D; &#39;Arr&#39; + &#39;ay&#39;</span><br><span class="line">var b</span><br><span class="line">if(a &#x3D;&#x3D; &#39;Array&#39;) &#123;</span><br><span class="line">    b &#x3D; Array</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    b &#x3D; Menu</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b.prototype.unique &#x3D; function() &#123;</span><br><span class="line">    &#x2F;&#x2F; 将 array 中的重复元素去除</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Menu;</span><br></pre></td></tr></table></figure>

<p>这种代码，静态分析是分析不了的，就算能静态分析代码，想要正确完全的分析也比较困难。</p>
<p>更多关于副作用的讨论，可以看这个</p>
<p><a href="http://link.zhihu.com/?target=https://github.com/rollup/rollup/issues/349"><img src="19.jpg#alt=img"></a></p>
<p><a href="http://link.zhihu.com/?target=https://github.com/rollup/rollup/issues/349">Tree shaking class methods · Issue #349 · rollup/rollupgithub.com</a></p>
<p><img src="20.jpg#alt=img"></p>
<blockquote>
<p>tree-shaking 对函数效果较好</p>
</blockquote>
<p>函数的副作用相对较少，顶层函数相对来说更容易分析，加上 babel 默认都是”use strict”严格模式，减少顶层函数的动态访问的方式，也更容易分析</p>
<p>我们开始说的三个工具，rollup 和 webpack 表现不理想，那 closure compiler 又如何呢？</p>
<p>将示例中的代码用 cc 打包后得到的结果如下：</p>
<p><img src="21.jpg#alt=img"></p>
<p>天啊，这不就是我们要的结果吗？完美消除所有无用代码的结果，输出的结果非常性感</p>
<blockquote>
<p>closure compiler， tree-shaking 的结果完美！</p>
</blockquote>
<p>可是不能高兴得太早，能得到这么完美结果是需要条件的，那就是 cc 的侵入式约束规范。必须在代码里添加这样的代码，看红线框标示的</p>
<p><img src="22.jpg#alt=img"></p>
<p>google 定义一整套注解规范 Annotating JavaScript for the Closure Compiler，想更多了解的，可以去看下官网。</p>
<p>侵入式这个就让人很不爽，google Closure Compiler 是 java 写的，和我们基于 node 的各种构建库不可能兼容（不过目前好像已经有 nodejs 版 Closure Compiler），Closure Compiler 使用起来也比较麻烦，所以虽然效果很赞，但比较难以应用到项目中，迁移成本较大。</p>
<p><strong>说了这么多，总结一下：</strong></p>
<p>三大工具的 tree-shaking 对于无用代码，无用模块的消除，都是有限的，有条件的。closure compiler 是最好的，但与我们日常的基于 node 的开发流很难兼容。</p>
<p><img src="23.jpg#alt=img"></p>
<p>tree-shaking 对 web 意义重大，是一个极致优化的理想世界，是前端进化的又一个终极理想。</p>
<p>理想是美好的，但目前还处在发展阶段，还比较困难，有各个方面的，甚至有目前看来无法解</p>
<p>决的问题，但还是应该相信新技术能带来更好的前端世界。</p>
<p>优化是一种态度，不因小而不为，不因艰而不攻。</p>
<blockquote>
<p>知识有限，如果错误，请不惜指正，谢谢</p>
</blockquote>
<p>下一篇将继续介绍 <a target="_blank" rel="noopener" href="https://juejin.im/post/6844903544760336398">Tree-Shaking 性能优化实践 - 实践篇</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903544760336398"><img src="24.webp#alt=img"></a></p>
<blockquote>
<p>本文中示例代码都能在我们的 github 中找到，欢迎戳 ❤</p>
</blockquote>
<p><a href="http://link.zhihu.com/?target=https://github.com/lin-xi/treeshaking/tree/master/rollup-webpack"><img src="25.jpg#alt=img"></a></p>
<p><a href="http://link.zhihu.com/?target=https://github.com/lin-xi/treeshaking/tree/master/rollup-webpack">lin-xi/treeshakinggithub.com</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/26/yuque/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/26/yuque/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/" class="post-title-link" itemprop="url">前端模块化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-26 00:26:40 / 修改时间：01:05:35" itemprop="dateCreated datePublished" datetime="2021-04-26T00:26:40+08:00">2021-04-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在 JavaScript 发展初期就是为了实现简单的页面交互逻辑，寥寥数语即可；如今 CPU、浏览器性能得到了极大的提升，很多页面逻辑迁移到了客户端（表单验证等），随着 web2.0 时代的到来，Ajax 技术得到广泛应用，jQuery 等前端库层出不穷，前端代码日益膨胀，此时在 JS 方面就会考虑使用模块化规范去管理。本文内容主要有理解模块化，为什么要模块化，模块化的优缺点以及模块化规范,并且介绍下开发中最流行的 CommonJS, AMD, ES6、CMD 规范。本文试图站在小白的角度，用通俗易懂的笔调介绍这些枯燥无味的概念，希望诸君阅读后，对模块化编程有个全新的认识和理解！</p>
<p><strong>建议下载本文源代码，自己动手敲一遍，请猛戳</strong><a target="_blank" rel="noopener" href="https://github.com/ljianshu/Blog">GitHub 个人博客</a><br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619368031111-ae8eeeb9-6592-4649-b5ad-301fb9aeec79.png#clientId=u650f5481-1581-4&from=paste&height=333&id=u02eadb23&margin=%5Bobject%20Object%5D&name=image.png&originHeight=333&originWidth=732&originalType=binary&size=101358&status=done&style=none&taskId=ua9ac1d85-8e29-4203-ad78-0e38ec391cd&width=732" alt="image.png"></p>
<h2 id="一、模块化的理解"><a href="#一、模块化的理解" class="headerlink" title="一、模块化的理解"></a>一、模块化的理解</h2><h3 id="1-什么是模块"><a href="#1-什么是模块" class="headerlink" title="1.什么是模块?"></a>1.什么是模块?</h3><ul>
<li>将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起</li>
<li>块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信</li>
</ul>
<h3 id="2-模块化的进化过程"><a href="#2-模块化的进化过程" class="headerlink" title="2.模块化的进化过程"></a>2.模块化的进化过程</h3><ul>
<li><strong>全局 function 模式 : 将不同的功能封装成不同的全局函数</strong><ul>
<li>编码: 将不同的功能封装成不同的全局函数</li>
<li>问题: 污染全局命名空间, 容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>namespace 模式 : 简单对象封装</strong><ul>
<li>作用: 减少了全局变量，解决命名冲突</li>
<li>问题: 数据不安全(外部可以直接修改模块内部的数据)</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myModule = &#123;</span><br><span class="line">  data: <span class="string">&quot;www.baidu.com&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`foo() <span class="subst">$&#123;<span class="built_in">this</span>.data&#125;</span>`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">bar</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`bar() <span class="subst">$&#123;<span class="built_in">this</span>.data&#125;</span>`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">myModule.data = <span class="string">&quot;other data&quot;</span>; <span class="comment">//能直接修改模块内部的数据</span></span><br><span class="line">myModule.foo(); <span class="comment">// foo() other data</span></span><br></pre></td></tr></table></figure>

<p>这样的写法会暴露所有模块成员，内部状态可以被外部改写。</p>
<ul>
<li><strong>IIFE 模式：匿名函数自调用(闭包)</strong><ul>
<li>作用: 数据是私有的, 外部只能通过暴露的方法操作</li>
<li>编码: 将数据和行为封装到一个函数内部, 通过给 window 添加属性来向外暴露接口</li>
<li>问题: 如果当前这个模块依赖另一个模块怎么办?</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.html文件</span></span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;module.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    myModule.foo()</span><br><span class="line">    myModule.bar()</span><br><span class="line">    <span class="built_in">console</span>.log(myModule.data) <span class="comment">//undefined 不能访问模块内部数据</span></span><br><span class="line">    myModule.data = <span class="string">&#x27;xxxx&#x27;</span> <span class="comment">//不是修改的模块内部的data</span></span><br><span class="line">    myModule.foo() <span class="comment">//没有改变</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">window</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = <span class="string">&quot;www.baidu.com&quot;</span>;</span><br><span class="line">  <span class="comment">//操作数据的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//用于暴露有函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`foo() <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//用于暴露有函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`bar() <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">    otherFun(); <span class="comment">//内部调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">otherFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//内部私有的函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;otherFun()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//暴露行为</span></span><br><span class="line">  <span class="built_in">window</span>.myModule = &#123; foo, bar &#125;; <span class="comment">//ES6写法</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>

<p>最后得到的结果：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619368117913-22682704-66d2-497e-9f2b-34f1efafc980.png#clientId=u0cc1c904-12a0-4&from=paste&height=105&id=uc27c29db&margin=%5Bobject%20Object%5D&name=image.png&originHeight=105&originWidth=419&originalType=binary&size=4563&status=done&style=none&taskId=u463fad66-1d12-44cc-84c0-8faaec2403e&width=419" alt="image.png"></p>
<ul>
<li><strong>IIFE 模式增强 : 引入依赖</strong></li>
</ul>
<p>这就是现代模块实现的基石</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">window</span>, $</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = <span class="string">&quot;www.baidu.com&quot;</span>;</span><br><span class="line">  <span class="comment">//操作数据的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//用于暴露有函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`foo() <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">    $(<span class="string">&quot;body&quot;</span>).css(<span class="string">&quot;background&quot;</span>, <span class="string">&quot;red&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//用于暴露有函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`bar() <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">    otherFun(); <span class="comment">//内部调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">otherFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//内部私有的函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;otherFun()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//暴露行为</span></span><br><span class="line">  <span class="built_in">window</span>.myModule = &#123; foo, bar &#125;;</span><br><span class="line">&#125;)(<span class="built_in">window</span>, jQuery);</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// index.html文件</span><br><span class="line"><span class="comment">&lt;!-- 引入的js必须有一定顺序 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;jquery-1.10.1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;module.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line">  myModule.foo();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上例子通过 jquery 方法将页面的背景颜色改成红色，所以必须先引入 jQuery 库，就把这个库当作参数传入。<strong>这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显</strong>。</p>
<h3 id="3-模块化的好处"><a href="#3-模块化的好处" class="headerlink" title="3. 模块化的好处"></a>3. 模块化的好处</h3><ul>
<li>避免命名冲突(减少命名空间污染)</li>
<li>更好的分离, 按需加载</li>
<li>更高复用性</li>
<li>高可维护性</li>
</ul>
<h3 id="4-引入多个后出现出现问题"><a href="#4-引入多个后出现出现问题" class="headerlink" title="4. 引入多个后出现出现问题"></a>4. 引入多个<script>后出现出现问题</h3><ul>
<li>请求过多</li>
</ul>
<p>首先我们要依赖多个模块，那样就会发送多个请求，导致请求过多</p>
<ul>
<li>依赖模糊</li>
</ul>
<p>我们不知道他们的具体依赖关系是什么，也就是说很容易因为不了解他们之间的依赖关系导致加载先后顺序出错。</p>
<ul>
<li>难以维护</li>
</ul>
<p>以上两种原因就导致了很难维护，很可能出现牵一发而动全身的情况导致项目出现严重的问题。模块化固然有多个好处，然而一个页面需要引入多个 js 文件，就会出现以上这些问题。而这些问题可以通过模块化规范来解决，下面介绍开发中最流行的 commonjs, AMD, ES6, CMD 规范。</p>
<h2 id="二、模块化规范"><a href="#二、模块化规范" class="headerlink" title="二、模块化规范"></a>二、模块化规范</h2><h3 id="1-CommonJS"><a href="#1-CommonJS" class="headerlink" title="1.CommonJS"></a>1.CommonJS</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="(1)概述"></a>(1)概述</h4><p>Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。<strong>在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。</strong></p>
<h4 id="2-特点"><a href="#2-特点" class="headerlink" title="(2)特点"></a>(2)特点</h4><ul>
<li>所有代码都运行在模块作用域，不会污染全局作用域。</li>
<li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li>
<li>模块加载的顺序，按照其在代码中出现的顺序。</li>
</ul>
<h4 id="3-基本语法"><a href="#3-基本语法" class="headerlink" title="(3)基本语法"></a>(3)基本语法</h4><ul>
<li>暴露模块：module.exports = value 或 exports.xxx = value</li>
<li>引入模块：require(xxx),如果是第三方模块，xxx 为模块名；如果是自定义模块，xxx 为模块文件路径</li>
</ul>
<p>此处我们有个疑问：<strong>CommonJS 暴露的模块到底是什么?<strong>CommonJS 规范规定，每个模块内部，module 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即 module.exports）是对外的接口。</strong>加载某个模块，其实是加载该模块的 module.exports 属性</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example.js</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> addX = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value + x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports.x = x;</span><br><span class="line"><span class="built_in">module</span>.exports.addX = addX;</span><br></pre></td></tr></table></figure>

<p>上面代码通过 module.exports 输出变量 x 和函数 addX。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = <span class="built_in">require</span>(<span class="string">&quot;./example.js&quot;</span>); <span class="comment">//如果参数字符串以“./”开头，则表示加载的是一个位于相对路径</span></span><br><span class="line"><span class="built_in">console</span>.log(example.x); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(example.addX(<span class="number">1</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>require 命令用于加载模块文件。<strong>require 命令的基本功能是，读入并执行一个 JavaScript 文件，然后返回该模块的 exports 对象。如果没有发现指定模块，会报错</strong>。</p>
<h4 id="4-模块的加载机制"><a href="#4-模块的加载机制" class="headerlink" title="(4)模块的加载机制"></a>(4)模块的加载机制</h4><p><strong>CommonJS 模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值</strong>。这点与 ES6 模块化有重大差异（下文会介绍），请看下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  counter: counter,</span><br><span class="line">  incCounter: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码输出内部变量 counter 和改写这个变量的内部方法 incCounter。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="built_in">require</span>(<span class="string">&quot;./lib&quot;</span>).counter;</span><br><span class="line"><span class="keyword">var</span> incCounter = <span class="built_in">require</span>(<span class="string">&quot;./lib&quot;</span>).incCounter;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>上面代码说明，counter 输出以后，lib.js 模块内部的变化就影响不到 counter 了。<strong>这是因为 counter 是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值</strong>。</p>
<h4 id="5-服务器端实现"><a href="#5-服务器端实现" class="headerlink" title="(5)服务器端实现"></a>(5)服务器端实现</h4><h4 id="①-下载安装-node-js"><a href="#①-下载安装-node-js" class="headerlink" title="① 下载安装 node.js"></a>① 下载安装 node.js</h4><h4 id="②-创建项目结构"><a href="#②-创建项目结构" class="headerlink" title="② 创建项目结构"></a>② 创建项目结构</h4><p><strong>注意：用 npm init 自动生成 package.json 时，package name(包名)不能有中文和大写</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|-modules</span><br><span class="line">  |-module1.js</span><br><span class="line">  |-module2.js</span><br><span class="line">  |-module3.js</span><br><span class="line">|-app.js</span><br><span class="line">|-package.json</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;commonJS-node&quot;,</span><br><span class="line">    &quot;version&quot;: &quot;1.0.0&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="③-下载第三方模块"><a href="#③-下载第三方模块" class="headerlink" title="③ 下载第三方模块"></a>③ 下载第三方模块</h4><p>npm install uniq –save // 用于数组去重</p>
<h4 id="④-定义模块代码"><a href="#④-定义模块代码" class="headerlink" title="④ 定义模块代码"></a>④ 定义模块代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module1.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  msg: <span class="string">&quot;module1&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.msg);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module2.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;module2&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module3.js</span></span><br><span class="line"><span class="built_in">exports</span>.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;foo() module3&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">exports</span>.arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js文件</span></span><br><span class="line"><span class="comment">// 引入第三方库，应该放置在最前面</span></span><br><span class="line"><span class="keyword">let</span> uniq = <span class="built_in">require</span>(<span class="string">&quot;uniq&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> module1 = <span class="built_in">require</span>(<span class="string">&quot;./modules/module1&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> module2 = <span class="built_in">require</span>(<span class="string">&quot;./modules/module2&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> module3 = <span class="built_in">require</span>(<span class="string">&quot;./modules/module3&quot;</span>);</span><br><span class="line"></span><br><span class="line">module1.foo(); <span class="comment">//module1</span></span><br><span class="line">module2(); <span class="comment">//module2</span></span><br><span class="line">module3.foo(); <span class="comment">//foo() module3</span></span><br><span class="line"><span class="built_in">console</span>.log(uniq(module3.arr)); <span class="comment">//[ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>

<h4 id="⑤-通过-node-运行-app-js"><a href="#⑤-通过-node-运行-app-js" class="headerlink" title="⑤ 通过 node 运行 app.js"></a>⑤ 通过 node 运行 app.js</h4><p>命令行输入 node app.js，运行 JS 文件</p>
<h4 id="6-浏览器端实现-借助-Browserify"><a href="#6-浏览器端实现-借助-Browserify" class="headerlink" title="(6)浏览器端实现(借助 Browserify)"></a>(6)浏览器端实现(借助 Browserify)</h4><h4 id="①-创建项目结构"><a href="#①-创建项目结构" class="headerlink" title="① 创建项目结构"></a>① 创建项目结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|-js</span><br><span class="line">  |-dist &#x2F;&#x2F;打包生成文件的目录</span><br><span class="line">  |-src &#x2F;&#x2F;源码所在的目录</span><br><span class="line">    |-module1.js</span><br><span class="line">    |-module2.js</span><br><span class="line">    |-module3.js</span><br><span class="line">    |-app.js &#x2F;&#x2F;应用主源文件</span><br><span class="line">|-index.html &#x2F;&#x2F;运行于浏览器上</span><br><span class="line">|-package.json</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;browserify-test&quot;,</span><br><span class="line">    &quot;version&quot;: &quot;1.0.0&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="②-下载-browserify"><a href="#②-下载-browserify" class="headerlink" title="② 下载 browserify"></a>② 下载 browserify</h4><ul>
<li>全局: npm install browserify -g</li>
<li>局部: npm install browserify –save-dev</li>
</ul>
<h4 id="③-定义模块代码-同服务器端"><a href="#③-定义模块代码-同服务器端" class="headerlink" title="③ 定义模块代码(同服务器端)"></a>③ 定义模块代码(同服务器端)</h4><p>注意：index.html 文件要运行在浏览器上，需要借助 browserify 将 app.js 文件打包编译，如果直接在 index.html 引入 app.js 就会报错！</p>
<h4 id="④-打包处理-js"><a href="#④-打包处理-js" class="headerlink" title="④ 打包处理 js"></a>④ 打包处理 js</h4><p>根目录下运行 browserify js/src/app.js -o js/dist/bundle.js</p>
<h4 id="⑤-页面使用引入"><a href="#⑤-页面使用引入" class="headerlink" title="⑤ 页面使用引入"></a>⑤ 页面使用引入</h4><p>在 index.html 文件中引入<script type="text/javascript" src="js/dist/bundle.js"></script></p>
<h3 id="2-AMD"><a href="#2-AMD" class="headerlink" title="2.AMD"></a>2.AMD</h3><p>CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD 规范则是非同步加载模块，允许指定回调函数。由于 Node.js 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 CommonJS 规范比较适用。但是，<strong>如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用 AMD 规范</strong>。此外 AMD 规范比 CommonJS 规范在浏览器端实现要来着早。</p>
<h4 id="1-AMD-规范基本语法"><a href="#1-AMD-规范基本语法" class="headerlink" title="(1)AMD 规范基本语法"></a>(1)AMD 规范基本语法</h4><p><strong>定义暴露模块</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义没有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> 模块;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义有依赖的模块</span></span><br><span class="line">define([<span class="string">&quot;module1&quot;</span>, <span class="string">&quot;module2&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">m1, m2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> 模块;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>引入使用模块</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">&quot;module1&quot;</span>, <span class="string">&quot;module2&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">m1, m2</span>) </span>&#123;</span><br><span class="line">  使用m1 / m2;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="2-未使用-AMD-规范与使用-require-js"><a href="#2-未使用-AMD-规范与使用-require-js" class="headerlink" title="(2)未使用 AMD 规范与使用 require.js"></a>(2)未使用 AMD 规范与使用 require.js</h4><p>通过比较两者的实现方法，来说明使用 AMD 规范的好处。</p>
<ul>
<li>未使用 AMD 规范</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dataService.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">window</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> msg = <span class="string">&quot;www.baidu.com&quot;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> msg.toUpperCase();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">window</span>.dataService = &#123; getMsg &#125;;</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alerter.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">window</span>, dataService</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">showMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(dataService.getMsg() + <span class="string">&quot;, &quot;</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">window</span>.alerter = &#123; showMsg &#125;;</span><br><span class="line">&#125;)(<span class="built_in">window</span>, dataService);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">alerter</span>) </span>&#123;</span><br><span class="line">  alerter.showMsg();</span><br><span class="line">&#125;)(alerter);</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// index.html文件</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Modular Demo 1: 未使用AMD(require.js)<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/modules/dataService.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/modules/alerter.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后得到如下结果：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619368360078-dea15769-8e59-4cf4-9798-8bd4173960da.png#clientId=u0cc1c904-12a0-4&from=paste&height=170&id=u8e06bb4f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=170&originWidth=508&originalType=binary&size=8509&status=done&style=none&taskId=u1e0ddbef-4733-45d3-ac12-2e8c1bc5b9f&width=508" alt="image.png"><br>这种方式缺点很明显：<strong>首先会发送多个请求，其次引入的 js 文件顺序不能搞错，否则会报错！</strong></p>
<ul>
<li>使用 require.js</li>
</ul>
<p>RequireJS 是一个工具库，主要用于客户端的模块管理。它的模块管理遵守 AMD 规范，<strong>RequireJS 的基本思想是，通过 define 方法，将代码定义为模块；通过 require 方法，实现代码的模块加载</strong>。接下来介绍 AMD 规范在浏览器实现的步骤：</p>
<h4 id="①-下载-require-js-并引入"><a href="#①-下载-require-js-并引入" class="headerlink" title="① 下载 require.js, 并引入"></a>① 下载 require.js, 并引入</h4><ul>
<li>官网:<a target="_blank" rel="noopener" href="http://www.requirejs.cn/">http://www.requirejs.cn/</a></li>
<li>github :<a target="_blank" rel="noopener" href="https://github.com/requirejs/requirejs">https://github.com/requirejs/requirejs</a></li>
</ul>
<p>然后将 require.js 导入项目: js/libs/require.js</p>
<h4 id="②-创建项目结构-1"><a href="#②-创建项目结构-1" class="headerlink" title="② 创建项目结构"></a>② 创建项目结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|-js</span><br><span class="line">  |-libs</span><br><span class="line">    |-require.js</span><br><span class="line">  |-modules</span><br><span class="line">    |-alerter.js</span><br><span class="line">    |-dataService.js</span><br><span class="line">  |-main.js</span><br><span class="line">|-index.html</span><br></pre></td></tr></table></figure>

<h4 id="③-定义-require-js-的模块代码"><a href="#③-定义-require-js-的模块代码" class="headerlink" title="③ 定义 require.js 的模块代码"></a>③ 定义 require.js 的模块代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dataService.js文件</span></span><br><span class="line"><span class="comment">// 定义没有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> msg = <span class="string">&quot;www.baidu.com&quot;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> msg.toUpperCase();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; getMsg &#125;; <span class="comment">// 暴露模块</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//alerter.js文件</span></span><br><span class="line"><span class="comment">// 定义有依赖的模块</span></span><br><span class="line">define([<span class="string">&quot;dataService&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">dataService</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">showMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(dataService.getMsg() + <span class="string">&quot;, &quot;</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 暴露模块</span></span><br><span class="line">  <span class="keyword">return</span> &#123; showMsg &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">require</span>.config(&#123;</span><br><span class="line">    baseUrl: <span class="string">&quot;js/&quot;</span>, <span class="comment">//基本路径 出发点在根目录下</span></span><br><span class="line">    paths: &#123;</span><br><span class="line">      <span class="comment">//映射: 模块标识名: 路径</span></span><br><span class="line">      alerter: <span class="string">&quot;./modules/alerter&quot;</span>, <span class="comment">//此处不能写成alerter.js,会报错</span></span><br><span class="line">      dataService: <span class="string">&quot;./modules/dataService&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">require</span>([<span class="string">&quot;alerter&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">alerter</span>) </span>&#123;</span><br><span class="line">    alerter.showMsg();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// index.html文件</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Modular Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入require.js并指定js主文件的入口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">data-main</span>=<span class="string">&quot;js/main&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/libs/require.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="④-页面引入-require-js-模块"><a href="#④-页面引入-require-js-模块" class="headerlink" title="④ 页面引入 require.js 模块:"></a>④ 页面引入 require.js 模块:</h4><p>在 index.html 引入<script data-main="js/main" src="js/libs/require.js"></script><br><strong>此外在项目中如何引入第三方库？</strong>只需在上面代码的基础稍作修改：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alerter.js文件</span></span><br><span class="line">define([<span class="string">&quot;dataService&quot;</span>, <span class="string">&quot;jquery&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">dataService, $</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">showMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(dataService.getMsg() + <span class="string">&quot;, &quot;</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line">  $(<span class="string">&quot;body&quot;</span>).css(<span class="string">&quot;background&quot;</span>, <span class="string">&quot;green&quot;</span>);</span><br><span class="line">  <span class="comment">// 暴露模块</span></span><br><span class="line">  <span class="keyword">return</span> &#123; showMsg &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">require</span>.config(&#123;</span><br><span class="line">    baseUrl: <span class="string">&quot;js/&quot;</span>, <span class="comment">//基本路径 出发点在根目录下</span></span><br><span class="line">    paths: &#123;</span><br><span class="line">      <span class="comment">//自定义模块</span></span><br><span class="line">      alerter: <span class="string">&quot;./modules/alerter&quot;</span>, <span class="comment">//此处不能写成alerter.js,会报错</span></span><br><span class="line">      dataService: <span class="string">&quot;./modules/dataService&quot;</span>,</span><br><span class="line">      <span class="comment">// 第三方库模块</span></span><br><span class="line">      jquery: <span class="string">&quot;./libs/jquery-1.10.1&quot;</span>, <span class="comment">//注意：写成jQuery会报错</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">require</span>([<span class="string">&quot;alerter&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">alerter</span>) </span>&#123;</span><br><span class="line">    alerter.showMsg();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>上例是在 alerter.js 文件中引入 jQuery 第三方库，main.js 文件也要有相应的路径配置。<strong>小结</strong>：通过两者的比较，可以得出<strong>AMD 模块定义的方法非常清晰，不会污染全局环境，能够清楚地显示依赖关系</strong>。AMD 模式可以用于浏览器环境，并且允许非同步加载模块，也可以根据需要动态加载模块。</p>
<h3 id="3-CMD"><a href="#3-CMD" class="headerlink" title="3.CMD"></a>3.CMD</h3><p>CMD 规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD 规范整合了 CommonJS 和 AMD 规范的特点。在 Sea.js 中，所有 JavaScript 模块都遵循 CMD 模块定义规范。</p>
<h4 id="1-CMD-规范基本语法"><a href="#1-CMD-规范基本语法" class="headerlink" title="(1)CMD 规范基本语法"></a>(1)CMD 规范基本语法</h4><p><strong>定义暴露模块：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义没有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">exports</span>.xxx = value;</span><br><span class="line">  <span class="built_in">module</span>.exports = value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//引入依赖模块(同步)</span></span><br><span class="line">  <span class="keyword">var</span> module2 = <span class="built_in">require</span>(<span class="string">&quot;./module2&quot;</span>);</span><br><span class="line">  <span class="comment">//引入依赖模块(异步)</span></span><br><span class="line">  <span class="built_in">require</span>.async(<span class="string">&quot;./module3&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m3</span>) </span>&#123;&#125;);</span><br><span class="line">  <span class="comment">//暴露模块</span></span><br><span class="line">  <span class="built_in">exports</span>.xxx = value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>引入使用模块：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> m1 = <span class="built_in">require</span>(<span class="string">&quot;./module1&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> m4 = <span class="built_in">require</span>(<span class="string">&quot;./module4&quot;</span>);</span><br><span class="line">  m1.show();</span><br><span class="line">  m4.show();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="2-sea-js-简单使用教程"><a href="#2-sea-js-简单使用教程" class="headerlink" title="(2)sea.js 简单使用教程"></a>(2)sea.js 简单使用教程</h4><h4 id="①-下载-sea-js-并引入"><a href="#①-下载-sea-js-并引入" class="headerlink" title="① 下载 sea.js, 并引入"></a>① 下载 sea.js, 并引入</h4><ul>
<li>官网:<a target="_blank" rel="noopener" href="http://seajs.org/">http://seajs.org/</a></li>
<li>github :<a target="_blank" rel="noopener" href="https://github.com/seajs/seajs">https://github.com/seajs/seajs</a></li>
</ul>
<p>然后将 sea.js 导入项目: js/libs/sea.js</p>
<h4 id="②-创建项目结构-2"><a href="#②-创建项目结构-2" class="headerlink" title="② 创建项目结构"></a>② 创建项目结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|-js</span><br><span class="line">  |-libs</span><br><span class="line">    |-sea.js</span><br><span class="line">  |-modules</span><br><span class="line">    |-module1.js</span><br><span class="line">    |-module2.js</span><br><span class="line">    |-module3.js</span><br><span class="line">    |-module4.js</span><br><span class="line">    |-main.js</span><br><span class="line">|-index.html</span><br></pre></td></tr></table></figure>

<h4 id="③-定义-sea-js-的模块代码"><a href="#③-定义-sea-js-的模块代码" class="headerlink" title="③ 定义 sea.js 的模块代码"></a>③ 定义 sea.js 的模块代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module1.js文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//内部变量数据</span></span><br><span class="line">  <span class="keyword">var</span> data = <span class="string">&quot;atguigu.com&quot;</span>;</span><br><span class="line">  <span class="comment">//内部函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;module1 show() &quot;</span> + data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//向外暴露</span></span><br><span class="line">  <span class="built_in">exports</span>.show = show;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module2.js文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    msg: <span class="string">&quot;I Will Back&quot;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module3.js文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> API_KEY = <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line">  <span class="built_in">exports</span>.API_KEY = API_KEY;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module4.js文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//引入依赖模块(同步)</span></span><br><span class="line">  <span class="keyword">var</span> module2 = <span class="built_in">require</span>(<span class="string">&quot;./module2&quot;</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;module4 show() &quot;</span> + module2.msg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exports</span>.show = show;</span><br><span class="line">  <span class="comment">//引入依赖模块(异步)</span></span><br><span class="line">  <span class="built_in">require</span>.async(<span class="string">&quot;./module3&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m3</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;异步引入依赖模块3  &quot;</span> + m3.API_KEY);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> m1 = <span class="built_in">require</span>(<span class="string">&quot;./module1&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> m4 = <span class="built_in">require</span>(<span class="string">&quot;./module4&quot;</span>);</span><br><span class="line">  m1.show();</span><br><span class="line">  m4.show();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="④-在-index-html-中引入"><a href="#④-在-index-html-中引入" class="headerlink" title="④ 在 index.html 中引入"></a>④ 在 index.html 中引入</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/libs/sea.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  seajs.use(<span class="string">&quot;./js/modules/main&quot;</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后得到结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619368668530-d6477aad-29fa-4012-b354-27d275f9c9f5.png#clientId=u0cc1c904-12a0-4&from=paste&height=84&id=ud03b9b5b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=84&originWidth=430&originalType=binary&size=4381&status=done&style=none&taskId=u4003f26a-2c46-4c19-a106-ff39fe4dbbb&width=430" alt="image.png"></p>
<h3 id="4-ES6-模块化"><a href="#4-ES6-模块化" class="headerlink" title="4.ES6 模块化"></a>4.ES6 模块化</h3><p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p>
<h4 id="1-ES6-模块化语法"><a href="#1-ES6-模块化语法" class="headerlink" title="(1)ES6 模块化语法"></a>(1)ES6 模块化语法</h4><p>export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 定义模块 math.js **/</span></span><br><span class="line"><span class="keyword">var</span> basicNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; basicNum, add &#125;;</span><br><span class="line"><span class="comment">/** 引用模块 **/</span></span><br><span class="line"><span class="keyword">import</span> &#123; basicNum, add &#125; <span class="keyword">from</span> <span class="string">&quot;./math&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">ele</span>) </span>&#123;</span><br><span class="line">  ele.textContent = add(<span class="number">99</span> + basicNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上例所示，使用 import 命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到 export default 命令，为模块指定默认输出。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import-default.js</span></span><br><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">&quot;./export-default&quot;</span>;</span><br><span class="line">customName(); <span class="comment">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure>

<p>模块默认输出, 其他模块加载该模块时，import 命令可以为该匿名函数指定任意名字。</p>
<h4 id="2-ES6-模块与-CommonJS-模块的差异"><a href="#2-ES6-模块与-CommonJS-模块的差异" class="headerlink" title="(2)ES6 模块与 CommonJS 模块的差异"></a>(2)ES6 模块与 CommonJS 模块的差异</h4><p>它们有两个重大差异：<br><strong>① CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用</strong>。<br><strong>② CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</strong>。<br>第二个差异是因为 CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。<br>下面重点解释第一个差异，我们还是举上面那个 CommonJS 模块的加载机制例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">&quot;./lib&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>ES6 模块的运行机制与 CommonJS 不一样。<strong>ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块</strong>。</p>
<h4 id="3-ES6-Babel-Browserify-使用教程"><a href="#3-ES6-Babel-Browserify-使用教程" class="headerlink" title="(3) ES6-Babel-Browserify 使用教程"></a>(3) ES6-Babel-Browserify 使用教程</h4><p>简单来说就一句话：<strong>使用 Babel 将 ES6 编译为 ES5 代码，使用 Browserify 编译打包 js</strong>。</p>
<h4 id="①-定义-package-json-文件"><a href="#①-定义-package-json-文件" class="headerlink" title="① 定义 package.json 文件"></a>① 定义 package.json 文件</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;es6-babel-browserify&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="②-安装-babel-cli-babel-preset-es2015-和-browserify"><a href="#②-安装-babel-cli-babel-preset-es2015-和-browserify" class="headerlink" title="② 安装 babel-cli, babel-preset-es2015 和 browserify"></a>② 安装 babel-cli, babel-preset-es2015 和 browserify</h4><ul>
<li>npm install babel-cli browserify -g</li>
<li>npm install babel-preset-es2015 –save-dev</li>
<li>preset 预设(将 es6 转换成 es5 的所有插件打包)</li>
</ul>
<h4 id="③-定义-babelrc-文件"><a href="#③-定义-babelrc-文件" class="headerlink" title="③ 定义.babelrc 文件"></a>③ 定义.babelrc 文件</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;presets&quot;</span>: [<span class="string">&quot;es2015&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="④-定义模块代码-1"><a href="#④-定义模块代码-1" class="headerlink" title="④ 定义模块代码"></a>④ 定义模块代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module1.js文件</span></span><br><span class="line"><span class="comment">// 分别暴露</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;foo() module1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;bar() module1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module2.js文件</span></span><br><span class="line"><span class="comment">// 统一暴露</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;fun1() module2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;fun2() module2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; fun1, fun2 &#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module3.js文件</span></span><br><span class="line"><span class="comment">// 默认暴露 可以暴露任意数据类项，暴露什么数据，接收到就是什么数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;默认暴露&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js文件</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">&quot;./module1&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; fun1, fun2 &#125; <span class="keyword">from</span> <span class="string">&quot;./module2&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> module3 <span class="keyword">from</span> <span class="string">&quot;./module3&quot;</span>;</span><br><span class="line">foo();</span><br><span class="line">bar();</span><br><span class="line">fun1();</span><br><span class="line">fun2();</span><br><span class="line">module3();</span><br></pre></td></tr></table></figure>

<h4 id="⑤-编译并在-index-html-中引入"><a href="#⑤-编译并在-index-html-中引入" class="headerlink" title="⑤ 编译并在 index.html 中引入"></a>⑤ 编译并在 index.html 中引入</h4><ul>
<li>使用 Babel 将 ES6 编译为 ES5 代码(但包含 CommonJS 语法) :babel js/src -d js/lib</li>
<li>使用 Browserify 编译 js :browserify js/lib/app.js -o js/lib/bundle.js</li>
</ul>
<p>然后在 index.html 文件中引入</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/lib/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后得到如下结果：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619369029376-9a9914a3-75c0-42cb-8c31-0f64a14a78a4.png#clientId=u0cc1c904-12a0-4&from=paste&height=102&id=ua6b37741&margin=%5Bobject%20Object%5D&name=image.png&originHeight=102&originWidth=437&originalType=binary&size=3646&status=done&style=none&taskId=u7cfa784c-d662-4080-8701-81af1964f53&width=437" alt="image.png"><br><strong>此外第三方库(以 jQuery 为例)如何引入呢</strong>？<br>首先安装依赖 npm install jquery@1<br>然后在 app.js 文件中引入</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//app.js文件 import &#123; foo, bar &#125; from &#x27;./module1&#x27; import &#123; fun1, fun2 &#125; from</span><br><span class="line">&#x27;./module2&#x27; import module3 from &#x27;./module3&#x27; import $ from &#x27;jquery&#x27; foo() bar()</span><br><span class="line">fun1() fun2() module3() $(&#x27;body&#x27;).css(&#x27;background&#x27;, &#x27;green&#x27;)</span><br></pre></td></tr></table></figure>

<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><ul>
<li>CommonJS 规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了 AMD CMD 解决方案。</li>
<li>AMD 规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD 规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。</li>
<li>CMD 规范与 AMD 规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在 Node.js 中运行。不过，依赖 SPM 打包，模块的加载逻辑偏重</li>
<li><strong>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案</strong>。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/25/yuque/%E6%B8%B2%E6%9F%93%E5%90%88%E6%88%90%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/25/yuque/%E6%B8%B2%E6%9F%93%E5%90%88%E6%88%90%E5%B1%82/" class="post-title-link" itemprop="url">渲染合成层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-25 23:11:28" itemprop="dateCreated datePublished" datetime="2021-04-25T23:11:28+08:00">2021-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-26 01:05:35" itemprop="dateModified" datetime="2021-04-26T01:05:35+08:00">2021-04-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="梳理浏览器渲染流程"><a href="#梳理浏览器渲染流程" class="headerlink" title="梳理浏览器渲染流程"></a>梳理浏览器渲染流程</h2><p>首先简单了解一下浏览器请求、加载、渲染一个页面的大致过程：</p>
<ul>
<li>DNS 查询</li>
<li>TCP 连接</li>
<li>HTTP 请求即响应</li>
<li>服务器响应</li>
<li>客户端渲染</li>
</ul>
<p>这里主要将客户端渲染展开梳理一下，从浏览器器内核拿到内容（渲染线程接收请求，加载网页并渲染网页），渲染大概可以划分成以下几个步骤：</p>
<ul>
<li>解析 html 建立 dom 树</li>
<li>解析 css 构建 render 树（将 CSS 代码解析成树形的数据结构，然后结合 DOM 合并成 render 树）</li>
<li>布局 render 树（Layout/reflow），负责各元素尺寸、位置的计算</li>
<li>绘制 render 树（paint），绘制页面像素信息</li>
<li>浏览器会将各层的信息发送给 GPU（GPU 进程：最多一个，用于 3D 绘制等），GPU 会将各层合成（composite），显示在屏幕上。</li>
</ul>
<p>参考一张图（webkit 渲染主要流程）：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619363642174-481e16d9-9a43-4096-b6e3-0d05efa9c009.png#clientId=u5af2961a-f81b-4&from=paste&height=289&id=u4f533940&margin=%5Bobject%20Object%5D&name=image.png&originHeight=289&originWidth=624&originalType=binary&size=39586&status=done&style=none&taskId=u9daf1abb-fe8b-4964-9127-e58530ea4e2&width=624" alt="image.png"><br>这里先解释一下几个概念，方便大家理解：<br>　　 DOM Tree：浏览器将 HTML 解析成树形的数据结构。<br>　　 CSS Rule Tree：浏览器将 CSS 解析成树形的数据结构。<br>　　 Render Tree: DOM 和 CSSOM 合并后生成 Render Tree。<br>　　 layout: 有了 Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的 CSS 定义以及他们的从属关系，从而去计算出每个节点在屏幕中的位置。<br>　　 painting: 按照算出来的规则，通过显卡，把内容画到屏幕上。<br>　　 reflow（回流）：当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，内行称这个回退的过程叫 reflow。reflow 会从 <html> 这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置。reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。<br>　　 repaint（重绘）：改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。<br>注意：</p>
<ol>
<li>display:none 的节点不会被加入 Render Tree，而 visibility: hidden 则会，所以，如果某个节点最开始是不显示的，设为 display:none 是更优的。</li>
<li>display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发现位置变化。</li>
<li>有些情况下，比如修改了元素的样式，浏览器并不会立刻 reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次 reflow，这又叫异步 reflow 或增量异步 reflow。但是在有些情况下，比如 resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。</li>
</ol>
<p>再参考一张图理解一下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619363668703-951a22f8-23c8-4b9b-9abf-c3c4e82ddb6a.png#clientId=u5af2961a-f81b-4&from=paste&height=111&id=u4e02cff7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=111&originWidth=700&originalType=binary&size=56388&status=done&style=none&taskId=u5b23f9b4-f095-42f4-8ee4-9785c055796&width=700" alt="image.png"><br>细致分离两个环节，其他环节参考上述概念注解：<br>JavaScript：JavaScript 实现动画效果，DOM 元素操作等。Composite（渲染层合并）：对页面中 DOM 元素的绘制是在多个层上进行的。在每个层上完成绘制过程之后，浏览器会将所有层按照合理的顺序合并成一个图层，然后显示在屏幕上。对于有位置重叠的元素的页面，这个过程尤其重要，因为一旦图层的合并顺序出错，将会导致元素显示异常。<br>在实际场景下，大致会出现三种常见的渲染流程（Layout 和 Paint 步骤是可避免的，可参考上一张图的注意部分理解）：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619363684549-4c380d60-da59-499e-802f-040741adf294.png#clientId=u5af2961a-f81b-4&from=paste&height=381&id=u6450f303&margin=%5Bobject%20Object%5D&name=image.png&originHeight=381&originWidth=580&originalType=binary&size=140788&status=done&style=none&taskId=u978aeeac-ffc9-4a25-a9fb-86a97c01760&width=580" alt="image.png"></p>
<hr>
<h2 id="Composite"><a href="#Composite" class="headerlink" title="Composite"></a>Composite</h2><h4 id="了解层"><a href="#了解层" class="headerlink" title="了解层"></a>了解层</h4><p><strong>注意：首先说明，这里讨论的是 WebKit，描述的是 Chrome 的实现细节，而并非是 web 平台的功能，因此这里介绍的内容不一定适用于其他浏览器。</strong></p>
<ul>
<li>Chrome 拥有两套不同的渲染路径(rendering path)：硬件加速路径和旧软件路径(older software path)</li>
<li>Chrome 中有不同类型的层： RenderLayer(负责 DOM 子树)和 GraphicsLayer(负责 RenderLayer 的子树)，只有 GraphicsLayer 是作为纹理(texture)上传给 GPU 的。</li>
<li>什么是纹理？可以把它想象成一个从主存储器(例如 RAM)移动到图像存储器(例如 GPU 中的 VRAM)的位图图像(bitmapimage)</li>
<li>Chrome 使用纹理来从 GPU 上获得大块的页面内容。通过将纹理应用到一个非常简单的矩形网格就能很容易匹配不同的位置(position)和变形(transformation)。这也就是 3DCSS 的工作原理，它对于快速滚动也十分有效。</li>
</ul>
<p>整个图：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619363614081-e37ca74c-d966-423f-8242-1a40e169b31b.png#clientId=u5af2961a-f81b-4&from=paste&height=268&id=u13b8f6dd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=268&originWidth=650&originalType=binary&size=57852&status=done&style=none&taskId=u99e5ce91-02ad-4872-8d3e-5dec17afbb9&width=650" alt="image.png"><br>在 Chrome 中其实有几种不同的层类型：</p>
<ul>
<li>RenderLayers 渲染层，这是负责对应 DOM 子树</li>
<li>GraphicsLayers 图形层，这是负责对应 RenderLayers 子树。</li>
</ul>
<p>在浏览器渲染流程中提到了 composite 概念，在 DOM 树中每个节点都会对应一个 LayoutObject，当他们的 LayoutObject 处于相同的坐标空间时，就会形成一个 RenderLayers ，也就是渲染层。RenderLayers 来保证页面元素以正确的顺序合成，这时候就会出现层合成（composite），从而正确处理透明元素和重叠元素的显示。<br>某些特殊的渲染层会被认为是合成层（Compositing Layers），合成层拥有单独的 GraphicsLayer，而其他不是合成层的渲染层，则和其第一个拥有 GraphicsLayer 父层公用一个。<br>而每个 GraphicsLayer（合成层单独拥有的图层） 都有一个 GraphicsContext，GraphicsContext 会负责输出该层的位图，位图是存储在共享内存中，作为纹理上传到 GPU 中，最后由 GPU 将多个位图进行合成，然后显示到屏幕上。</p>
<h2 id="如何变成合成层"><a href="#如何变成合成层" class="headerlink" title="如何变成合成层"></a>如何变成合成层</h2><h4 id="合成层创建标准"><a href="#合成层创建标准" class="headerlink" title="合成层创建标准"></a>合成层创建标准</h4><p>什么情况下能使元素获得自己的层？虽然 Chrome 的启发式方法(heuristic)随着时间在不断发展进步，但是从目前来说，满足以下任意情况便会创建层：</p>
<ul>
<li>3D 或透视变换(perspective transform) CSS 属性</li>
<li>使用加速视频解码的 <video> 元素 拥有 3D</li>
<li>(WebGL) 上下文或加速的 2D 上下文的 <canvas> 元素</li>
<li>混合插件(如 Flash)</li>
<li>对自己的 opacity 做 CSS 动画或使用一个动画变换的元素</li>
<li>拥有加速 CSS 过滤器的元素</li>
<li>元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)</li>
<li>元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)</li>
</ul>
<h2 id="合成层的优点"><a href="#合成层的优点" class="headerlink" title="合成层的优点"></a>合成层的优点</h2><p><a target="_blank" rel="noopener" href="http://taobaofed.org/blog/2016/04/25/performance-composite/">淘宝的栗子</a>举的很详细，值得一看，里面提到了一旦 renderLayer 提升为了合成层就会有自己的绘图上下文，并且会开启硬件加速，有利于性能提升,里面列举了一些特点</p>
<ul>
<li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快</li>
<li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</li>
<li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li>
</ul>
<p><strong>注意：</strong></p>
<ol>
<li>提升到合成层后合成层的位图会交 GPU 处理，但请注意，仅仅只是合成的处理（把绘图上下文的位图输出进行组合）需要用到 GPU，生成合成层的位图处理（绘图上下文的工作）是需要 CPU。</li>
<li>当需要 repaint 的时候可以只 repaint 本身，不影响其他层，但是 paint 之前还有 style， layout,那就意味着即使合成层只是 repaint 了自己，但 style 和 layout 本身就很占用时间。</li>
<li>仅仅是 transform 和 opacity 不会引发 layout 和 paint，那么其他的属性不确定。</li>
</ol>
<p>总结合成层的优势：一般一个元素开启硬件加速后会变成合成层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能。<br><strong>性能优化点：</strong></p>
<ol>
<li>提升动画效果的元素 合成层的好处是不会影响到其他元素的绘制，因此，为了减少动画元素对其他元素的影响，从而减少 paint，我们需要把动画效果中的元素提升为合成层。提升合成层的最好方式是使用 CSS 的 will-change 属性。从上一节合成层产生原因中，可以知道 will-change 设置为 opacity、transform、top、left、bottom、right 可以将元素提升为合成层。</li>
<li>使用 transform 或者 opacity 来实现动画效果, 这样只需要做合成层的合并就好了。</li>
<li>减少绘制区域 对于不需要重新绘制的区域应尽量避免绘制，以减少绘制区域，比如一个 fix 在页面顶部的固定不变的导航 header，在页面内容某个区域 repaint 时，整个屏幕包括 fix 的 header 也会被重绘。而对于固定不变的区域，我们期望其并不会被重绘，因此可以通过之前的方法，将其提升为独立的合成层。减少绘制区域，需要仔细分析页面，区分绘制区域，减少重绘区域甚至避免重绘。</li>
</ol>
<h2 id="利用合成层可能踩到的坑"><a href="#利用合成层可能踩到的坑" class="headerlink" title="利用合成层可能踩到的坑"></a>利用合成层可能踩到的坑</h2><ol>
<li>合成层占用内存的问题</li>
<li>层爆炸，由于某些原因可能导致产生大量不在预期内的合成层，虽然有浏览器的层压缩机制，但是也有很多无法进行压缩的情况，这就可能出现层爆炸的现象（简单理解就是，很多不需要提升为合成层的元素因为某些不当操作成为了合成层）。解决层爆炸的问题，最佳方案是打破 overlap 的条件，也就是说让其他元素不要和合成层元素重叠。简单直接的方式：使用 3D 硬件加速提升动画性能时，最好给元素增加一个 z-index 属性，人为干扰合成的排序，可以有效减少 chrome 创建不必要的合成层，提升渲染性能，移动端优化效果尤为明显。在这篇<a target="_blank" rel="noopener" href="http://div.io/topic/1348">文章</a>中的<a target="_blank" rel="noopener" href="http://fouber.github.io/test/layer/">demo</a>可以看出其中厉害。</li>
</ol>
<p>用 chremo 打开 demo 页面后，开启浏览器的开发者模式，再按照<strong>如图操作</strong>打开查看工具：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619363731138-9a26cf8b-8104-43dc-a945-f5e0e011277f.png#clientId=u5af2961a-f81b-4&from=paste&height=732&id=u92de5f1d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=732&originWidth=569&originalType=binary&size=174228&status=done&style=none&taskId=ufa589ae5-a274-4ce8-a4b3-00deb5dffaa&width=569" alt="image.png"><br>开启 Rendering 的 Layer borders 后 观察点击为动画元素设置 z-index 复选框的页面提示变化：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619363714774-f2da0ca4-e51e-4fbc-91f7-307d4388cf87.png#clientId=u5af2961a-f81b-4&from=paste&height=732&id=u9e699078&margin=%5Bobject%20Object%5D&name=image.png&originHeight=732&originWidth=641&originalType=binary&size=154880&status=done&style=none&taskId=ubf52f35a-428c-4da3-be16-f3031b35920&width=641" alt="image.png"><br>上图中可以明显看出：页面中设置了一个 h1 标题，应用了 translate3d 动画，使得它被放到 composited layer 中渲染，然后在这个元素后面创建了 2000 个 list。在不为 h1 元素设置 z-index 的情况下，使得本不需要提升到合成层的 ul 元素下的每个 li 元素都提升为一个单独合成层（每个 li 元素的黄色提示边框），最终会导致 GPU 资源过度消耗页面滑动时很卡，尤其在移动端（安卓）上更加明显。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619363748135-c0ff102e-1850-410e-81dd-77d7afe77610.png#clientId=u5af2961a-f81b-4&from=paste&height=732&id=u13441047&margin=%5Bobject%20Object%5D&name=image.png&originHeight=732&originWidth=653&originalType=binary&size=187431&status=done&style=none&taskId=uced4698a-1d9a-4209-8b1c-a91dad1df24&width=653" alt="image.png"><br>如上图操作选中为动画元素设置 z-index，可以看出 ul 下的每个 li 都回归到普通渲染层，不再是合成层也就不会消耗 GPU 资源去渲染，从而达到了优化页面性能优化的目的。<br>大家可以用支持『硬件加速』的『安卓』手机浏览器测试上述页面，给动画元素加 z-index 前后的性能差距非常明显。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>在实际的前端开发中尤其是移动端开发，很多小伙伴都很喜欢使用类似 translateZ(0)等属性来进行所谓的硬件加速，以提升性能，达到优化页面动态效果的目的，但还是要注意凡事过犹不及，应用硬件加速的同时也要注意到千万别踩坑。关于合成层的更细致具体的讲解，可以仔细学习下下面的参考文章（尤其是前三篇哦）。最后祝愿热爱技术的你我始终坚持在探索技术的路上奋力前行！<br><strong>参考文章：</strong><a target="_blank" rel="noopener" href="http://taobaofed.org/blog/2016/04/25/performance-composite/">无线性能优化：Composite</a><a target="_blank" rel="noopener" href="https://www.html5rocks.com/zh/tutorials/speed/layers/">DOM to Screen</a><a target="_blank" rel="noopener" href="https://www.smashingmagazine.com/2016/12/gpu-animation-doing-it-right/">CSS GPU Animation: Doing It Right</a><a target="_blank" rel="noopener" href="https://github.com/hello2dj/blog/blob/master/%08web%E4%BC%98%E5%8C%96%E4%B9%8Bcomposite.md">web 优化之 composite</a><a target="_blank" rel="noopener" href="https://juejin.im/entry/59dc9aedf265da43200232f9">详谈层合成（composite）</a><a target="_blank" rel="noopener" href="http://div.io/topic/1348">CSS3 硬件加速也有坑</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/t/chrome">chrome</a><a target="_blank" rel="noopener" href="https://segmentfault.com/t/html5">html5</a><a target="_blank" rel="noopener" href="https://segmentfault.com/t/html">html</a><a target="_blank" rel="noopener" href="https://segmentfault.com/t/css">css</a><a target="_blank" rel="noopener" href="https://segmentfault.com/t/javascript">javascript</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/25/yuque/UDP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/25/yuque/UDP/" class="post-title-link" itemprop="url">UDP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-25 22:40:45" itemprop="dateCreated datePublished" datetime="2021-04-25T22:40:45+08:00">2021-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-26 01:05:35" itemprop="dateModified" datetime="2021-04-26T01:05:35+08:00">2021-04-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>UDP 数据报<strong>一、UDP 的概述</strong>（<strong>User Datagram Protocol，用户数据报协议</strong>）UDP 是<strong>传输层</strong>的协议，功能即为在 IP 的数据报服务之上增加了最基本的服务：<strong>复用</strong>和<strong>分用</strong>以及<strong>差错检测</strong>。UDP 提供<strong>不可靠</strong>服务，具有 TCP 所没有的<strong>优势</strong>：</p>
<ul>
<li>UDP<strong>无连接</strong>，时间上<strong>不存在建立连接需要的时延</strong>。空间上，TCP 需要在端系统中<strong>维护连接</strong>状态，需要一定的开销。此连接装入包括接收和发送缓存，拥塞控制参数和序号与确认号的参数。UCP 不维护连接状态，也不跟踪这些参数，开销小。空间和时间上都具有优势。举个例子：DNS 如果运行在 TCP 之上而不是 UDP，那么 DNS 的速度将会慢很多。HTTP 使用 TCP 而不是 UDP，是因为对于基于文本数据的 Web 网页来说，<strong>可靠性</strong>很重要。同一种专用应用服务器在支持 UDP 时，一定能支持更多的活动客户机。</li>
<li>分组首部开销小**，TCP 首部 20 字节，UDP 首部 8 字节。</li>
<li><strong>UDP 没有拥塞控制</strong>，应用层能够更好的控制要发送的数据和发送时间，网络中的拥塞控制也不会影响主机的发送速率。某些实时应用要求以稳定的速度发送，<strong>能容 忍一些数据的丢失，但是不能允许有较大的时延</strong>（比如实时视频，直播等）</li>
<li>UDP<strong>提供尽最大努力的交付</strong>，不保证可靠交付。所有维护传输可靠性的工作需要用户在<strong>应用层</strong>来完成。没有 TCP 的确认机制、重传机制。如果因为网络原因没有传送到对端，UDP 也不会给应用层返回错误信息</li>
<li>UDP 是<strong>面向报文</strong>的，对应用层交下来的报文，添加首部后直接向下交付为 IP 层，既不合并，也不拆分，保留这些报文的边界。对 IP 层交上来 UDP 用户数据报，在去除首部后就原封不动地交付给上层应用进程，报文不可分割，是 UDP 数据报处理的最小单位。正是因为这样，UDP 显得不够灵活，不能控制读写数据的次数和数量。比如我们要发送 100 个字节的报文，我们调用一次 sendto 函数就会发送 100 字节，对端也需要用 recvfrom 函数一次性接收 100 字节，不能使用循环每次获取 10 个字节，获取十次这样的做法。</li>
<li>UDP<strong>常用一次性传输比较少量数据的网络应用</strong>，如 DNS,SNMP 等，因为对于这些应用，若是采用 TCP，为连接的创建，维护和拆除带来不小的开销。UDP 也常用于多媒体应用（如 IP 电话，实时视频会议，流媒体等）数据的可靠传输对他们而言并不重要，TCP 的拥塞控制会使他们有较大的延迟，也是不可容忍的</li>
</ul>
<p><strong>二、UDP 的首部格式</strong>UDP 数据报分为<strong>首部</strong>和<strong>用户数据部分</strong>，整个 UDP 数据报作为 IP 数据报的数据部分封装在 IP 数据报中，UDP 数据报文结构如图所示：<br><img src="https://cdn.nlark.com/yuque/0/2021/jpg/21377586/1619361667214-2e9fb5f8-10e5-4e4d-bcf9-a232a777c3db.jpg#clientId=uf766e91f-7da9-4&from=paste&height=434&id=uc13cee0b&margin=%5Bobject%20Object%5D&originHeight=434&originWidth=1121&originalType=url&status=done&style=none&taskId=ucab3cb07-e1f4-49d7-a7a2-56d5143d585&width=1121"><br>UDP 首部有 8 个字节，由 4 个字段构成，每个字段都是两个字节，1.<strong>源端口</strong>： 源端口号，需要对方回信时选用，不需要时全部置 0.2.<strong>目的端口</strong>：目的端口号，在终点交付报文的时候需要用到。3.<strong>长度</strong>：UDP 的数据报的长度（包括首部和数据）其最小值为 8（只有首部）4.<strong>校验和</strong>：检测 UDP 数据报在传输中是否有错，有错则丢弃。该字段是可选的，当源主机不想计算校验和，则直接令该字段全为 0.当传输层从 IP 层收到 UDP 数据报时，就根据首部中的目的端口，把 UDP 数据报通过相应的端口，上交给应用进程。如果接收方 UDP 发现收到的报文中的目的端口号不正确（不存在对应端口号的应用进程 0,），就丢弃该报文，并由 ICMP 发送“端口不可达”差错报文给对方。UDP 校验在计算校验和的时候，需要在 UDP 数据报之前增加<strong>12 字节的伪首部</strong>，伪首部并不是 UDP 真正的首部。只是在计算校验和，临时添加在 UDP 数据报的前面，得到一个临时的 UDP 数据报。校验和就是按照这个临时的 UDP 数据报计算的。伪首部既不向下传送也不向上递交，而<strong>仅仅是为了计算校验和</strong>。这样的校验和，既<strong>检查了 UDP 数据报，又对 IP 数据报的源 IP 地址和目的 IP 地址进行了检验。</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619361667396-09c2b15d-e2c0-4254-b729-d4987d18a9b3.jpeg#clientId=uf766e91f-7da9-4&from=paste&height=521&id=u0b96cd49&margin=%5Bobject%20Object%5D&originHeight=521&originWidth=720&originalType=url&status=done&style=none&taskId=u6a91d411-a507-43da-a0b9-046e4cfe127&width=720"><br>UDP 校验和的计算方法和 IP 数据报首部校验和的计算方法相似，都使用二进制反码运算求和再取反，但不同的是：IP 数据报的校验和之检验 IP 数据报和首部，但 UDP 的校验和是把首部和数据部分一起校验。发送方，首先是把<strong>全零放入校验和字段</strong>并且添加<strong>伪首部</strong>，然后把 UDP 数据报看成是由许多 16 位的子串连接起来，若 UDP 数据报的数据部分不是偶数个字节，则要在数据部分末尾增加一个全零字节（此字节不发送），接下来就按照二进制反码计算出这些 16 位字的和。将此和的二进制反码写入校验和字段。在接收方，把收到得 UDP 数据报加上伪首部（如果不为偶数个字节，还需要补上全零字节）后，按二进制反码计算出这些 16 位字的和。<strong>当无差错时其结果全为 1</strong>,。否则就表明有差错出现，接收方应该丢弃这个 UDP 数据报。<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619361667438-0f18033d-fc51-4edd-a53a-b8a608f63d22.jpeg#clientId=uf766e91f-7da9-4&from=paste&height=454&id=u21c6ee63&margin=%5Bobject%20Object%5D&originHeight=454&originWidth=720&originalType=url&status=done&style=none&taskId=ucb722cc4-afb5-4088-81f6-28fdb315bda&width=720"><br>注意：1.校验时，若 UDP 数据报部分的长度不是偶数个字节，则需要填入一个全 0 字节，但是次字节和伪首部一样，是不发送的。2.如果 UDP 校验和校验出 UDP 数据报是错误的，可以丢弃，也可以交付上层，但是要附上错误报告，告诉上层这是错误的数据报。3.通过伪首部，不仅可以检查源端口号，目的端口号和 UDP 用户数据报的数据部分，还可以检查 IP 数据报的源 IP 地址和目的地址。这种差错检验的检错能力不强，但是简单，速度快</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/25/yuque/TCP%20%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%EF%BC%88%E4%B8%8B%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/25/yuque/TCP%20%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%EF%BC%88%E4%B8%8B%EF%BC%89/" class="post-title-link" itemprop="url">TCP 的那些事儿（下）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-25 22:24:44" itemprop="dateCreated datePublished" datetime="2021-04-25T22:24:44+08:00">2021-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-26 01:05:35" itemprop="dateModified" datetime="2021-04-26T01:05:35+08:00">2021-04-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这篇文章是下篇，所以如果你对 TCP 不熟悉的话，还请你先看看上篇《<a target="_blank" rel="noopener" href="https://coolshell.cn/articles/11564.html">TCP 的那些事儿（上）</a>》 上篇中，我们介绍了 TCP 的协议头、状态机、数据重传中的东西。但是 TCP 要解决一个很大的事，那就是要在一个网络根据不同的情况来动态调整自己的发包的速度，小则让自己的连接更稳定，大则让整个网络更稳定。在你阅读下篇之前，你需要做好准备，本篇文章有好些算法和策略，可能会引发你的各种思考，让你的大脑分配很多内存和计算资源，所以，不适合在厕所中阅读。</p>
<h1 id="TCP-的-RTT-算法"><a href="#TCP-的-RTT-算法" class="headerlink" title="TCP 的 RTT 算法"></a>TCP 的 RTT 算法</h1><p>从前面的 TCP 重传机制我们知道 Timeout 的设置对于重传非常重要。</p>
<ul>
<li>设长了，重发就慢，丢了老半天才重发，没有效率，性能差；</li>
<li>设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li>
</ul>
<p>而且，这个超时时间在不同的网络的情况下，根本没有办法设置一个死的值。只能动态地设置。 为了动态地设置，TCP 引入了 RTT——Round Trip Time，也就是一个数据包从发出去到回来的时间。这样发送端就大约知道需要多少的时间，从而可以方便地设置 Timeout——RTO（Retransmission TimeOut），以让我们的重传机制更高效。 听起来似乎很简单，好像就是在发送端发包时记下 t0，然后接收端再把这个 ack 回来时再记一个 t1，于是 RTT = t1 – t0。没那么简单，这只是一个采样，不能代表普遍情况。</p>
<h2 id="经典算法"><a href="#经典算法" class="headerlink" title="经典算法"></a>经典算法</h2><p><a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc793">RFC793</a>  中定义的经典算法是这样的：<br>1）首先，先采样 RTT，记下最近好几次的 RTT 值。<br>2）然后做平滑计算 SRTT（ Smoothed RTT）。公式为：（其中的 α 取值在 0.8 到 0.9 之间，这个算法英文叫 Exponential weighted moving average，中文叫：加权移动平均）</p>
<blockquote>
<p><strong>SRTT = ( α _ SRTT ) + ((1- α) _ RTT)</strong></p>
</blockquote>
<p>3）开始计算 RTO。公式如下：</p>
<blockquote>
<p><strong>RTO = min [ UBOUND,  max [ LBOUND,   (β * SRTT) ]  ]</strong></p>
</blockquote>
<p>其中：</p>
<ul>
<li>UBOUND 是最大的 timeout 时间，上限值</li>
<li>LBOUND 是最小的 timeout 时间，下限值</li>
<li>β 值一般在 1.3 到 2.0 之间。</li>
</ul>
<h2 id="Karn-Partridge-算法"><a href="#Karn-Partridge-算法" class="headerlink" title="Karn / Partridge 算法"></a>Karn / Partridge 算法</h2><p>但是上面的这个算法在重传的时候会出有一个终极问题——你是用第一次发数据的时间和 ack 回来的时间做 RTT 样本值，还是用重传的时间和 ACK 回来的时间做 RTT 样本值？<br>这个问题无论你选那头都是按下葫芦起了瓢。 如下图所示：</p>
<ul>
<li>情况（a）是 ack 没回来，所以重传。如果你计算第一次发送和 ACK 的时间，那么，明显算大了。</li>
<li>情况（b）是 ack 回来慢了，但是导致了重传，但刚重传不一会儿，之前 ACK 就回来了。如果你是算重传的时间和 ACK 回来的时间的差，就会算短了。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619360709603-b1b4a5a5-fd6f-4578-8ef1-195181201ece.jpeg#clientId=u6f576584-d24a-4&from=paste&height=166&id=uce4be580&margin=%5Bobject%20Object%5D&originHeight=332&originWidth=745&originalType=url&status=done&style=none&taskId=ufc3d1fc5-bfdc-481e-a012-79e1502cfb7&width=372.5"><br>所以 1987 年的时候，搞了一个叫<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Karn's_Algorithm">Karn / Partridge Algorithm</a>，这个算法的最大特点是——<strong>忽略重传，不把重传的 RTT 做采样</strong>（你看，你不需要去解决不存在的问题）。<br>但是，这样一来，又会引发一个大 BUG——<strong>如果在某一时间，网络闪动，突然变慢了，产生了比较大的延时，这个延时导致要重转所有的包（因为之前的 RTO 很小），于是，因为重转的不算，所以，RTO 就不会被更新，这是一个灾难</strong>。 于是 Karn 算法用了一个取巧的方式——只要一发生重传，就对现有的 RTO 值翻倍（这就是所谓的  Exponential backoff），很明显，这种死规矩对于一个需要估计比较准确的 RTT 也不靠谱。</p>
<h2 id="Jacobson-Karels-算法"><a href="#Jacobson-Karels-算法" class="headerlink" title="Jacobson / Karels 算法"></a>Jacobson / Karels 算法</h2><p>前面两种算法用的都是“加权移动平均”，这种方法最大的毛病就是如果 RTT 有一个大的波动的话，很难被发现，因为被平滑掉了。所以，1988 年，又有人推出来了一个新的算法，这个算法叫 Jacobson / Karels Algorithm（参看<a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc6298">RFC6289</a>）。这个算法引入了最新的 RTT 的采样和平滑过的 SRTT 的差距做因子来计算。 公式如下：（其中的 DevRTT 是 Deviation RTT 的意思）<br>**SRTT = SRTT + α(RTT – SRTT)  **—— 计算平滑 RTT<br>**DevRTT = (1-β)<em>DevRTT + β</em>(|RTT-SRTT|)**——计算平滑 RTT 和真实的差距（加权移动平均）<br>**RTO= µ * SRTT + ∂ *DevRTT**—— 神一样的公式<br>（其中：在 Linux 下，α = 0.125，β = 0.25， μ = 1，∂ = 4 ——这就是算法中的“调得一手好参数”，nobody knows why, it just works…） 最后的这个算法在被用在今天的 TCP 协议中（Linux 的源代码在：<a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/net/ipv4/tcp_input.c?v=2.6.32#L609">tcp_rtt_estimator</a>）。</p>
<h1 id="TCP-滑动窗口"><a href="#TCP-滑动窗口" class="headerlink" title="TCP 滑动窗口"></a>TCP 滑动窗口</h1><p>需要说明一下，如果你不了解 TCP 的滑动窗口这个事，你等于不了解 TCP 协议。我们都知道，<strong>TCP 必需要解决的可靠传输以及包乱序（reordering）的问题</strong>，所以，TCP 必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。<br>所以，TCP 引入了一些技术和设计来做网络流控，Sliding Window 是其中一个技术。 前面我们说过，<strong>TCP 头里有一个字段叫 Window，又叫 Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据</strong>。<strong>于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来</strong>。 为了说明滑动窗口，我们需要先看一下 TCP 缓冲区的一些数据结构：<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619360709691-99063d87-cbcd-4b7e-afe1-483a70de3f4c.jpeg#clientId=u6f576584-d24a-4&from=paste&height=300&id=ud1be6304&margin=%5Bobject%20Object%5D&originHeight=361&originWidth=906&originalType=url&status=done&style=none&taskId=u6def94ed-edcb-415f-ba41-b4814d42fb3&width=752"><br>上图中，我们可以看到：</p>
<ul>
<li>接收端 LastByteRead 指向了 TCP 缓冲区中读到的位置，NextByteExpected 指向的地方是收到的连续包的最后一个位置，LastByteRcved 指向的是收到的包的最后一个位置，我们可以看到中间有些数据还没有到达，所以有数据空白区。</li>
<li>发送端的 LastByteAcked 指向了被接收端 Ack 过的位置（表示成功发送确认），LastByteSent 表示发出去了，但还没有收到成功确认的 Ack，LastByteWritten 指向的是上层应用正在写的地方。</li>
</ul>
<p>于是：</p>
<ul>
<li>接收端在给发送端回 ACK 中会汇报自己的 AdvertisedWindow = MaxRcvBuffer – LastByteRcvd – 1;</li>
<li>而发送方会根据这个窗口来控制发送数据的大小，以保证接收方可以处理。</li>
</ul>
<p>下面我们来看一下发送方的滑动窗口示意图：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619360709607-365d12f9-613c-4a0f-8c7b-b960f3ce4c78.png#clientId=u6f576584-d24a-4&from=paste&height=270&id=ud4273986&margin=%5Bobject%20Object%5D&originHeight=270&originWidth=660&originalType=url&status=done&style=none&taskId=uf069525e-1120-4c5f-98ad-e5f5498d983&width=660"><br>（<a target="_blank" rel="noopener" href="http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo-6.htm">图片来源</a>）<br>上图中分成了四个部分，分别是：（其中那个黑模型就是滑动窗口）</p>
<ul>
<li>#1 已收到 ack 确认的数据。</li>
<li>#2 发还没收到 ack 的。</li>
<li>#3 在窗口中还没有发出的（接收方还有空间）。</li>
<li>#4 窗口以外的数据（接收方没空间）</li>
</ul>
<p>下面是个滑动后的示意图（收到 36 的 ack，并发出了 46-51 的字节）：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619360709766-9861b05c-aef1-430a-b230-6c9a03f9ca33.png#clientId=u6f576584-d24a-4&from=paste&height=210&id=uf0d3e0ab&margin=%5Bobject%20Object%5D&originHeight=210&originWidth=660&originalType=url&status=done&style=none&taskId=u037ab23b-7d6a-4a43-896d-3fd26808699&width=660"><br>下面我们来看一个接受端控制发送端的图示：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619360709741-26b260ab-1f10-4f23-8c1e-c8664d5e02e5.png#clientId=u6f576584-d24a-4&from=paste&height=836&id=u76b6d6e1&margin=%5Bobject%20Object%5D&originHeight=836&originWidth=666&originalType=url&status=done&style=none&taskId=ufb60f2ea-587c-4c9c-8a36-ab3bd8a8436&width=666"><br>（<a target="_blank" rel="noopener" href="http://www.tcpipguide.com/free/t_TCPWindowSizeAdjustmentandFlowControl-2.htm">图片来源</a>）</p>
<h2 id="Zero-Window"><a href="#Zero-Window" class="headerlink" title="Zero Window"></a>Zero Window</h2><p>上图，我们可以看到一个处理缓慢的 Server（接收端）是怎么把 Client（发送端）的 TCP Sliding Window 给降成 0 的。此时，你一定会问，如果 Window 变成 0 了，TCP 会怎么样？是不是发送端就不发数据了？是的，发送端就不发数据了，你可以想像成“Window Closed”，那你一定还会问，如果发送端不发数据了，接收方一会儿 Window size 可用了，怎么通知发送端呢？<br>解决这个问题，TCP 使用了 Zero Window Probe 技术，缩写为 ZWP，也就是说，发送端在窗口变成 0 后，会发 ZWP 的包给接收方，让接收方来 ack 他的 Window 尺寸，一般这个值会设置成 3 次，第次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后还是 0 的话，有的 TCP 实现就会发 RST 把链接断了。<br><strong>注意</strong>：只要有等待的地方都可能出现 DDoS 攻击，Zero Window 也不例外，一些攻击者会在和 HTTP 建好链发完 GET 请求后，就把 Window 设置为 0，然后服务端就只能等待进行 ZWP，于是攻击者会并发大量的这样的请求，把服务器端的资源耗尽。（关于这方面的攻击，大家可以移步看一下<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Sockstress">Wikipedia 的 SockStress 词条</a>）<br>另外，Wireshark 中，你可以使用 tcp.analysis.zero_window 来过滤包，然后使用右键菜单里的 follow TCP stream，你可以看到 ZeroWindowProbe 及 ZeroWindowProbeAck 的包。</p>
<h2 id="Silly-Window-Syndrome"><a href="#Silly-Window-Syndrome" class="headerlink" title="Silly Window Syndrome"></a>Silly Window Syndrome</h2><p>Silly Window Syndrome 翻译成中文就是“糊涂窗口综合症”。正如你上面看到的一样，如果我们的接收方太忙了，来不及取走 Receive Windows 里的数据，那么，就会导致发送方越来越小。到最后，如果接收方腾出几个字节并告诉发送方现在有几个字节的 window，而我们的发送方会义无反顾地发送这几个字节。<br>要知道，我们的 TCP+IP 头有 40 个字节，为了几个字节，要达上这么大的开销，这太不经济了。<br>另外，你需要知道网络上有个 MTU，对于以太网来说，MTU 是 1500 字节，除去 TCP+IP 头的 40 个字节，真正的数据传输可以有 1460，这就是所谓的 MSS（Max Segment Size）注意，TCP 的 RFC 定义这个 MSS 的默认值是 536，这是因为<a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc791">RFC 791</a>里说了任何一个 IP 设备都得最少接收 576 尺寸的大小（实际上来说 576 是拨号的网络的 MTU，而 576 减去 IP 头的 20 个字节就是 536）。<br><strong>如果你的网络包可以塞满 MTU，那么你可以用满整个带宽，如果不能，那么你就会浪费带宽</strong>。（大于 MTU 的包有两种结局，一种是直接被丢了，另一种是会被重新分块打包发送） 你可以想像成一个 MTU 就相当于一个飞机的最多可以装的人，如果这飞机里满载的话，带宽最高，如果一个飞机只运一个人的话，无疑成本增加了，也而相当二。<br>所以，<strong>Silly Windows Syndrome 这个现像就像是你本来可以坐 200 人的飞机里只做了一两个人</strong>。 要解决这个问题也不难，就是避免对小的 window size 做出响应，直到有足够大的 window size 再响应，这个思路可以同时实现在 sender 和 receiver 两端。</p>
<ul>
<li>如果这个问题是由 Receiver 端引起的，那么就会使用  David D Clark’s 方案。在 receiver 端，如果收到的数据导致 window size 小于某个值，可以直接 ack(0)回 sender，这样就把 window 给关闭了，也阻止了 sender 再发数据过来，等到 receiver 端处理了一些数据后 windows size 大于等于了 MSS，或者，receiver buffer 有一半为空，就可以把 window 打开让 send 发送数据过来。</li>
<li>如果这个问题是由 Sender 端引起的，那么就会使用著名的<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Nagle%27s_algorithm">Nagle’s algorithm</a>。这个算法的思路也是延时处理，他有两个主要的条件：1）要等到 Window Size&gt;=MSS 或是 Data Size &gt;=MSS，2）收到之前发送数据的 ack 回包，他才会发数据，否则就是在攒数据。</li>
</ul>
<p>另外，Nagle 算法默认是打开的，所以，对于一些需要小包场景的程序——<strong>比如像 telnet 或 ssh 这样的交互性比较强的程序，你需要关闭这个算法</strong>。你可以在 Socket 设置 TCP_NODELAY 选项来关闭这个算法（关闭 Nagle 算法没有全局参数，需要根据每个应用自己的特点来关闭）</p>
<blockquote>
<p>setsockopt(sock_fd, IPPROTO_TCP, TCP_NODELAY, (<strong>char</strong> *)&amp;value,sizeof(<strong>int</strong>));</p>
</blockquote>
<p>另外，网上有些文章说 TCP_CORK 的 socket option 是也关闭 Nagle 算法，这不对。<strong>TCP_CORK 其实是更新激进的 Nagle 算汉，完全禁止小包发送，而 Nagle 算法没有禁止小包发送，只是禁止了大量的小包发送</strong>。最好不要两个选项都设置。</p>
<h1 id="TCP-的拥塞处理-–-Congestion-Handling"><a href="#TCP-的拥塞处理-–-Congestion-Handling" class="headerlink" title="TCP 的拥塞处理 – Congestion Handling"></a>TCP 的拥塞处理 – Congestion Handling</h1><p>上面我们知道了，TCP 通过 Sliding Window 来做流控（Flow Control），但是 TCP 觉得这还不够，因为 Sliding Window 需要依赖于连接的发送端和接收端，其并不知道网络中间发生了什么。TCP 的设计者觉得，一个伟大而牛逼的协议仅仅做到流控并不够，因为流控只是网络模型 4 层以上的事，TCP 的还应该更聪明地知道整个网络上的事。<br>具体一点，我们知道 TCP 通过一个 timer 采样了 RTT 并计算 RTO，但是，<strong>如果网络上的延时突然增加，那么，TCP 对这个事做出的应对只有重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，于是，这个情况就会进入恶性循环被不断地放大。试想一下，如果一个网络内有成千上万的 TCP 连接都这么行事，那么马上就会形成“网络风暴”，TCP 这个协议就会拖垮整个网络。</strong>这是一个灾难。<br>所以，TCP 不能忽略网络上发生的事情，而无脑地一个劲地重发数据，对网络造成更大的伤害。对此 TCP 的设计理念是：<strong>TCP 不是一个自私的协议，当拥塞发生的时候，要做自我牺牲。就像交通阻塞一样，每个车都应该把路让出来，而不要再去抢路了。</strong><br>关于拥塞控制的论文请参看《<a target="_blank" rel="noopener" href="http://ee.lbl.gov/papers/congavoid.pdf">Congestion Avoidance and Control</a>》(PDF)<br>拥塞控制主要是四个算法：<strong>1）慢启动</strong>，<strong>2）拥塞避免</strong>，<strong>3）拥塞发生</strong>，<strong>4）快速恢复</strong>。这四个算法不是一天都搞出来的，这个四算法的发展经历了很多时间，到今天都还在优化中。 备注:</p>
<ul>
<li>1988 年，TCP-Tahoe 提出了 1）慢启动，2）拥塞避免，3）拥塞发生时的快速重传</li>
<li>1990 年，TCP Reno 在 Tahoe 的基础上增加了 4）快速恢复</li>
</ul>
<h2 id="慢热启动算法-–-Slow-Start"><a href="#慢热启动算法-–-Slow-Start" class="headerlink" title="慢热启动算法 – Slow Start"></a>慢热启动算法 – Slow Start</h2><p>首先，我们来看一下 TCP 的慢热启动。慢启动的意思是，刚刚加入网络的连接，一点一点地提速，不要一上来就像那些特权车一样霸道地把路占满。新同学上高速还是要慢一点，不要把已经在高速上的秩序给搞乱了。<br>慢启动的算法如下(cwnd 全称 Congestion Window)：<br>1）连接建好的开始先初始化 cwnd = 1，表明可以传一个 MSS 大小的数据。<br>2）每当收到一个 ACK，cwnd++; 呈线性上升<br>3）每当过了一个 RTT，cwnd = cwnd*2; 呈指数让升<br>4）还有一个 ssthresh（slow start threshold），是一个上限，当 cwnd &gt;= ssthresh 时，就会进入“拥塞避免算法”（后面会说这个算法）<br>所以，我们可以看到，如果网速很快的话，ACK 也会返回得快，RTT 也会短，那么，这个慢启动就一点也不慢。下图说明了这个过程。<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619360710925-01185c73-f485-4be8-98f0-5fe748057a7c.jpeg#clientId=u6f576584-d24a-4&from=paste&height=194&id=ufd70501a&margin=%5Bobject%20Object%5D&originHeight=388&originWidth=662&originalType=url&status=done&style=none&taskId=u8b627dde-5740-4010-941a-b5fd27fba47&width=331"><br>这里，我需要提一下的是一篇 Google 的论文《<a target="_blank" rel="noopener" href="http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36640.pdf">An Argument for Increasing TCP’s Initial Congestion Window</a>》Linux 3.0 后采用了这篇论文的建议——把 cwnd 初始化成了 10 个 MSS。而 Linux 3.0 以前，比如 2.6，Linux 采用了<a target="_blank" rel="noopener" href="http://www.rfc-editor.org/rfc/rfc3390.txt">RFC3390</a>，cwnd 是跟 MSS 的值来变的，如果 MSS&lt; 1095，则 cwnd = 4；如果 MSS&gt;2190，则 cwnd=2；其它情况下，则是 3。</p>
<h2 id="拥塞避免算法-–-Congestion-Avoidance"><a href="#拥塞避免算法-–-Congestion-Avoidance" class="headerlink" title="拥塞避免算法 – Congestion Avoidance"></a>拥塞避免算法 – Congestion Avoidance</h2><p>前面说过，还有一个 ssthresh（slow start threshold），是一个上限，当 cwnd &gt;= ssthresh 时，就会进入“拥塞避免算法”。一般来说 ssthresh 的值是 65535，单位是字节，当 cwnd 达到这个值时后，算法如下：<br>1）收到一个 ACK 时，cwnd = cwnd + 1/cwnd<br>2）当每过一个 RTT 时，cwnd = cwnd + 1<br>这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。很明显，是一个线性上升的算法。</p>
<h2 id="拥塞状态时的算法"><a href="#拥塞状态时的算法" class="headerlink" title="拥塞状态时的算法"></a>拥塞状态时的算法</h2><p>前面我们说过，当丢包的时候，会有两种情况：<br>1）等到 RTO 超时，重传数据包。TCP 认为这种情况太糟糕，反应也很强烈。</p>
<ul>
<li>sshthresh =  cwnd /2</li>
<li>cwnd 重置为 1</li>
<li>进入慢启动过程</li>
</ul>
<p>2）Fast Retransmit 算法，也就是在收到 3 个 duplicate ACK 时就开启重传，而不用等到 RTO 超时。</p>
<ul>
<li>TCP Tahoe 的实现和 RTO 超时一样。</li>
<li>TCP Reno 的实现是：<ul>
<li>cwnd = cwnd /2</li>
<li>sshthresh = cwnd</li>
<li>进入快速恢复算法——Fast Recovery</li>
</ul>
</li>
</ul>
<p>上面我们可以看到 RTO 超时后，sshthresh 会变成 cwnd 的一半，这意味着，如果 cwnd&lt;=sshthresh 时出现的丢包，那么 TCP 的 sshthresh 就会减了一半，然后等 cwnd 又很快地以指数级增涨爬到这个地方时，就会成慢慢的线性增涨。我们可以看到，TCP 是怎么通过这种强烈地震荡快速而小心得找到网站流量的平衡点的。</p>
<h2 id="快速恢复算法-–-Fast-Recovery"><a href="#快速恢复算法-–-Fast-Recovery" class="headerlink" title="快速恢复算法 – Fast Recovery"></a>快速恢复算法 – Fast Recovery</h2><p><strong>TCP Reno</strong><br>这个算法定义在<a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc5681">RFC5681</a>。快速重传和快速恢复算法一般同时使用。快速恢复算法是认为，你还有 3 个 Duplicated Acks 说明网络也不那么糟糕，所以没有必要像 RTO 超时那么强烈。注意，正如前面所说，进入 Fast Recovery 之前，cwnd 和 sshthresh 已被更新：</p>
<ul>
<li>cwnd = cwnd /2</li>
<li>sshthresh = cwnd</li>
</ul>
<p>然后，真正的 Fast Recovery 算法如下：</p>
<ul>
<li>cwnd = sshthresh  + 3 * MSS （3 的意思是确认有 3 个数据包被收到了）</li>
<li>重传 Duplicated ACKs 指定的数据包</li>
<li>如果再收到 duplicated Acks，那么 cwnd = cwnd +1</li>
<li>如果收到了新的 Ack，那么，cwnd = sshthresh ，然后就进入了拥塞避免的算法了。</li>
</ul>
<p>如果你仔细思考一下上面的这个算法，你就会知道，<strong>上面这个算法也有问题，那就是——它依赖于 3 个重复的 Acks</strong>。注意，3 个重复的 Acks 并不代表只丢了一个数据包，很有可能是丢了好多包。但这个算法只会重传一个，而剩下的那些包只能等到 RTO 超时，于是，进入了恶梦模式——超时一个窗口就减半一下，多个超时会超成 TCP 的传输速度呈级数下降，而且也不会触发 Fast Recovery 算法了。<br>通常来说，正如我们前面所说的，SACK 或 D-SACK 的方法可以让 Fast Recovery 或 Sender 在做决定时更聪明一些，但是并不是所有的 TCP 的实现都支持 SACK（SACK 需要两端都支持），所以，需要一个没有 SACK 的解决方案。而通过 SACK 进行拥塞控制的算法是 FACK（后面会讲）<br><strong>TCP New Reno</strong><br>于是，1995 年，TCP New Reno（参见  <a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc6582">RFC 6582</a> ）算法提出来，主要就是在没有 SACK 的支持下改进 Fast Recovery 算法的——</p>
<ul>
<li>当 sender 这边收到了 3 个 Duplicated Acks，进入 Fast Retransimit 模式，开发重传重复 Acks 指示的那个包。如果只有这一个包丢了，那么，重传这个包后回来的 Ack 会把整个已经被 sender 传输出去的数据 ack 回来。如果没有的话，说明有多个包丢了。我们叫这个 ACK 为 Partial ACK。</li>
<li>一旦 Sender 这边发现了 Partial ACK 出现，那么，sender 就可以推理出来有多个包被丢了，于是乎继续重传 sliding window 里未被 ack 的第一个包。直到再也收不到了 Partial Ack，才真正结束 Fast Recovery 这个过程</li>
</ul>
<p>我们可以看到，这个“Fast Recovery 的变更”是一个非常激进的玩法，他同时延长了 Fast Retransmit 和 Fast Recovery 的过程。</p>
<h2 id="算法示意图"><a href="#算法示意图" class="headerlink" title="算法示意图"></a>算法示意图</h2><p>下面我们来看一个简单的图示以同时看一下上面的各种算法的样子：<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619360711007-954db5a2-33c1-46b8-88d1-876b1ba3bc41.jpeg#clientId=u6f576584-d24a-4&from=paste&height=180&id=u228560e9&margin=%5Bobject%20Object%5D&originHeight=359&originWidth=1024&originalType=url&status=done&style=none&taskId=u8a97b8d9-dad4-4106-9e6b-660badfae83&width=512"></p>
<h2 id="FACK-算法"><a href="#FACK-算法" class="headerlink" title="FACK 算法"></a>FACK 算法</h2><p>FACK 全称 Forward Acknowledgment 算法，论文地址在这里（PDF）<a target="_blank" rel="noopener" href="http://conferences.sigcomm.org/sigcomm/1996/papers/mathis.pdf">Forward Acknowledgement: Refining TCP Congestion Control</a>这个算法是其于 SACK 的，前面我们说过 SACK 是使用了 TCP 扩展字段 Ack 了有哪些数据收到，哪些数据没有收到，他比 Fast Retransmit 的 3 个 duplicated acks 好处在于，前者只知道有包丢了，不知道是一个还是多个，而 SACK 可以准确的知道有哪些包丢了。 所以，SACK 可以让发送端这边在重传过程中，把那些丢掉的包重传，而不是一个一个的传，但这样的一来，如果重传的包数据比较多的话，又会导致本来就很忙的网络就更忙了。所以，FACK 用来做重传过程中的拥塞流控。</p>
<ul>
<li>这个算法会把 SACK 中最大的 Sequence Number 保存在<strong>snd.fack</strong>这个变量中，snd.fack 的更新由 ack 带秋，如果网络一切安好则和 snd.una 一样（snd.una 就是还没有收到 ack 的地方，也就是前面 sliding window 里的 category #2 的第一个地方）</li>
<li>然后定义一个<strong>awnd = snd.nxt – snd.fack</strong>（snd.nxt 指向发送端 sliding window 中正在要被发送的地方——前面 sliding windows 图示的 category#3 第一个位置），这样 awnd 的意思就是在网络上的数据。（所谓 awnd 意为：actual quantity of data outstanding in the network）</li>
<li>如果需要重传数据，那么，<strong>awnd = snd.nxt – snd.fack + retran_data</strong>，也就是说，awnd 是传出去的数据 + 重传的数据。</li>
<li>然后触发 Fast Recovery 的条件是： (** ( snd.fack – snd.una ) &gt; (3*MSS) **) || (dupacks == 3) ) 。这样一来，就不需要等到 3 个 duplicated acks 才重传，而是只要 sack 中的最大的一个数据和 ack 的数据比较长了（3 个 MSS），那就触发重传。在整个重传过程中 cwnd 不变。直到当第一次丢包的 snd.nxt&lt;=snd.una（也就是重传的数据都被确认了），然后进来拥塞避免机制——cwnd 线性上涨。</li>
</ul>
<p>我们可以看到如果没有 FACK 在，那么在丢包比较多的情况下，原来保守的算法会低估了需要使用的 window 的大小，而需要几个 RTT 的时间才会完成恢复，而 FACK 会比较激进地来干这事。 但是，FACK 如果在一个网络包会被 reordering 的网络里会有很大的问题。</p>
<h1 id="其它拥塞控制算法简介"><a href="#其它拥塞控制算法简介" class="headerlink" title="其它拥塞控制算法简介"></a>其它拥塞控制算法简介</h1><h2 id="TCP-Vegas-拥塞控制算法"><a href="#TCP-Vegas-拥塞控制算法" class="headerlink" title="TCP Vegas 拥塞控制算法"></a>TCP Vegas 拥塞控制算法</h2><p>这个算法 1994 年被提出，它主要对 TCP Reno 做了些修改。这个算法通过对 RTT 的非常重的监控来计算一个基准 RTT。然后通过这个基准 RTT 来估计当前的网络实际带宽，如果实际带宽比我们的期望的带宽要小或是要多的活，那么就开始线性地减少或增加 cwnd 的大小。如果这个计算出来的 RTT 大于了 Timeout 后，那么，不等 ack 超时就直接重传。（Vegas 的核心思想是用 RTT 的值来影响拥塞窗口，而不是通过丢包） 这个算法的论文是《<a target="_blank" rel="noopener" href="http://www.cs.cmu.edu/~srini/15-744/F02/readings/BP95.pdf">TCP Vegas: End to End Congestion Avoidance on a Global Internet</a>》这篇论文给了 Vegas 和 New Reno 的对比：<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619360711090-1050cc4c-22d7-4ff9-a5e0-a357a2dbb4aa.jpeg#clientId=u6f576584-d24a-4&from=paste&height=278&id=u74444425&margin=%5Bobject%20Object%5D&originHeight=555&originWidth=1024&originalType=url&status=done&style=none&taskId=ub3b4ce85-9fe7-411e-8b38-8ce61da93c8&width=512"><br>关于这个算法实现，你可以参看 Linux 源码：<a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/net/ipv4/tcp_vegas.h">/net/ipv4/tcp_vegas.h</a>， <a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/net/ipv4/tcp_vegas.c">/net/ipv4/tcp_vegas.c</a></p>
<h2 id="HSTCP-High-Speed-TCP-算法"><a href="#HSTCP-High-Speed-TCP-算法" class="headerlink" title="HSTCP(High Speed TCP) 算法"></a>HSTCP(High Speed TCP) 算法</h2><p>这个算法来自<a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc3649">RFC 3649</a>（<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/HSTCP">Wikipedia 词条</a>）。其对最基础的算法进行了更改，他使得 Congestion Window 涨得快，减得慢。其中：</p>
<ul>
<li>拥塞避免时的窗口增长方式： cwnd = cwnd + α(cwnd) / cwnd</li>
<li>丢包后窗口下降方式：cwnd = (1- β(cwnd))*cwnd</li>
</ul>
<p>注：α(cwnd)和 β(cwnd)都是函数，如果你要让他们和标准的 TCP 一样，那么让 α(cwnd)=1，β(cwnd)=0.5 就可以了。 对于 α(cwnd)和 β(cwnd)的值是个动态的变换的东西。 关于这个算法的实现，你可以参看 Linux 源码：<a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/net/ipv4/tcp_highspeed.c">/net/ipv4/tcp_highspeed.c</a></p>
<h2 id="TCP-BIC-算法"><a href="#TCP-BIC-算法" class="headerlink" title="TCP BIC 算法"></a>TCP BIC 算法</h2><p>2004 年，产内出 BIC 算法。现在你还可以查得到相关的新闻《Google：<a target="_blank" rel="noopener" href="https://www.google.com/search?lr=lang_zh-CN%7Clang_zh-TW&newwindow=1&biw=1366&bih=597&tbs=lr:lang_1zh-CN%7Clang_1zh-TW&q=%E7%BE%8E%E7%A7%91%E5%AD%A6%E5%AE%B6%E7%A0%94%E5%8F%91BIC-TCP%E5%8D%8F%E8%AE%AE+%E9%80%9F%E5%BA%A6%E6%98%AFDSL%E5%85%AD%E5%8D%83%E5%80%8D&oq=%E7%BE%8E%E7%A7%91%E5%AD%A6%E5%AE%B6%E7%A0%94%E5%8F%91BIC-TCP%E5%8D%8F%E8%AE%AE+%E9%80%9F%E5%BA%A6%E6%98%AFDSL%E5%85%AD%E5%8D%83%E5%80%8D">美科学家研发 BIC-TCP 协议 速度是 DSL 六千倍</a>》 BIC 全称<a target="_blank" rel="noopener" href="http://research.csc.ncsu.edu/netsrv/?q=content/bic-and-cubic">Binary Increase Congestion control</a>，在 Linux 2.6.8 中是默认拥塞控制算法。BIC 的发明者发这么多的拥塞控制算法都在努力找一个合适的 cwnd – Congestion Window，而且 BIC-TCP 的提出者们看穿了事情的本质，其实这就是一个搜索的过程，所以 BIC 这个算法主要用的是 Binary Search——二分查找来干这个事。 关于这个算法实现，你可以参看 Linux 源码：<a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/net/ipv4/tcp_bic.c">/net/ipv4/tcp_bic.c</a></p>
<h2 id="TCP-WestWood-算法"><a href="#TCP-WestWood-算法" class="headerlink" title="TCP WestWood 算法"></a>TCP WestWood 算法</h2><p>westwood 采用和 Reno 相同的慢启动算法、拥塞避免算法。westwood 的主要改进方面：在发送端做带宽估计，当探测到丢包时，根据带宽值来设置拥塞窗口、慢启动阈值。那么，这个算法是怎么测量带宽的？每个 RTT 时间，会测量一次带宽，测量带宽的公式很简单，就是这段 RTT 内成功被 ack 了多少字节。因为，这个带宽和用 RTT 计算 RTO 一样，也是需要从每个样本来平滑到一个值的——也是用一个加权移平均的公式。 另外，我们知道，如果一个网络的带宽是每秒可以发送 X 个字节，而 RTT 是一个数据发出去后确认需要的时候，所以，X _ RTT 应该是我们缓冲区大小。所以，在这个算法中，ssthresh 的值就是 est_BD _ min-RTT(最小的 RTT 值)，如果丢包是 Duplicated ACKs 引起的，那么如果 cwnd &gt; ssthresh，则 cwin = ssthresh。如果是 RTO 引起的，cwnd = 1，进入慢启动。   关于这个算法实现，你可以参看 Linux 源码： <a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/net/ipv4/tcp_westwood.c">/net/ipv4/tcp_westwood.c</a></p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>更多的算法，你可以从 Wikipedia 的  <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/TCP_congestion-avoidance_algorithm">TCP Congestion Avoidance Algorithm</a>词条中找到相关的线索</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>好了，到这里我想可以结束了，TCP 发展到今天，里面的东西可以写上好几本书。本文主要目的，还是把你带入这些古典的基础技术和知识中，希望本文能让你了解 TCP，更希望本文能让你开始有学习这些基础或底层知识的兴趣和信心。<br>当然，TCP 东西太多了，不同的人可能有不同的理解，而且本文可能也会有一些荒谬之言甚至错误，还希望得到您的反馈和批评。<br>（全文完）<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619360711160-b492d96c-152c-4165-bf3d-c36362fc2359.jpeg#clientId=u6f576584-d24a-4&from=paste&height=129&id=ue1e91874&margin=%5Bobject%20Object%5D&originHeight=258&originWidth=258&originalType=url&status=done&style=none&taskId=u14a5554b-c21f-4e12-afa9-09d00a50397&width=129"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619360711264-17fc4846-2b4e-45b6-9f8b-9c594ed37469.jpeg#clientId=u6f576584-d24a-4&from=paste&height=129&id=u6b4d50ab&margin=%5Bobject%20Object%5D&originHeight=258&originWidth=258&originalType=url&status=done&style=none&taskId=u906dd6ed-944c-48a7-9251-a32a7d166f8&width=129">关注 CoolShell 微信公众账号和微信小程序</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/25/yuque/TCP%20%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%EF%BC%88%E4%B8%8A%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/25/yuque/TCP%20%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%EF%BC%88%E4%B8%8A%EF%BC%89/" class="post-title-link" itemprop="url">TCP 的那些事儿（上）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-25 22:19:58" itemprop="dateCreated datePublished" datetime="2021-04-25T22:19:58+08:00">2021-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-26 01:05:35" itemprop="dateModified" datetime="2021-04-26T01:05:35+08:00">2021-04-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>TCP 是一个巨复杂的协议，因为他要解决很多问题，而这些问题又带出了很多子问题和阴暗面。所以学习 TCP 本身是个比较痛苦的过程，但对于学习的过程却能让人有很多收获。关于 TCP 这个协议的细节，我还是推荐你去看<a target="_blank" rel="noopener" href="http://www.kohala.com/start/">W.Richard Stevens</a>的《<a target="_blank" rel="noopener" href="http://book.douban.com/subject/1088054/">TCP/IP 详解 卷 1：协议</a>》（当然，你也可以去读一下<a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc793">RFC793</a>以及后面 N 多的 RFC）。另外，本文我会使用英文术语，这样方便你通过这些英文关键词来查找相关的技术文档。<br>之所以想写这篇文章，目的有三个，</p>
<ul>
<li>一个是想锻炼一下自己是否可以用简单的篇幅把这么复杂的 TCP 协议描清楚的能力。</li>
<li>另一个是觉得现在的好多程序员基本上不会认认真真地读本书，喜欢快餐文化，所以，希望这篇快餐文章可以让你对 TCP 这个古典技术有所了解，并能体会到软件设计中的种种难处。并且你可以从中有一些软件设计上的收获。</li>
<li>最重要的希望这些基础知识可以让你搞清很多以前一些似是而非的东西，并且你能意识到基础的重要。</li>
</ul>
<p>所以，本文不会面面俱到，只是对 TCP 协议、算法和原理的科普。<br>我本来只想写一个篇幅的文章的，但是 TCP 真 TMD 的复杂，比 C++复杂多了，这 30 多年来，各种优化变种争论和修改。所以，写着写着就发现只有砍成两篇。</p>
<ul>
<li>上篇中，主要向你介绍 TCP 协议的定义和丢包时的重传机制。</li>
<li>下篇中，重点介绍 TCP 的流迭、拥塞处理。</li>
</ul>
<p>废话少说，首先，我们需要知道 TCP 在网络 OSI 的七层模型中的第四层——Transport 层，IP 在第三层——Network 层，ARP 在第二层——Data Link 层，在第二层上的数据，我们叫 Frame，在第三层上的数据叫 Packet，第四层的数据叫 Segment。<br>首先，我们需要知道，我们程序的数据首先会打到 TCP 的 Segment 中，然后 TCP 的 Segment 会打到 IP 的 Packet 中，然后再打到以太网 Ethernet 的 Frame 中，传到对端后，各个层解析自己的协议，然后把数据交给更高层的协议处理。</p>
<h1 id="TCP-头格式"><a href="#TCP-头格式" class="headerlink" title="TCP 头格式"></a>TCP 头格式</h1><p>接下来，我们来看一下 TCP 头的格式<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619360435712-cb93875c-cbbb-4568-a93c-cd610d064896.jpeg#clientId=ud05b6d37-a831-4&from=paste&height=324&id=u73cb9979&margin=%5Bobject%20Object%5D&originHeight=324&originWidth=800&originalType=url&status=done&style=none&taskId=ub7a2e625-7c99-4e81-a419-5a010e35f15&width=800">TCP 头格式（<a target="_blank" rel="noopener" href="http://nmap.org/book/tcpip-ref.html">图片来源</a>）<br>你需要注意这么几点：</p>
<ul>
<li>TCP 的包是没有 IP 地址的，那是 IP 层上的事。但是有源端口和目标端口。</li>
<li>一个 TCP 连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说 TCP 协议，所以，这里我只说四元组。</li>
<li>注意上图中的四个非常重要的东西：<ul>
<li><strong>Sequence Number</strong>是包的序号，<strong>用来解决网络包乱序（reordering）问题。</strong></li>
<li><strong>Acknowledgement Number</strong>就是 ACK——用于确认收到，<strong>用来解决不丢包的问题</strong>。</li>
<li><strong>Window 又叫 Advertised-Window</strong>，也就是著名的滑动窗口（Sliding Window），<strong>用于解决流控的</strong>。</li>
<li><strong>TCP Flag</strong>，也就是包的类型，<strong>主要是用于操控 TCP 的状态机的</strong>。</li>
</ul>
</li>
</ul>
<p>关于其它的东西，可以参看下面的图示<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619360435612-00cf3a4b-0003-418b-aa31-24ba052fe8c4.jpeg#clientId=ud05b6d37-a831-4&from=paste&height=245&id=u69ac5547&margin=%5Bobject%20Object%5D&originHeight=245&originWidth=800&originalType=url&status=done&style=none&taskId=u86f9dfbe-f310-4599-8fa7-c7a71241924&width=800"><br>（<a target="_blank" rel="noopener" href="http://nmap.org/book/tcpip-ref.html">图片来源</a>）</p>
<h1 id="TCP-的状态机"><a href="#TCP-的状态机" class="headerlink" title="TCP 的状态机"></a>TCP 的状态机</h1><p>其实，<strong>网络上的传输是没有连接的，包括 TCP 也是一样的</strong>。而 TCP 所谓的“连接”，其实只不过是在通讯的双方维护一个“连接状态”，让它看上去好像有连接一样。所以，TCP 的状态变换是非常重要的。<br>下面是：“<strong>TCP 协议的状态机</strong>”（<a target="_blank" rel="noopener" href="http://www.tcpipguide.com/free/t_TCPOperationalOverviewandtheTCPFiniteStateMachineF-2.htm">图片来源</a>） 和 “<strong>TCP 建链接</strong>”、“<strong>TCP 断链接</strong>”、“<strong>传数据</strong>” 的对照图，我把两个图并排放在一起，这样方便在你对照着看。另外，下面这两个图非常非常的重要，你一定要记牢。（吐个槽：看到这样复杂的状态机，就知道这个协议有多复杂，复杂的东西总是有很多坑爹的事情，所以 TCP 协议其实也挺坑爹的）<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619360435478-bdc079d8-59eb-4c14-b331-a1da33d9d01c.png#clientId=ud05b6d37-a831-4&from=paste&height=401&id=u58631bd8&margin=%5Bobject%20Object%5D&originHeight=801&originWidth=562&originalType=url&status=done&style=none&taskId=u2e244c08-3758-4f85-b8af-bea88766a30&width=281"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619360435742-10a18c36-7582-46d0-8722-b1765b434855.jpeg#clientId=ud05b6d37-a831-4&from=paste&height=488&id=u92e9d4bc&margin=%5Bobject%20Object%5D&originHeight=976&originWidth=875&originalType=url&status=done&style=none&taskId=ubbcb5cdf-a996-417b-9dc7-9d94bbdd3c0&width=437.5"><br>很多人会问，为什么建链接要 3 次握手，断链接需要 4 次挥手？</p>
<ul>
<li><strong>对于建链接的 3 次握手，</strong>主要是要初始化 Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的 Sequence Number（缩写为 ISN：Inital Sequence Number）——所以叫 SYN，全称 Synchronize Sequence Numbers。也就上图中的 x 和 y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP 会用这个序号来拼接数据）。</li>
<li><strong>对于 4 次挥手，</strong>其实你仔细看是 2 次，因为 TCP 是全双工的，所以，发送方和接收方都需要 Fin 和 Ack。只不过，有一方是被动的，所以看上去就成了所谓的 4 次挥手。如果两边同时断连接，那就会就进入到 CLOSING 状态，然后到达 TIME_WAIT 状态。下图是双方同时断连接的示意图（你同样可以对照着 TCP 状态机看）：</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619360435653-74f01dce-4151-4153-ae85-ef5f7c8934ef.png#clientId=ud05b6d37-a831-4&from=paste&height=526&id=u9a87d6d5&margin=%5Bobject%20Object%5D&originHeight=526&originWidth=666&originalType=url&status=done&style=none&taskId=u366cc996-5eb3-4b87-b5ff-af4b774637b&width=666"><br>两端同时断连接（<a target="_blank" rel="noopener" href="http://www.tcpipguide.com/free/t_TCPConnectionTermination-4.htm">图片来源</a>）<br>另外，有几个事情需要注意一下：</p>
<ul>
<li><strong>关于建连接时 SYN 超时</strong>。试想一下，如果 server 端接到了 clien 发的 SYN 后回了 SYN-ACK 后 client 掉线了，server 端没有收到 client 回来的 ACK，那么，这个连接处于一个中间状态，即没成功，也没失败。于是，server 端如果在一定时间内没有收到的 TCP 会重发 SYN-ACK。在 Linux 下，默认重试次数为 5 次，重试的间隔时间从 1s 开始每次都翻售，5 次的重试时间间隔为 1s, 2s, 4s, 8s, 16s，总共 31s，第 5 次发出后还要等 32s 都知道第 5 次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 -1 = 63s，TCP 才会把断开这个连接。</li>
<li><strong>关于 SYN Flood 攻击</strong>。一些恶意的人就为此制造了 SYN Flood 攻击——给服务器发了一个 SYN 后，就下线了，于是服务器需要默认等 63s 才会断开连接，这样，攻击者就可以把服务器的 syn 连接的队列耗尽，让正常的连接请求不能处理。于是，Linux 下给了一个叫<strong>tcp_syncookies</strong>的参数来应对这个事——当 SYN 队列满了后，TCP 会通过源地址端口、目标地址端口和时间戳打造出一个特别的 Sequence Number 发回去（又叫 cookie），如果是攻击者则不会有响应，如果是正常连接，则会把这个 SYN Cookie 发回来，然后服务端可以通过 cookie 建连接（即使你不在 SYN 队列中）。请注意，<strong>请先千万别用 tcp_syncookies 来处理正常的大负载的连接的情况</strong>。因为，synccookies 是妥协版的 TCP 协议，并不严谨。对于正常的请求，你应该调整三个 TCP 参数可供你选择，第一个是：tcp_synack_retries 可以用他来减少重试次数；第二个是：tcp_max_syn_backlog，可以增大 SYN 连接数；第三个是：tcp_abort_on_overflow 处理不过来干脆就直接拒绝连接了。</li>
<li><strong>关于 ISN 的初始化</strong>。ISN 是不能 hard code 的，不然会出问题的——比如：如果连接建好后始终用 1 来做 ISN，如果 client 发了 30 个 segment 过去，但是网络断了，于是 client 重连，又用了 1 做 ISN，但是之前连接的那些包到了，于是就被当成了新连接的包，此时，client 的 Sequence Number 可能是 3，而 Server 端认为 client 端的这个号是 30 了。全乱了。<a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc793">RFC793</a>中说，ISN 会和一个假的时钟绑在一起，这个时钟会在每 4 微秒对 ISN 做加一操作，直到超过 2^32，又从 0 开始。这样，一个 ISN 的周期大约是 4.55 个小时。因为，我们假设我们的 TCP Segment 在网络上的存活时间不会超过 Maximum Segment Lifetime（缩写为 MSL – <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Maximum_Segment_Lifetime">Wikipedia 语条</a>），所以，只要 MSL 的值小于 4.55 小时，那么，我们就不会重用到 ISN。</li>
<li><strong>关于 MSL 和  TIME_WAIT</strong>。通过上面的 ISN 的描述，相信你也知道 MSL 是怎么来的了。我们注意到，在 TCP 的状态图中，从 TIME_WAIT 状态到 CLOSED 状态，有一个超时设置，这个超时设置是 2*MSL（<a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc793">RFC793</a>定义了 MSL 为 2 分钟，Linux 设置成了 30s）为什么要这有 TIME_WAIT？为什么不直接给转成 CLOSED 状态呢？主要有两个原因：1）TIME_WAIT 确保有足够的时间让对端收到了 ACK，如果被动关闭的那方没有收到 Ack，就会触发被动端重发 Fin，一来一去正好 2 个 MSL，2）有足够的时间让这个连接不会跟后面的连接混在一起（你要知道，有些自做主张的路由器会缓存 IP 数据包，如果连接被重用了，那么这些延迟收到的包就有可能会跟新连接混在一起）。你可以看看这篇文章《<a target="_blank" rel="noopener" href="http://www.serverframework.com/asynchronousevents/2011/01/time-wait-and-its-design-implications-for-protocols-and-scalable-servers.html">TIME_WAIT and its design implications for protocols and scalable client server systems</a>》</li>
<li><strong>关于 TIME_WAIT 数量太多</strong>。从上面的描述我们可以知道，TIME_WAIT 是个很重要的状态，但是如果在大并发的短链接下，TIME_WAIT 就会太多，这也会消耗很多系统资源。只要搜一下，你就会发现，十有八九的处理方式都是教你设置两个参数，一个叫<strong>tcp_tw_reuse</strong>，另一个叫<strong>tcp_tw_recycle</strong>的参数，这两个参数默认值都是被关闭的，后者 recyle 比前者 resue 更为激进，resue 要温柔一些。另外，如果使用 tcp_tw_reuse，必需设置 tcp_timestamps=1，否则无效。这里，你一定要注意，<strong>打开这两个参数会有比较大的坑——可能会让 TCP 连接出一些诡异的问题</strong>（因为如上述一样，如果不等待超时重用连接的话，新的连接可能会建不上。正如<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt">官方文档</a>上说的一样“<strong>It should not be changed without advice/request of technical experts</strong>”）。<ul>
<li><strong>关于 tcp_tw_reuse</strong>。官方文档上说 tcp_tw_reuse 加上 tcp_timestamps（又叫 PAWS, for Protection Against Wrapped Sequence Numbers）可以保证协议的角度上的安全，但是你需要 tcp_timestamps 在两边都被打开（你可以读一下<a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/ident?i=tcp_twsk_unique">tcp_twsk_unique</a>的源码）。我个人估计还是有一些场景会有问题。</li>
<li><strong>关于 tcp_tw_recycle</strong>。如果是 tcp_tw_recycle 被打开了话，会假设对端开启了 tcp_timestamps，然后会去比较时间戳，如果时间戳变大了，就可以重用。但是，如果对端是一个 NAT 网络的话（如：一个公司只用一个 IP 出公网）或是对端的 IP 被另一台重用了，这个事就复杂了。建链接的 SYN 可能就被直接丢掉了（你可能会看到 connection time out 的错误）（如果你想观摩一下 Linux 的内核代码，请参看源码<a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/ident?i=tcp_timewait_state_process">tcp_timewait_state_process</a>）。</li>
<li><strong>关于 tcp_max_tw_buckets</strong>。这个是控制并发的 TIME_WAIT 的数量，默认值是 180000，如果超限，那么，系统会把多的给 destory 掉，然后在日志里打一个警告（如：time wait bucket table overflow），官网文档说这个参数是用来对抗 DDoS 攻击的。也说的默认值 180000 并不小。这个还是需要根据实际情况考虑。</li>
</ul>
</li>
</ul>
<p><strong>Again，使用 tcp_tw_reuse 和 tcp_tw_recycle 来解决 TIME_WAIT 的问题是非常非常危险的，因为这两个参数违反了 TCP 协议（</strong><a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc1122">RFC 1122</a>**） **<br>其实，TIME_WAIT 表示的是你主动断连接，所以，这就是所谓的“不作死不会死”。试想，如果让对端断连接，那么这个破问题就是对方的了，呵呵。另外，如果你的服务器是于 HTTP 服务器，那么设置一个<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/HTTP_persistent_connection">HTTP 的 KeepAlive</a>有多重要（浏览器会重用一个 TCP 连接来处理多个 HTTP 请求），然后让客户端去断链接（你要小心，浏览器可能会非常贪婪，他们不到万不得已不会主动断连接）。</p>
<h1 id="数据传输中的-Sequence-Number"><a href="#数据传输中的-Sequence-Number" class="headerlink" title="数据传输中的 Sequence Number"></a>数据传输中的 Sequence Number</h1><p>下图是我从 Wireshark 中截了个我在访问 coolshell.cn 时的有数据传输的图给你看一下，SeqNum 是怎么变的。（使用 Wireshark 菜单中的 Statistics -&gt;Flow Graph… ）<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619360436840-9ad57394-22a9-4ea3-b7cb-3e1f3c4b2288.jpeg#clientId=ud05b6d37-a831-4&from=paste&height=181&id=u961b086c&margin=%5Bobject%20Object%5D&originHeight=361&originWidth=381&originalType=url&status=done&style=none&taskId=ufa11b3ce-ee94-4178-ba9a-f7fc169d625&width=190.5"><br>你可以看到，<strong>SeqNum 的增加是和传输的字节数相关的</strong>。上图中，三次握手后，来了两个 Len:1440 的包，而第二个包的 SeqNum 就成了 1441。然后第一个 ACK 回的是 1441，表示第一个 1440 收到了。<br><strong>注意</strong>：如果你用 Wireshark 抓包程序看 3 次握手，你会发现 SeqNum 总是为 0，不是这样的，Wireshark 为了显示更友好，使用了 Relative SeqNum——相对序号，你只要在右键菜单中的 protocol preference 中取消掉就可以看到“Absolute SeqNum”了</p>
<h1 id="TCP-重传机制"><a href="#TCP-重传机制" class="headerlink" title="TCP 重传机制"></a>TCP 重传机制</h1><p>TCP 要保证所有的数据包都可以到达，所以，必需要有重传机制。<br>注意，接收端给发送端的 Ack 确认只会确认最后一个连续的包，比如，发送端发了 1,2,3,4,5 一共五份数据，接收端收到了 1，2，于是回 ack 3，然后收到了 4（注意此时 3 没收到），此时的 TCP 会怎么办？我们要知道，因为正如前面所说的，<strong>SeqNum 和 Ack 是以字节数为单位，所以 ack 的时候，不能跳着确认，只能确认最大的连续收到的包</strong>，不然，发送端就以为之前的都收到了。</p>
<h2 id="超时重传机制"><a href="#超时重传机制" class="headerlink" title="超时重传机制"></a>超时重传机制</h2><p>一种是不回 ack，死等 3，当发送方发现收不到 3 的 ack 超时后，会重传 3。一旦接收方收到 3 后，会 ack 回 4——意味着 3 和 4 都收到了。<br>但是，这种方式会有比较严重的问题，那就是因为要死等 3，所以会导致 4 和 5 即便已经收到了，而发送方也完全不知道发生了什么事，因为没有收到 Ack，所以，发送方可能会悲观地认为也丢了，所以有可能也会导致 4 和 5 的重传。<br>对此有两种选择：</p>
<ul>
<li>一种是仅重传 timeout 的包。也就是第 3 份数据。</li>
<li>另一种是重传 timeout 后所有的数据，也就是第 3，4，5 这三份数据。</li>
</ul>
<p>这两种方式有好也有不好。第一种会节省带宽，但是慢，第二种会快一点，但是会浪费带宽，也可能会有无用功。但总体来说都不好。因为都在等 timeout，timeout 可能会很长（在下篇会说 TCP 是怎么动态地计算出 timeout 的）</p>
<h2 id="快速重传机制"><a href="#快速重传机制" class="headerlink" title="快速重传机制"></a>快速重传机制</h2><p>于是，TCP 引入了一种叫<strong>Fast Retransmit</strong>的算法，<strong>不以时间驱动，而以数据驱动重传</strong>。也就是说，如果，包没有连续到达，就 ack 最后那个可能被丢了的包，如果发送方连续收到 3 次相同的 ack，就重传。Fast Retransmit 的好处是不用等 timeout 了再重传。<br>比如：如果发送方发出了 1，2，3，4，5 份数据，第一份先到送了，于是就 ack 回 2，结果 2 因为某些原因没收到，3 到达了，于是还是 ack 回 2，后面的 4 和 5 都到了，但是还是 ack 回 2，因为 2 还是没有收到，于是发送端收到了三个 ack=2 的确认，知道了 2 还没有到，于是就马上重转 2。然后，接收端收到了 2，此时因为 3，4，5 都收到了，于是 ack 回 6。示意图如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619360436853-3da25777-c070-4722-8c42-e3c5fc36707b.png#clientId=ud05b6d37-a831-4&from=paste&height=291&id=u83d95bef&margin=%5Bobject%20Object%5D&originHeight=291&originWidth=450&originalType=url&status=done&style=none&taskId=u246727c5-356f-42de-8b6a-e79c6b1156f&width=450"><br>Fast Retransmit 只解决了一个问题，就是 timeout 的问题，它依然面临一个艰难的选择，就是，是重传之前的一个还是重传所有的问题。对于上面的示例来说，是重传#2 呢还是重传#2，#3，#4，#5 呢？因为发送端并不清楚这连续的 3 个 ack(2)是谁传回来的？也许发送端发了 20 份数据，是#6，#10，#20 传来的呢。这样，发送端很有可能要重传从 2 到 20 的这堆数据（这就是某些 TCP 的实际的实现）。可见，这是一把双刃剑。</p>
<h2 id="SACK-方法"><a href="#SACK-方法" class="headerlink" title="SACK 方法"></a>SACK 方法</h2><p>另外一种更好的方式叫：<strong>Selective Acknowledgment (SACK)<strong>（参看<a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc2018">RFC 2018</a>），这种方式需要在 TCP 头里加一个 SACK 的东西，ACK 还是 Fast Retransmit 的 ACK，SACK 则是汇报收到的数据碎版。参看下图：<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619360436992-f9514dc3-2ff5-4739-b8b3-abeca5fcf8d9.jpeg#clientId=ud05b6d37-a831-4&from=paste&height=431&id=u3b552a87&margin=%5Bobject%20Object%5D&originHeight=577&originWidth=1024&originalType=url&status=done&style=none&taskId=ud770b3d1-7779-4030-932e-452d804ed7c&width=765"><br>这样，在发送端就可以根据回传的 SACK 来知道哪些数据到了，哪些没有到。于是就优化了 Fast Retransmit 的算法。当然，这个协议需要两边都支持。在 Linux 下，可以通过</strong>tcp_sack</strong>参数打开这个功能（Linux 2.4 后默认打开）。<br>这里还需要注意一个问题——<strong>接收方 Reneging，所谓 Reneging 的意思就是接收方有权把已经报给发送端 SACK 里的数据给丢了</strong>。这样干是不被鼓励的，因为这个事会把问题复杂化了，但是，接收方这么做可能会有些极端情况，比如要把内存给别的更重要的东西。<strong>所以，发送方也不能完全依赖 SACK，还是要依赖 ACK，并维护 Time-Out，如果后续的 ACK 没有增长，那么还是要把 SACK 的东西重传，另外，接收端这边永远不能把 SACK 的包标记为 Ack。</strong><br>注意：SACK 会消费发送方的资源，试想，如果一个攻击者给数据发送方发一堆 SACK 的选项，这会导致发送方开始要重传甚至遍历已经发出的数据，这会消耗很多发送端的资源。详细的东西请参看《<a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/linux/l-tcp-sack/">TCP SACK 的性能权衡</a>》</p>
<h2 id="Duplicate-SACK-–-重复收到数据的问题"><a href="#Duplicate-SACK-–-重复收到数据的问题" class="headerlink" title="Duplicate SACK – 重复收到数据的问题"></a>Duplicate SACK – 重复收到数据的问题</h2><p>Duplicate SACK 又称 D-SACK，<strong>其主要使用了 SACK 来告诉发送方有哪些数据被重复接收了</strong>。<a target="_blank" rel="noopener" href="http://www.ietf.org/rfc/rfc2883.txt">RFC-2883</a>里有详细描述和示例。下面举几个例子（来源于<a target="_blank" rel="noopener" href="http://www.ietf.org/rfc/rfc2883.txt">RFC-2883</a>）<br>D-SACK 使用了 SACK 的第一个段来做标志，</p>
<ul>
<li>如果 SACK 的第一个段的范围被 ACK 所覆盖，那么就是 D-SACK</li>
<li>如果 SACK 的第一个段的范围被 SACK 的第二个段覆盖，那么就是 D-SACK</li>
</ul>
<p><strong>示例一：ACK 丢包</strong><br>下面的示例中，丢了两个 ACK，所以，发送端重传了第一个数据包（3000-3499），于是接收端发现重复收到，于是回了一个 SACK=3000-3500，因为 ACK 都到了 4000 意味着收到了 4000 之前的所有数据，所以这个 SACK 就是 D-SACK——旨在告诉发送端我收到了重复的数据，而且我们的发送端还知道，数据包没有丢，丢的是 ACK 包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Transmitted  Received    ACK Sent</span><br><span class="line">Segment      Segment     (Including SACK Blocks)</span><br><span class="line"></span><br><span class="line">3000-34993000-34993500 (ACK dropped)</span><br><span class="line">3500-39993500-39994000 (ACK dropped)</span><br><span class="line">3000-34993000-34994000, SACK&#x3D;3000-3500</span><br><span class="line">                                        ---------</span><br></pre></td></tr></table></figure>

<p>**  示例二，网络延误**<br>下面的示例中，网络包（1000-1499）被网络给延误了，导致发送方没有收到 ACK，而后面到达的三个包触发了“Fast Retransmit 算法”，所以重传，但重传时，被延误的包又到了，所以，回了一个 SACK=1000-1500，因为 ACK 已到了 3000，所以，这个 SACK 是 D-SACK——标识收到了重复的包。<br>这个案例下，发送端知道之前因为“Fast Retransmit 算法”触发的重传不是因为发出去的包丢了，也不是因为回应的 ACK 包丢了，而是因为网络延时了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Transmitted    Received    ACK Sent</span><br><span class="line">Segment        Segment     (Including SACK Blocks)</span><br><span class="line"></span><br><span class="line">500-999500-9991000</span><br><span class="line">1000-1499      (delayed)</span><br><span class="line">1500-19991500-19991000, SACK&#x3D;1500-2000</span><br><span class="line">2000-24992000-24991000, SACK&#x3D;1500-2500</span><br><span class="line">2500-29992500-29991000, SACK&#x3D;1500-3000</span><br><span class="line">1000-14991000-14993000</span><br><span class="line">1000-14993000, SACK&#x3D;1000-1500</span><br><span class="line">                                          ---------</span><br></pre></td></tr></table></figure>

<p>可见，引入了 D-SACK，有这么几个好处：<br>1）可以让发送方知道，是发出去的包丢了，还是回来的 ACK 包丢了。<br>2）是不是自己的 timeout 太小了，导致重传。<br>3）网络上出现了先发的包后到的情况（又称 reordering）<br>4）网络上是不是把我的数据包给复制了。<br><strong>知道这些东西可以很好得帮助 TCP 了解网络情况，从而可以更好的做网络上的流控</strong>。<br>Linux 下的 tcp_dsack 参数用于开启这个功能（Linux 2.4 后默认打开）<br>好了，上篇就到这里结束了。如果你觉得我写得还比较浅显易懂，那么，欢迎移步看下篇《<a target="_blank" rel="noopener" href="https://coolshell.cn/articles/11609.html">TCP 的那些事（下）</a>》<br><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/11609.html">TCP 的那些事儿（下）&gt;&gt;&gt;</a><br>（上篇完）<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619360437335-05195b27-62c3-44dd-b137-209d4380410b.jpeg#clientId=ud05b6d37-a831-4&from=paste&height=129&id=u0e081c04&margin=%5Bobject%20Object%5D&originHeight=258&originWidth=258&originalType=url&status=done&style=none&taskId=ue1002983-687d-4442-bb7c-9692e8f2dc8&width=129"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619360438065-ea6f45eb-52cd-490e-a2a0-ffdcb1957a54.jpeg#clientId=ud05b6d37-a831-4&from=paste&height=129&id=u6dbf991e&margin=%5Bobject%20Object%5D&originHeight=258&originWidth=258&originalType=url&status=done&style=none&taskId=ufc420364-0496-4029-82f4-e8800284f91&width=129">关注 CoolShell 微信公众账号和微信小程序<br><strong>（转载本站文章请注明作者和出处</strong><a target="_blank" rel="noopener" href="https://coolshell.cn/">酷 壳 – CoolShell</a><strong>，请勿用于任何商业用途）</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/25/yuque/websocket%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%8A%A5%E6%96%87%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/25/yuque/websocket%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%8A%A5%E6%96%87%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">websocket协议详解及报文分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-25 22:01:29" itemprop="dateCreated datePublished" datetime="2021-04-25T22:01:29+08:00">2021-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-26 01:05:35" itemprop="dateModified" datetime="2021-04-26T01:05:35+08:00">2021-04-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>#websocket 协议详解及报文分析</p>
<h1 id="websocket-协议详解及报文分析"><a href="#websocket-协议详解及报文分析" class="headerlink" title="websocket 协议详解及报文分析"></a>websocket 协议详解及报文分析</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相较于 HTTP 协议，HTTP 协议有一个的缺陷为：通信只能由客户端发起。在一些场景下，这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用轮询：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。</p>
<p>轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。</p>
<h2 id="websocket-协议概述"><a href="#websocket-协议概述" class="headerlink" title="websocket 协议概述"></a>websocket 协议概述</h2><p>Webscoket 是 Web 浏览器和服务器之间的一种全双工通信协议，其中 WebSocket 协议由 IETF 定为标准，WebSocket API 由 W3C 定为标准。一旦 Web 客户端与服务器建立起连接，之后的全部数据通信都通过这个连接进行。通信过程中，可互相发送 JSON、XML、HTML 或图片等任意格式的数据。 WS（WebSocket）与 HTTP 协议相比，</p>
<p><strong>相同点主要有：</strong></p>
<ul>
<li>都是基于 TCP 的应用层协议；- 都使用 Request/Response 模型进行连接的建立；- 在连接的建立过程中对错误的处理方式相同，在这个阶段 WS 可能返回和 HTTP 相同的返回码；- 都可以在网络中传输数据。</li>
</ul>
<p><strong>不同之处在于：</strong></p>
<ul>
<li>WS 使用 HTTP 来建立连接，但是定义了一系列新的 header 域，这些域在 HTTP 中并不会使用；- WS 的连接不能通过中间人来转发，它必须是一个直接连接；- WS 连接建立之后，通信双方都可以在任何时刻向另一方发送数据；- WS 连接建立之后，数据的传输使用帧来传递，不再需要 Request 消息；- WS 的数据帧有序。</li>
</ul>
<h2 id="websocket-通信过程及对应报文分析"><a href="#websocket-通信过程及对应报文分析" class="headerlink" title="websocket 通信过程及对应报文分析"></a>websocket 通信过程及对应报文分析</h2><p>WS 整个通信过程如下图所示： <img src="https://img-blog.csdnimg.cn/20200527233222508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xMODQ1ODc2NDI1,size_16,color_FFFFFF,t_70#alt="> <img src="https://img-blog.csdnimg.cn/20200527233246458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xMODQ1ODc2NDI1,size_16,color_FFFFFF,t_70#alt="></p>
<p>websocket 是基于 TCP 的一个应用协议，与 HTTP 协议的关联之处在于 websocket 的握手数据被 HTTP 服务器当作 HTTP 包来处理，主要通过 Update request HTTP 包建立起连接，之后的通信全部使用 websocket 自己的协议。</p>
<p><strong>请求：</strong>TCP 连接建立后，客户端发送 websocket 的握手请求，请求报文头部如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;uin&#x3D;xxxxxxxx&amp;app&#x3D;xxxxxxxxx&amp;token&#x3D;XXXXXXXXXXXX HTTP&#x2F;1.1</span><br><span class="line">Host: server.example.cn:443</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_2) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;81.0.4044.138 Safari&#x2F;537.36</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9</span><br><span class="line">Cookie: user_id&#x3D;XXXXX</span><br><span class="line">Sec-WebSocket-Key: 1&#x2F;2hTi&#x2F;+eNURiekpNI4k5Q&#x3D;&#x3D;</span><br><span class="line">Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits</span><br><span class="line">Sec-WebSocket-Protocol: binary, base64</span><br></pre></td></tr></table></figure>

<ul>
<li>第一行为为请求的方法，类型必须为 GET，协议版本号必须大于 1.1- Upgrade 字段必须包含，值为 websocket- Connection 字段必须包含，值为 Upgrade- Sec-WebSocket-Key 字段必须包含 ，记录着握手过程中必不可少的键值。- Sec-WebSocket-Protocol 字段必须包含 ，记录着使用的子协议- Origin（请求头）：Origin 用来指明请求的来源，Origin 头部主要用于保护 Websocket 服务器免受非授权的跨域脚本调用 Websocket API 的请求。也就是不想没被授权的跨域访问与服务器建立连接，服务器可以通过这个字段来判断来源的域并有选择的拒绝。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200527233303721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xMODQ1ODc2NDI1,size_16,color_FFFFFF,t_70#alt="></p>
<p><strong>响应：</strong>服务器接收到请求后，返回状态码为 101 Switching Protocols 的响应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Server: WebSockify Python&#x2F;2.6.6</span><br><span class="line">Date: Wed, 27 May 2020 03:03:21 GMT</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: hXXXXXXXXXXXXXXxGmM&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: binary</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200527233326813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xMODQ1ODc2NDI1,size_16,color_FFFFFF,t_70#alt="></p>
<p>Sec-WebSocket-Accept 字段是由握手请求中的 Sec-WebSocket-Key 字段生层的。</p>
<p>握手成功后，通信不再使用 HTTP 协议，而采用 WebSocket 独立的数据帧。如下图所示，为协议帧格式：</p>
<p><img src="https://img-blog.csdnimg.cn/20200527233345809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xMODQ1ODc2NDI1,size_16,color_FFFFFF,t_70#alt="></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FIN，指明Frame是否是一个Message里最后Frame（之前说过一个Message可能又多个Frame组成）；1bit，是否为信息的最后一帧</span><br><span class="line">RSV1-3，默认是0 (必须是0)，除非有扩展定义了非零值的意义。</span><br><span class="line">Opcode，这个比较重要，有如下取值是被协议定义的</span><br><span class="line">				0x00 denotes a continuation frame</span><br><span class="line">				0x01 表示一个text frame</span><br><span class="line">				0x02 表示一个binary frame</span><br><span class="line">				0x03 ~~ 0x07 are reserved for further non-control frames,为将来的非控制消息片段保留测操作码</span><br><span class="line">				0x08 表示连接关闭</span><br><span class="line">				0x09 表示 ping (心跳检测相关)</span><br><span class="line">				0x0a 表示 pong (心跳检测相关)</span><br><span class="line">				0x0b ~~ 0x0f are reserved for further control frames,为将来的控制消息片段保留的操作码</span><br><span class="line">Mask，这个是指明“payload data”是否被计算掩码。这个和后面的Masking-key有关，如果设置为1,掩码键必须放在masking-key区域，客户端发送给服务端的所有消息，此位的值都是1；</span><br><span class="line">Payload len，数据的长度，</span><br><span class="line">Masking-key，0或者4bit，只有当MASK设置为1时才有效。，给一个Websocket中掩码的意义</span><br><span class="line">Payload data，帧真正要发送的数据，可以是任意长度，但尽管理论上帧的大小没有限制，但发送的数据不能太大，否则会导致无法高效利用网络带宽，正如上面所说Websocket提供分片。</span><br><span class="line">Extension data：扩展数据，如果客户端和服务端没有特殊的约定，那么扩展数据长度始终为0</span><br><span class="line">Application data：应用数据，</span><br></pre></td></tr></table></figure>

<p>websocket 报文细节，这里由于 client 和 server 端的 ip 都是 127.0.0.1 ：</p>
<p><img src="https://img-blog.csdnimg.cn/20200527233405188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xMODQ1ODc2NDI1,size_16,color_FFFFFF,t_70#alt="></p>
<h2 id="nginx-支持-websocket-配置"><a href="#nginx-支持-websocket-配置" class="headerlink" title="nginx 支持 websocket 配置"></a>nginx 支持 websocket 配置</h2><p>由于 http 请求 涉及 反向代理 所以就涉及 nginx 配置需要支持 websocket 需要做一些特殊的配置；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 配置Nginx支持webSocket开始</span><br><span class="line">proxy_set_header Host $http_host;</span><br><span class="line">proxy_http_version 1.1;</span><br><span class="line">proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">proxy_set_header Connection &quot;upgrade&quot;;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200527233424850.png#alt="></p>
<p>其他通过代码模拟 websocket 的代码可以查阅其他博客内容，这里就不赘述；</p>
<p><a target="_blank" rel="noopener" href="https://www.tutorialspoint.com/websockets/websockets_send_receive_messages.htm">https://www.tutorialspoint.com/websockets/websockets_send_receive_messages.htm</a></p>
<p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">http://www.ruanyifeng.com/blog/2017/05/websocket.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/25/yuque/HTTP3.0%E5%92%8CQUIC%E5%8D%8F%E8%AE%AE%E9%82%A3%E4%BA%9B%E4%BA%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/25/yuque/HTTP3.0%E5%92%8CQUIC%E5%8D%8F%E8%AE%AE%E9%82%A3%E4%BA%9B%E4%BA%8B/" class="post-title-link" itemprop="url">HTTP3.0和QUIC协议那些事</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-25 17:04:07" itemprop="dateCreated datePublished" datetime="2021-04-25T17:04:07+08:00">2021-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-26 01:05:36" itemprop="dateModified" datetime="2021-04-26T01:05:36+08:00">2021-04-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>#HTTP3.0 和 QUIC 协议那些事</p>
<h1 id="HTTP3-0-和-QUIC-协议那些事"><a href="#HTTP3-0-和-QUIC-协议那些事" class="headerlink" title="HTTP3.0 和 QUIC 协议那些事"></a>HTTP3.0 和 QUIC 协议那些事</h1><ul>
<li>写在前面<blockquote>
<ul>
<li>如果你的 App，在不需要任何修改的情况下就能提升 15% 以上的访问速度。特别是弱网络的时候能够提升 20% 以上的访问速度。</li>
<li>如果你的 App，在频繁切换 4G 和 WIFI 网络的情况下，不会断线，不需要重连，用户无任何感知。如果你的 App，既需要 TLS 的安全，也想实现 HTTP2 多路复用的强大。</li>
<li>如果你刚刚才听说 HTTP2 是下一代互联网协议，如果你刚刚才关注到 TLS1.3 是一个革命性具有里程碑意义的协议，但是这两个协议却一直在被另一个更新兴的协议所影响和挑战。</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="一、HTTP2-0-和-HTTP3-0"><a href="#一、HTTP2-0-和-HTTP3-0" class="headerlink" title="一、HTTP2.0 和 HTTP3.0"></a>一、HTTP2.0 和 HTTP3.0</h2><blockquote>
<p>科技永不止步 -   我们都知道互联网中业务是不断迭代前进的，像 HTTP 这种重要的网络协议也是如此，新版本是对旧版本的扬弃。</p>
</blockquote>
<h3 id="1-1-HTTP2-0-和-TCP-的爱恨纠葛"><a href="#1-1-HTTP2-0-和-TCP-的爱恨纠葛" class="headerlink" title="1.1 HTTP2.0 和 TCP 的爱恨纠葛"></a>1.1 HTTP2.0 和 TCP 的爱恨纠葛</h3><p><code>**HTTP2.0**</code><strong>是 2015 年推出的，还是比较年轻的，</strong><code>**其重要的二进制分帧协议、多路复用、头部压缩、服务端推送等**</code><strong>重要优化使 HTTP 协议真正上了一个新台阶。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200922123003302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=BHt2w&originHeight=962&originWidth=828&originalType=binary&status=done&style=none"></p>
<blockquote>
<p>像谷歌这种重要的公司并没有满足于此，而且想继续提升 HTTP 的性能，花最少的时间和资源获取极致体验。<br>那么肯定要问 HTTP2.0 虽然性能已经不错了，还有什么不足吗？ <code>建立连接时间长(本质上是TCP的问题) ,队头阻塞问题</code> &gt; <code>移动互联网领域表现不佳(弱网环境</code>) …</p>
</blockquote>
<ul>
<li><strong>熟悉 HTTP2.0 协议的同学应该知道，这些缺点基本都是由于 TCP 协议引起的，水能载舟亦能覆舟，其实 TCP 也很无辜呀！</strong></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200922123253603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=tAooz&originHeight=748&originWidth=1080&originalType=binary&status=done&style=none"></p>
<ul>
<li><code>**在我们眼里，TCP是面向连接、可靠的传输层协议，当前几乎所有重要的协议和应用都是基于TCP来实现的。**</code></li>
<li><strong>网络环境的改变速度很快，但是 TCP 协议相对缓慢，正是这种矛盾促使谷歌做出了一个看似出乎意料的决定-</strong><code>**基于UDP来开发新一代HTTP协议**</code><strong>。</strong></li>
</ul>
<h3 id="1-2-谷歌为什么选择-UDP"><a href="#1-2-谷歌为什么选择-UDP" class="headerlink" title="1.2 谷歌为什么选择 UDP"></a>1.2 谷歌为什么选择 UDP</h3><p>上面提到，谷歌选择 UDP 是看似出乎意料的，仔细想一想其实很有道理。</p>
<p>我们单纯地看看 TCP 协议的不足和 UDP 的一些优点：</p>
<ul>
<li>基于 TCP 开发的设备和协议非常多，兼容困难</li>
<li>TCP 协议栈是 Linux 内部的重要部分，修改和升级成本很大</li>
<li>UDP 本身是无连接的、没有建链和拆链成本</li>
<li>UDP 的数据包无队头阻塞问题</li>
<li>UDP 改造成本小</li>
</ul>
<p>从上面的对比可以知道，<code>谷歌要想从TCP上进行改造升级绝非易事，但是UDP虽然没有TCP为了保证可靠连接而引发的问题，但是UDP本身不可靠，又不能直接用</code></p>
<p><img src="https://img-blog.csdnimg.cn/20200922123855517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=tDBTF&originHeight=378&originWidth=548&originalType=binary&status=done&style=none"></p>
<blockquote>
<p>综合而知，谷歌决定在 UDP 基础上改造一个具备 TCP 协议优点的新协议也就顺理成章了，这个新协议就是 QUIC 协议。</p>
</blockquote>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>1.3 QUIC 协议和 HTTP3.0</p>
<p>QUIC 其实是 Quick UDP Internet Connections 的缩写，直译为快速 UDP 互联网连接。</p>
<p><img src="https://img-blog.csdnimg.cn/20200922124004308.png#pic_center#id=NQ3nM&originHeight=133&originWidth=308&originalType=binary&status=done&style=none"></p>
<p>我们来看看维基百科对于 QUIC 协议的一些介绍：</p>
<blockquote>
<p>QUIC 协议最初由 Google 的 Jim Roskind 设计，实施并于 2012 年部署，在 2013 年随着实验的扩大而公开宣布，并向 IETF 进行了描述。<br>QUIC 提高了当前正在使用 TCP 的面向连接的 Web 应用程序的性能。它在两个端点之间使用用户数据报协议（UDP）建立多个复用连接来实现此目的。<br>QUIC 的次要目标包括减少连接和传输延迟，在每个方向进行带宽估计以避免拥塞。它还将拥塞控制算法移动到用户空间，而不是内核空间，此外使用前向纠错（FEC）进行扩展，以在出现错误时进一步提高性能。</p>
</blockquote>
<ul>
<li><strong>HTTP3.0 又称为 HTTP Over QUIC，其弃用 TCP 协议，改为使用基于 UDP 协议的 QUIC 协议来实现。</strong> <img src="https://img-blog.csdnimg.cn/20200922124129106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#height=306&id=lfjni&originHeight=306&originWidth=357&originalType=binary&status=done&style=none&width=357"></li>
</ul>
<h2 id="二、QUIC-详解"><a href="#二、QUIC-详解" class="headerlink" title="二、QUIC 详解"></a>二、QUIC 详解</h2><p>择其善者而从之，其不善者而改之。</p>
<ul>
<li><code>**HTTP3.0既然选择了QUIC协议，也就意味着HTTP3.0基本继承了HTTP2.0的强大功能，并且进一步解决了HTTP2.0存在的一些问题，同时必然引入了新的问题**</code></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200922124303607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=nq4cr&originHeight=305&originWidth=778&originalType=binary&status=done&style=none"> QUIC 协议必须要实现 HTTP2.0 在 TCP 协议上的重要功能，同时解决遗留问题，我们来看看 QUIC 是如何实现的。</p>
<h3 id="2-1-队头阻塞问题"><a href="#2-1-队头阻塞问题" class="headerlink" title="2.1 队头阻塞问题"></a>2.1 队头阻塞问题</h3><ul>
<li><p><code>**队头阻塞 Head-of-line blocking（缩写为HOL blocking）是计算机网络中是一种性能受限的现象**</code><strong>，通俗来说就是：</strong><code>**一个数据包影响了一堆数据包，它不来大家都走不了**</code><strong>。</strong></p>
</li>
<li><p><code>队头阻塞问题可能存在于HTTP层和TCP层，在HTTP1.x时两个层次都存在该问题</code>。 <img src="https://img-blog.csdnimg.cn/20200922124452630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=oAWYE&originHeight=444&originWidth=812&originalType=binary&status=done&style=none"></p>
</li>
<li><p><code>**HTTP2.0协议的多路复用机制解决了HTTP层的队头阻塞问题，但是在TCP层仍然存在队头阻塞问题。**</code></p>
</li>
<li><p><code>**TCP协议在收到数据包之后，这部分数据可能是乱序到达的，但是TCP必须将所有数据收集排序整合后给上层使用，如果其中某个包丢失了，就必须等待重传，从而出现某个丢包数据阻塞整个连接的数据使用。**</code></p>
</li>
<li><p>多路复用是 HTTP2 最强大的特性 ，能够将多条请求在一条 TCP 连接上同时发出去。但也恶化了 TCP 的一个问题，队头阻塞 ，如下图示： <img src="https://img-blog.csdnimg.cn/20200922135620387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=ptWhT&originHeight=377&originWidth=1011&originalType=binary&status=done&style=none"></p>
</li>
<li><p><strong>HTTP2 在一个 TCP 连接上同时发送 4 个 Stream。其中 Stream1 已经正确到达，并被应用层读取</strong>。</p>
</li>
<li><p><code>但是 Stream2 的第三个 tcp segment 丢失了，TCP 为了保证数据的可靠性，需要发送端重传第 3 个 segment 才能通知应用层读取接下去的数据，虽然这个时候 Stream3 和 Stream4 的全部数据已经到达了接收端，但都被阻塞住了</code>。</p>
</li>
<li><p><code>不仅如此，由于 HTTP2 强制使用 TLS，还存在一个 TLS 协议层面的队头阻塞</code> <img src="https://img-blog.csdnimg.cn/20200922135807354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=B4UBy&originHeight=692&originWidth=1080&originalType=binary&status=done&style=none"></p>
</li>
<li><p><strong>QUIC 的多路复用和 HTTP2 类似。</strong><code>**在一条 QUIC 连接上可以并发发送多个 HTTP 请求 (stream)**</code><strong>。但是 QUIC 的多路复用相比 HTTP2 有一个很大的优势</strong>。</p>
</li>
<li><p><code>**QUIC 一个连接上的多个 stream 之间没有依赖。这样假如 stream2 丢了一个 udp packet，也只会影响 stream2 的处理。不会影响 stream2 之前及之后的 stream 的处理**</code><strong>。</strong> -   这也就在很大程度上缓解甚至消除了队头阻塞的影响。</p>
</li>
<li><p><strong>QUIC 协议是基于 UDP 协议实现的，</strong><code>**在一条链接上可以有多个流，流与流之间是互不影响的，当一个流出现丢包影响范围非常小，从而解决队头阻塞**</code><strong>问题</strong></p>
</li>
</ul>
<h3 id="2-2-0RTT-建链"><a href="#2-2-0RTT-建链" class="headerlink" title="2.2 0RTT 建链"></a>2.2 0RTT 建链</h3><ul>
<li><code>**衡量网络建链的常用指标是RTT Round-Trip Time，也就是数据包一来一回的时间消耗。**</code> <img src="https://img-blog.csdnimg.cn/20200922124623833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=AsS3u&originHeight=226&originWidth=372&originalType=binary&status=done&style=none"></li>
<li><code>**RTT包括三部分：往返传播时延、网络设备内排队时延、应用程序数据处理时延。**</code> <img src="https://img-blog.csdnimg.cn/20200922124649743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=hg0Cd&originHeight=239&originWidth=579&originalType=binary&status=done&style=none"></li>
<li><strong>一般来说 HTTPS 协议要建立完整链接包括:TCP 握手和 TLS 握手，总计需要至少 2-3 个 RTT，普通的 HTTP 协议也需要至少 1 个 RTT 才可以完成握手。</strong></li>
<li><strong>然而，</strong><code>**QUIC协议可以实现在第一个包就可以包含有效的应用数据，从而实现0RTT，但这也是有条件**</code><strong>的。</strong> - 0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势。那什么是 0RTT 建连呢？这里面有两层含义。</li>
<li><code>传输层 0RTT 就能建立连接</code></li>
<li><code>加密层 0RTT 就能建立加密连接</code> <img src="https://img-blog.csdnimg.cn/20200922132748609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=oQp0N&originHeight=530&originWidth=1080&originalType=binary&status=done&style=none"></li>
</ul>
<blockquote>
<ul>
<li>比如上图左边是 HTTPS 的一次完全握手的建连过程，需要 3 个 RTT。就算是 Session Resumption，也需要至少 2 个 RTT。</li>
<li>而 QUIC 呢？由于建立在 UDP 的基础上，同时又实现了 0RTT 的安全握手，所以在大部分情况下，只需要 0 个 RTT 就能实现数据发送，在实现前向加密 的基础上，并且 0RTT 的成功率相比 TLS 的 Sesison Ticket 要高很多。</li>
</ul>
</blockquote>
<ul>
<li>简单来说，<code>基于TCP协议和TLS协议的HTTP2.0在真正发送数据包之前需要花费一些时间来完成握手和加密协商，完成之后才可以真正传输业务数据</code>。</li>
<li><strong>但是 QUIC 则第一个数据包就可以发业务数据，从而在连接延时有很大优势，可以节约数百毫秒的时间。</strong></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200922124817379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=pqC6c&originHeight=530&originWidth=748&originalType=binary&status=done&style=none"></p>
<ul>
<li><strong>QUIC 的 0RTT 也是需要条件的，</strong><code>**对于第一次交互的客户端和服务端0RTT也是做不到的**</code><strong>，毕竟双方完全陌生。</strong>- <strong>因此，QUIC 协议可以分为首次连接和非首次连接，两种情况进行讨论。</strong></li>
</ul>
<h4 id="2-2-1-首次连接和非首次连接"><a href="#2-2-1-首次连接和非首次连接" class="headerlink" title="2.2.1 首次连接和非首次连接"></a>2.2.1 首次连接和非首次连接</h4><ul>
<li><code>**使用QUIC协议的客户端和服务端要使用1RTT进行密钥交换，使用的交换算法是DH(Diffie-Hellman)迪菲-赫尔曼算法。**</code></li>
</ul>
<h4 id="2-2-2-首次连接"><a href="#2-2-2-首次连接" class="headerlink" title="2.2.2 首次连接"></a>2.2.2 首次连接</h4><ul>
<li>简单来说一下，<code>**首次连接时客户端和服务端的密钥协商和数据传输过程**</code>，其中涉及了 DH 算法的基本过程： <img src="https://img-blog.csdnimg.cn/20200922125205577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=Vl5eN&originHeight=1020&originWidth=1356&originalType=binary&status=done&style=none"> <img src="https://img-blog.csdnimg.cn/20200922125320566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=kzbFK&originHeight=1030&originWidth=1080&originalType=binary&status=done&style=none"></li>
</ul>
<h4 id="2-2-3-非首次连接"><a href="#2-2-3-非首次连接" class="headerlink" title="2.2.3 非首次连接"></a>2.2.3 非首次连接</h4><ul>
<li><code>**前面提到客户端和服务端首次连接时服务端传递了config包，里面包含了服务端公钥和两个随机数，客户端会将config存储下来，后续再连接时可以直接使用，从而跳过这个1RTT，实现0RTT的业务数据交互**</code><strong>。</strong>- <code>**客户端保存config是有时间期限的，在config失效之后仍然需要进行首次连接时的密钥交换。**</code></li>
</ul>
<h3 id="2-3-前向安全问题"><a href="#2-3-前向安全问题" class="headerlink" title="2.3 前向安全问题"></a>2.3 前向安全问题</h3><p>前向安全是密码学领域的专业术语，看下百度上的解释：</p>
<blockquote>
<ul>
<li><code>前向安全或前向保密Forward Secrecy是密码学中通讯协议的安全属性，指的是长期使用的主密钥泄漏不会导致过去的会话密钥泄漏</code>。</li>
<li><code>前向安全能够保护过去进行的通讯不受密码或密钥在未来暴露的威胁，如果系统具有前向安全性，就可以保证在主密钥泄露时历史通讯的安全，即使系统遭到主动攻击也是如此</code></li>
</ul>
</blockquote>
<p><strong>通俗来说，</strong><code>**前向安全指的是密钥泄漏也不会让之前加密的数据被泄漏，影响的只有当前，对之前的数据无影响**</code><strong>。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200922125908240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=NuSZa&originHeight=232&originWidth=1224&originalType=binary&status=done&style=none"> <img src="https://img-blog.csdnimg.cn/20200922125953787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=ZYRgn&originHeight=722&originWidth=1080&originalType=binary&status=done&style=none"></p>
<h3 id="2-4-前向纠错"><a href="#2-4-前向纠错" class="headerlink" title="2.4 前向纠错"></a>2.4 前向纠错</h3><p>前向纠错是通信领域的术语，看下百科的解释：</p>
<ul>
<li>前向纠错也叫前向纠错码 Forward Error Correction 简称 FEC;<code>是增加数据通讯可信度的方法，在单向通讯信道中，一旦错误被发现，其接收器将无权再请求传输</code>。- FEC 是利用数据进行传输冗余信息的方法，当传输中出现错误，将允许接收器再建数据。</li>
<li>听这段描述就是做校验的，看看 QUIC 协议是如何实现的：</li>
<li><code>**QUIC每发送一组数据就对这组数据进行异或运算，并将结果作为一个FEC包发送出去，接收方收到这一组数据后根据数据包和FEC包即可进行校验和纠错**</code>。</li>
</ul>
<h3 id="2-5-连接迁移"><a href="#2-5-连接迁移" class="headerlink" title="2.5 连接迁移"></a>2.5 连接迁移</h3><p>网络切换几乎无时无刻不在发生。</p>
<ul>
<li><code>TCP协议使用五元组来表示一条唯一的连接，当我们从4G环境切换到wifi环境时，手机的IP地址就会发生变化，这时必须创建新的TCP连接才能继续传输数据</code>。</li>
<li><strong>QUIC 协议基于 UDP 实现摒弃了五元组的概念，使用 64 位的随机数作为连接的 ID，并使用该 ID 表示连接。</strong></li>
<li><code>基于QUIC协议之下，我们在日常wifi和4G切换时，或者不同基站之间切换都不会重连，从而提高业务层的体验。</code></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200922130333415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=SOMdm&originHeight=723&originWidth=1080&originalType=binary&status=done&style=none"></p>
<h3 id="2-6-改进的拥塞控制"><a href="#2-6-改进的拥塞控制" class="headerlink" title="2.6 改进的拥塞控制"></a>2.6 改进的拥塞控制</h3><ul>
<li><code>**TCP 的拥塞控制实际上包含了四个算法：慢启动，拥塞避免，快速重传，快速恢复**</code> -  QUIC 协议当前默认使用了 TCP 协议的 Cubic 拥塞控制算法 ，同时也支持 CubicBytes, Reno, RenoBytes, BBR, PCC 等拥塞控制算法。</li>
<li><code>从拥塞算法本身来看，QUIC 只是按照 TCP 协议重新实现了一遍</code>，那么 QUIC 协议到底改进在哪些方面呢？主要有如下几点：</li>
</ul>
<h4 id="2-6-1-可插拔"><a href="#2-6-1-可插拔" class="headerlink" title="2.6.1 可插拔"></a>2.6.1 可插拔</h4><p>什么叫可插拔呢？<code>就是能够非常灵活地生效，变更和停止</code>,体现在如下方面：</p>
<ul>
<li><code>**应用程序层面就能实现不同的拥塞控制算法，不需要操作系统，不需要内核支持**</code><strong>。这是一个飞跃，因为</strong><code>**传统的 TCP 拥塞控制，必须要端到端的网络协议栈支持，才能实现控制效果**</code><strong>。而内核和操作系统的部署成本非常高，升级周期很长，这在产品快速迭代，网络爆炸式增长的今天，显然有点满足不了需求。</strong></li>
<li><strong>即使是单个应用程序的不同连接也能支持配置不同的拥塞控制。就算是一台服务器，接入的用户网络环境也千差万别，结合大数据及人工智能处理，我们能为各个用户提供不同的但又更加精准更加有效的拥塞控制。比如 BBR 适合，Cubic 适合。</strong></li>
<li><code>**应用程序不需要停机和升级就能实现拥塞控制的变更**</code><strong>，我们在服务端只需要修改一下配置，reload 一下，</strong><code>**完全不需要停止服务就能实现拥塞控制的切换**</code><strong>。STGW 在配置层面进行了优化，我们可以针对不同业务，不同网络制式，甚至不同的 RTT，使用不同的拥塞控制算法。</strong></li>
</ul>
<h4 id="2-6-2-单调递增的-Packet-Number"><a href="#2-6-2-单调递增的-Packet-Number" class="headerlink" title="2.6.2 单调递增的 Packet Number"></a>2.6.2 单调递增的 Packet Number</h4><ul>
<li><code>**TCP 为了保证可靠性，使用了基于字节序号的 Sequence Number 及 Ack 来确认消息的有序到达。**</code></li>
<li><code>**QUIC**</code>** 同样是一个可靠的协议，它**<code>**使用 Packet Number 代替了 TCP 的 sequence number，并且每个 Packet Number 都严格递增**</code><strong>，也就是说</strong><code>**就算 Packet N 丢失了，重传的 Packet N 的 Packet Number 已经不是 N，而是一个比 N 大的值**</code><strong>。</strong></li>
<li><strong>而 TCP 呢，重传 segment 的 sequence number 和原始的 segment 的 Sequence Number 保持不变，也正是由于这个特性，引入了 Tcp 重传的歧义问题</strong></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200922133727910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=eVtip&originHeight=473&originWidth=1080&originalType=binary&status=done&style=none"></p>
<ul>
<li><strong>如上图所示，超时事件 RTO 发生后，</strong><code>**客户端发起重传**</code><strong>，然后接收到了 Ack 数据。</strong><code>**由于序列号一样，这个 Ack 数据到底是原始请求的响应还是重传请求的响应呢？不好判断**</code><strong>。</strong></li>
<li>如果<code>算成原始请求的响应，但实际上是重传请求的响应（上图左），会导致采样 RTT 变大。如果算成重传请求的响应，但实际上是原始请求的响应，又很容易导致采样 RTT 过小</code>。</li>
<li><code>**由于 Quic 重传的 Packet 和原始 Packet 的 Pakcet Number 是严格递增的，所以很容易就解决了这个问题。**</code></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200922133916874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=UF0FI&originHeight=427&originWidth=1080&originalType=binary&status=done&style=none"></p>
<ul>
<li><code>如上图所示，RTO 发生后，根据重传的 Packet Number 就能确定精确的 RTT 计算。如果 Ack 的 Packet Number 是 N+M，就根据重传请求计算采样 RTT。如果 Ack 的 Pakcet Number 是 N，就根据原始请求的时间计算采样 RTT，没有歧义性</code>。</li>
<li><strong>但是单纯依靠严格递增的 Packet Number 肯定是无法保证数据的顺序性和可靠性。QUIC 又引入了一个 <strong><code>**Stream Offset**</code></strong> 的概念。</strong></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200922134146426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=ZMt3g&originHeight=312&originWidth=1080&originalType=binary&status=done&style=none"></p>
<ul>
<li>即<code>一个 Stream 可以经过多个 Packet 传输，Packet Number 严格递增，没有依赖</code>。<blockquote>
<ul>
<li>Packet 里的 Payload 如果是 Stream 的话，就需要依靠 Stream 的 Offset 来保证应用数据的顺序。</li>
<li>如图所示，发送端先后发送了 Pakcet N 和 Pakcet N+1，Stream 的 Offset 分别是 x 和 x+y。</li>
<li>假设 Packet N 丢失了，发起重传，重传的 Packet Number 是 N+2，但是它的 Stream 的 Offset 依然是 x，这样就算 Packet N + 2 是后到的，依然可以将 Stream x 和 Stream x+y 按照顺序组织起来，交给应用程序处理。</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="2-6-3-不允许-Reneging"><a href="#2-6-3-不允许-Reneging" class="headerlink" title="2.6.3 不允许 Reneging"></a>2.6.3 不允许 Reneging</h4><ul>
<li><code>**什么叫 Reneging 呢？就是接收方丢弃已经接收并且上报给 SACK 选项的内容 。TCP 协议不鼓励这种行为，但是协议层面允许这样的行为。主要是考虑到服务器资源有限，比如 Buffer 溢出，内存不够等情况。**</code></li>
<li><strong>Reneging 对数据重传会产生很大的干扰。因为 Sack 都已经表明接收到了，但是接收端事实上丢弃了该数据</strong>。</li>
<li><code>QUIC 在协议层面禁止 Reneging，一个 Packet 只要被 Ack，就认为它一定被正确接收，减少了这种干扰</code>。</li>
</ul>
<h4 id="2-6-4-更多的-Ack-块"><a href="#2-6-4-更多的-Ack-块" class="headerlink" title="2.6.4 更多的 Ack 块"></a>2.6.4 更多的 Ack 块</h4><ul>
<li><strong>TCP 的 Sack 选项能够告诉发送方已经接收到的连续 Segment 的范围，方便发送方进行选择性重传。</strong> -   <code>由于 TCP 头部最大只有 60 个字节，标准头部占用了 20 字节，所以 Tcp Option 最大长度只有 40 字节，再加上 Tcp Timestamp option 占用了 10 个字节 ，所以留给 Sack 选项的只有 30 个字节</code>。</li>
<li><strong>每一个 Sack Block 的长度是 8 个，加上 Sack Option 头部 2 个字节，也就意味着 Tcp Sack Option 最大只能提供 3 个 Block</strong>。</li>
<li><code>但是 Quic Ack Frame 可以同时提供 256 个 Ack Block，在丢包率比较高的网络下，更多的 Sack Block 可以提升网络的恢复速度，减少重传量</code>。</li>
</ul>
<h4 id="2-6-5-Ack-Delay-时间"><a href="#2-6-5-Ack-Delay-时间" class="headerlink" title="2.6.5 Ack Delay 时间"></a>2.6.5 Ack Delay 时间</h4><ul>
<li><code>**Tcp 的 Timestamp 选项存在一个问题 ，它只是回显了发送方的时间戳，但是没有计算接收端接收到 segment 到发送 Ack 该 segment 的时间。这个时间可以简称为 Ack Delay。**</code></li>
<li>这样就会导致 RTT 计算误差。如下图：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200922134723577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=BEhaw&originHeight=816&originWidth=1080&originalType=binary&status=done&style=none"></p>
<ul>
<li>可以认为 TCP 的 RTT 计算： <img src="https://img-blog.csdnimg.cn/20200922134807851.png#pic_center#id=KPX6u&originHeight=41&originWidth=301&originalType=binary&status=done&style=none"></li>
<li>而 Quic 计算如下： <img src="https://img-blog.csdnimg.cn/20200922134824234.png#pic_center#id=k1B88&originHeight=41&originWidth=367&originalType=binary&status=done&style=none"></li>
</ul>
<blockquote>
<ul>
<li>当然 RTT 的具体计算没有这么简单，需要采样，参考历史数值进行平滑计算，参考如下公式:</li>
</ul>
</blockquote>
<blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200922134848538.png#pic_center#id=JDhGD&originHeight=67&originWidth=301&originalType=binary&status=done&style=none"></p>
</blockquote>
<h4 id="2-6-6-基于-stream-和-connecton-级别的流量控制"><a href="#2-6-6-基于-stream-和-connecton-级别的流量控制" class="headerlink" title="2.6.6 基于 stream 和 connecton 级别的流量控制"></a>2.6.6 基于 stream 和 connecton 级别的流量控制</h4><ul>
<li>QUIC 的流量控制 类似 HTTP2，<code>即在 Connection 和 Stream 级别提供了两种流量控制</code>。为什么需要两类流量控制呢？主要是因为 QUIC 支持多路复用。</li>
<li>Stream 可以认为就是一条 HTTP 请求。</li>
<li>Connection 可以类比一条 TCP 连接。</li>
<li><strong>多路复用意味着在一条 Connetion 上会同时存在多条 Stream。既需要对单个 Stream 进行控制，又需要针对所有 Stream 进行总体控制。</strong></li>
</ul>
<p>QUIC 实现流量控制的原理比较简单：</p>
<ul>
<li><code>通过 window_update 帧告诉对端自己可以接收的字节数，这样发送方就不会发送超过这个数量的数据</code>。- <strong>通过 BlockFrame 告诉对端由于流量控制被阻塞了，无法发送数据</strong>。</li>
<li><code>QUIC 的流量控制和 TCP 有点区别，TCP 为了保证可靠性，窗口左边沿向右滑动时的长度取决于已经确认的字节数。如果中间出现丢包，就算接收到了更大序号的 Segment，窗口也无法超过这个序列号</code>。</li>
<li><strong>但 QUIC 不同，就算此前有些 packet 没有接收到，它的滑动只取决于接收到的最大偏移字节数。</strong></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200922135106709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=Lk09m&originHeight=442&originWidth=1080&originalType=binary&status=done&style=none"></p>
<ul>
<li>针对 Stream：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200922135129300.png#pic_center#id=wNSZL&originHeight=37&originWidth=431&originalType=binary&status=done&style=none"><br>针对 Connection：<br><img src="https://img-blog.csdnimg.cn/20200922135146282.png#pic_center#id=fmXEv&originHeight=37&originWidth=610&originalType=binary&status=done&style=none"><br>同样地，STGW 也在连接和 Stream 级别设置了不同的窗口数。</p>
<p>最重要的是，我们可以在内存不足或者上游处理性能出现问题时，通过流量控制来限制传输速率，保障服务可用性。</p>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>QUIC 协议 存在的意义在于解决 TCP 协议的一些无法解决的痛点</p>
<ul>
<li><code>多次握手</code>：TCP 协议需要三次握手建立连接，而如果需要 TLS 证书的交换，那么则需要更多次的握手才能建立可靠连接，这在如今长肥网络的趋势下是一个巨大的痛点</li>
<li><code>队头阻塞</code>：TCP 协议下，如果出现丢包，则一条连接将一直被阻塞等待该包的重传，即使后来的数据包可以被缓存，但也无法被递交给应用层去处理。</li>
<li><code>无法判断一个 ACK 是重传包的 ACK 还是原本包的 ACK</code>：比如 一个包 seq=1, 超时重传的包同样是 seq=1，这样在收到一个 ack=1 之后，我们无法判断这个 ack 是对之前的包的 ack 还是对重传包的 ack，这会导致我们对 RTT 的估计出现误差，无法提供更准确的拥塞控制</li>
<li><code>无法进行连接迁移</code>：<strong>一条连接由一个四元组标识，在当今移动互联网的时代，如果一台手机从一个 wifi 环境切换到另一个 wifi 环境，ip 发生变化，那么连接必须重新建立，inflight 的包全部丢失。</strong></li>
</ul>
<p>现在我们给出一个 QUIC 协议的 Overview</p>
<ul>
<li><code>更好的连接建立方式</code></li>
<li><code>更好的拥塞控制</code></li>
<li><code>没有队头阻塞的多路复用</code></li>
<li><code>前向纠错</code></li>
<li><code>连接迁移</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/25/yuque/HTTP2.0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/25/yuque/HTTP2.0/" class="post-title-link" itemprop="url">HTTP2.0</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-25 16:48:35" itemprop="dateCreated datePublished" datetime="2021-04-25T16:48:35+08:00">2021-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-26 01:05:36" itemprop="dateModified" datetime="2021-04-26T01:05:36+08:00">2021-04-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619340543736-a33f0c98-6dbb-4088-95a8-8d42c25df28e.jpeg#clientId=u148c49a8-157a-4&from=drop&id=u449ec38d&margin=%5Bobject%20Object%5D&name=1.jpg&originHeight=145&originWidth=798&originalType=binary&size=16049&status=done&style=none&taskId=uf8ec65be-f7fd-44db-af5d-1208b45fafb" alt="1.jpg"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/gif/21377586/1619340548956-54a67302-7ca7-4ed6-b03e-22497facf880.gif#clientId=u148c49a8-157a-4&from=drop&id=u1cfa2027&margin=%5Bobject%20Object%5D&name=2.gif&originHeight=281&originWidth=1200&originalType=binary&size=2075450&status=done&style=none&taskId=u963af8b6-9efa-4aab-9114-635366bd545" alt="2.gif"></p>
<p>本文字数：<strong>3825 字</strong></p>
<p>预计阅读时间：<strong>20 分钟</strong></p>
<p><strong>导读</strong></p>
<p>http2.0 是一种安全高效的下一代 http 传输协议。安全是因为 http2.0 建立在 https 协议的基础上，高效是因为它是通过二进制分帧来进行数据传输。正因为这些特性，http2.0 协议也在被越来越多的网站支持。据统计，截止至 2018 年 8 月，已经有 27.9%的网站支持 http2.0。</p>
<p>本文将从<strong>概述、原理、实战及检测</strong>等方面来详细介绍 http2.0，希望能够加深你的理解。</p>
<p><strong>什么是 http2.0 协议？</strong></p>
<p>在 http2.0 官网 ① 的描述是：</p>
<p>http/2 is a replacement for how http is expressed “on the wire.” It is not a ground-up rewrite of the protocol; http methods, status codes and semantics are the same, and it should be possible to use the same APIs as http/1.x (possibly with some small additions) to represent the protocol.</p>
<p>The focus of the protocol is on performance; specifically, end-user perceived latency, network and server resource usage. One major goal is to allow the use of a single connection from browsers to a Web site.</p>
<p>The basis of the work was SPDY, but http/2 has evolved to take the community’s input into account, incorporating several improvements in the process.</p>
<p>中文总结一下就是：</p>
<p><strong>● 对 1.x 协议语意的完全兼容</strong></p>
<p>2.0 协议是在 1.x 基础上的升级而不是重写，1.x 协议的方法，状态及 api 在 2.0 协议里是一样的。</p>
<p><strong>● 性能的大幅提升</strong></p>
<p>2.0 协议重点是对终端用户的感知延迟、网络及服务器资源的使用等性能的优化。</p>
<p><strong>http2.0 优化内容</strong></p>
<p><strong>01</strong></p>
<p><strong>二进制分帧（Binary Format）- http2.0 的基石</strong></p>
<p>http2.0 之所以能够突破 http1.X 标准的性能限制，改进传输性能，实现低延迟和高吞吐量，就是因为其新增了二进制分帧层。</p>
<p>帧(frame)包含部分：类型 Type, 长度 Length, 标记 Flags, 流标识 Stream 和 frame payload 有效载荷。</p>
<p>消息(message)：一个完整的请求或者响应，比如请求、响应等，由一个或多个 Frame 组成。</p>
<p>流是连接中的一个虚拟信道，可以承载双向消息传输。每个流有唯一整数标识符。为了防止两端流 ID 冲突，客户端发起的流具有奇数 ID，服务器端发起的流具有偶数 ID。</p>
<p>流标识是描述二进制 frame 的格式，使得每个 frame 能够基于 http2 发送，与流标识联系的是一个流，每个流是一个逻辑联系，一个独立的双向的 frame 存在于客户端和服务器端之间的 http2 连接中。一个 http2 连接上可包含多个并发打开的流，这个并发流的数量能够由客户端设置。</p>
<p>在二进制分帧层上，http2.0 会将所有传输信息分割为更小的消息和帧，并对它们采用二进制格式的编码将其封装，新增的二进制分帧层同时也能够保证 http 的各种动词，方法，首部都不受影响，兼容上一代 http 标准。其中，http1.X 中的首部信息 header 封装到 Headers 帧中，而 request body 将被封装到 Data 帧中。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619340552914-6d85f416-ef90-425c-aadf-5b8012ea6a0e.jpeg#clientId=u148c49a8-157a-4&from=drop&height=328&id=ud9ea1c6a&margin=%5Bobject%20Object%5D&name=3.jpg&originHeight=328&originWidth=624&originalType=binary&size=27637&status=done&style=none&taskId=u5db12245-ba46-48b9-9407-0903347de64&width=624" alt="3.jpg"></p>
<p><strong>02</strong></p>
<p><strong>多路复用 (Multiplexing) / 连接共享</strong></p>
<p>在 http1.1 中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量的限制，超过限制数目的请求会被阻塞。这也是为何一些站点会有多个静态资源 CDN 域名的原因之一。</p>
<p>而 http2.0 中的多路复用优化了这一性能。多路复用允许同时通过单一的 http/2 连接发起多重的请求-响应消息。有了新的分帧机制后，http/2 不再依赖多个 TCP 连接去实现多流并行了。每个数据流都拆分成很多互不依赖的帧，而这些帧可以交错（乱序发送），还可以分优先级，最后再在另一端把它们重新组合起来。</p>
<p>http 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接（每个域名一个连接）即可。http2 连接可以承载数十或数百个流的复用，多路复用意味着来自很多流的数据包能够混合在一起通过同样连接传输。当到达终点时，再根据不同帧首部的流标识符重新连接将不同的数据流进行组装。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619340559408-1ecd3083-c71e-4701-a7eb-5b198b78904c.png#clientId=u148c49a8-157a-4&from=drop&id=uc5a8e1c5&margin=%5Bobject%20Object%5D&name=4.png&originHeight=224&originWidth=830&originalType=binary&size=81541&status=done&style=none&taskId=ufc08a7ca-a9e9-4475-b4c4-8186fe89a0a" alt="4.png"></p>
<p>上图展示了一个连接上的多个传输数据流：客户端向服务端传输数据帧 stream5，同时服务端向客户端乱序发送 stream1 和 stream3。这次连接上有三个响应请求乱序并行交换。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619340563946-a4561bc4-3067-4483-9864-3db695ec5a1f.jpeg#clientId=u148c49a8-157a-4&from=drop&height=618&id=uf7621412&margin=%5Bobject%20Object%5D&name=5.jpg&originHeight=618&originWidth=625&originalType=binary&size=35776&status=done&style=none&taskId=u4632ef5b-fe20-4abb-a08a-81893d10b95&width=625" alt="5.jpg"></p>
<p>上图就是 http1.X 和 http2.0 在传输数据时的区别。以货物运输为例再现 http1.1 与 http2.0 的场景：</p>
<p>http1.1 过程：货轮 1 从 A 地到 B 地去取货物，取到货物后，从 B 地返回，然后货轮 2 在 A 返回并卸下货物后才开始再从 A 地出发取货返回，如此有序往返。</p>
<p>http2.0 过程：货轮 1、2、3、4、5 从 A 地无序全部出发，取货后返回，然后根据货轮号牌卸载对应货物。</p>
<p>显然，第二种方式运输货物多，河道的利用率高。</p>
<p>03</p>
<p><strong>头部压缩（Header Compression）</strong></p>
<p>http1.x 的头带有大量信息，而且每次都要重复发送。http/2 使用 encoder 来减少需要传输的 header 大小，通讯双方各自缓存一份头部字段表，既避免了重复 header 的传输，又减小了需要传输的大小。</p>
<p>对于相同的数据，不再通过每次请求和响应发送，通信期间几乎不会改变通用键-值对(用户代理、可接受的媒体类型，等等)只需发送一次。</p>
<p>事实上,如果请求中不包含首部(例如对同一资源的轮询请求)，那么，首部开销就是零字节，此时所有首部都自动使用之前请求发送的首部。</p>
<p>如果首部发生了变化，则只需将变化的部分加入到 header 帧中，改变的部分会加入到头部字段表中，首部表在 http 2.0 的连接存续期内始终存在，由客户端和服务器共同渐进地更新。</p>
<p>需要注意的是，http 2.0 关注的是首部压缩，而我们常用的 gzip 等是报文内容（body）的压缩，二者不仅不冲突，且能够一起达到更好的压缩效果。</p>
<p>http/2 使用的是专门为首部压缩而设计的 HPACK② 算法。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619340576632-76592f6e-2635-4ef2-bdeb-bbf31c06beb7.jpeg#clientId=u148c49a8-157a-4&from=drop&height=318&id=uda892c3a&margin=%5Bobject%20Object%5D&name=6.jpg&originHeight=318&originWidth=627&originalType=binary&size=34790&status=done&style=none&taskId=u919f26c9-7da5-450e-8bc4-400b98d0fc0&width=627" alt="6.jpg"></p>
<p>从上图可以看到 http1.X 不支持首部压缩，而 http2.0 的压缩算法效果最好，发送和接受的数据量都是最少的。</p>
<p><strong>04</strong></p>
<p><strong>压缩原理</strong></p>
<p>用 header 字段表里的索引代替实际的 header。</p>
<p>http/2 的 HPACK 算法使用一份索引表来定义常用的 http Header，把常用的 http Header 存放在表里，请求的时候便只需要发送在表里的索引位置即可。</p>
<p>例如 :method=GET 使用索引值 2 表示，:path=/index.html 使用索引值 5 表示，如下图：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619340594084-7273a70e-647d-4b4e-b4ae-5524a9083cea.png#clientId=u148c49a8-157a-4&from=drop&height=488&id=ub851fcd8&margin=%5Bobject%20Object%5D&name=7.png&originHeight=488&originWidth=479&originalType=binary&size=25243&status=done&style=none&taskId=u6fa0f53f-f5c2-4e6d-8fde-d9eae036267&width=479" alt="7.png"></p>
<p>完整的列表参考：HPACK Static Table③ 。</p>
<p>只要给服务端发送一个 Frame，该 Frame 的 Payload 部分存储 0x8285，Frame 的 Type 设置为 Header 类型，便可表示这个 Frame 属于 http Header，请求的内容是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1GET &#x2F;index.html</span><br></pre></td></tr></table></figure>

<p>为什么是 0x8285，而不是 0x0205？这是因为高位设置为 1 表示这个字节是一个完全索引值（key 和 value 都在索引中）。</p>
<p>类似的，通过高位的标志位可以区分出这个字节是属于一个完全索引值，还是仅索引了 key，还是 key 和 value 都没有索引(参见：HTTP/2 首部压缩的 OkHttp3 实现 ④)。</p>
<p>因为索引表的大小的是有限的，它仅保存了一些常用的 http Header，同时每次请求还可以在表的末尾动态追加新的 http Header 缓存，动态部分称之为 Dynamic Table。Static Table 和 Dynamic Table 在一起组合成了索引表：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619340602194-476ded49-c784-46c1-b5aa-5311ef73667e.png#clientId=u148c49a8-157a-4&from=drop&id=u3c0d1396&margin=%5Bobject%20Object%5D&name=8.png&originHeight=222&originWidth=768&originalType=binary&size=32088&status=done&style=none&taskId=u982cf32a-aab1-4bfc-a608-e6db4ef4116" alt="8.png"></p>
<p>HPACK 不仅仅通过索引键值对来降低数据量，同时还会将字符串进行霍夫曼编码来压缩字符串大小。</p>
<p>以常用的 User-Agent 为例，它在静态表中的索引值是 58，它的值是不存在表中的，因为它的值是多变的。第一次请求的时候它的 key 用 58 表示，表示这是一个 User-Agent ，它的值部分会进行霍夫曼编码（如果编码后的字符串变更长了，则不采用霍夫曼编码）。</p>
<p>服务端收到请求后，会将这个 User-Agent 添加到 Dynamic Table 缓存起来，分配一个新的索引值。客户端下一次请求时，假设上次请求 User-Agent 的在表中的索引位置是 62， 此时只需要发送 0xBE（同样的，高位置 1），便可以代表：User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.146 Safari/537.36。</p>
<p>其过程如下图所示：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619340620286-e641085e-f964-41dd-bc5b-e481eff873c5.png#clientId=u148c49a8-157a-4&from=drop&height=259&id=u2bad4692&margin=%5Bobject%20Object%5D&name=9.png&originHeight=259&originWidth=792&originalType=binary&size=78576&status=done&style=none&taskId=ufc5c19f5-828f-441e-a4e5-43847fea366&width=792" alt="9.png"></p>
<p>最终，相同的 Header 只需要发送索引值，新的 Header 会重新加入 Dynamic Table。</p>
<p><strong>05</strong></p>
<p><strong>请求优先级（Request Priorities）</strong></p>
<p>把 http 消息分为很多独立帧之后，就可以通过优化这些帧的交错和传输顺序进一步优化性能。每个流都可以带有一个 31 比特的优先值：0 表示最高优先级；2 的 31 次方-1 表示最低优先级。</p>
<p>服务器可以根据流的优先级，控制资源分配（CPU、内存、带宽），而在响应数据准备好之后，优先将最高优先级的帧发送给客户端。高优先级的流都应该优先发送，但又不会绝对的。绝对地准守，可能又会引入首队阻塞的问题：高优先级的请求慢导致阻塞其他资源交付。</p>
<p>分配处理资源和客户端与服务器间的带宽，不同优先级的混合也是必须的。客户端会指定哪个流是最重要的，有一些依赖参数，这样一个流可以依赖另外一个流。优先级别可以在运行时动态改变，当用户滚动页面时，可以告诉浏览器哪个图像是最重要的，你也可以在一组流中进行优先筛选，能够突然抓住重点流。</p>
<p>● 优先级最高：主要的 html</p>
<p>● 优先级高：CSS 文件</p>
<p>● 优先级中：js 文件</p>
<p>● 优先级低：图片</p>
<p><strong>06</strong></p>
<p><strong>服务端推送（Server Push）</strong></p>
<p>服务器可以对一个客户端请求发送多个响应，服务器向客户端推送资源无需客户端明确地请求。并且，服务端推送能把客户端所需要的资源伴随着 index.html 一起发送到客户端，省去了客户端重复请求的步骤。</p>
<p>正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。Server Push 让 http1.x 时代使用内嵌资源的优化手段变得没有意义；如果一个请求是由你的主页发起的，服务器很可能会响应主页内容、logo 以及样式表，因为它知道客户端会用到这些东西，这相当于在一个 HTML 文档内集合了所有的资源。</p>
<p>不过与之相比，服务器推送还有一个很大的优势：可以缓存！也让在遵循同源的情况下，不同页面之间可以共享缓存资源成为可能。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619340635870-3a618bdd-7c58-4bb4-8181-0753af6a5ba4.png#clientId=u148c49a8-157a-4&from=drop&height=210&id=u8ae706c2&margin=%5Bobject%20Object%5D&name=10.png&originHeight=210&originWidth=494&originalType=binary&size=79425&status=done&style=none&taskId=uebee46ce-df66-4b12-a96d-cef0d181957&width=494" alt="10.png"></p>
<p>注意两点：</p>
<p>1、推送遵循同源策略；</p>
<p>2、这种服务端的推送是基于客户端的请求响应来确定的。</p>
<p>当服务端需要主动推送某个资源时，便会发送一个 Frame Type 为 PUSH_PROMISE 的 Frame，里面带了 PUSH 需要新建的 Stream ID。意思是告诉客户端：接下来我要用这个 ID 向你发送东西，客户端准备好接着。客户端解析 Frame 时，发现它是一个 PUSH_PROMISE 类型，便会准备接收服务端要推送的流。</p>
<p><strong>http2.0 性能瓶颈</strong></p>
<p>启用 http2.0 后会给性能带来很大的提升，但同时也会带来新的性能瓶颈。因为现在所有的压力集中在底层一个 TCP 连接之上，TCP 很可能就是下一个性能瓶颈，比如 TCP 分组的队首阻塞问题，单个 TCP packet 丢失导致整个连接阻塞，无法逃避，此时所有消息都会受到影响。未来，服务器端针对 http 2.0 下的 TCP 配置优化至关重要。</p>
<p><strong>01</strong></p>
<p><strong>如何升级 http2.0 协议</strong></p>
<p>nginx 服务器升级 http2.0 协议需要满足如下条件：</p>
<p>1、nginx 版本高于 1.9.5；</p>
<p>2、–with-http_ssl_module 跟 –with-http_v2_module</p>
<p>–with-http_ssl_module 模块是因为 http2.0 协议是一种 https 协议。</p>
<p><strong>02</strong></p>
<p><strong>查看你的 nginx 配置</strong></p>
<p><code>nginx -V</code></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619340645097-a0c876d8-0a96-479b-a34b-aa41bb60d041.png#clientId=u148c49a8-157a-4&from=drop&id=u3466751d&margin=%5Bobject%20Object%5D&name=11.png&originHeight=152&originWidth=1080&originalType=binary&size=76381&status=done&style=none&taskId=u7fe82bb9-f187-4e1c-89c9-fb83ddf4235" alt="11.png"></p>
<p>这个是已经添加了对应模块。没有这两个模块的需要手动编译安装。</p>
<p><strong>03</strong></p>
<p><strong>找到 nginx 文件目录</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619340651193-7aa65a17-275e-4e6f-b4e8-50742b5a2e5b.jpeg#clientId=u148c49a8-157a-4&from=drop&height=299&id=u45311b71&margin=%5Bobject%20Object%5D&name=12.jpg&originHeight=380&originWidth=1080&originalType=binary&size=41158&status=done&style=none&taskId=udd394e18-2eb9-44bb-91d6-9b11cdf3eca&width=849" alt="12.jpg"></p>
<p><strong>04</strong></p>
<p><strong>编译安装 nginx 文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx  --with-http_stub_status_module  --with-http_ssl_module  --with-http_v2_module</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619340659111-a0b4decb-6a0e-423b-b3d6-8f25b86fedc2.jpeg#clientId=u148c49a8-157a-4&from=drop&id=u7c1a3838&margin=%5Bobject%20Object%5D&name=13.jpg&originHeight=354&originWidth=1080&originalType=binary&size=37571&status=done&style=none&taskId=u435617e3-248c-47f3-a67d-dceb948fc21" alt="13.jpg"></p>
<p>然后执行如下命令，进行编译安装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1make2make install</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619340666832-f7a52a22-fc6e-4d92-aa9f-7970338d3ffb.jpeg#clientId=u148c49a8-157a-4&from=drop&id=ubd20aad5&margin=%5Bobject%20Object%5D&name=14.jpg&originHeight=240&originWidth=1080&originalType=binary&size=27416&status=done&style=none&taskId=u8b29a217-21a1-490f-8815-0ff2e825a7e" alt="14.jpg"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619340672605-191b5f93-e594-459e-82d3-5b3ba09005fc.png#clientId=u148c49a8-157a-4&from=drop&id=u90f5039a&margin=%5Bobject%20Object%5D&name=15.png&originHeight=245&originWidth=906&originalType=binary&size=11897&status=done&style=none&taskId=ud9481316-7173-41ce-adcb-cf16257d872" alt="15.png"></p>
<p><strong>05</strong></p>
<p><strong>更改 nginx 配置</strong></p>
<p>安装结束后将 nginx.config 文件中 443 端口添加 http2；</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619340677468-59acc9ca-e4fc-48bb-8a56-cd87a8c6e895.png#clientId=u148c49a8-157a-4&from=drop&id=u97b5ae08&margin=%5Bobject%20Object%5D&name=16.png&originHeight=83&originWidth=1060&originalType=binary&size=16284&status=done&style=none&taskId=u9f3eb4a7-ef20-46f9-a826-28e0559d8db" alt="16.png"></p>
<p><strong>06</strong></p>
<p><strong>启动 nginx</strong></p>
<p>最后一步，重启 nginx nginx restart（注意不要直接   nginx -s reload ）。这时候你的站点就升级为了 http2.0 协议了。</p>
<p><strong>检测</strong></p>
<p>升级完成后，怎么确定自己的站点是 http2.0 协议呢？一般有如下几种方法：</p>
<p><strong>●chrome devtool</strong></p>
<p>打开 chrome 调试工具，在 network 勾选 protocol 项，h2 代表的是 http2.0 协议，可以看到笔者的网站已经都升级好了；</p>
<p><strong>● 网站</strong></p>
<p>SSL lab⑤ 一个 SSL 服务器检测的网站，对网站进行安全评级，并将检测结果自动生成一个详细的评价报告；</p>
<p><strong>● 插件</strong></p>
<p>http/2 and SPDY indicator 这是一款检测 http2.0 和 SPDY 协议（Google 开发的基于 TCP 的会话层协议）的插件。</p>
<p>参考资料：</p>
<p>[1].<a target="_blank" rel="noopener" href="https://http2.github.io/">https://http2.github.io/</a></p>
<p>[2].<a target="_blank" rel="noopener" href="http://http2.github.io/http2-spec/compression.html">http://http2.github.io/http2-spec/compression.html</a></p>
<p>[3].<a target="_blank" rel="noopener" href="http://http2.github.io/http2-spec/compression.html#rfc.section.A">http://http2.github.io/http2-spec/compression.html#rfc.section.A</a></p>
<p>[4].<a target="_blank" rel="noopener" href="https://neyoufan.github.io/2017/01/06/android/OkHttp3%E4%B8%AD%E7%9A%84HTTP2%E9%A6%96%E9%83%A8%E5%8E%8B%E7%BC%A9/">https://neyoufan.github.io/2017/01/06/android/OkHttp3中的HTTP2首部压缩/</a></p>
<p>[5].<a target="_blank" rel="noopener" href="https://www.ssllabs.com/ssltest/analyze.html">https://www.ssllabs.com/ssltest/analyze.html</a></p>
<p><strong>也许你还想看</strong></p>
<p><strong>（▼ 点击文章标题或封面查看）</strong></p>
<p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzU3NTY3MTQzMg==%E2%88%A3=2247483791&idx=1&sn=f6fd2d66e35e93a27e5918b4ee4c5358&chksm=fd1edc68ca69557ef2d79b7b6bf4ea89de6affa6919c1c85e70d888464e007f9b8683f4e949a&scene=21#wechat_redirect">搜狐新闻推荐算法  |  呈现给你的，都是你所关心的</a></p>
<p>2018-08-30</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619340684287-15958bdc-6ca2-4afe-a819-fe13b1f645b5.jpeg#clientId=u148c49a8-157a-4&from=drop&id=u46cdb403&margin=%5Bobject%20Object%5D&name=17.jpg&originHeight=606&originWidth=1080&originalType=binary&size=87862&status=done&style=none&taskId=ub83e9869-c2af-4963-b51e-e76f9279b1f" alt="17.jpg"></p>
<p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzU3NTY3MTQzMg==%E2%88%A3=2247484862&idx=1&sn=9e1723862ce80488dabc4d3535464cae&chksm=fd1ed859ca69514f02c055a5c8d636f8af2eddd6e7deb0d496d36bb1e5fd404aef90e435b50c&scene=21#wechat_redirect">新闻推荐系统的 CTR 预估模型</a></p>
<p>2019-04-18</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619340689130-b51ed7a9-cea1-417c-bdcd-477568886629.jpeg#clientId=u148c49a8-157a-4&from=drop&id=udef0eb41&margin=%5Bobject%20Object%5D&name=18.jpg&originHeight=459&originWidth=817&originalType=binary&size=36981&status=done&style=none&taskId=u72fc9fb7-90ea-4401-8c50-ffa753221b4" alt="18.jpg"></p>
<p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzU3NTY3MTQzMg==%E2%88%A3=2247483690&idx=1&sn=7187cad324ad14821bf88fa8be4eebf0&chksm=fd1edccdca6955db28c8ce1f24c92367f06cbf81793b2125fa0d76c4692d4a7096f013ca695f&scene=21#wechat_redirect">互联网架构演进之路</a></p>
<p>2018-08-16</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619340693785-dfcc5ff2-345f-4222-ba51-9693b7c94ae7.jpeg#clientId=u148c49a8-157a-4&from=drop&id=u397d1b60&margin=%5Bobject%20Object%5D&name=19.jpg&originHeight=606&originWidth=1080&originalType=binary&size=103864&status=done&style=none&taskId=ue67c9e99-6e7b-42b1-a029-9cc99883457" alt="19.jpg"></p>
<p>加入<strong>搜狐技术作者天团</strong></p>
<p><strong>千元稿费等你来！</strong></p>
<p>戳这里！☛</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619340698782-bc08850e-0b94-4196-932a-55386a90067d.jpeg#clientId=u148c49a8-157a-4&from=drop&id=u87eacb17&margin=%5Bobject%20Object%5D&name=20.jpg&originHeight=1698&originWidth=1080&originalType=binary&size=40520&status=done&style=none&taskId=u1262e6fd-a181-4ed2-9a3f-7162a2ef6e4" alt="20.jpg"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/gif/21377586/1619340708379-ccc64cbf-5988-4df4-84c6-55480795171d.gif#clientId=u148c49a8-157a-4&from=drop&id=u314e39f6&margin=%5Bobject%20Object%5D&name=21.gif&originHeight=318&originWidth=640&originalType=binary&size=2278314&status=done&style=none&taskId=u17beafd1-bded-4021-a835-6a15fe50744" alt="21.gif"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Adam Blog</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Adam Blog</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
