<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Adam">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Adam">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Adam Blog">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Adam</title>
  <meta name="referrer" content="no-referrer" />
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Adam</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/02/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/02/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-02 20:00:41" itemprop="dateCreated datePublished" datetime="2021-05-02T20:00:41+08:00">2021-05-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/02/yuque/Object%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95api/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/02/yuque/Object%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95api/" class="post-title-link" itemprop="url">Object的常用方法api</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-02 17:58:08 / 修改时间：20:01:26" itemprop="dateCreated datePublished" datetime="2021-05-02T17:58:08+08:00">2021-05-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-Object-keys-，Object-getOwnPropertyNames"><a href="#1-Object-keys-，Object-getOwnPropertyNames" class="headerlink" title="1.Object.keys()，Object.getOwnPropertyNames()"></a>1.Object.keys()，Object.getOwnPropertyNames()</h1><p><strong>Object.keys 方法和 Object.getOwnPropertyNames 方法都用来遍历对象的属性。</strong><br><strong>Object.keys 方法的参数是一个对象，返回一个数组。该数组的成员都是该对象自身的（而不是继承的）所有属性名</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="string">&quot;123&quot;</span>, <span class="attr">b</span>: <span class="string">&quot;456&quot;</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.keys(obj);</span><br><span class="line"><span class="comment">// [&quot;a&quot;, &quot;b&quot;]</span></span><br></pre></td></tr></table></figure>

<p><strong>Object.getOwnPropertyNames 方法与 Object.keys 类似，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="string">&quot;123&quot;</span>, <span class="attr">b</span>: <span class="string">&quot;456&quot;</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj);</span><br><span class="line"><span class="comment">// [&quot;a&quot;, &quot;b&quot;]</span></span><br></pre></td></tr></table></figure>

<p><strong>对于一般的对象来说，Object.keys()和 Object.getOwnPropertyNames()返回的结果是一样的。只有涉及不可枚举属性时，才会有不一样的结果。Object.keys 方法只返回可枚举的属性（详见《对象属性的描述对象》一章），Object.getOwnPropertyNames 方法还返回不可枚举的属性名。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames([<span class="number">123</span>, <span class="number">456</span>]); <span class="comment">// [&quot;0&quot;, &quot;1&quot;, &quot;length&quot;]</span></span><br><span class="line"><span class="built_in">Object</span>.keys([<span class="number">123</span>, <span class="number">456</span>]); <span class="comment">// [&quot;0&quot;, &quot;1&quot;]</span></span><br></pre></td></tr></table></figure>

<h1 id="2-Object-prototype-valueOf"><a href="#2-Object-prototype-valueOf" class="headerlink" title="2.Object.prototype.valueOf()"></a>2.Object.prototype.valueOf()</h1><p><strong>valueOf 方法的作用是返回一个对象的“值”，默认情况下返回对象本身。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="string">&quot;123&quot;</span>, <span class="attr">b</span>: <span class="string">&quot;456&quot;</span> &#125;;</span><br><span class="line">obj.valueOf() === obj; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h1 id="3-Object-prototype-toString"><a href="#3-Object-prototype-toString" class="headerlink" title="3.Object.prototype.toString()"></a>3.Object.prototype.toString()</h1><p><strong>toString 方法的作用是返回一个对象的字符串形式，默认情况下返回类型字符串。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="string">&quot;123&quot;</span>, <span class="attr">b</span>: <span class="string">&quot;456&quot;</span> &#125;;</span><br><span class="line">obj.toString(); <span class="comment">// &quot;[object Object]&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>Object.prototype.toString 方法返回对象的类型字符串，因此可以用来判断一个值的类型。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(value);</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/29/yuque/String%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95api/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/29/yuque/String%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95api/" class="post-title-link" itemprop="url">String常用方法api</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-29 13:06:47" itemprop="dateCreated datePublished" datetime="2021-04-29T13:06:47+08:00">2021-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-02 20:01:26" itemprop="dateModified" datetime="2021-05-02T20:01:26+08:00">2021-05-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-String-fromCharCode"><a href="#1-String-fromCharCode" class="headerlink" title="1.String.fromCharCode()"></a>1.String.fromCharCode()</h1><p><strong>String 对象提供的静态方法（即定义在对象本身，而不是定义在对象实例的方法），主要是 String.fromCharCode()。该方法的参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">104</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>);</span><br><span class="line"><span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="2-String-prototype-length"><a href="#2-String-prototype-length" class="headerlink" title="2.String.prototype.length"></a>2.String.prototype.length</h1><p>字符串实例的 length 属性返回字符串的长度。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;abc&quot;</span>.length; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h1 id="3-String-prototype-charAt"><a href="#3-String-prototype-charAt" class="headerlink" title="3.String.prototype.charAt()"></a>3.String.prototype.charAt()</h1><p>charAt 方法返回指定位置的字符，参数是从 0 开始编号的位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">s.charAt();</span><br><span class="line">a;</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br><span class="line"><span class="comment">// String &#123;&quot;abc&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="4-String-prototype-charCodeAt"><a href="#4-String-prototype-charCodeAt" class="headerlink" title="4.String.prototype.charCodeAt()"></a>4.String.prototype.charCodeAt()</h1><p><strong>charCodeAt()方法返回字符串指定位置的 Unicode 码点（十进制表示），相当于 String.fromCharCode()的逆操作。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;abc&quot;</span>.charCodeAt(<span class="number">1</span>); <span class="comment">// 98</span></span><br></pre></td></tr></table></figure>

<h1 id="5-String-prototype-concat"><a href="#5-String-prototype-concat" class="headerlink" title="5.String.prototype.concat()"></a>5.String.prototype.concat()</h1><p><strong>concat 方法用于连接两个字符串，返回一个新字符串，不改变原字符串。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;abc&quot;</span>.concat(<span class="string">&quot;bcd&quot;</span>);</span><br><span class="line"><span class="comment">// &quot;abcbcd&quot;</span></span><br><span class="line"><span class="string">&quot;abc&quot;</span>.concat(<span class="string">&quot;bcd&quot;</span>, <span class="string">&quot;dss&quot;</span>);</span><br><span class="line"><span class="comment">// &quot;abcbcddss&quot;</span></span><br><span class="line"><span class="string">&quot;abc&quot;</span>.concat(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// &quot;abc123&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="6-String-prototype-slice"><a href="#6-String-prototype-slice" class="headerlink" title="6.String.prototype.slice()"></a>6.String.prototype.slice()</h1><p><strong>slice()方法用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;JavaScript&quot;</span>.slice(<span class="number">0</span>, <span class="number">4</span>); <span class="comment">// &quot;Java&quot;</span></span><br><span class="line"><span class="string">&quot;JavaScript&quot;</span>.slice(<span class="number">4</span>); <span class="comment">// &quot;Script&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="7-String-prototype-substring"><a href="#7-String-prototype-substring" class="headerlink" title="7.String.prototype.substring()"></a>7.String.prototype.substring()</h1><p><strong>substring 方法用于从原字符串取出子字符串并返回，不改变原字符串，跟 slice 方法很相像。它的第一个参数表示子字符串的开始位置，第二个位置表示结束位置（返回结果不含该位置）</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Javascript&quot;</span>.substring(<span class="number">0</span>, <span class="number">4</span>); <span class="comment">// &quot;Java&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="8-String-prototype-substr"><a href="#8-String-prototype-substr" class="headerlink" title="8.String.prototype.substr()"></a>8.String.prototype.substr()</h1><p><strong>substr 方法用于从原字符串取出子字符串并返回，不改变原字符串，跟 slice 和 substring 方法的作用相同。</strong><br><strong>substr 方法的第一个参数是子字符串的开始位置（从 0 开始计算），第二个参数是子字符串的长度</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Javascript&quot;</span>.substr(<span class="number">0</span>, <span class="number">4</span>); <span class="comment">// &quot;Java&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="9-String-prototype-indexOf-，String-prototype-lastIndexOf"><a href="#9-String-prototype-indexOf-，String-prototype-lastIndexOf" class="headerlink" title="9.String.prototype.indexOf()，String.prototype.lastIndexOf()"></a>9.String.prototype.indexOf()，String.prototype.lastIndexOf()</h1><p><strong>indexOf 方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回-1，就表示不匹配。</strong><br><strong>indexOf 方法还可以接受第二个参数，表示从该位置开始向后匹配。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;hello&quot;</span>.indexOf(<span class="string">&quot;o&quot;</span>); <span class="comment">// 4</span></span><br><span class="line"><span class="string">&quot;hello&quot;</span>.indexOf(<span class="string">&quot;h&quot;</span>, <span class="number">1</span>); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<p><strong>lastIndexOf 方法的用法跟 indexOf 方法一致，主要的区别是 lastIndexOf 从尾部开始匹配，indexOf 则是从头部开始匹配。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;hello world&quot;</span>.lastIndexOf(<span class="string">&quot;o&quot;</span>); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

<h1 id="10-String-prototype-trim"><a href="#10-String-prototype-trim" class="headerlink" title="10.String.prototype.trim()"></a>10.String.prototype.trim()</h1><p><strong>trim 方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。</strong><br><strong>该方法去除的不仅是空格，还包括制表符（\t、\v）、换行符（\n）和回车符（\r）。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;  hello world  &quot;</span>.trim();</span><br><span class="line"><span class="comment">// &quot;hello world&quot;</span></span><br><span class="line"><span class="string">&quot;\r\nabc \t&quot;</span>.trim(); <span class="comment">// &#x27;abc&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="11-String-prototype-toLowerCase-，String-prototype-toUpperCase"><a href="#11-String-prototype-toLowerCase-，String-prototype-toUpperCase" class="headerlink" title="11.String.prototype.toLowerCase()，String.prototype.toUpperCase()"></a>11.String.prototype.toLowerCase()，String.prototype.toUpperCase()</h1><p><strong>toLowerCase 方法用于将一个字符串全部转为小写，toUpperCase 则是全部转为大写。它们都返回一个新字符串，不改变原字符串。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Hello World&quot;</span>.toLowerCase();</span><br><span class="line"><span class="comment">// &quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Hello World&quot;</span>.toUpperCase();</span><br><span class="line"><span class="comment">// &quot;HELLO WORLD&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="12-String-prototype-match"><a href="#12-String-prototype-match" class="headerlink" title="12.String.prototype.match()"></a>12.String.prototype.match()</h1><p><strong>match 方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回 null。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;hello&quot;</span>.match(<span class="string">&quot;ll&quot;</span>);</span><br><span class="line"><span class="comment">// [&quot;ll&quot;, index: 2, input: &quot;hello&quot;, groups: undefined]</span></span><br><span class="line"><span class="string">&quot;hello&quot;</span>.match(<span class="string">&quot;;;&quot;</span>);</span><br><span class="line"><span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p><strong>返回的数组还有 index 属性和 input 属性，分别表示匹配字符串开始的位置和原始字符串。</strong></p>
<h1 id="13-String-prototype-search-，String-prototype-replace"><a href="#13-String-prototype-search-，String-prototype-replace" class="headerlink" title="13.String.prototype.search()，String.prototype.replace()"></a>13.String.prototype.search()，String.prototype.replace()</h1><p><strong>search 方法的用法基本等同于 match，但是返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;hello&quot;</span>.search(<span class="string">&quot;ll&quot;</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h1 id="14-String-prototype-split"><a href="#14-String-prototype-split" class="headerlink" title="14.String.prototype.split()"></a>14.String.prototype.split()</h1><p><strong>split 方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;a|b|c&quot;</span>.split(<span class="string">&quot;|&quot;</span>); <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"><span class="string">&quot;a|b|c&quot;</span>.split(<span class="string">&quot;&quot;</span>); <span class="comment">// [&quot;a&quot;, &quot;|&quot;, &quot;b&quot;, &quot;|&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure>

<p><strong>replace 方法用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有 g 修饰符的正则表达式）。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;aaa&quot;</span>.replace(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>); <span class="comment">// &quot;baa&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="15-String-prototype-localeCompare"><a href="#15-String-prototype-localeCompare" class="headerlink" title="15.String.prototype.localeCompare()"></a>15.String.prototype.localeCompare()</h1><p><strong>localeCompare 方法用于比较两个字符串。它返回一个整数，如果小于 0，表示第一个字符串小于第二个字符串；如果等于 0，表示两者相等；如果大于 0，表示第一个字符串大于第二个字符串。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;apple&quot;</span>.localeCompare(<span class="string">&quot;banana&quot;</span>); <span class="comment">// -1</span></span><br><span class="line"><span class="string">&quot;apple&quot;</span>.localeCompare(<span class="string">&quot;apple&quot;</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h1 id="16-repeat"><a href="#16-repeat" class="headerlink" title="16.repeat()"></a>16.repeat()</h1><p><strong>repeat 方法返回一个新字符串，表示将原字符串重复 n 次。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;x&quot;</span>.repeat(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// &#x27;xxx&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>参数如果是小数，会被取整。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;x&quot;</span>.repeat(<span class="number">2.9</span>);</span><br><span class="line"><span class="comment">// &#x27;xx&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="17-String-raw"><a href="#17-String-raw" class="headerlink" title="17.String.raw()"></a>17.String.raw()</h1><p><strong>ES6 还为原生的 String 对象，提供了一个 raw()方法。该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw<span class="string">`\n<span class="subst">$&#123;<span class="number">2</span> + <span class="number">2</span>&#125;</span>`</span>;</span><br><span class="line"><span class="comment">// &quot;\\n4&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="18-includes-startsWith-endsWith"><a href="#18-includes-startsWith-endsWith" class="headerlink" title="18.includes(), startsWith(), endsWith()"></a>18.includes(), startsWith(), endsWith()</h1><p><strong>传统上，JavaScript 只有 indexOf 方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。</strong></p>
<ul>
<li><strong>includes()：返回布尔值，表示是否找到了参数字符串。</strong></li>
<li><strong>startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。</strong></li>
<li><strong>endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">`hello world`</span>;</span><br><span class="line">s.includes(<span class="string">`hello`</span>);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">s.startsWith(<span class="string">`hello`</span>);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">`hello`</span>);</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h1 id="19-padStart-，padEnd"><a href="#19-padStart-，padEnd" class="headerlink" title="19.padStart()，padEnd()"></a>19.padStart()，padEnd()</h1><p><strong>ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="string">&quot;x&quot;</span>;</span><br><span class="line">b.padStart(<span class="number">4</span>, <span class="string">&quot;ab&quot;</span>);</span><br><span class="line"><span class="comment">// &#x27;abax&#x27;</span></span><br><span class="line">b.padEnd(<span class="number">6</span>, <span class="string">&quot;cd&quot;</span>);</span><br><span class="line"><span class="comment">// &#x27;xcdcdc&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="20-trimStart-，trimEnd"><a href="#20-trimStart-，trimEnd" class="headerlink" title="20.trimStart()，trimEnd()"></a>20.trimStart()，trimEnd()</h1><p><a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-string-left-right-trim"><strong>ES2019</strong></a><strong>对字符串实例新增了 trimStart()和 trimEnd()这两个方法。它们的行为与 trim()一致，trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> t = <span class="string">` hello `</span>;</span><br><span class="line">t.trim(); <span class="comment">// &quot;hello&quot;</span></span><br><span class="line">t.trimStart(); <span class="comment">// &quot;hello &quot;</span></span><br><span class="line">t.trimEnd(); <span class="comment">// &quot; hello&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="21-matchAll"><a href="#21-matchAll" class="headerlink" title="21.matchAll()"></a>21.matchAll()</h1><p><strong>matchAll()方法返回一个正则表达式在当前字符串的所有匹配</strong></p>
<h1 id="22-replaceAll"><a href="#22-replaceAll" class="headerlink" title="22.replaceAll()"></a>22.replaceAll()</h1><p><strong>历史上，字符串的实例方法 replace()只能替换第一个匹配。(不会修改原来的字符串)</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> g = <span class="string">`heelo`</span>;</span><br><span class="line">g.replace(<span class="string">&quot;e&quot;</span>, <span class="string">&quot;l&quot;</span>); <span class="comment">// &quot;hlelo&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(g); <span class="comment">// &quot;heelo&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>上面例子中，replace()只将第一个 e 替换成了 l。</strong><br><strong>如果要替换所有的匹配，不得不使用正则表达式的 g 修饰符。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.replace(<span class="regexp">/e/g</span>, <span class="string">&quot;l&quot;</span>); <span class="comment">// &quot;hlllo&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>正则表达式毕竟不是那么方便和直观，</strong><a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-string-replaceall"><strong>ES2021</strong></a><strong>引入了 replaceAll()方法，可以一次性替换所有匹配。(不会修改原来的字符串)</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g.replaceAll(<span class="string">&quot;e&quot;</span>, <span class="string">&quot;l&quot;</span>);</span><br><span class="line"><span class="comment">// &#x27;hlllo&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>replaceAll()的第二个参数 replacement 除了为字符串，也可以是一个函数，该函数的返回值将替换掉第一个参数 searchValue 匹配的文本。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;aabbcc&quot;</span>.replaceAll(<span class="string">&quot;b&quot;</span>, <span class="function">() =&gt;</span> <span class="string">&quot;_&quot;</span>);</span><br><span class="line"><span class="comment">// &#x27;aa__cc&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>上面例子中，replaceAll()的第二个参数是一个函数，该函数的返回值会替换掉所有 b 的匹配。</strong><br><strong>这个替换函数可以接受多个参数。第一个参数是捕捉到的匹配内容，第二个参数捕捉到是组匹配（有多少个组匹配，就有多少个对应的参数）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置，最后一个参数是原字符串。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;123abc456&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/(\d+)([a-z]+)(\d+)/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replacer</span>(<span class="params">match, p1, p2, p3, offset, string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [p1, p2, p3].join(<span class="string">&quot; - &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">str.replaceAll(regex, replacer);</span><br><span class="line"><span class="comment">// 123 - abc - 456</span></span><br></pre></td></tr></table></figure>

<p><strong>上面例子中，正则表达式有三个组匹配，所以 replacer()函数的第一个参数 match 是捕捉到的匹配内容（即字符串 123abc456），后面三个参数 p1、p2、p3 则依次为三个组匹配。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/29/yuque/uglify%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/29/yuque/uglify%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">uglify原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-29 13:03:10" itemprop="dateCreated datePublished" datetime="2021-04-29T13:03:10+08:00">2021-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-02 20:01:26" itemprop="dateModified" datetime="2021-05-02T20:01:26+08:00">2021-05-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-AST（抽象语法树）"><a href="#1-AST（抽象语法树）" class="headerlink" title="1. AST（抽象语法树）"></a>1. AST（抽象语法树）</h2><p>要想了解 JS 的压缩原理，需要首先了解 AST。<br>抽象语法树：AST（Abstract Syntax Tree)，是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。树上的每个节点都表示源代码中的一种结构。之所以说语法是「抽象」的，是因为这里的语法并不会表示出真实语法中出现的每个细节。<br>举个例子：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619672668724-5d3358d3-d081-4ee0-8dfb-5ea211241701.png#clientId=u345a0e7d-2a1d-4&from=paste&height=288&id=u08c9713a&margin=%5Bobject%20Object%5D&originHeight=288&originWidth=800&originalType=url&status=done&style=none&taskId=u7b2e6f9e-7023-443f-bad2-85b82471e5d&width=800"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619672668632-dfb7a922-3e21-4aa2-a90e-1f63de20b25d.png#clientId=u345a0e7d-2a1d-4&from=paste&height=599&id=u35c87bbd&margin=%5Bobject%20Object%5D&originHeight=599&originWidth=800&originalType=url&status=done&style=none&taskId=u89688d6a-a0a1-46a2-8ea2-8032c37b70d&width=800"><br>从上面两个例子中，可以看出 AST 是源代码根据其语法结构，省略一些细节（比如：括号没有生成节点），抽象成树形表达。抽象语法树在计算机科学中有很多应用，比如编译器、IDE、压缩代码、格式化代码等。[1]</p>
<h2 id="2-代码压缩原理"><a href="#2-代码压缩原理" class="headerlink" title="2. 代码压缩原理"></a>2. 代码压缩原理</h2><p>了解了 AST 之后，我们再分析一下 JS 的代码压缩原理。简单的说，就是</p>
<ol>
<li>将 code 转换成 AST</li>
<li>将 AST 进行优化，生成一个更小的 AST</li>
<li>将新生成的 AST 再转化成 code<br>PS：具体的 AST 树大家可以在 astexplorer 上在线获得<br>babel，eslint，v8 的逻辑均与此类似，下图是我们引用了 babel 的转化示意图：<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619672668742-e01926f8-b6e2-484e-8199-be950d1dc148.jpeg#clientId=u345a0e7d-2a1d-4&from=paste&height=332&id=uea97fb66&margin=%5Bobject%20Object%5D&originHeight=332&originWidth=800&originalType=url&status=done&style=none&taskId=ubdc3cbe5-e218-40ee-9e90-498a01e57ba&width=800"><br>以我们之前被质疑的代码为例，看看它在 uglify 中是怎么样一步一步被压缩的：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uglify-js的版本需要为2.x, 3.0之后uglifyjs不再暴露Compressor api</span></span><br><span class="line"><span class="comment">// 2.x的uglify不能自动解析es6，所以这里先切换成es5</span></span><br><span class="line"><span class="comment">// npm install uglify-js@2.x</span></span><br><span class="line"><span class="keyword">var</span> UglifyJS = <span class="built_in">require</span>(<span class="string">&quot;uglify-js&quot;</span>);</span><br><span class="line"><span class="comment">// 原始代码</span></span><br><span class="line"><span class="keyword">var</span> code = <span class="string">`var a;</span></span><br><span class="line"><span class="string">var x = &#123; b: 123 &#125;;</span></span><br><span class="line"><span class="string">a = 123,</span></span><br><span class="line"><span class="string">delete x`</span>;</span><br><span class="line"><span class="comment">// 通过 UglifyJS 把代码解析为 AST</span></span><br><span class="line"><span class="keyword">var</span> ast = UglifyJS.parse(code);</span><br><span class="line">ast.figure_out_scope();</span><br><span class="line"><span class="comment">// 转化为一颗更小的 AST 树</span></span><br><span class="line">compressor = UglifyJS.Compressor();</span><br><span class="line">ast = ast.transform(compressor);</span><br><span class="line"><span class="comment">// 再把 AST 转化为代码</span></span><br><span class="line">code = ast.print_to_string();</span><br><span class="line"><span class="comment">// var a,x=&#123;b:123&#125;;a=123,delete x;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;code&quot;</span>, code);</span><br></pre></td></tr></table></figure>

<p>到这里，我们已经了解了 uglifyjs 的代码压缩原理，但是还没有解决一个问题——为什么某些语句间的分号会被转换为逗号，某些不会转换。这就涉及到了 uglifyjs 的压缩规则。</p>
<h2 id="3-代码压缩规则"><a href="#3-代码压缩规则" class="headerlink" title="3. 代码压缩规则"></a>3. 代码压缩规则</h2><p>由于 uglifyjs 的代码压缩规则很多，我们这里只分析与本文中相关的部分:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uglifyjs的全部压缩规则可以参见：</span><br><span class="line">《[解读uglifyJS（四）——Javascript代码压缩](https:&#x2F;&#x2F;rapheal.sinaapp.com&#x2F;2014&#x2F;05&#x2F;22&#x2F;uglifyjs-squeeze&#x2F;#more-705)》</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619672718992-6f322231-e031-4622-9fe6-93c5bed01720.png#clientId=u345a0e7d-2a1d-4&from=paste&height=145&id=u42935634&margin=%5Bobject%20Object%5D&originHeight=145&originWidth=800&originalType=url&status=done&style=none&taskId=u9312dfff-ac37-4f6a-b034-b454e30c000&width=800"><br>PS：在线 demo<br>这其中需要注意的是只有“表达式语句”才能被合并，那么什么是表达式语句呢？<br><strong>表达式 VS 语句 VS 表达式语句</strong><br>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a; <span class="comment">//返回a的值</span></span><br><span class="line">b + <span class="number">3</span>; <span class="comment">// 返回b+3的结果</span></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; arr.length; i ++) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   A();</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;();</span><br><span class="line"><span class="keyword">delete</span> x.b;</span><br><span class="line">b = b + <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>综上所述，因为 a = 123 和 delete x 都是表达式语句，所以分号被转换为逗号。而 var x = {b:123}则因为是声明语句，所以和 a=123 不会合并，分号不会被转换。但 var x = {b:123}和第一行 var a 又触发了另外一条规则，<br>所以第一行和第二行会被合并为 var a,x={b:123}</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>在本文中，我们讨论了什么是抽象语法树，uglifyjs 的压缩原理，以及相应的压缩规则，最终明晰了为什么代码会被压缩成我们得到的样子，希望对大家有所帮助。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/28/yuque/Array%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95api/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/28/yuque/Array%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95api/" class="post-title-link" itemprop="url">Array常用方法api</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-28 13:22:31" itemprop="dateCreated datePublished" datetime="2021-04-28T13:22:31+08:00">2021-04-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-02 20:01:26" itemprop="dateModified" datetime="2021-05-02T20:01:26+08:00">2021-05-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-扩展运算符"><a href="#1-扩展运算符" class="headerlink" title="1.扩展运算符"></a>1.扩展运算符</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 1 2</span></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> arr3 = arr1.concat(arr2);</span><br><span class="line"><span class="built_in">console</span>.log(...[arr3]); <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span></span><br><span class="line"><span class="keyword">const</span> [a, b, c] = [...arr3];</span><br><span class="line"><span class="comment">// a : &quot;a&quot;</span></span><br><span class="line"><span class="comment">// b : &quot;b&quot;</span></span><br><span class="line"><span class="comment">// c : &quot;c&quot;</span></span><br><span class="line"><span class="keyword">const</span> d = [...<span class="string">&quot;hello&quot;</span>];</span><br><span class="line"><span class="comment">// [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]</span></span><br></pre></td></tr></table></figure>

<h1 id="2-Array-from"><a href="#2-Array-from" class="headerlink" title="2.Array.from()"></a>2.Array.from()</h1><p><strong>Array.from 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arraylike = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">  length: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(arraylike);</span><br><span class="line"><span class="comment">// [&quot;1&quot;, &quot;2&quot;]</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="string">&quot;hello&quot;</span>); <span class="comment">//[&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]</span></span><br><span class="line"><span class="keyword">let</span> nameSet = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>]);</span><br><span class="line"><span class="built_in">Array</span>.from(nameSet); <span class="comment">// [&quot;a&quot;, &quot;b&quot;]</span></span><br></pre></td></tr></table></figure>

<p><strong>Array.from 还可以接受第二个参数，作用类似于数组的 map 方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">x</span>) =&gt;</span> x * x); <span class="comment">// [1, 4, 9]</span></span><br><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).map(<span class="function">(<span class="params">x</span>) =&gt;</span> x * x); <span class="comment">// [1, 4, 9]</span></span><br></pre></td></tr></table></figure>

<h1 id="3-Array-of"><a href="#3-Array-of" class="headerlink" title="3.Array.of()"></a>3.Array.of()</h1><p><strong>Array.of()方法用于将一组值，转换为数组。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1，2，3]</span></span><br></pre></td></tr></table></figure>

<h1 id="4-数组实例的-copyWithin"><a href="#4-数组实例的-copyWithin" class="headerlink" title="4.数组实例的 copyWithin()"></a>4.数组实例的 copyWithin()</h1><p>数组实例的 copyWithin()方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.copyWithin(target, (start = <span class="number">0</span>), (end = <span class="built_in">this</span>.length));</span><br></pre></td></tr></table></figure>

<p>它接受三个参数。</p>
<ul>
<li>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</li>
<li>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。</li>
</ul>
<p>这三个参数都应该是数值，如果不是，会自动转为数值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">  .copyWithin(<span class="number">0</span>, <span class="number">3</span>) <span class="comment">// [4, 5, 3, 4, 5]</span></span><br><span class="line">  [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)].copyWithin(<span class="number">0</span>, <span class="number">4</span>); <span class="comment">// [5, 5, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<h1 id="5-数组实例的-find-和-findIndex"><a href="#5-数组实例的-find-和-findIndex" class="headerlink" title="5.数组实例的 find() 和 findIndex()"></a>5.数组实例的 find() 和 findIndex()</h1><p><strong>数组实例的 find 方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 true 的成员，然后返回该成员。如果没有符合条件的成员，则返回 undefined。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line">  .find(<span class="function">(<span class="params">n</span>) =&gt;</span> n &gt; <span class="number">0</span>) <span class="comment">// 1</span></span><br><span class="line">  [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>)].find(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">  [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>)].find(<span class="function"><span class="keyword">function</span> (<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value &gt; <span class="number">1</span>;</span><br><span class="line">  &#125;); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p><strong>上面代码中，find 方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</strong><br><strong>数组实例的 findIndex 方法的用法与 find 方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].findIndex(<span class="function"><span class="keyword">function</span> (<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p><strong>这两个方法都可以接受第二个参数，用来绑定回调函数的 this 对象。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v &gt; <span class="built_in">this</span>.age;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">19</span>, <span class="number">27</span>].find(f, &#123; <span class="attr">age</span>: <span class="number">26</span> &#125;); <span class="comment">// 27</span></span><br></pre></td></tr></table></figure>

<h1 id="6-数组实例的-fill"><a href="#6-数组实例的-fill" class="headerlink" title="6.数组实例的 fill()"></a>6.数组实例的 fill()</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>].fill(<span class="number">7</span>); <span class="comment">// [7,7,7]</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">1</span>); <span class="comment">// [1,1,1]</span></span><br></pre></td></tr></table></figure>

<p><strong>fill 方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>].fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;, 7, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><strong>上面代码表示，fill 方法从 1 号位开始，向原数组填充 7，到 2 号位之前结束。</strong><br><strong>注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(&#123; <span class="attr">name</span>: <span class="string">&quot;Mike&quot;</span> &#125;);</span><br><span class="line">arr[<span class="number">0</span>].name = <span class="string">&quot;Ben&quot;</span>;</span><br><span class="line">arr;</span><br><span class="line"><span class="comment">// [&#123;name: &quot;Ben&quot;&#125;, &#123;name: &quot;Ben&quot;&#125;, &#123;name: &quot;Ben&quot;&#125;]</span></span><br></pre></td></tr></table></figure>

<h1 id="7-数组实例的-entries-，keys-和-values"><a href="#7-数组实例的-entries-，keys-和-values" class="headerlink" title="7.数组实例的 entries()，keys() 和 values()"></a>7.数组实例的 entries()，keys() 和 values()</h1><p><strong>ES6 提供三个新的方法——entries()，keys()和 values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用 for…of 循环进行遍历，唯一的区别是 keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>].keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>].values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>].entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 &quot;a&quot;</span></span><br><span class="line"><span class="comment">// 1 &quot;b&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>如果不使用 for…of 循环，可以手动调用遍历器对象的 next 方法，进行遍历。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> letter = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> entries = letter.entries();</span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [0, &#x27;a&#x27;]</span></span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [1, &#x27;b&#x27;]</span></span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [2, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<h1 id="8-数组实例的-includes"><a href="#8-数组实例的-includes" class="headerlink" title="8.数组实例的 includes()"></a>8.数组实例的 includes()</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">  .includes(<span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line">  [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)].includes(<span class="number">0</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><strong>该方法的第二个参数表示搜索的起始位置，默认为 0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为 3），则会重置为从 0 开始。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>, <span class="number">3</span>); <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>, -<span class="number">1</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h1 id="9-数组实例的-flat-，flatMap"><a href="#9-数组实例的-flat-，flatMap" class="headerlink" title="9.数组实例的 flat()，flatMap()"></a>9.数组实例的 flat()，flatMap()</h1><p><strong>数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]].flat() <span class="comment">// [1,2,3,4]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>,[<span class="number">4</span>],[<span class="number">5</span>]]].flat(<span class="number">2</span>) <span class="comment">//  [1, 2, 3, 4, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>]]].flat(<span class="literal">Infinity</span>) <span class="comment">// [1,2,3]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, , <span class="number">4</span>, <span class="number">5</span>].flat() <span class="comment">// [1,2,4,5]</span></span><br></pre></td></tr></table></figure>

<p><strong>flatMap()方法对原数组的每个成员执行一个函数（相当于执行 Array.prototype.map()），然后对返回值组成的数组执行 flat()方法。该方法返回一个新数组，不改变原数组。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].flatMap(<span class="function">(<span class="params">x</span>) =&gt;</span> x * x); <span class="comment">// [4, 9, 16]</span></span><br></pre></td></tr></table></figure>

<h1 id="10-Array-prototype-sort-的排序稳定性"><a href="#10-Array-prototype-sort-的排序稳定性" class="headerlink" title="10.Array.prototype.sort() 的排序稳定性"></a>10.Array.prototype.sort() 的排序稳定性</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">  .sort(<span class="function"><span class="keyword">function</span> (<span class="params">a1, a2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a1 - a2;</span><br><span class="line">  &#125;) <span class="comment">// [1, 2, 4, 10]</span></span><br><span class="line">  [(<span class="number">1</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">2</span>)].sort(<span class="function"><span class="keyword">function</span> (<span class="params">a1, a2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a2 - a1;</span><br><span class="line">  &#125;); <span class="comment">// [10, 4, 2, 1]</span></span><br></pre></td></tr></table></figure>

<h1 id="11-Array-isArray"><a href="#11-Array-isArray" class="headerlink" title="11.Array.isArray()"></a>11.Array.isArray()</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray(&#123;&#125;); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Array</span>.isArray([]); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h1 id="12-valueOf-，toString"><a href="#12-valueOf-，toString" class="headerlink" title="12.valueOf()，toString()"></a>12.valueOf()，toString()</h1><p><strong>valueOf 方法是一个所有对象都拥有的方法，表示对该对象求值。不同对象的 valueOf 方法不尽一致，数组的 valueOf 方法返回数组本身。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].valueOf()[</span><br><span class="line">  <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line">  (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">].toString();</span><br><span class="line"><span class="comment">// &quot;1,2,3,4&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="13-push-，pop"><a href="#13-push-，pop" class="headerlink" title="13.push()，pop()"></a>13.push()，pop()</h1><p><strong>push 方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。</strong><br><strong>pop 方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr2.push(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// [1,2,3,4]</span></span><br><span class="line">arr2.pop();</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<h1 id="14-shift-，unshift"><a href="#14-shift-，unshift" class="headerlink" title="14.shift()，unshift()"></a>14.shift()，unshift()</h1><p>shift()方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">b.shift(); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// [2,3]</span></span><br></pre></td></tr></table></figure>

<p><strong>unshift()方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">c.unshift(<span class="number">5</span>); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(c);</span><br><span class="line"><span class="comment">// [1,2,3,5]</span></span><br></pre></td></tr></table></figure>

<h1 id="15-join"><a href="#15-join" class="headerlink" title="15.join()"></a>15.join()</h1><p><strong>join()方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">a.join();</span><br><span class="line"><span class="comment">// 1,2,3,4</span></span><br><span class="line">a.join(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="comment">// 1 2 3 4</span></span><br></pre></td></tr></table></figure>

<p><strong>如果数组成员是 undefined 或 null 或空位，会被转成空字符串。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">undefined</span>, <span class="literal">null</span>].join(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">// &quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="16-concat"><a href="#16-concat" class="headerlink" title="16.concat()"></a>16.concat()</h1><p><strong>concat 方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> g = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">g.concat(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// [1,2,3,4]</span></span><br><span class="line">g.concat([<span class="number">5</span>]);</span><br><span class="line"><span class="comment">// [1, 2, 3, 5]</span></span><br></pre></td></tr></table></figure>

<p><strong>如果数组成员包括对象，concat 方法返回当前数组的一个浅拷贝。所谓“浅拷贝”，指的是新数组拷贝的是对象的引用。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> g = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> b = &#123; <span class="attr">a</span>: <span class="string">&quot;123&quot;</span> &#125;;</span><br><span class="line">g = g.concat(b);</span><br><span class="line"><span class="comment">// [1, 2, 3, &#123;…&#125;]</span></span><br><span class="line"><span class="built_in">console</span>.log(g[<span class="number">3</span>].a);</span><br><span class="line"><span class="comment">// &#123;a: &quot;123&quot;&#125;</span></span><br><span class="line">g3.a = <span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// a : &#x27;1&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="17-reverse"><a href="#17-reverse" class="headerlink" title="17.reverse()"></a>17.reverse()</h1><p><strong>reverse 方法用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> h = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>];</span><br><span class="line">h.reverse();</span><br><span class="line"><span class="comment">// [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</span></span><br></pre></td></tr></table></figure>

<h1 id="18-slice"><a href="#18-slice" class="headerlink" title="18.slice()"></a>18.slice()</h1><p><strong>slice()方法用于提取目标数组的一部分，返回一个新数组，原数组不变。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.slice(start, end);</span><br></pre></td></tr></table></figure>

<p><strong>它的第一个参数为起始位置（从 0 开始，会包括在返回的新数组之中），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">a.slice(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// [2,3,4]</span></span><br></pre></td></tr></table></figure>

<p><strong>slice()方法的一个重要应用，是将类似数组的对象转为真正的数组。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice.call(&#123; <span class="number">0</span>: <span class="string">&quot;1&quot;</span>, <span class="number">1</span>: <span class="string">&quot;2&quot;</span>, <span class="attr">length</span>: <span class="number">2</span> &#125;);</span><br><span class="line"><span class="comment">// [&quot;1&quot;, &quot;2&quot;]</span></span><br></pre></td></tr></table></figure>

<h1 id="19-splice"><a href="#19-splice" class="headerlink" title="19.splice()"></a>19.splice()</h1><p><strong>splice()方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.splice(start, count, addElement1, addElement2, ...);</span><br></pre></td></tr></table></figure>

<p><strong>splice 的第一个参数是删除的起始位置（从 0 开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> u = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">u.splice(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// [2,3]</span></span><br><span class="line"><span class="built_in">console</span>.log(u);</span><br><span class="line"><span class="comment">// [1,4]</span></span><br><span class="line">u.push(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// [1,4,2,3]</span></span><br><span class="line">u.splice(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// [4,2]</span></span><br><span class="line"><span class="built_in">console</span>.log(u);</span><br><span class="line"><span class="comment">// [1, 1, 1, 3]</span></span><br></pre></td></tr></table></figure>

<h1 id="20-sort"><a href="#20-sort" class="headerlink" title="20.sort()"></a>20.sort()</h1><p><strong>sort 方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&quot;d&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;a&quot;</span>]</span><br><span class="line">  .sort() <span class="comment">// [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;]</span></span><br><span class="line">  [(<span class="number">5</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">0</span>)].sort(); <span class="comment">// [0,1,5,8]</span></span><br></pre></td></tr></table></figure>

<h1 id="21-map"><a href="#21-map" class="headerlink" title="21.map()"></a>21.map()</h1><p><strong>map 方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> m1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">m1.map(<span class="function"><span class="keyword">function</span> (<span class="params">elem, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> elem * index;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [0,2,6]</span></span><br></pre></td></tr></table></figure>

<h1 id="22-forEach"><a href="#22-forEach" class="headerlink" title="22.forEach()"></a>22.forEach()</h1><p><strong>forEach 方法与 map 方法很相似，也是对数组的所有成员依次执行参数函数。但是，forEach 方法不返回值，只用来操作数据。这就是说，如果数组遍历的目的是为了得到返回值，那么使用 map 方法，否则使用 forEach 方法。</strong><br><strong>forEach 的用法与 map 方法一致，参数是一个函数，该函数同样接受三个参数：当前值、当前位置、整个数组。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> out = [];</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">elem</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.push(elem * elem);</span><br><span class="line">&#125;, out);</span><br><span class="line"><span class="comment">// [1,4,9]</span></span><br></pre></td></tr></table></figure>

<p><strong>注意，forEach 方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用 for 循环。</strong></p>
<h1 id="23-filter"><a href="#23-filter" class="headerlink" title="23.filter()"></a>23.filter()</h1><p><strong>filter 方法用于过滤数组成员，满足条件的成员组成一个新数组返回。</strong><br><strong>它的参数是一个函数，所有数组成员依次执行该函数，返回结果为 true 的成员组成一个新数组返回。该方法不会改变原数组。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].filter(<span class="function"><span class="keyword">function</span> (<span class="params">elem, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> elem &gt; <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [2,3,4,5]</span></span><br></pre></td></tr></table></figure>

<h1 id="24-some-，every"><a href="#24-some-，every" class="headerlink" title="24.some()，every()"></a>24.some()，every()</h1><p><strong>这两个方法类似“断言”（assert），返回一个布尔值，表示判断数组成员是否符合某种条件。</strong><br><strong>它们接受一个函数作为参数，所有数组成员依次执行该函数。该函数接受三个参数：当前成员、当前位置和整个数组，然后返回一个布尔值。</strong><br><strong>some 方法是只要一个成员的返回值是 true，则整个 some 方法的返回值就是 true，否则返回 false。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].some(<span class="function"><span class="keyword">function</span> (<span class="params">elem</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> elem &gt; <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>every 方法是所有成员的返回值都是 true，整个 every 方法才返回 true，否则返回 false。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].every(<span class="function"><span class="keyword">function</span> (<span class="params">elem</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> elem &gt; <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h1 id="25-reduce-，reduceRight"><a href="#25-reduce-，reduceRight" class="headerlink" title="25.reduce()，reduceRight()"></a>25.reduce()，reduceRight()</h1><p><strong>reduce 方法和 reduceRight 方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，reduce 是从左到右处理（从第一个成员到最后一个成员），reduceRight 则是从右到左（从最后一个成员到第一个成员），其他完全一样。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].reduce(<span class="function"><span class="keyword">function</span> (<span class="params">a1, a2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a1 + a2;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<h1 id="26-indexOf-，lastIndexOf"><a href="#26-indexOf-，lastIndexOf" class="headerlink" title="26.indexOf()，lastIndexOf()"></a>26.indexOf()，lastIndexOf()</h1><p>**indexOf 方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1 **<br><strong>indexOf 方法还可以接受第二个参数，表示搜索的开始位置。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].indexOf(<span class="number">1</span>)[</span><br><span class="line">  <span class="comment">// 0</span></span><br><span class="line">  (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">].indexOf(<span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p><strong>lastIndexOf 方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].lastIndexOf(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<h1 id="27-总结图"><a href="#27-总结图" class="headerlink" title="27.总结图"></a>27.总结图</h1><p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619672235917-33ae37b0-6740-4040-af97-6b80eb16a7ac.png#clientId=u5f198714-ef64-4&from=paste&height=912&id=uf6695a7d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=917&originWidth=823&originalType=binary&size=524360&status=done&style=none&taskId=u459400e2-8921-4dd7-a229-92597137029&width=818.5" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619672246144-2a807e43-11a5-421f-b3e7-e72920d0c788.png#clientId=u5f198714-ef64-4&from=paste&height=1908&id=ud045c8ec&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1946&originWidth=1080&originalType=binary&size=865562&status=done&style=none&taskId=u7c8d3621-8d81-49e1-9257-e047cc5ab3b&width=1059" alt="image.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/26/yuque/Tree-Shaking%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5-%E5%AE%9E%E8%B7%B5%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/26/yuque/Tree-Shaking%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5-%E5%AE%9E%E8%B7%B5%E7%AF%87/" class="post-title-link" itemprop="url">Tree-Shaking性能优化实践-实践篇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-26 14:05:39" itemprop="dateCreated datePublished" datetime="2021-04-26T14:05:39+08:00">2021-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-02 20:01:26" itemprop="dateModified" datetime="2021-05-02T20:01:26+08:00">2021-05-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上一篇文章 <a target="_blank" rel="noopener" href="https://juejin.im/post/6844903544756109319">Tree-Shaking 性能优化实践 - 原理篇</a> 介绍了 tree-shaking 的原理，本文主要介绍 tree-shaking 的实践</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417176669-626362ab-6164-4bb3-b700-463db3ee8027.jpeg#clientId=ue71f5aac-b372-4&from=drop&height=120&id=u706055df&margin=%5Bobject%20Object%5D&name=1.jpg&originHeight=120&originWidth=180&originalType=binary&size=6581&status=done&style=none&taskId=uec8d1f6e-41b1-4021-8111-765498ed4c7&width=180" alt="1.jpg"></p>
<h2 id="三-tree-shaking-实践"><a href="#三-tree-shaking-实践" class="headerlink" title="三. tree-shaking 实践"></a>三. tree-shaking 实践</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417185298-aebd7e76-9d26-404e-8510-758287b50fb9.jpeg#clientId=ue71f5aac-b372-4&from=drop&id=u5729f233&margin=%5Bobject%20Object%5D&name=2.jpg&originHeight=405&originWidth=720&originalType=binary&size=6650&status=done&style=none&taskId=u06c1c936-fc57-4b44-a3e1-96901b03f42" alt="2.jpg"></p>
<p>webpack2 发布，宣布支持 tree-shaking，webpack 3 发布，支持作用域提升，生成的 bundle 文件更小。 再没有升级 webpack 之前，增幻想我们的性能又要大幅提升了，对升级充满了期待。实际上事实是这样的</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417191922-3d9e77c7-2db8-4669-ab41-cf0322d484ef.jpeg#clientId=ue71f5aac-b372-4&from=drop&id=u4d97b1fb&margin=%5Bobject%20Object%5D&name=3.jpg&originHeight=405&originWidth=720&originalType=binary&size=11332&status=done&style=none&taskId=u9d5ca2ab-b4c9-489e-8b48-37dd15af1b0" alt="3.jpg"></p>
<p>升级完之后，bundle 文件大小并没有大幅减少，当时有较大的心理落差，然后去研究了为什么效果不理想，原因见 <a target="_blank" rel="noopener" href="https://juejin.im/post/6844903544756109319">Tree-Shaking 性能优化实践 - 原理篇</a> 。</p>
<p>优化还是要继续的，虽然工具自带的 tree-shaking 不能去除太多无用代码，在去除无用代码这一方面也还是有可以做的事情。我们从三个方面做里一些优化。</p>
<h2 id="（1）对组件库引用的优化"><a href="#（1）对组件库引用的优化" class="headerlink" title="（1）对组件库引用的优化"></a>（1）对组件库引用的优化</h2><p>先来看一个问题</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417203100-cbcd535b-d7af-49ff-900c-c4b7827caa01.jpeg#clientId=ue71f5aac-b372-4&from=drop&id=ue93e7c8a&margin=%5Bobject%20Object%5D&name=4.jpg&originHeight=376&originWidth=720&originalType=binary&size=21516&status=done&style=none&taskId=u0abbe6ec-1ad4-4b1d-870a-50dd2fbb7be" alt="4.jpg"></p>
<p>当我们使用组件库的时候，import {Button} from ‘element-ui’，相对于 Vue.use(elementUI)，已经是具有性能意识，是比较推荐的做法，但如果我们写成右边的形式，具体到文件的引用，打包之后的区别是非常大的，以 antd 为例，右边形式 bundle 体积减少约 80%。</p>
<p>这个引用也属于有副作用，webpack 不能把其他组件进行 tree-shaking。既然工具本身是做不了，那我们可以做工具把左边代码自动改成右边代码这种形式。这个工具 antd 库本身也是提供的。我在 antd 的工具基础上做了少量的修改，不用任何配置，原生支持我们自己的组件库， <a href="http://link.zhihu.com/?target=https://w-ui.github.io/%23/doc">wui</a> 和 <a href="http://link.zhihu.com/?target=https://wmfe.github.io/xcui/%23/home">xcui</a> 以及一些其他常用的库</p>
<p><strong>babel-plugin-import-fix ，缩小引用范围</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417213027-2a680ba0-7647-447f-a9d6-4c963ef6ad09.jpeg#clientId=ue71f5aac-b372-4&from=drop&id=uea1764cc&margin=%5Bobject%20Object%5D&name=5.jpg&originHeight=198&originWidth=720&originalType=binary&size=10817&status=done&style=none&taskId=u95bc3c68-97a5-4c25-8190-d9499856cc0" alt="5.jpg"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417217960-614afe7b-13a3-40f0-a7ca-2e2ca2dc3126.jpeg#clientId=ue71f5aac-b372-4&from=drop&id=ueef65da2&margin=%5Bobject%20Object%5D&name=6.jpg&originHeight=120&originWidth=120&originalType=binary&size=4686&status=done&style=none&taskId=u9463d119-35ae-49e5-8df3-582361fd628" alt="6.jpg"></p>
<p><a href="http://link.zhihu.com/?target=https://github.com/lin-xi/babel-plugin-import-fix">lin-xi/babel-plugin-import-fix</a></p>
<p>下面介绍一下原理</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417223638-fa9c6c05-7a28-424f-bb5b-8cf4f83a21ed.jpeg#clientId=ue71f5aac-b372-4&from=drop&id=ub1729c08&margin=%5Bobject%20Object%5D&name=7.jpg&originHeight=405&originWidth=720&originalType=binary&size=12869&status=done&style=none&taskId=u743db0cb-9d20-4bfa-8079-ac5c78ddbd5" alt="7.jpg"></p>
<p>这是一个 babel 的插件，babel 通过核心 babylon 将 ES6 代码转换成 AST 抽象语法树，然后插件遍历语法树找出类似 import {Button} from ‘element-ui’这样的语句，进行转换，最后重新生成代码。</p>
<p>babel-plugin-import-fix 默认支持 antd，element，meterial-UI，wui，xcui 和 d3，只需要再.babelrc 中配置插件本身就可以。</p>
<p>.babelrc</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    [&quot;es2015&quot;, &#123; &quot;modules&quot;: false &#125;], &quot;react&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;plugins&quot;: [&quot;import-fix&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417230775-fcf865d2-f123-4214-adc6-8914952dfb5d.jpeg#clientId=ue71f5aac-b372-4&from=drop&id=u45ca0143&margin=%5Bobject%20Object%5D&name=8.jpg&originHeight=405&originWidth=720&originalType=binary&size=9224&status=done&style=none&taskId=ud6b209ce-caac-4800-980e-5a61e12d7ec" alt="8.jpg"></p>
<p>其实是想把所有常用的库都默认支持，但很多常用的库却不支持缩小引用范围。因为没有独立输出各个子模块，不能把引用修改为对单个子模块的引用。</p>
<h2 id="（2）CSS-Tree-shaking"><a href="#（2）CSS-Tree-shaking" class="headerlink" title="（2）CSS Tree-shaking"></a>（2）CSS Tree-shaking</h2><p>我们前面所说的 tree-shaking 都是针对 js 文件，通过静态分析，尽可能消除无用的代码，那对于 css 我们能做 tree-shaking 吗？</p>
<p>随着 CSS3，LESS，SASS 等各种 css 预处理语言的普及，css 文件在整个工程中占比是不可忽视的。随着大项目功能的不停迭代，导致 css 中可能就存在着无用的代码。我实现了一个 webpack 插件来解决这个问题，找出 css 代码无用的代码。</p>
<p><a href="http://link.zhihu.com/?target=https://github.com/lin-xi/webpack-css-treeshaking-plugin"><strong>webpack-css-treeshaking-plugin</strong></a><strong>，对 css 进行 tree-shaking</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417236617-b3f1bf5c-e32d-4c56-b932-71b640794f3e.jpeg#clientId=ue71f5aac-b372-4&from=drop&id=u816fab64&margin=%5Bobject%20Object%5D&name=9.jpg&originHeight=120&originWidth=120&originalType=binary&size=4686&status=done&style=none&taskId=ub99c9de7-84c5-4a61-b523-140015afd27" alt="9.jpg"></p>
<p>[webpack-css-treeshaking-plugin</p>
<p>](<a href="http://link.zhihu.com/?target=https://github.com/lin-xi/webpack-css-treeshaking-plugin">http://link.zhihu.com/?target=https%3A//github.com/lin-xi/webpack-css-treeshaking-plugin</a>)</p>
<p>下面介绍一下原理</p>
<p>整体思路是这样的，遍历所有的 css 文件中的 selector 选择器，然后去所有 js 代码中匹配，如果选择器没有在代码出现过，则认为该选择器是无用代码。</p>
<p><strong>首先面临的问题是，如何优雅的遍历所有的选择器呢？难道要用正则表达式很苦逼的去匹配分割吗？</strong></p>
<p>babel 是 js 世界的福星，其实 css 世界也有利器，那就是 postCss。</p>
<p>PostCSS 提供了一个解析器，它能够将 CSS 解析成 AST 抽象语法树。然后我们能写各种插件，对抽象语法树做处理，最终生成新的 css 文件，以达到对 css 进行精确修改的目的。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417244857-2cc0e501-2546-4a96-83e9-07236d806d89.jpeg#clientId=ue71f5aac-b372-4&from=drop&id=uc818a839&margin=%5Bobject%20Object%5D&name=10.jpg&originHeight=394&originWidth=720&originalType=binary&size=16294&status=done&style=none&taskId=ua622f1ee-12ee-48b4-9122-14c9b3aba66" alt="10.jpg"></p>
<p>整体又是一个 webpack 的插件，架构图如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417249458-955d4c96-c638-47e5-a97a-b7092d5f18dc.jpeg#clientId=ue71f5aac-b372-4&from=drop&id=u9c2e7c64&margin=%5Bobject%20Object%5D&name=11.jpg&originHeight=405&originWidth=720&originalType=binary&size=17641&status=done&style=none&taskId=u184075c6-13de-4115-ae5b-f3ee4d2fce4" alt="11.jpg"></p>
<p>主要流程：</p>
<ul>
<li>插件监听 webapck 编译完成事件，webpack 编译完成之后，从 compilation 中找出所有的 css 文件和 js 文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apply (compiler) &#123;</span><br><span class="line">    compiler.plugin(&#39;after-emit&#39;, (compilation, callback) &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">      let styleFiles &#x3D; Object.keys(compilation.assets).filter(asset &#x3D;&gt; &#123;</span><br><span class="line">        return &#x2F;\.css$&#x2F;.test(asset)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      let jsFiles &#x3D; Object.keys(compilation.assets).filter(asset &#x3D;&gt; &#123;</span><br><span class="line">        return &#x2F;\.(js|jsx)$&#x2F;.test(asset)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">     ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将所有的 css 文件送至 postCss 处理，找出无用代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let tasks &#x3D; []</span><br><span class="line"> styleFiles.forEach((filename) &#x3D;&gt; &#123;</span><br><span class="line">     const source &#x3D; compilation.assets[filename].source()</span><br><span class="line">     let listOpts &#x3D; &#123;</span><br><span class="line">       include: &#39;&#39;,</span><br><span class="line">       source: jsContents,  &#x2F;&#x2F;传入全部js文件</span><br><span class="line">       opts: this.options   &#x2F;&#x2F;插件配置选项</span><br><span class="line">     &#125;</span><br><span class="line">     tasks.push(postcss(treeShakingPlugin(listOpts)).process(source).then(result &#x3D;&gt; &#123;</span><br><span class="line">       let css &#x3D; result.toString()  &#x2F;&#x2F; postCss处理后的css AST</span><br><span class="line">       &#x2F;&#x2F;替换webpack的编译产物compilation</span><br><span class="line">       compilation.assets[filename] &#x3D; &#123;</span><br><span class="line">         source: () &#x3D;&gt; css,</span><br><span class="line">         size: () &#x3D;&gt; css.length</span><br><span class="line">       &#125;</span><br><span class="line">       return result</span><br><span class="line">     &#125;))</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>postCss 遍历，匹配，删除过程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; postcss.plugin(&#39;list-selectors&#39;, function (options) &#123;</span><br><span class="line">   &#x2F;&#x2F; 从根节点开始遍历</span><br><span class="line">   cssRoot.walkRules(function (rule) &#123;</span><br><span class="line">     &#x2F;&#x2F; Ignore keyframes, which can log e.g. 10%, 20% as selectors</span><br><span class="line">     if (rule.parent.type &#x3D;&#x3D;&#x3D; &#39;atrule&#39; &amp;&amp; &#x2F;keyframes&#x2F;.test(rule.parent.name)) return</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; 对每一个规则进行处理</span><br><span class="line">     checkRule(rule).then(result &#x3D;&gt; &#123;</span><br><span class="line">       if (result.selectors.length &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">         &#x2F;&#x2F; 选择器全部被删除</span><br><span class="line">         let log &#x3D; &#39; ✂️ [&#39; + rule.selector + &#39;] shaked, [1]&#39;</span><br><span class="line">         console.log(log)</span><br><span class="line">         if (config.remove) &#123;</span><br><span class="line">           rule.remove()</span><br><span class="line">         &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         &#x2F;&#x2F; 选择器被部分删除</span><br><span class="line">         let shaked &#x3D; rule.selectors.filter(item &#x3D;&gt; &#123;</span><br><span class="line">           return result.selectors.indexOf(item) &#x3D;&#x3D;&#x3D; -1</span><br><span class="line">         &#125;)</span><br><span class="line">         if (shaked &amp;&amp; shaked.length &gt; 0) &#123;</span><br><span class="line">           let log &#x3D; &#39; ✂️ [&#39; + shaked.join(&#39; &#39;) + &#39;] shaked, [2]&#39;</span><br><span class="line">           console.log(log)</span><br><span class="line">         &#125;</span><br><span class="line">         if (config.remove) &#123;</span><br><span class="line">           &#x2F;&#x2F; 修改AST抽象语法树</span><br><span class="line">           rule.selectors &#x3D; result.selectors</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>

<p>checkRule 处理每一个规则核心代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">let checkRule &#x3D; (rule) &#x3D;&gt; &#123;</span><br><span class="line">      return new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">        let secs &#x3D; rule.selectors.filter(function (selector) &#123;</span><br><span class="line">          let result &#x3D; true</span><br><span class="line">          let processor &#x3D; parser(function (selectors) &#123;</span><br><span class="line">            for (let i &#x3D; 0, len &#x3D; selectors.nodes.length; i &lt; len; i++) &#123;</span><br><span class="line">              let node &#x3D; selectors.nodes[i]</span><br><span class="line">              if (_.includes([&#39;comment&#39;, &#39;combinator&#39;, &#39;pseudo&#39;], node.type)) continue</span><br><span class="line">              for (let j &#x3D; 0, len2 &#x3D; node.nodes.length; j &lt; len2; j++) &#123;</span><br><span class="line">                let n &#x3D; node.nodes[j]</span><br><span class="line">                if (!notCache[n.value]) &#123;</span><br><span class="line">                  switch (n.type) &#123;</span><br><span class="line">                    case &#39;tag&#39;:</span><br><span class="line">                      &#x2F;&#x2F; nothing</span><br><span class="line">                      break</span><br><span class="line">                    case &#39;id&#39;:</span><br><span class="line">                    case &#39;class&#39;:</span><br><span class="line">                      if (!classInJs(n.value)) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 调用classInJs判断是否在JS中出现过</span><br><span class="line">                        notCache[n.value] &#x3D; true</span><br><span class="line">                        result &#x3D; false</span><br><span class="line">                        break</span><br><span class="line">                      &#125;</span><br><span class="line">                      break</span><br><span class="line">                    default:</span><br><span class="line">                      &#x2F;&#x2F; nothing</span><br><span class="line">                      break</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                  result &#x3D; false</span><br><span class="line">                  break</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">          ...</span><br><span class="line">        &#125;)</span><br><span class="line">        ...</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到其实我只处理里 id 选择器和 class 选择器，id 和 class 相对来说副作用小，引起样式异常的可能性相对较小。</p>
<p>判断 css 是否再 js 中出现过，是使用正则匹配。</p>
<p>其实，后续还可以继续优化，比如对 tag 类的选择器，可以配置是否再 html，jsx，template 中出现过，如果出现过，没有出现过也可以认为是无用代码。</p>
<p>当然，插件能正常工作还是的有一些前提和约束。我们可以在代码中动态改变 css，比如再 react 和 vue 中，可以这么写</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417258077-ca5886f8-045c-4b99-89da-b063e43149bf.jpeg#clientId=ue71f5aac-b372-4&from=drop&id=u456c9f5e&margin=%5Bobject%20Object%5D&name=12.jpg&originHeight=219&originWidth=720&originalType=binary&size=11908&status=done&style=none&taskId=u0422f285-8f06-45f7-826c-a8a4256f1f5" alt="12.jpg"></p>
<p>这样是比较推荐的方式，选择器作为字符或变量名出现在代码中，下面这样动态生成选择器的情况就会导致匹配失败</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">  this.stateClass &#x3D; &#39;state-&#39; + this.state &#x3D;&#x3D; 2 ? &#39;open&#39; : &#39;close&#39;</span><br><span class="line">  return &lt;div class&#x3D;&#123;this.stateClass&#125;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中这样情况很容易避免</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">  this.stateClass &#x3D; this.state &#x3D;&#x3D; 2 ? &#39;state-open&#39; : &#39;state-close&#39;</span><br><span class="line">  return &lt;div class&#x3D;&#123;this.stateClass&#125;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以有一个好的编码规范的约束，插件能更好的工作。</p>
<h2 id="（3）webpack-bundle-文件去重"><a href="#（3）webpack-bundle-文件去重" class="headerlink" title="（3）webpack bundle 文件去重"></a>（3）webpack bundle 文件去重</h2><p>如果 webpack 打包后的 bundle 文件中存在着相同的模块，也属于无用代码的一种。也应该被去除掉</p>
<p>首先我们需要一个能对 bundle 文件定性分析的工具，能发现问题，能看出优化效果。</p>
<p>webpack-bundle-analyzer 这个插件完全能满足我们的需求，他能以图形化的方式展示 bundle 中所有的模块的构成的各构成的大小。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417264814-7e9330da-796e-4ff8-8f4c-5b598ac4e667.jpeg#clientId=ue71f5aac-b372-4&from=drop&id=ua801459f&margin=%5Bobject%20Object%5D&name=13.jpg&originHeight=405&originWidth=720&originalType=binary&size=18473&status=done&style=none&taskId=u56e06f26-6d1b-4d5d-909e-00c99647abe" alt="13.jpg"></p>
<p>其次，需求对通用模块进行提取，CommonsChunkPlugin 是最被人熟知的用于提供通用模块的插件。早期的时候，我并不完全了解他的功能，并没有发挥最大的功效。</p>
<p>下面介绍 CommonsChunkPlugin 的正确用法</p>
<p><strong>自动提取所有的 node_moudles 或者引用次数两次以上的模块</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417270065-ff9e3f12-cb26-48d7-b81c-7ac3f51eb0da.jpeg#clientId=ue71f5aac-b372-4&from=drop&id=u4893c42d&margin=%5Bobject%20Object%5D&name=14.jpg&originHeight=192&originWidth=720&originalType=binary&size=9906&status=done&style=none&taskId=ud7ac520f-f577-4128-80b8-8d82d0b2ea3" alt="14.jpg"></p>
<p>minChunks 可以接受一个数值或者函数，如果是函数，可自定义打包规则</p>
<p>但使用上面记载的配置之后，并不能高枕无忧。因为这个配置只能提取所有 entry 打包后的文件中的通用模块。而现实是，有了提高性能，我们会按需加载，通过 webpack 提供的 import（…）方法，这种按需加载的文件并不会存在于 entry 之中，所以按需加载的异步模块中的通用模块并没有提取。</p>
<p><strong>如何提取按需加载的异步模块里的通用模块呢？</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417275241-489bbef7-42df-46b3-bac9-580cf920a8ab.jpeg#clientId=ue71f5aac-b372-4&from=drop&id=u6bea9d0b&margin=%5Bobject%20Object%5D&name=15.jpg&originHeight=331&originWidth=720&originalType=binary&size=21512&status=done&style=none&taskId=uf770f890-910a-41c2-b268-98db8a669d7" alt="15.jpg"></p>
<p>配置另一个 CommonsChunkPlugin，添加 async 属性，async 可以接受布尔值或字符串。当时字符串时，默认是输出文件的名称。</p>
<p>names 是所有异步模块的名称</p>
<p>这里还涉及一个给异步模块命名的知识点。我是这样做的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const Edit &#x3D; resolve &#x3D;&gt; &#123; import( &#x2F;* webpackChunkName: &quot;EditPage&quot; *&#x2F; &#39;.&#x2F;pages&#x2F;Edit&#x2F;Edit&#39;).then((mod) &#x3D;&gt; &#123; resolve(mod.default); &#125;) &#125;;</span><br><span class="line">const PublishPage &#x3D; resolve &#x3D;&gt; &#123; import( &#x2F;* webpackChunkName: &quot;Publish&quot; *&#x2F; &#39;.&#x2F;pages&#x2F;Publish&#x2F;Publish&#39;).then((mod) &#x3D;&gt; &#123; resolve(mod); &#125;) &#125;;</span><br><span class="line">const Models &#x3D; resolve &#x3D;&gt; &#123; import( &#x2F;* webpackChunkName: &quot;Models&quot; *&#x2F; &#39;.&#x2F;pages&#x2F;Models&#x2F;Models&#39;).then((mod) &#x3D;&gt; &#123; resolve(mod.default); &#125;) &#125;;</span><br><span class="line">const MediaUpload &#x3D; resolve &#x3D;&gt; &#123; import( &#x2F;* webpackChunkName: &quot;MediaUpload&quot; *&#x2F; &#39;.&#x2F;pages&#x2F;Media&#x2F;MediaUpload&#39;).then((mod) &#x3D;&gt; &#123; resolve(mod); &#125;) &#125;;</span><br><span class="line">const RealTime &#x3D; resolve &#x3D;&gt; &#123; import( &#x2F;* webpackChunkName: &quot;RealTime&quot; *&#x2F; &#39;.&#x2F;pages&#x2F;RealTime&#x2F;RealTime&#39;).then((mod) &#x3D;&gt; &#123; resolve(mod.default); &#125;) &#125;;</span><br></pre></td></tr></table></figure>

<p>没错，在 import 里添加注释。/_ webpackChunkName: “EditPage” _/ ，虽然看着不舒服，但是管用。</p>
<p>贴一个项目的优化效果对比图</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417280783-55fb56f0-e13e-4424-b662-b11bfe12a00e.jpeg#clientId=ue71f5aac-b372-4&from=drop&id=u9ecfab79&margin=%5Bobject%20Object%5D&name=16.jpg&originHeight=405&originWidth=720&originalType=binary&size=27747&status=done&style=none&taskId=u81f9d6e0-0583-4bca-90ed-a793591757b" alt="16.jpg"></p>
<p>优化效果还是比较明显。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417285132-f56688f8-be56-4545-bba3-2687b8398459.jpeg#clientId=ue71f5aac-b372-4&from=drop&id=u5e535843&margin=%5Bobject%20Object%5D&name=17.jpg&originHeight=405&originWidth=720&originalType=binary&size=25678&status=done&style=none&taskId=ud6da4518-ff37-4958-982e-7abf2ff05fc" alt="17.jpg"></p>
<p>优化前 bundle</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417289834-408cd2e7-ef19-496a-9125-5ac4ad04656a.jpeg#clientId=ue71f5aac-b372-4&from=drop&id=uad419791&margin=%5Bobject%20Object%5D&name=18.jpg&originHeight=405&originWidth=720&originalType=binary&size=24291&status=done&style=none&taskId=u3f99a4c5-7841-4d8d-b8dc-74be296417f" alt="18.jpg"></p>
<p>优化后 bundle</p>
<p><strong>最后思考一个问题：</strong></p>
<p><strong>不同 entry 模块或按需加载的异步模块需不需要提取通用模块？</strong></p>
<p>这个需要看场景了，比如模块都是在线加载的，如果通用模块提取粒度过小，会导致首页首屏需要的文件变多，很多可能是首屏用不到的，导致首屏过慢，二级或三级页面加载会大幅提升。所以这个就需要根据业务场景做权衡，控制通用模块提取的粒度。</p>
<p>百度外卖的移动端应用场景是这样的，我们所有的移动端页面都做了离线化的处理。离线之后，加载本地的 js 文件，与网络无关，基本上可以忽略文件大小，所以更关注整个离线包的大小。离线包越小，耗费用户的流量就越小，用户体验更好，所以离线化的场景是非常适合最小粒提取通用模块的，即将所有 entry 模块和异步加载模块的引用大于 2 的模块都提取，这样能获得最小的输出文件，最小的离线包。</p>
<p>1 月 20 日，我将在掘金分享《百度外卖前端离线化实践》，有兴趣的可以关注一下。</p>
<p>文本提到的插件都是开源的，链接汇总，欢迎交流，欢迎戳 ❤</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417305159-1c75e841-c2cd-42d8-a345-ec8541f4dbba.jpeg#clientId=ue71f5aac-b372-4&from=drop&id=u91704679&margin=%5Bobject%20Object%5D&name=19.jpg&originHeight=120&originWidth=120&originalType=binary&size=4686&status=done&style=none&taskId=u5836fcec-3272-40dc-9088-0ee4d96214a" alt="19.jpg"></p>
<p><a href="http://link.zhihu.com/?target=https://github.com/lin-xi/babel-plugin-import-fix">lin-xi/babel-plugin-import-fix</a></p>
<p><a href="http://link.zhihu.com/?target=https://github.com/lin-xi/webpack-css-treeshaking-plugin">lin-xi/webpack-css-treeshaking-plugin</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/26/yuque/Tree-Shaking%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5%20%E5%8E%9F%E7%90%86%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/26/yuque/Tree-Shaking%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5%20%E5%8E%9F%E7%90%86%E7%AF%87/" class="post-title-link" itemprop="url">Tree-Shaking性能优化实践 原理篇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-26 01:04:35" itemprop="dateCreated datePublished" datetime="2021-04-26T01:04:35+08:00">2021-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-02 20:01:26" itemprop="dateModified" datetime="2021-05-02T20:01:26+08:00">2021-05-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一-什么是-Tree-shaking"><a href="#一-什么是-Tree-shaking" class="headerlink" title="一. 什么是 Tree-shaking"></a>一. 什么是 Tree-shaking</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415487699-2976267a-70a5-4dc4-8642-c5c9722d10cd.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=uaa735294&margin=%5Bobject%20Object%5D&name=1.jpg&originHeight=405&originWidth=720&originalType=binary&size=6737&status=done&style=none&taskId=ub91413ec-e2c7-4325-a62e-122f16394cf" alt="1.jpg"></p>
<p>先来看一下 Tree-shaking 原始的本意</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/gif/21377586/1619415501641-bbf5f45d-3a0c-4811-9919-761bbc00e701.gif#clientId=u022f3b9a-a5ad-4&from=drop&id=ubfb99f78&margin=%5Bobject%20Object%5D&name=2.gif&originHeight=341&originWidth=606&originalType=binary&size=3761493&status=done&style=none&taskId=u70618439-fddd-42cc-bf2f-a38d6a58d38" alt="2.gif"></p>
<p>上图形象的解释了 Tree-shaking 的本意，本文所说的前端中的 tree-shaking 可以理解为通过工具”摇”我们的 JS 文件，将其中用不到的代码”摇”掉，是一个性能优化的范畴。具体来说，在 webpack 项目中，有一个入口文件，相当于一棵树的主干，入口文件有很多依赖的模块，相当于树枝。实际情况中，虽然依赖了某个模块，但其实只使用其中的某些功能。通过 tree-shaking，将没有使用的模块摇掉，这样来达到删除无用代码的目的。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415504181-f5f2cce4-ceef-4702-9da5-c6a11f90d8e3.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=uc32a1b51&margin=%5Bobject%20Object%5D&name=3.jpg&originHeight=405&originWidth=720&originalType=binary&size=12958&status=done&style=none&taskId=u2e02d442-f1cc-487d-b7f4-a35c40e2d7c" alt="3.jpg"></p>
<p>Tree-shaking 较早由 Rich_Harris 的 rollup 实现，后来，webpack2 也增加了 tree-shaking 的功能。其实在更早，google closure compiler 也做过类似的事情。三个工具的效果和使用各不相同，使用方法可以通过官网文档去了解，三者的效果对比，后文会详细介绍。</p>
<h2 id="二-tree-shaking-的原理"><a href="#二-tree-shaking-的原理" class="headerlink" title="二. tree-shaking 的原理"></a>二. tree-shaking 的原理</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415508232-a021a71e-e50c-448d-b9f3-f1a442fb8592.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=u47b707e4&margin=%5Bobject%20Object%5D&name=4.jpg&originHeight=405&originWidth=720&originalType=binary&size=6384&status=done&style=none&taskId=u1f413566-615e-45aa-bfe6-19178616240" alt="4.jpg"></p>
<p>Tree-shaking 的本质是消除无用的 js 代码。无用代码消除在广泛存在于传统的编程语言编译器中，编译器可以判断出某些代码根本不影响输出，然后消除这些代码，这个称之为 DCE（dead code elimination）。</p>
<p>Tree-shaking 是 DCE 的一种新的实现，Javascript 同传统的编程语言不同的是，javascript 绝大多数情况需要通过网络进行加载，然后执行，加载的文件大小越小，整体执行时间更短，所以去除无用代码以减少文件体积，对 javascript 来说更有意义。</p>
<p>Tree-shaking 和传统的 DCE 的方法又不太一样，传统的 DCE 消灭不可能执行的代码，而 Tree-shaking 更关注宇消除没有用到的代码。下面详细介绍一下 DCE 和 Tree-shaking。</p>
<p><strong>（1）先来看一下 DCE 消除大法</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415512124-bdf2b8d6-a44d-48c5-b4cd-7e832d3b6c66.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=u5c04aa5e&margin=%5Bobject%20Object%5D&name=5.jpg&originHeight=405&originWidth=720&originalType=binary&size=13053&status=done&style=none&taskId=u994cfb70-3fbb-4acd-a721-79e4fca1cec" alt="5.jpg"></p>
<p>Dead Code 一般具有以下几个特征</p>
<p>•代码不会被执行，不可到达</p>
<p>•代码执行的结果不会被用到</p>
<p>•代码只会影响死变量（只写不读）</p>
<p>下面红框标示的代码就属于死码，满足以上特征</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415515648-7a8ef020-4e11-4040-9745-5729523c8cdc.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=u0baad115&margin=%5Bobject%20Object%5D&name=6.jpg&originHeight=405&originWidth=720&originalType=binary&size=16079&status=done&style=none&taskId=udfcd44cf-a7e4-40bf-a2ec-bab6467e90d" alt="6.jpg"></p>
<p>图 4</p>
<p>传统编译型的语言中，都是由编译器将 Dead Code 从 AST（抽象语法树）中删除，那 javascript 中是由谁做 DCE 呢？</p>
<p>首先肯定不是浏览器做 DCE，因为当我们的代码送到浏览器，那还谈什么消除无法执行的代码来优化呢，所以肯定是送到浏览器之前的步骤进行优化。</p>
<p>其实也不是上面提到的三个工具，rollup，webpack，cc 做的，而是著名的代码压缩优化工具 uglify，uglify 完成了 javascript 的 DCE，下面通过一个实验来验证一下。</p>
<blockquote>
<p>以下所有的示例代码都能在我们的 github 中找到，欢迎戳 ❤</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/lin-xi/treeshaking/tree/master/rollup-webpack">https://github.com/lin-xi/treeshaking/tree/master/rollup-webpack</a></p>
<p><strong>分别用 rollup 和 webpack 将图 4 中的代码进行打包</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415520261-c9810972-e615-475e-b2da-6b2320929fb6.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=u204a249f&margin=%5Bobject%20Object%5D&name=7.jpg&originHeight=438&originWidth=720&originalType=binary&size=23130&status=done&style=none&taskId=u5c0f07c6-ff5e-4124-8ef9-1776c7af118" alt="7.jpg"></p>
<p>图 5</p>
<p>中间是 rollup 打包的结果，右边是 webpack 打包的结果</p>
<p>可以发现，rollup 将无用的代码 foo 函数和 unused 函数消除了，但是仍然保留了不会执行到的代码，而 webpack 完整的保留了所有的无用代码和不会执行到的代码。</p>
<p><strong>分别用 rollup + uglify 和 webpack + uglify 将图 4 中的代码进行打包</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415524659-a3f45414-4a9a-43b4-a539-4fb74268e2a8.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=ub23d203b&margin=%5Bobject%20Object%5D&name=8.jpg&originHeight=463&originWidth=720&originalType=binary&size=40456&status=done&style=none&taskId=uff6d2484-b35d-4c91-9ad8-f9888347565" alt="8.jpg"></p>
<p>图 6</p>
<p>中间是配置文件，右侧是结果</p>
<p>可以看到右侧最终打包结果中都去除了无法执行到的代码，结果符合我们的预期。</p>
<p><strong>(2) 再来看一下 Tree-shaking 消除大法</strong></p>
<p>前面提到了 tree-shaking 更关注于无用模块的消除，消除那些引用了但并没有被使用的模块。</p>
<p>先思考一个问题，为什么 tree-shaking 是最近几年流行起来了？而前端模块化概念已经有很多年历史了，其实 tree-shaking 的消除原理是依赖于 ES6 的模块特性。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415529275-6678a338-f495-4b4b-aec0-34f7fd52fc7d.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=u2646efa9&margin=%5Bobject%20Object%5D&name=9.jpg&originHeight=405&originWidth=720&originalType=binary&size=19655&status=done&style=none&taskId=u1d25af48-af5f-4cd8-b795-d3887492aac" alt="9.jpg"></p>
<p>ES6 module 特点：</p>
<ul>
<li>只能作为模块顶层的语句出现</li>
<li>import 的模块名只能是字符串常量</li>
<li>import binding 是 immutable 的</li>
</ul>
<p>ES6 模块依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析，这就是 tree-shaking 的基础。</p>
<p>所谓静态分析就是不执行代码，从字面量上对代码进行分析，ES6 之前的模块化，比如我们可以动态 require 一个模块，只有执行后才知道引用的什么模块，这个就不能通过静态分析去做优化。</p>
<p>这是 ES6 modules 在设计时的一个重要考量，也是为什么没有直接采用 CommonJS，正是基于这个基础上，才使得 tree-shaking 成为可能，这也是为什么 rollup 和 webpack 2 都要用 ES6 module syntax 才能 tree-shaking。</p>
<p>我们还是通过例子来详细了解一下</p>
<p>面向过程编程函数和面向对象编程是 javascript 最常用的编程模式和代码组织方式，从这两个方面来实验：</p>
<ul>
<li>函数消除实验</li>
<li>类消除实验</li>
</ul>
<p><strong>先看下函数消除实验</strong></p>
<p>utils 中 get 方法没有被使用到，我们期望的是 get 方法最终被消除。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415534000-a1a9637c-2995-4449-89d8-514b596f70db.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=u49a3465b&margin=%5Bobject%20Object%5D&name=10.jpg&originHeight=646&originWidth=720&originalType=binary&size=16134&status=done&style=none&taskId=u79851800-4d14-4761-8c88-28e86aba6c4" alt="10.jpg"></p>
<p>注意，uglify 目前不会跨文件去做 DCE，所以上面这种情况，uglify 是不能优化的。</p>
<p><strong>先看看 rollup 的打包结果</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415537651-2f568864-b6ec-4658-a01e-7a65eb402363.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=uca06a248&margin=%5Bobject%20Object%5D&name=11.jpg&originHeight=343&originWidth=720&originalType=binary&size=18232&status=done&style=none&taskId=ud208b28f-157f-4401-802e-2ba8c4ad76f" alt="11.jpg"></p>
<p>完全符合预期，最终结果中没有 get 方法</p>
<p><strong>再看看 webpack 的结果</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415541004-8eb43d30-08e8-4365-a7a4-6b75d1760a0f.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=u87646e1e&margin=%5Bobject%20Object%5D&name=12.jpg&originHeight=962&originWidth=720&originalType=binary&size=67249&status=done&style=none&taskId=u0d35bad0-09c2-4a6f-9274-92606112252" alt="12.jpg"></p>
<p>也符合预期，最终结果中没有 get 方法</p>
<p>可以看到 rollup 打包的结果比 webpack 更优化</p>
<blockquote>
<p>函数消除实验中，rollup 和 webpack 都通过，符合预期</p>
</blockquote>
<p><strong>再来看下类消除实验</strong></p>
<p>增加了对 menu.js 的引用，但其实代码中并没有用到 menu 的任何方法和变量，所以我们的期望是，最终代码中 menu.js 里的内容被消除</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415546773-c2ab6200-6b6a-4822-b98b-6beb2edb14fd.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=u1e2d25c7&margin=%5Bobject%20Object%5D&name=13.jpg&originHeight=446&originWidth=720&originalType=binary&size=14514&status=done&style=none&taskId=u00b6a7f8-c295-4a64-b196-ee3fba81903" alt="13.jpg"></p>
<p>main.js</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415551742-449c1ac0-dec7-4dcb-8099-180d2b28b5a5.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=u5de75d50&margin=%5Bobject%20Object%5D&name=14.jpg&originHeight=507&originWidth=720&originalType=binary&size=17925&status=done&style=none&taskId=u15268bf2-b626-45f8-b48a-f07a7451cda" alt="14.jpg"></p>
<p>menu.js</p>
<p><strong>rollup 打包结果</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415555773-5ac8b3e7-6822-4d17-9cf6-c399e4c11d8a.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=ucd7802ee&margin=%5Bobject%20Object%5D&name=15.jpg&originHeight=499&originWidth=720&originalType=binary&size=48979&status=done&style=none&taskId=u5d04d8e1-7bde-4e29-91d4-258ec3596f2" alt="15.jpg"></p>
<p>包中竟然包含了 menu.js 的全部代码</p>
<p><strong>webpack 打包结果</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415560732-7edb865f-1721-4fa8-b382-a7e560c849de.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=u70238c69&margin=%5Bobject%20Object%5D&name=16.jpg&originHeight=831&originWidth=720&originalType=binary&size=84376&status=done&style=none&taskId=u9c8d019c-d5f4-4cd1-9543-8c562d70068" alt="16.jpg"></p>
<p>包中竟然也包含了 menu.js 的全部代码</p>
<blockquote>
<p>类消除实验中，rollup，webpack 全军覆没，都没有达到预期</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415568229-847f4002-321b-4113-8a11-20dcb8b89efa.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=u6424d3bf&margin=%5Bobject%20Object%5D&name=17.jpg&originHeight=534&originWidth=521&originalType=binary&size=18147&status=done&style=none&taskId=u1b710400-a506-4982-afda-5d2a62011ff" alt="17.jpg"></p>
<p>what happend？</p>
<p>这跟我们想象的完全不一样啊？为什么呢？无用的类不能消除，这还能叫做 tree-shaking 吗？我当时一度怀疑自己的 demo 有问题，后来各种网上搜索，才明白 demo 没有错。</p>
<p>下面摘取了 rollup 核心贡献者的的一些回答：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415572931-7c587419-fc3a-4b62-993c-22e2f267c188.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=u4870e358&margin=%5Bobject%20Object%5D&name=18.jpg&originHeight=482&originWidth=720&originalType=binary&size=30357&status=done&style=none&taskId=u826a695b-c38e-433b-a27e-b714d1e71ba" alt="18.jpg"></p>
<p>图 7</p>
<ul>
<li>rollup 只处理函数和顶层的 import/export 变量，不能把没用到的类的方法消除掉</li>
<li>javascript 动态语言的特性使得静态分析比较困难</li>
<li>图 7 下部分的代码就是副作用的一个例子，如果静态分析的时候删除里 run 或者 jump，程序运行时就可能报错，那就本末倒置了，我们的目的是优化，肯定不能影响执行</li>
</ul>
<p>再举个例子说明下为什么不能消除 menu.js，比如下面这个场景</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Menu() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Menu.prototype.show &#x3D; function() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array.prototype.unique &#x3D; function() &#123;</span><br><span class="line">    &#x2F;&#x2F; 将 array 中的重复元素去除</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Menu;</span><br></pre></td></tr></table></figure>

<p>如果删除里 menu.js，那对 Array 的扩展也会被删除，就会影响功能。那也许你会问，难道 rollup，webpack 不能区分是定义 Menu 的 proptotype 还是定义 Array 的 proptotype 吗？当然如果代码写成上面这种形式是可以区分的，如果我写成这样呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Menu() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Menu.prototype.show &#x3D; function() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a &#x3D; &#39;Arr&#39; + &#39;ay&#39;</span><br><span class="line">var b</span><br><span class="line">if(a &#x3D;&#x3D; &#39;Array&#39;) &#123;</span><br><span class="line">    b &#x3D; Array</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    b &#x3D; Menu</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b.prototype.unique &#x3D; function() &#123;</span><br><span class="line">    &#x2F;&#x2F; 将 array 中的重复元素去除</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Menu;</span><br></pre></td></tr></table></figure>

<p>这种代码，静态分析是分析不了的，就算能静态分析代码，想要正确完全的分析也比较困难。</p>
<p>更多关于副作用的讨论，可以看这个</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415584766-5e4c8d34-b5e3-4055-9ceb-d3cdf65cdc0c.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=u8859213e&margin=%5Bobject%20Object%5D&name=19.jpg&originHeight=120&originWidth=120&originalType=binary&size=6543&status=done&style=none&taskId=uaf2b39e5-32bc-4452-8a7c-509e86bde83" alt="19.jpg"></p>
<p><a href="http://link.zhihu.com/?target=https://github.com/rollup/rollup/issues/349">Tree shaking class methods · Issue #349 · rollup/rollupgithub.com</a></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415594094-0ad21064-9164-4717-8e7b-a3fac32c32fc.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=u880b8ec5&margin=%5Bobject%20Object%5D&name=20.jpg&originHeight=405&originWidth=720&originalType=binary&size=15712&status=done&style=none&taskId=u70554999-8e4f-48bc-96da-ada236ab9b5" alt="20.jpg"></p>
<blockquote>
<p>tree-shaking 对函数效果较好</p>
</blockquote>
<p>函数的副作用相对较少，顶层函数相对来说更容易分析，加上 babel 默认都是”use strict”严格模式，减少顶层函数的动态访问的方式，也更容易分析</p>
<p>我们开始说的三个工具，rollup 和 webpack 表现不理想，那 closure compiler 又如何呢？</p>
<p>将示例中的代码用 cc 打包后得到的结果如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415606997-0930df34-d241-4fe3-896d-064756351b99.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=u919ddbe8&margin=%5Bobject%20Object%5D&name=21.jpg&originHeight=405&originWidth=720&originalType=binary&size=17714&status=done&style=none&taskId=u7bdca274-c8e7-4dae-beb6-412b706c473" alt="21.jpg"></p>
<p>天啊，这不就是我们要的结果吗？完美消除所有无用代码的结果，输出的结果非常性感</p>
<blockquote>
<p>closure compiler， tree-shaking 的结果完美！</p>
</blockquote>
<p>可是不能高兴得太早，能得到这么完美结果是需要条件的，那就是 cc 的侵入式约束规范。必须在代码里添加这样的代码，看红线框标示的</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415613494-0a044226-4eee-4ec9-9588-3135701029ba.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=ue1d60932&margin=%5Bobject%20Object%5D&name=22.jpg&originHeight=261&originWidth=720&originalType=binary&size=19369&status=done&style=none&taskId=u9847ceb1-7e7a-41a3-ab4e-b5bba4893dd" alt="22.jpg"></p>
<p>google 定义一整套注解规范 Annotating JavaScript for the Closure Compiler，想更多了解的，可以去看下官网。</p>
<p>侵入式这个就让人很不爽，google Closure Compiler 是 java 写的，和我们基于 node 的各种构建库不可能兼容（不过目前好像已经有 nodejs 版 Closure Compiler），Closure Compiler 使用起来也比较麻烦，所以虽然效果很赞，但比较难以应用到项目中，迁移成本较大。</p>
<p><strong>说了这么多，总结一下：</strong></p>
<p>三大工具的 tree-shaking 对于无用代码，无用模块的消除，都是有限的，有条件的。closure compiler 是最好的，但与我们日常的基于 node 的开发流很难兼容。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415618300-5633fb7e-a976-41d6-aa8a-2bf6594aaf2c.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=uc3f28788&margin=%5Bobject%20Object%5D&name=23.jpg&originHeight=405&originWidth=720&originalType=binary&size=6175&status=done&style=none&taskId=u2a5dacca-7a51-4245-a236-beef0048988" alt="23.jpg"></p>
<p>tree-shaking 对 web 意义重大，是一个极致优化的理想世界，是前端进化的又一个终极理想。</p>
<p>理想是美好的，但目前还处在发展阶段，还比较困难，有各个方面的，甚至有目前看来无法解</p>
<p>决的问题，但还是应该相信新技术能带来更好的前端世界。</p>
<p>优化是一种态度，不因小而不为，不因艰而不攻。</p>
<blockquote>
<p>知识有限，如果错误，请不惜指正，谢谢</p>
</blockquote>
<p>下一篇将继续介绍 <a target="_blank" rel="noopener" href="https://juejin.im/post/6844903544760336398">Tree-Shaking 性能优化实践 - 实践篇</a></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/21377586/1619415622789-70d6d885-0b51-4a90-beab-dac792588f41.webp#clientId=u022f3b9a-a5ad-4&from=drop&id=ud6bae893&margin=%5Bobject%20Object%5D&name=24.webp&originHeight=120&originWidth=180&originalType=binary&size=3120&status=done&style=none&taskId=u157a1607-0193-4ba3-a16c-ebf3c82baf4" alt="24.webp"></p>
<blockquote>
<p>本文中示例代码都能在我们的 github 中找到，欢迎戳 ❤</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415628594-b9024704-66a8-422f-bf1b-d2ce8af8060a.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=u9b1ca6b3&margin=%5Bobject%20Object%5D&name=25.jpg&originHeight=120&originWidth=120&originalType=binary&size=4686&status=done&style=none&taskId=u8270d645-c494-4431-a0d7-c42824bb91f" alt="25.jpg"></p>
<p><a href="http://link.zhihu.com/?target=https://github.com/lin-xi/treeshaking/tree/master/rollup-webpack">lin-xi/treeshakinggithub.com</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/26/yuque/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/26/yuque/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/" class="post-title-link" itemprop="url">前端模块化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-26 00:26:40" itemprop="dateCreated datePublished" datetime="2021-04-26T00:26:40+08:00">2021-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-02 20:01:27" itemprop="dateModified" datetime="2021-05-02T20:01:27+08:00">2021-05-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在 JavaScript 发展初期就是为了实现简单的页面交互逻辑，寥寥数语即可；如今 CPU、浏览器性能得到了极大的提升，很多页面逻辑迁移到了客户端（表单验证等），随着 web2.0 时代的到来，Ajax 技术得到广泛应用，jQuery 等前端库层出不穷，前端代码日益膨胀，此时在 JS 方面就会考虑使用模块化规范去管理。本文内容主要有理解模块化，为什么要模块化，模块化的优缺点以及模块化规范,并且介绍下开发中最流行的 CommonJS, AMD, ES6、CMD 规范。本文试图站在小白的角度，用通俗易懂的笔调介绍这些枯燥无味的概念，希望诸君阅读后，对模块化编程有个全新的认识和理解！</p>
<p><strong>建议下载本文源代码，自己动手敲一遍，请猛戳</strong><a target="_blank" rel="noopener" href="https://github.com/ljianshu/Blog">GitHub 个人博客</a><br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619368031111-ae8eeeb9-6592-4649-b5ad-301fb9aeec79.png#clientId=u650f5481-1581-4&from=paste&height=333&id=u02eadb23&margin=%5Bobject%20Object%5D&name=image.png&originHeight=333&originWidth=732&originalType=binary&size=101358&status=done&style=none&taskId=ua9ac1d85-8e29-4203-ad78-0e38ec391cd&width=732" alt="image.png"></p>
<h2 id="一、模块化的理解"><a href="#一、模块化的理解" class="headerlink" title="一、模块化的理解"></a>一、模块化的理解</h2><h3 id="1-什么是模块"><a href="#1-什么是模块" class="headerlink" title="1.什么是模块?"></a>1.什么是模块?</h3><ul>
<li>将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起</li>
<li>块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信</li>
</ul>
<h3 id="2-模块化的进化过程"><a href="#2-模块化的进化过程" class="headerlink" title="2.模块化的进化过程"></a>2.模块化的进化过程</h3><ul>
<li><strong>全局 function 模式 : 将不同的功能封装成不同的全局函数</strong><ul>
<li>编码: 将不同的功能封装成不同的全局函数</li>
<li>问题: 污染全局命名空间, 容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>namespace 模式 : 简单对象封装</strong><ul>
<li>作用: 减少了全局变量，解决命名冲突</li>
<li>问题: 数据不安全(外部可以直接修改模块内部的数据)</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myModule = &#123;</span><br><span class="line">  data: <span class="string">&quot;www.baidu.com&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`foo() <span class="subst">$&#123;<span class="built_in">this</span>.data&#125;</span>`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">bar</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`bar() <span class="subst">$&#123;<span class="built_in">this</span>.data&#125;</span>`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">myModule.data = <span class="string">&quot;other data&quot;</span>; <span class="comment">//能直接修改模块内部的数据</span></span><br><span class="line">myModule.foo(); <span class="comment">// foo() other data</span></span><br></pre></td></tr></table></figure>

<p>这样的写法会暴露所有模块成员，内部状态可以被外部改写。</p>
<ul>
<li><strong>IIFE 模式：匿名函数自调用(闭包)</strong><ul>
<li>作用: 数据是私有的, 外部只能通过暴露的方法操作</li>
<li>编码: 将数据和行为封装到一个函数内部, 通过给 window 添加属性来向外暴露接口</li>
<li>问题: 如果当前这个模块依赖另一个模块怎么办?</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.html文件</span></span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;module.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    myModule.foo()</span><br><span class="line">    myModule.bar()</span><br><span class="line">    <span class="built_in">console</span>.log(myModule.data) <span class="comment">//undefined 不能访问模块内部数据</span></span><br><span class="line">    myModule.data = <span class="string">&#x27;xxxx&#x27;</span> <span class="comment">//不是修改的模块内部的data</span></span><br><span class="line">    myModule.foo() <span class="comment">//没有改变</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">window</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = <span class="string">&quot;www.baidu.com&quot;</span>;</span><br><span class="line">  <span class="comment">//操作数据的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//用于暴露有函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`foo() <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//用于暴露有函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`bar() <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">    otherFun(); <span class="comment">//内部调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">otherFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//内部私有的函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;otherFun()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//暴露行为</span></span><br><span class="line">  <span class="built_in">window</span>.myModule = &#123; foo, bar &#125;; <span class="comment">//ES6写法</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>

<p>最后得到的结果：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619368117913-22682704-66d2-497e-9f2b-34f1efafc980.png#clientId=u0cc1c904-12a0-4&from=paste&height=105&id=uc27c29db&margin=%5Bobject%20Object%5D&name=image.png&originHeight=105&originWidth=419&originalType=binary&size=4563&status=done&style=none&taskId=u463fad66-1d12-44cc-84c0-8faaec2403e&width=419" alt="image.png"></p>
<ul>
<li><strong>IIFE 模式增强 : 引入依赖</strong></li>
</ul>
<p>这就是现代模块实现的基石</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">window</span>, $</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = <span class="string">&quot;www.baidu.com&quot;</span>;</span><br><span class="line">  <span class="comment">//操作数据的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//用于暴露有函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`foo() <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">    $(<span class="string">&quot;body&quot;</span>).css(<span class="string">&quot;background&quot;</span>, <span class="string">&quot;red&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//用于暴露有函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`bar() <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">    otherFun(); <span class="comment">//内部调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">otherFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//内部私有的函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;otherFun()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//暴露行为</span></span><br><span class="line">  <span class="built_in">window</span>.myModule = &#123; foo, bar &#125;;</span><br><span class="line">&#125;)(<span class="built_in">window</span>, jQuery);</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// index.html文件</span><br><span class="line"><span class="comment">&lt;!-- 引入的js必须有一定顺序 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;jquery-1.10.1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;module.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line">  myModule.foo();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上例子通过 jquery 方法将页面的背景颜色改成红色，所以必须先引入 jQuery 库，就把这个库当作参数传入。<strong>这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显</strong>。</p>
<h3 id="3-模块化的好处"><a href="#3-模块化的好处" class="headerlink" title="3. 模块化的好处"></a>3. 模块化的好处</h3><ul>
<li>避免命名冲突(减少命名空间污染)</li>
<li>更好的分离, 按需加载</li>
<li>更高复用性</li>
<li>高可维护性</li>
</ul>
<h3 id="4-引入多个后出现出现问题"><a href="#4-引入多个后出现出现问题" class="headerlink" title="4. 引入多个后出现出现问题"></a>4. 引入多个<script>后出现出现问题</h3><ul>
<li>请求过多</li>
</ul>
<p>首先我们要依赖多个模块，那样就会发送多个请求，导致请求过多</p>
<ul>
<li>依赖模糊</li>
</ul>
<p>我们不知道他们的具体依赖关系是什么，也就是说很容易因为不了解他们之间的依赖关系导致加载先后顺序出错。</p>
<ul>
<li>难以维护</li>
</ul>
<p>以上两种原因就导致了很难维护，很可能出现牵一发而动全身的情况导致项目出现严重的问题。模块化固然有多个好处，然而一个页面需要引入多个 js 文件，就会出现以上这些问题。而这些问题可以通过模块化规范来解决，下面介绍开发中最流行的 commonjs, AMD, ES6, CMD 规范。</p>
<h2 id="二、模块化规范"><a href="#二、模块化规范" class="headerlink" title="二、模块化规范"></a>二、模块化规范</h2><h3 id="1-CommonJS"><a href="#1-CommonJS" class="headerlink" title="1.CommonJS"></a>1.CommonJS</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="(1)概述"></a>(1)概述</h4><p>Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。<strong>在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。</strong></p>
<h4 id="2-特点"><a href="#2-特点" class="headerlink" title="(2)特点"></a>(2)特点</h4><ul>
<li>所有代码都运行在模块作用域，不会污染全局作用域。</li>
<li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li>
<li>模块加载的顺序，按照其在代码中出现的顺序。</li>
</ul>
<h4 id="3-基本语法"><a href="#3-基本语法" class="headerlink" title="(3)基本语法"></a>(3)基本语法</h4><ul>
<li>暴露模块：module.exports = value 或 exports.xxx = value</li>
<li>引入模块：require(xxx),如果是第三方模块，xxx 为模块名；如果是自定义模块，xxx 为模块文件路径</li>
</ul>
<p>此处我们有个疑问：<strong>CommonJS 暴露的模块到底是什么?<strong>CommonJS 规范规定，每个模块内部，module 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即 module.exports）是对外的接口。</strong>加载某个模块，其实是加载该模块的 module.exports 属性</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example.js</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> addX = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value + x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports.x = x;</span><br><span class="line"><span class="built_in">module</span>.exports.addX = addX;</span><br></pre></td></tr></table></figure>

<p>上面代码通过 module.exports 输出变量 x 和函数 addX。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = <span class="built_in">require</span>(<span class="string">&quot;./example.js&quot;</span>); <span class="comment">//如果参数字符串以“./”开头，则表示加载的是一个位于相对路径</span></span><br><span class="line"><span class="built_in">console</span>.log(example.x); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(example.addX(<span class="number">1</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>require 命令用于加载模块文件。<strong>require 命令的基本功能是，读入并执行一个 JavaScript 文件，然后返回该模块的 exports 对象。如果没有发现指定模块，会报错</strong>。</p>
<h4 id="4-模块的加载机制"><a href="#4-模块的加载机制" class="headerlink" title="(4)模块的加载机制"></a>(4)模块的加载机制</h4><p><strong>CommonJS 模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值</strong>。这点与 ES6 模块化有重大差异（下文会介绍），请看下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  counter: counter,</span><br><span class="line">  incCounter: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码输出内部变量 counter 和改写这个变量的内部方法 incCounter。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="built_in">require</span>(<span class="string">&quot;./lib&quot;</span>).counter;</span><br><span class="line"><span class="keyword">var</span> incCounter = <span class="built_in">require</span>(<span class="string">&quot;./lib&quot;</span>).incCounter;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>上面代码说明，counter 输出以后，lib.js 模块内部的变化就影响不到 counter 了。<strong>这是因为 counter 是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值</strong>。</p>
<h4 id="5-服务器端实现"><a href="#5-服务器端实现" class="headerlink" title="(5)服务器端实现"></a>(5)服务器端实现</h4><h4 id="①-下载安装-node-js"><a href="#①-下载安装-node-js" class="headerlink" title="① 下载安装 node.js"></a>① 下载安装 node.js</h4><h4 id="②-创建项目结构"><a href="#②-创建项目结构" class="headerlink" title="② 创建项目结构"></a>② 创建项目结构</h4><p><strong>注意：用 npm init 自动生成 package.json 时，package name(包名)不能有中文和大写</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|-modules</span><br><span class="line">  |-module1.js</span><br><span class="line">  |-module2.js</span><br><span class="line">  |-module3.js</span><br><span class="line">|-app.js</span><br><span class="line">|-package.json</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;commonJS-node&quot;,</span><br><span class="line">    &quot;version&quot;: &quot;1.0.0&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="③-下载第三方模块"><a href="#③-下载第三方模块" class="headerlink" title="③ 下载第三方模块"></a>③ 下载第三方模块</h4><p>npm install uniq –save // 用于数组去重</p>
<h4 id="④-定义模块代码"><a href="#④-定义模块代码" class="headerlink" title="④ 定义模块代码"></a>④ 定义模块代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module1.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  msg: <span class="string">&quot;module1&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.msg);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module2.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;module2&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module3.js</span></span><br><span class="line"><span class="built_in">exports</span>.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;foo() module3&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">exports</span>.arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js文件</span></span><br><span class="line"><span class="comment">// 引入第三方库，应该放置在最前面</span></span><br><span class="line"><span class="keyword">let</span> uniq = <span class="built_in">require</span>(<span class="string">&quot;uniq&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> module1 = <span class="built_in">require</span>(<span class="string">&quot;./modules/module1&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> module2 = <span class="built_in">require</span>(<span class="string">&quot;./modules/module2&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> module3 = <span class="built_in">require</span>(<span class="string">&quot;./modules/module3&quot;</span>);</span><br><span class="line"></span><br><span class="line">module1.foo(); <span class="comment">//module1</span></span><br><span class="line">module2(); <span class="comment">//module2</span></span><br><span class="line">module3.foo(); <span class="comment">//foo() module3</span></span><br><span class="line"><span class="built_in">console</span>.log(uniq(module3.arr)); <span class="comment">//[ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>

<h4 id="⑤-通过-node-运行-app-js"><a href="#⑤-通过-node-运行-app-js" class="headerlink" title="⑤ 通过 node 运行 app.js"></a>⑤ 通过 node 运行 app.js</h4><p>命令行输入 node app.js，运行 JS 文件</p>
<h4 id="6-浏览器端实现-借助-Browserify"><a href="#6-浏览器端实现-借助-Browserify" class="headerlink" title="(6)浏览器端实现(借助 Browserify)"></a>(6)浏览器端实现(借助 Browserify)</h4><h4 id="①-创建项目结构"><a href="#①-创建项目结构" class="headerlink" title="① 创建项目结构"></a>① 创建项目结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|-js</span><br><span class="line">  |-dist &#x2F;&#x2F;打包生成文件的目录</span><br><span class="line">  |-src &#x2F;&#x2F;源码所在的目录</span><br><span class="line">    |-module1.js</span><br><span class="line">    |-module2.js</span><br><span class="line">    |-module3.js</span><br><span class="line">    |-app.js &#x2F;&#x2F;应用主源文件</span><br><span class="line">|-index.html &#x2F;&#x2F;运行于浏览器上</span><br><span class="line">|-package.json</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;browserify-test&quot;,</span><br><span class="line">    &quot;version&quot;: &quot;1.0.0&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="②-下载-browserify"><a href="#②-下载-browserify" class="headerlink" title="② 下载 browserify"></a>② 下载 browserify</h4><ul>
<li>全局: npm install browserify -g</li>
<li>局部: npm install browserify –save-dev</li>
</ul>
<h4 id="③-定义模块代码-同服务器端"><a href="#③-定义模块代码-同服务器端" class="headerlink" title="③ 定义模块代码(同服务器端)"></a>③ 定义模块代码(同服务器端)</h4><p>注意：index.html 文件要运行在浏览器上，需要借助 browserify 将 app.js 文件打包编译，如果直接在 index.html 引入 app.js 就会报错！</p>
<h4 id="④-打包处理-js"><a href="#④-打包处理-js" class="headerlink" title="④ 打包处理 js"></a>④ 打包处理 js</h4><p>根目录下运行 browserify js/src/app.js -o js/dist/bundle.js</p>
<h4 id="⑤-页面使用引入"><a href="#⑤-页面使用引入" class="headerlink" title="⑤ 页面使用引入"></a>⑤ 页面使用引入</h4><p>在 index.html 文件中引入<script type="text/javascript" src="js/dist/bundle.js"></script></p>
<h3 id="2-AMD"><a href="#2-AMD" class="headerlink" title="2.AMD"></a>2.AMD</h3><p>CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD 规范则是非同步加载模块，允许指定回调函数。由于 Node.js 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 CommonJS 规范比较适用。但是，<strong>如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用 AMD 规范</strong>。此外 AMD 规范比 CommonJS 规范在浏览器端实现要来着早。</p>
<h4 id="1-AMD-规范基本语法"><a href="#1-AMD-规范基本语法" class="headerlink" title="(1)AMD 规范基本语法"></a>(1)AMD 规范基本语法</h4><p><strong>定义暴露模块</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义没有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> 模块;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义有依赖的模块</span></span><br><span class="line">define([<span class="string">&quot;module1&quot;</span>, <span class="string">&quot;module2&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">m1, m2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> 模块;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>引入使用模块</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">&quot;module1&quot;</span>, <span class="string">&quot;module2&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">m1, m2</span>) </span>&#123;</span><br><span class="line">  使用m1 / m2;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="2-未使用-AMD-规范与使用-require-js"><a href="#2-未使用-AMD-规范与使用-require-js" class="headerlink" title="(2)未使用 AMD 规范与使用 require.js"></a>(2)未使用 AMD 规范与使用 require.js</h4><p>通过比较两者的实现方法，来说明使用 AMD 规范的好处。</p>
<ul>
<li>未使用 AMD 规范</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dataService.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">window</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> msg = <span class="string">&quot;www.baidu.com&quot;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> msg.toUpperCase();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">window</span>.dataService = &#123; getMsg &#125;;</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alerter.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">window</span>, dataService</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">showMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(dataService.getMsg() + <span class="string">&quot;, &quot;</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">window</span>.alerter = &#123; showMsg &#125;;</span><br><span class="line">&#125;)(<span class="built_in">window</span>, dataService);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">alerter</span>) </span>&#123;</span><br><span class="line">  alerter.showMsg();</span><br><span class="line">&#125;)(alerter);</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// index.html文件</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Modular Demo 1: 未使用AMD(require.js)<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/modules/dataService.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/modules/alerter.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后得到如下结果：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619368360078-dea15769-8e59-4cf4-9798-8bd4173960da.png#clientId=u0cc1c904-12a0-4&from=paste&height=170&id=u8e06bb4f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=170&originWidth=508&originalType=binary&size=8509&status=done&style=none&taskId=u1e0ddbef-4733-45d3-ac12-2e8c1bc5b9f&width=508" alt="image.png"><br>这种方式缺点很明显：<strong>首先会发送多个请求，其次引入的 js 文件顺序不能搞错，否则会报错！</strong></p>
<ul>
<li>使用 require.js</li>
</ul>
<p>RequireJS 是一个工具库，主要用于客户端的模块管理。它的模块管理遵守 AMD 规范，<strong>RequireJS 的基本思想是，通过 define 方法，将代码定义为模块；通过 require 方法，实现代码的模块加载</strong>。接下来介绍 AMD 规范在浏览器实现的步骤：</p>
<h4 id="①-下载-require-js-并引入"><a href="#①-下载-require-js-并引入" class="headerlink" title="① 下载 require.js, 并引入"></a>① 下载 require.js, 并引入</h4><ul>
<li>官网:<a target="_blank" rel="noopener" href="http://www.requirejs.cn/">http://www.requirejs.cn/</a></li>
<li>github :<a target="_blank" rel="noopener" href="https://github.com/requirejs/requirejs">https://github.com/requirejs/requirejs</a></li>
</ul>
<p>然后将 require.js 导入项目: js/libs/require.js</p>
<h4 id="②-创建项目结构-1"><a href="#②-创建项目结构-1" class="headerlink" title="② 创建项目结构"></a>② 创建项目结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|-js</span><br><span class="line">  |-libs</span><br><span class="line">    |-require.js</span><br><span class="line">  |-modules</span><br><span class="line">    |-alerter.js</span><br><span class="line">    |-dataService.js</span><br><span class="line">  |-main.js</span><br><span class="line">|-index.html</span><br></pre></td></tr></table></figure>

<h4 id="③-定义-require-js-的模块代码"><a href="#③-定义-require-js-的模块代码" class="headerlink" title="③ 定义 require.js 的模块代码"></a>③ 定义 require.js 的模块代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dataService.js文件</span></span><br><span class="line"><span class="comment">// 定义没有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> msg = <span class="string">&quot;www.baidu.com&quot;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> msg.toUpperCase();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; getMsg &#125;; <span class="comment">// 暴露模块</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//alerter.js文件</span></span><br><span class="line"><span class="comment">// 定义有依赖的模块</span></span><br><span class="line">define([<span class="string">&quot;dataService&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">dataService</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">showMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(dataService.getMsg() + <span class="string">&quot;, &quot;</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 暴露模块</span></span><br><span class="line">  <span class="keyword">return</span> &#123; showMsg &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">require</span>.config(&#123;</span><br><span class="line">    baseUrl: <span class="string">&quot;js/&quot;</span>, <span class="comment">//基本路径 出发点在根目录下</span></span><br><span class="line">    paths: &#123;</span><br><span class="line">      <span class="comment">//映射: 模块标识名: 路径</span></span><br><span class="line">      alerter: <span class="string">&quot;./modules/alerter&quot;</span>, <span class="comment">//此处不能写成alerter.js,会报错</span></span><br><span class="line">      dataService: <span class="string">&quot;./modules/dataService&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">require</span>([<span class="string">&quot;alerter&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">alerter</span>) </span>&#123;</span><br><span class="line">    alerter.showMsg();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// index.html文件</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Modular Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入require.js并指定js主文件的入口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">data-main</span>=<span class="string">&quot;js/main&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/libs/require.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="④-页面引入-require-js-模块"><a href="#④-页面引入-require-js-模块" class="headerlink" title="④ 页面引入 require.js 模块:"></a>④ 页面引入 require.js 模块:</h4><p>在 index.html 引入<script data-main="js/main" src="js/libs/require.js"></script><br><strong>此外在项目中如何引入第三方库？</strong>只需在上面代码的基础稍作修改：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alerter.js文件</span></span><br><span class="line">define([<span class="string">&quot;dataService&quot;</span>, <span class="string">&quot;jquery&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">dataService, $</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">showMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(dataService.getMsg() + <span class="string">&quot;, &quot;</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line">  $(<span class="string">&quot;body&quot;</span>).css(<span class="string">&quot;background&quot;</span>, <span class="string">&quot;green&quot;</span>);</span><br><span class="line">  <span class="comment">// 暴露模块</span></span><br><span class="line">  <span class="keyword">return</span> &#123; showMsg &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">require</span>.config(&#123;</span><br><span class="line">    baseUrl: <span class="string">&quot;js/&quot;</span>, <span class="comment">//基本路径 出发点在根目录下</span></span><br><span class="line">    paths: &#123;</span><br><span class="line">      <span class="comment">//自定义模块</span></span><br><span class="line">      alerter: <span class="string">&quot;./modules/alerter&quot;</span>, <span class="comment">//此处不能写成alerter.js,会报错</span></span><br><span class="line">      dataService: <span class="string">&quot;./modules/dataService&quot;</span>,</span><br><span class="line">      <span class="comment">// 第三方库模块</span></span><br><span class="line">      jquery: <span class="string">&quot;./libs/jquery-1.10.1&quot;</span>, <span class="comment">//注意：写成jQuery会报错</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">require</span>([<span class="string">&quot;alerter&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">alerter</span>) </span>&#123;</span><br><span class="line">    alerter.showMsg();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>上例是在 alerter.js 文件中引入 jQuery 第三方库，main.js 文件也要有相应的路径配置。<strong>小结</strong>：通过两者的比较，可以得出<strong>AMD 模块定义的方法非常清晰，不会污染全局环境，能够清楚地显示依赖关系</strong>。AMD 模式可以用于浏览器环境，并且允许非同步加载模块，也可以根据需要动态加载模块。</p>
<h3 id="3-CMD"><a href="#3-CMD" class="headerlink" title="3.CMD"></a>3.CMD</h3><p>CMD 规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD 规范整合了 CommonJS 和 AMD 规范的特点。在 Sea.js 中，所有 JavaScript 模块都遵循 CMD 模块定义规范。</p>
<h4 id="1-CMD-规范基本语法"><a href="#1-CMD-规范基本语法" class="headerlink" title="(1)CMD 规范基本语法"></a>(1)CMD 规范基本语法</h4><p><strong>定义暴露模块：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义没有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">exports</span>.xxx = value;</span><br><span class="line">  <span class="built_in">module</span>.exports = value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//引入依赖模块(同步)</span></span><br><span class="line">  <span class="keyword">var</span> module2 = <span class="built_in">require</span>(<span class="string">&quot;./module2&quot;</span>);</span><br><span class="line">  <span class="comment">//引入依赖模块(异步)</span></span><br><span class="line">  <span class="built_in">require</span>.async(<span class="string">&quot;./module3&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m3</span>) </span>&#123;&#125;);</span><br><span class="line">  <span class="comment">//暴露模块</span></span><br><span class="line">  <span class="built_in">exports</span>.xxx = value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>引入使用模块：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> m1 = <span class="built_in">require</span>(<span class="string">&quot;./module1&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> m4 = <span class="built_in">require</span>(<span class="string">&quot;./module4&quot;</span>);</span><br><span class="line">  m1.show();</span><br><span class="line">  m4.show();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="2-sea-js-简单使用教程"><a href="#2-sea-js-简单使用教程" class="headerlink" title="(2)sea.js 简单使用教程"></a>(2)sea.js 简单使用教程</h4><h4 id="①-下载-sea-js-并引入"><a href="#①-下载-sea-js-并引入" class="headerlink" title="① 下载 sea.js, 并引入"></a>① 下载 sea.js, 并引入</h4><ul>
<li>官网:<a target="_blank" rel="noopener" href="http://seajs.org/">http://seajs.org/</a></li>
<li>github :<a target="_blank" rel="noopener" href="https://github.com/seajs/seajs">https://github.com/seajs/seajs</a></li>
</ul>
<p>然后将 sea.js 导入项目: js/libs/sea.js</p>
<h4 id="②-创建项目结构-2"><a href="#②-创建项目结构-2" class="headerlink" title="② 创建项目结构"></a>② 创建项目结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|-js</span><br><span class="line">  |-libs</span><br><span class="line">    |-sea.js</span><br><span class="line">  |-modules</span><br><span class="line">    |-module1.js</span><br><span class="line">    |-module2.js</span><br><span class="line">    |-module3.js</span><br><span class="line">    |-module4.js</span><br><span class="line">    |-main.js</span><br><span class="line">|-index.html</span><br></pre></td></tr></table></figure>

<h4 id="③-定义-sea-js-的模块代码"><a href="#③-定义-sea-js-的模块代码" class="headerlink" title="③ 定义 sea.js 的模块代码"></a>③ 定义 sea.js 的模块代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module1.js文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//内部变量数据</span></span><br><span class="line">  <span class="keyword">var</span> data = <span class="string">&quot;atguigu.com&quot;</span>;</span><br><span class="line">  <span class="comment">//内部函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;module1 show() &quot;</span> + data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//向外暴露</span></span><br><span class="line">  <span class="built_in">exports</span>.show = show;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module2.js文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    msg: <span class="string">&quot;I Will Back&quot;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module3.js文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> API_KEY = <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line">  <span class="built_in">exports</span>.API_KEY = API_KEY;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module4.js文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//引入依赖模块(同步)</span></span><br><span class="line">  <span class="keyword">var</span> module2 = <span class="built_in">require</span>(<span class="string">&quot;./module2&quot;</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;module4 show() &quot;</span> + module2.msg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exports</span>.show = show;</span><br><span class="line">  <span class="comment">//引入依赖模块(异步)</span></span><br><span class="line">  <span class="built_in">require</span>.async(<span class="string">&quot;./module3&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m3</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;异步引入依赖模块3  &quot;</span> + m3.API_KEY);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> m1 = <span class="built_in">require</span>(<span class="string">&quot;./module1&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> m4 = <span class="built_in">require</span>(<span class="string">&quot;./module4&quot;</span>);</span><br><span class="line">  m1.show();</span><br><span class="line">  m4.show();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="④-在-index-html-中引入"><a href="#④-在-index-html-中引入" class="headerlink" title="④ 在 index.html 中引入"></a>④ 在 index.html 中引入</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/libs/sea.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  seajs.use(<span class="string">&quot;./js/modules/main&quot;</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后得到结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619368668530-d6477aad-29fa-4012-b354-27d275f9c9f5.png#clientId=u0cc1c904-12a0-4&from=paste&height=84&id=ud03b9b5b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=84&originWidth=430&originalType=binary&size=4381&status=done&style=none&taskId=u4003f26a-2c46-4c19-a106-ff39fe4dbbb&width=430" alt="image.png"></p>
<h3 id="4-ES6-模块化"><a href="#4-ES6-模块化" class="headerlink" title="4.ES6 模块化"></a>4.ES6 模块化</h3><p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p>
<h4 id="1-ES6-模块化语法"><a href="#1-ES6-模块化语法" class="headerlink" title="(1)ES6 模块化语法"></a>(1)ES6 模块化语法</h4><p>export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 定义模块 math.js **/</span></span><br><span class="line"><span class="keyword">var</span> basicNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; basicNum, add &#125;;</span><br><span class="line"><span class="comment">/** 引用模块 **/</span></span><br><span class="line"><span class="keyword">import</span> &#123; basicNum, add &#125; <span class="keyword">from</span> <span class="string">&quot;./math&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">ele</span>) </span>&#123;</span><br><span class="line">  ele.textContent = add(<span class="number">99</span> + basicNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上例所示，使用 import 命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到 export default 命令，为模块指定默认输出。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import-default.js</span></span><br><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">&quot;./export-default&quot;</span>;</span><br><span class="line">customName(); <span class="comment">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure>

<p>模块默认输出, 其他模块加载该模块时，import 命令可以为该匿名函数指定任意名字。</p>
<h4 id="2-ES6-模块与-CommonJS-模块的差异"><a href="#2-ES6-模块与-CommonJS-模块的差异" class="headerlink" title="(2)ES6 模块与 CommonJS 模块的差异"></a>(2)ES6 模块与 CommonJS 模块的差异</h4><p>它们有两个重大差异：<br><strong>① CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用</strong>。<br><strong>② CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</strong>。<br>第二个差异是因为 CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。<br>下面重点解释第一个差异，我们还是举上面那个 CommonJS 模块的加载机制例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">&quot;./lib&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>ES6 模块的运行机制与 CommonJS 不一样。<strong>ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块</strong>。</p>
<h4 id="3-ES6-Babel-Browserify-使用教程"><a href="#3-ES6-Babel-Browserify-使用教程" class="headerlink" title="(3) ES6-Babel-Browserify 使用教程"></a>(3) ES6-Babel-Browserify 使用教程</h4><p>简单来说就一句话：<strong>使用 Babel 将 ES6 编译为 ES5 代码，使用 Browserify 编译打包 js</strong>。</p>
<h4 id="①-定义-package-json-文件"><a href="#①-定义-package-json-文件" class="headerlink" title="① 定义 package.json 文件"></a>① 定义 package.json 文件</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;es6-babel-browserify&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="②-安装-babel-cli-babel-preset-es2015-和-browserify"><a href="#②-安装-babel-cli-babel-preset-es2015-和-browserify" class="headerlink" title="② 安装 babel-cli, babel-preset-es2015 和 browserify"></a>② 安装 babel-cli, babel-preset-es2015 和 browserify</h4><ul>
<li>npm install babel-cli browserify -g</li>
<li>npm install babel-preset-es2015 –save-dev</li>
<li>preset 预设(将 es6 转换成 es5 的所有插件打包)</li>
</ul>
<h4 id="③-定义-babelrc-文件"><a href="#③-定义-babelrc-文件" class="headerlink" title="③ 定义.babelrc 文件"></a>③ 定义.babelrc 文件</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;presets&quot;</span>: [<span class="string">&quot;es2015&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="④-定义模块代码-1"><a href="#④-定义模块代码-1" class="headerlink" title="④ 定义模块代码"></a>④ 定义模块代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module1.js文件</span></span><br><span class="line"><span class="comment">// 分别暴露</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;foo() module1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;bar() module1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module2.js文件</span></span><br><span class="line"><span class="comment">// 统一暴露</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;fun1() module2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;fun2() module2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; fun1, fun2 &#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module3.js文件</span></span><br><span class="line"><span class="comment">// 默认暴露 可以暴露任意数据类项，暴露什么数据，接收到就是什么数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;默认暴露&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js文件</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">&quot;./module1&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; fun1, fun2 &#125; <span class="keyword">from</span> <span class="string">&quot;./module2&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> module3 <span class="keyword">from</span> <span class="string">&quot;./module3&quot;</span>;</span><br><span class="line">foo();</span><br><span class="line">bar();</span><br><span class="line">fun1();</span><br><span class="line">fun2();</span><br><span class="line">module3();</span><br></pre></td></tr></table></figure>

<h4 id="⑤-编译并在-index-html-中引入"><a href="#⑤-编译并在-index-html-中引入" class="headerlink" title="⑤ 编译并在 index.html 中引入"></a>⑤ 编译并在 index.html 中引入</h4><ul>
<li>使用 Babel 将 ES6 编译为 ES5 代码(但包含 CommonJS 语法) :babel js/src -d js/lib</li>
<li>使用 Browserify 编译 js :browserify js/lib/app.js -o js/lib/bundle.js</li>
</ul>
<p>然后在 index.html 文件中引入</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/lib/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后得到如下结果：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619369029376-9a9914a3-75c0-42cb-8c31-0f64a14a78a4.png#clientId=u0cc1c904-12a0-4&from=paste&height=102&id=ua6b37741&margin=%5Bobject%20Object%5D&name=image.png&originHeight=102&originWidth=437&originalType=binary&size=3646&status=done&style=none&taskId=u7cfa784c-d662-4080-8701-81af1964f53&width=437" alt="image.png"><br><strong>此外第三方库(以 jQuery 为例)如何引入呢</strong>？<br>首先安装依赖 npm install jquery@1<br>然后在 app.js 文件中引入</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//app.js文件 import &#123; foo, bar &#125; from &#x27;./module1&#x27; import &#123; fun1, fun2 &#125; from</span><br><span class="line">&#x27;./module2&#x27; import module3 from &#x27;./module3&#x27; import $ from &#x27;jquery&#x27; foo() bar()</span><br><span class="line">fun1() fun2() module3() $(&#x27;body&#x27;).css(&#x27;background&#x27;, &#x27;green&#x27;)</span><br></pre></td></tr></table></figure>

<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><ul>
<li>CommonJS 规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了 AMD CMD 解决方案。</li>
<li>AMD 规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD 规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。</li>
<li>CMD 规范与 AMD 规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在 Node.js 中运行。不过，依赖 SPM 打包，模块的加载逻辑偏重</li>
<li><strong>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案</strong>。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/25/yuque/%E6%B8%B2%E6%9F%93%E5%90%88%E6%88%90%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/25/yuque/%E6%B8%B2%E6%9F%93%E5%90%88%E6%88%90%E5%B1%82/" class="post-title-link" itemprop="url">渲染合成层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-25 23:11:28" itemprop="dateCreated datePublished" datetime="2021-04-25T23:11:28+08:00">2021-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-02 20:01:27" itemprop="dateModified" datetime="2021-05-02T20:01:27+08:00">2021-05-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="梳理浏览器渲染流程"><a href="#梳理浏览器渲染流程" class="headerlink" title="梳理浏览器渲染流程"></a>梳理浏览器渲染流程</h1><p>首先简单了解一下浏览器请求、加载、渲染一个页面的大致过程：</p>
<ul>
<li>DNS 查询</li>
<li>TCP 连接</li>
<li>HTTP 请求即响应</li>
<li>服务器响应</li>
<li>客户端渲染</li>
</ul>
<p>这里主要将客户端渲染展开梳理一下，从浏览器器内核拿到内容（渲染线程接收请求，加载网页并渲染网页），渲染大概可以划分成以下几个步骤：</p>
<ul>
<li>解析 html 建立 dom 树</li>
<li>解析 css 构建 render 树（将 CSS 代码解析成树形的数据结构，然后结合 DOM 合并成 render 树）</li>
<li>布局 render 树（Layout/reflow），负责各元素尺寸、位置的计算</li>
<li>绘制 render 树（paint），绘制页面像素信息</li>
<li>浏览器会将各层的信息发送给 GPU（GPU 进程：最多一个，用于 3D 绘制等），GPU 会将各层合成（composite），显示在屏幕上。</li>
</ul>
<p>参考一张图（webkit 渲染主要流程）：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619363642174-481e16d9-9a43-4096-b6e3-0d05efa9c009.png#clientId=u5af2961a-f81b-4&from=paste&height=289&id=u4f533940&margin=%5Bobject%20Object%5D&name=image.png&originHeight=289&originWidth=624&originalType=binary&size=39586&status=done&style=none&taskId=u9daf1abb-fe8b-4964-9127-e58530ea4e2&width=624" alt="image.png"><br>这里先解释一下几个概念，方便大家理解：<br>　　 DOM Tree：浏览器将 HTML 解析成树形的数据结构。<br>　　 CSS Rule Tree：浏览器将 CSS 解析成树形的数据结构。<br>　　 Render Tree: DOM 和 CSSOM 合并后生成 Render Tree。<br>　　 layout: 有了 Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的 CSS 定义以及他们的从属关系，从而去计算出每个节点在屏幕中的位置。<br>　　 painting: 按照算出来的规则，通过显卡，把内容画到屏幕上。<br>　　 reflow（回流）：当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，内行称这个回退的过程叫 reflow。reflow 会从 <html> 这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置。reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。<br>　　 repaint（重绘）：改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。<br>注意：</p>
<ol>
<li>display:none 的节点不会被加入 Render Tree，而 visibility: hidden 则会，所以，如果某个节点最开始是不显示的，设为 display:none 是更优的。</li>
<li>display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发现位置变化。</li>
<li>有些情况下，比如修改了元素的样式，浏览器并不会立刻 reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次 reflow，这又叫异步 reflow 或增量异步 reflow。但是在有些情况下，比如 resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。</li>
</ol>
<p>再参考一张图理解一下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619363668703-951a22f8-23c8-4b9b-9abf-c3c4e82ddb6a.png#clientId=u5af2961a-f81b-4&from=paste&height=111&id=u4e02cff7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=111&originWidth=700&originalType=binary&size=56388&status=done&style=none&taskId=u5b23f9b4-f095-42f4-8ee4-9785c055796&width=700" alt="image.png"><br>细致分离两个环节，其他环节参考上述概念注解：<br>JavaScript：JavaScript 实现动画效果，DOM 元素操作等。Composite（渲染层合并）：对页面中 DOM 元素的绘制是在多个层上进行的。在每个层上完成绘制过程之后，浏览器会将所有层按照合理的顺序合并成一个图层，然后显示在屏幕上。对于有位置重叠的元素的页面，这个过程尤其重要，因为一旦图层的合并顺序出错，将会导致元素显示异常。<br>在实际场景下，大致会出现三种常见的渲染流程（Layout 和 Paint 步骤是可避免的，可参考上一张图的注意部分理解）：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619363684549-4c380d60-da59-499e-802f-040741adf294.png#clientId=u5af2961a-f81b-4&from=paste&height=381&id=u6450f303&margin=%5Bobject%20Object%5D&name=image.png&originHeight=381&originWidth=580&originalType=binary&size=140788&status=done&style=none&taskId=u978aeeac-ffc9-4a25-a9fb-86a97c01760&width=580" alt="image.png"></p>
<hr>
<h1 id="Composite"><a href="#Composite" class="headerlink" title="Composite"></a>Composite</h1><h2 id="了解层"><a href="#了解层" class="headerlink" title="了解层"></a>了解层</h2><p><strong>注意：首先说明，这里讨论的是 WebKit，描述的是 Chrome 的实现细节，而并非是 web 平台的功能，因此这里介绍的内容不一定适用于其他浏览器。</strong></p>
<ul>
<li>Chrome 拥有两套不同的渲染路径(rendering path)：硬件加速路径和旧软件路径(older software path)</li>
<li>Chrome 中有不同类型的层： RenderLayer(负责 DOM 子树)和 GraphicsLayer(负责 RenderLayer 的子树)，只有 GraphicsLayer 是作为纹理(texture)上传给 GPU 的。</li>
<li>什么是纹理？可以把它想象成一个从主存储器(例如 RAM)移动到图像存储器(例如 GPU 中的 VRAM)的位图图像(bitmapimage)</li>
<li>Chrome 使用纹理来从 GPU 上获得大块的页面内容。通过将纹理应用到一个非常简单的矩形网格就能很容易匹配不同的位置(position)和变形(transformation)。这也就是 3DCSS 的工作原理，它对于快速滚动也十分有效。</li>
</ul>
<p>整个图：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619363614081-e37ca74c-d966-423f-8242-1a40e169b31b.png#clientId=u5af2961a-f81b-4&from=paste&height=268&id=u13b8f6dd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=268&originWidth=650&originalType=binary&size=57852&status=done&style=none&taskId=u99e5ce91-02ad-4872-8d3e-5dec17afbb9&width=650" alt="image.png"><br>在 Chrome 中其实有几种不同的层类型：</p>
<ul>
<li>RenderLayers 渲染层，这是负责对应 DOM 子树</li>
<li>GraphicsLayers 图形层，这是负责对应 RenderLayers 子树。</li>
</ul>
<p>在浏览器渲染流程中提到了 composite 概念，在 DOM 树中每个节点都会对应一个 LayoutObject，当他们的 LayoutObject 处于相同的坐标空间时，就会形成一个 RenderLayers ，也就是渲染层。RenderLayers 来保证页面元素以正确的顺序合成，这时候就会出现层合成（composite），从而正确处理透明元素和重叠元素的显示。<br>某些特殊的渲染层会被认为是合成层（Compositing Layers），合成层拥有单独的 GraphicsLayer，而其他不是合成层的渲染层，则和其第一个拥有 GraphicsLayer 父层公用一个。<br>而每个 GraphicsLayer（合成层单独拥有的图层） 都有一个 GraphicsContext，GraphicsContext 会负责输出该层的位图，位图是存储在共享内存中，作为纹理上传到 GPU 中，最后由 GPU 将多个位图进行合成，然后显示到屏幕上。</p>
<h1 id="如何变成合成层"><a href="#如何变成合成层" class="headerlink" title="如何变成合成层"></a>如何变成合成层</h1><h2 id="合成层创建标准"><a href="#合成层创建标准" class="headerlink" title="合成层创建标准"></a>合成层创建标准</h2><p>什么情况下能使元素获得自己的层？虽然 Chrome 的启发式方法(heuristic)随着时间在不断发展进步，但是从目前来说，满足以下任意情况便会创建层：</p>
<ul>
<li>3D 或透视变换(perspective transform) CSS 属性</li>
<li>使用加速视频解码的 <video> 元素 拥有 3D</li>
<li>(WebGL) 上下文或加速的 2D 上下文的 <canvas> 元素</li>
<li>混合插件(如 Flash)</li>
<li>对自己的 opacity 做 CSS 动画或使用一个动画变换的元素</li>
<li>拥有加速 CSS 过滤器的元素</li>
<li>元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)</li>
<li>元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)</li>
</ul>
<h2 id="合成层的优点"><a href="#合成层的优点" class="headerlink" title="合成层的优点"></a>合成层的优点</h2><p><a target="_blank" rel="noopener" href="http://taobaofed.org/blog/2016/04/25/performance-composite/">淘宝的栗子</a>举的很详细，值得一看，里面提到了一旦 renderLayer 提升为了合成层就会有自己的绘图上下文，并且会开启硬件加速，有利于性能提升,里面列举了一些特点</p>
<ul>
<li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快</li>
<li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</li>
<li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li>
</ul>
<p><strong>注意：</strong></p>
<ol>
<li>提升到合成层后合成层的位图会交 GPU 处理，但请注意，仅仅只是合成的处理（把绘图上下文的位图输出进行组合）需要用到 GPU，生成合成层的位图处理（绘图上下文的工作）是需要 CPU。</li>
<li>当需要 repaint 的时候可以只 repaint 本身，不影响其他层，但是 paint 之前还有 style， layout,那就意味着即使合成层只是 repaint 了自己，但 style 和 layout 本身就很占用时间。</li>
<li>仅仅是 transform 和 opacity 不会引发 layout 和 paint，那么其他的属性不确定。</li>
</ol>
<p>总结合成层的优势：一般一个元素开启硬件加速后会变成合成层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能。<br><strong>性能优化点：</strong></p>
<ol>
<li>提升动画效果的元素 合成层的好处是不会影响到其他元素的绘制，因此，为了减少动画元素对其他元素的影响，从而减少 paint，我们需要把动画效果中的元素提升为合成层。提升合成层的最好方式是使用 CSS 的 will-change 属性。从上一节合成层产生原因中，可以知道 will-change 设置为 opacity、transform、top、left、bottom、right 可以将元素提升为合成层。</li>
<li>使用 transform 或者 opacity 来实现动画效果, 这样只需要做合成层的合并就好了。</li>
<li>减少绘制区域 对于不需要重新绘制的区域应尽量避免绘制，以减少绘制区域，比如一个 fix 在页面顶部的固定不变的导航 header，在页面内容某个区域 repaint 时，整个屏幕包括 fix 的 header 也会被重绘。而对于固定不变的区域，我们期望其并不会被重绘，因此可以通过之前的方法，将其提升为独立的合成层。减少绘制区域，需要仔细分析页面，区分绘制区域，减少重绘区域甚至避免重绘。</li>
</ol>
<h2 id="利用合成层可能踩到的坑"><a href="#利用合成层可能踩到的坑" class="headerlink" title="利用合成层可能踩到的坑"></a>利用合成层可能踩到的坑</h2><ol>
<li>合成层占用内存的问题</li>
<li>层爆炸，由于某些原因可能导致产生大量不在预期内的合成层，虽然有浏览器的层压缩机制，但是也有很多无法进行压缩的情况，这就可能出现层爆炸的现象（简单理解就是，很多不需要提升为合成层的元素因为某些不当操作成为了合成层）。解决层爆炸的问题，最佳方案是打破 overlap 的条件，也就是说让其他元素不要和合成层元素重叠。简单直接的方式：使用 3D 硬件加速提升动画性能时，最好给元素增加一个 z-index 属性，人为干扰合成的排序，可以有效减少 chrome 创建不必要的合成层，提升渲染性能，移动端优化效果尤为明显。在这篇<a target="_blank" rel="noopener" href="http://div.io/topic/1348">文章</a>中的<a target="_blank" rel="noopener" href="http://fouber.github.io/test/layer/">demo</a>可以看出其中厉害。</li>
</ol>
<p>用 chremo 打开 demo 页面后，开启浏览器的开发者模式，再按照<strong>如图操作</strong>打开查看工具：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619363731138-9a26cf8b-8104-43dc-a945-f5e0e011277f.png#clientId=u5af2961a-f81b-4&from=paste&height=732&id=u92de5f1d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=732&originWidth=569&originalType=binary&size=174228&status=done&style=none&taskId=ufa589ae5-a274-4ce8-a4b3-00deb5dffaa&width=569" alt="image.png"><br>开启 Rendering 的 Layer borders 后 观察点击为动画元素设置 z-index 复选框的页面提示变化：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619363714774-f2da0ca4-e51e-4fbc-91f7-307d4388cf87.png#clientId=u5af2961a-f81b-4&from=paste&height=732&id=u9e699078&margin=%5Bobject%20Object%5D&name=image.png&originHeight=732&originWidth=641&originalType=binary&size=154880&status=done&style=none&taskId=ubf52f35a-428c-4da3-be16-f3031b35920&width=641" alt="image.png"><br>上图中可以明显看出：页面中设置了一个 h1 标题，应用了 translate3d 动画，使得它被放到 composited layer 中渲染，然后在这个元素后面创建了 2000 个 list。在不为 h1 元素设置 z-index 的情况下，使得本不需要提升到合成层的 ul 元素下的每个 li 元素都提升为一个单独合成层（每个 li 元素的黄色提示边框），最终会导致 GPU 资源过度消耗页面滑动时很卡，尤其在移动端（安卓）上更加明显。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619363748135-c0ff102e-1850-410e-81dd-77d7afe77610.png#clientId=u5af2961a-f81b-4&from=paste&height=732&id=u13441047&margin=%5Bobject%20Object%5D&name=image.png&originHeight=732&originWidth=653&originalType=binary&size=187431&status=done&style=none&taskId=uced4698a-1d9a-4209-8b1c-a91dad1df24&width=653" alt="image.png"><br>如上图操作选中为动画元素设置 z-index，可以看出 ul 下的每个 li 都回归到普通渲染层，不再是合成层也就不会消耗 GPU 资源去渲染，从而达到了优化页面性能优化的目的。<br>大家可以用支持『硬件加速』的『安卓』手机浏览器测试上述页面，给动画元素加 z-index 前后的性能差距非常明显。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>在实际的前端开发中尤其是移动端开发，很多小伙伴都很喜欢使用类似 translateZ(0)等属性来进行所谓的硬件加速，以提升性能，达到优化页面动态效果的目的，但还是要注意凡事过犹不及，应用硬件加速的同时也要注意到千万别踩坑。关于合成层的更细致具体的讲解，可以仔细学习下下面的参考文章（尤其是前三篇哦）。最后祝愿热爱技术的你我始终坚持在探索技术的路上奋力前行！<br><strong>参考文章：</strong><a target="_blank" rel="noopener" href="http://taobaofed.org/blog/2016/04/25/performance-composite/">无线性能优化：Composite</a><a target="_blank" rel="noopener" href="https://www.html5rocks.com/zh/tutorials/speed/layers/">DOM to Screen</a><a target="_blank" rel="noopener" href="https://www.smashingmagazine.com/2016/12/gpu-animation-doing-it-right/">CSS GPU Animation: Doing It Right</a><a target="_blank" rel="noopener" href="https://github.com/hello2dj/blog/blob/master/%08web%E4%BC%98%E5%8C%96%E4%B9%8Bcomposite.md">web 优化之 composite</a><a target="_blank" rel="noopener" href="https://juejin.im/entry/59dc9aedf265da43200232f9">详谈层合成（composite）</a><a target="_blank" rel="noopener" href="http://div.io/topic/1348">CSS3 硬件加速也有坑</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/t/chrome">chrome</a><a target="_blank" rel="noopener" href="https://segmentfault.com/t/html5">html5</a><a target="_blank" rel="noopener" href="https://segmentfault.com/t/html">html</a><a target="_blank" rel="noopener" href="https://segmentfault.com/t/css">css</a><a target="_blank" rel="noopener" href="https://segmentfault.com/t/javascript">javascript</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/25/yuque/UDP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/25/yuque/UDP/" class="post-title-link" itemprop="url">UDP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-25 22:40:45" itemprop="dateCreated datePublished" datetime="2021-04-25T22:40:45+08:00">2021-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-02 20:01:27" itemprop="dateModified" datetime="2021-05-02T20:01:27+08:00">2021-05-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>UDP 数据报<strong>一、UDP 的概述</strong>（<strong>User Datagram Protocol，用户数据报协议</strong>）UDP 是<strong>传输层</strong>的协议，功能即为在 IP 的数据报服务之上增加了最基本的服务：<strong>复用</strong>和<strong>分用</strong>以及<strong>差错检测</strong>。UDP 提供<strong>不可靠</strong>服务，具有 TCP 所没有的<strong>优势</strong>：</p>
<ul>
<li>UDP<strong>无连接</strong>，时间上<strong>不存在建立连接需要的时延</strong>。空间上，TCP 需要在端系统中<strong>维护连接</strong>状态，需要一定的开销。此连接装入包括接收和发送缓存，拥塞控制参数和序号与确认号的参数。UCP 不维护连接状态，也不跟踪这些参数，开销小。空间和时间上都具有优势。举个例子：DNS 如果运行在 TCP 之上而不是 UDP，那么 DNS 的速度将会慢很多。HTTP 使用 TCP 而不是 UDP，是因为对于基于文本数据的 Web 网页来说，<strong>可靠性</strong>很重要。同一种专用应用服务器在支持 UDP 时，一定能支持更多的活动客户机。</li>
<li>分组首部开销小**，TCP 首部 20 字节，UDP 首部 8 字节。</li>
<li><strong>UDP 没有拥塞控制</strong>，应用层能够更好的控制要发送的数据和发送时间，网络中的拥塞控制也不会影响主机的发送速率。某些实时应用要求以稳定的速度发送，<strong>能容 忍一些数据的丢失，但是不能允许有较大的时延</strong>（比如实时视频，直播等）</li>
<li>UDP<strong>提供尽最大努力的交付</strong>，不保证可靠交付。所有维护传输可靠性的工作需要用户在<strong>应用层</strong>来完成。没有 TCP 的确认机制、重传机制。如果因为网络原因没有传送到对端，UDP 也不会给应用层返回错误信息</li>
<li>UDP 是<strong>面向报文</strong>的，对应用层交下来的报文，添加首部后直接向下交付为 IP 层，既不合并，也不拆分，保留这些报文的边界。对 IP 层交上来 UDP 用户数据报，在去除首部后就原封不动地交付给上层应用进程，报文不可分割，是 UDP 数据报处理的最小单位。正是因为这样，UDP 显得不够灵活，不能控制读写数据的次数和数量。比如我们要发送 100 个字节的报文，我们调用一次 sendto 函数就会发送 100 字节，对端也需要用 recvfrom 函数一次性接收 100 字节，不能使用循环每次获取 10 个字节，获取十次这样的做法。</li>
<li>UDP<strong>常用一次性传输比较少量数据的网络应用</strong>，如 DNS,SNMP 等，因为对于这些应用，若是采用 TCP，为连接的创建，维护和拆除带来不小的开销。UDP 也常用于多媒体应用（如 IP 电话，实时视频会议，流媒体等）数据的可靠传输对他们而言并不重要，TCP 的拥塞控制会使他们有较大的延迟，也是不可容忍的</li>
</ul>
<p><strong>二、UDP 的首部格式</strong>UDP 数据报分为<strong>首部</strong>和<strong>用户数据部分</strong>，整个 UDP 数据报作为 IP 数据报的数据部分封装在 IP 数据报中，UDP 数据报文结构如图所示：<br><img src="https://cdn.nlark.com/yuque/0/2021/jpg/21377586/1619361667214-2e9fb5f8-10e5-4e4d-bcf9-a232a777c3db.jpg#clientId=uf766e91f-7da9-4&from=paste&height=434&id=uc13cee0b&margin=%5Bobject%20Object%5D&originHeight=434&originWidth=1121&originalType=url&status=done&style=none&taskId=ucab3cb07-e1f4-49d7-a7a2-56d5143d585&width=1121"><br>UDP 首部有 8 个字节，由 4 个字段构成，每个字段都是两个字节，1.<strong>源端口</strong>： 源端口号，需要对方回信时选用，不需要时全部置 0.2.<strong>目的端口</strong>：目的端口号，在终点交付报文的时候需要用到。3.<strong>长度</strong>：UDP 的数据报的长度（包括首部和数据）其最小值为 8（只有首部）4.<strong>校验和</strong>：检测 UDP 数据报在传输中是否有错，有错则丢弃。该字段是可选的，当源主机不想计算校验和，则直接令该字段全为 0.当传输层从 IP 层收到 UDP 数据报时，就根据首部中的目的端口，把 UDP 数据报通过相应的端口，上交给应用进程。如果接收方 UDP 发现收到的报文中的目的端口号不正确（不存在对应端口号的应用进程 0,），就丢弃该报文，并由 ICMP 发送“端口不可达”差错报文给对方。UDP 校验在计算校验和的时候，需要在 UDP 数据报之前增加<strong>12 字节的伪首部</strong>，伪首部并不是 UDP 真正的首部。只是在计算校验和，临时添加在 UDP 数据报的前面，得到一个临时的 UDP 数据报。校验和就是按照这个临时的 UDP 数据报计算的。伪首部既不向下传送也不向上递交，而<strong>仅仅是为了计算校验和</strong>。这样的校验和，既<strong>检查了 UDP 数据报，又对 IP 数据报的源 IP 地址和目的 IP 地址进行了检验。</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619361667396-09c2b15d-e2c0-4254-b729-d4987d18a9b3.jpeg#clientId=uf766e91f-7da9-4&from=paste&height=521&id=u0b96cd49&margin=%5Bobject%20Object%5D&originHeight=521&originWidth=720&originalType=url&status=done&style=none&taskId=u6a91d411-a507-43da-a0b9-046e4cfe127&width=720"><br>UDP 校验和的计算方法和 IP 数据报首部校验和的计算方法相似，都使用二进制反码运算求和再取反，但不同的是：IP 数据报的校验和之检验 IP 数据报和首部，但 UDP 的校验和是把首部和数据部分一起校验。发送方，首先是把<strong>全零放入校验和字段</strong>并且添加<strong>伪首部</strong>，然后把 UDP 数据报看成是由许多 16 位的子串连接起来，若 UDP 数据报的数据部分不是偶数个字节，则要在数据部分末尾增加一个全零字节（此字节不发送），接下来就按照二进制反码计算出这些 16 位字的和。将此和的二进制反码写入校验和字段。在接收方，把收到得 UDP 数据报加上伪首部（如果不为偶数个字节，还需要补上全零字节）后，按二进制反码计算出这些 16 位字的和。<strong>当无差错时其结果全为 1</strong>,。否则就表明有差错出现，接收方应该丢弃这个 UDP 数据报。<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619361667438-0f18033d-fc51-4edd-a53a-b8a608f63d22.jpeg#clientId=uf766e91f-7da9-4&from=paste&height=454&id=u21c6ee63&margin=%5Bobject%20Object%5D&originHeight=454&originWidth=720&originalType=url&status=done&style=none&taskId=ucb722cc4-afb5-4088-81f6-28fdb315bda&width=720"><br>注意：1.校验时，若 UDP 数据报部分的长度不是偶数个字节，则需要填入一个全 0 字节，但是次字节和伪首部一样，是不发送的。2.如果 UDP 校验和校验出 UDP 数据报是错误的，可以丢弃，也可以交付上层，但是要附上错误报告，告诉上层这是错误的数据报。3.通过伪首部，不仅可以检查源端口号，目的端口号和 UDP 用户数据报的数据部分，还可以检查 IP 数据报的源 IP 地址和目的地址。这种差错检验的检错能力不强，但是简单，速度快</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Adam Blog</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">65</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Adam Blog</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
