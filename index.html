<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Adam">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Adam">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Adam Blog">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Adam</title>
  <meta name="referrer" content="no-referrer" />
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Adam</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/25/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/25/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-25 16:48:54" itemprop="dateCreated datePublished" datetime="2021-04-25T16:48:54+08:00">2021-04-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/25/yuque/HTTP2.0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/25/yuque/HTTP2.0/" class="post-title-link" itemprop="url">HTTP2.0</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-25 16:48:35 / 修改时间：16:49:30" itemprop="dateCreated datePublished" datetime="2021-04-25T16:48:35+08:00">2021-04-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619340543736-a33f0c98-6dbb-4088-95a8-8d42c25df28e.jpeg#clientId=u148c49a8-157a-4&from=drop&id=u449ec38d&margin=%5Bobject%20Object%5D&name=1.jpg&originHeight=145&originWidth=798&originalType=binary&size=16049&status=done&style=none&taskId=uf8ec65be-f7fd-44db-af5d-1208b45fafb" alt="1.jpg"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/gif/21377586/1619340548956-54a67302-7ca7-4ed6-b03e-22497facf880.gif#clientId=u148c49a8-157a-4&from=drop&id=u1cfa2027&margin=%5Bobject%20Object%5D&name=2.gif&originHeight=281&originWidth=1200&originalType=binary&size=2075450&status=done&style=none&taskId=u963af8b6-9efa-4aab-9114-635366bd545" alt="2.gif"></p>
<p>本文字数：<strong>3825 字</strong></p>
<p>预计阅读时间：<strong>20 分钟</strong></p>
<p><strong>导读</strong></p>
<p>http2.0 是一种安全高效的下一代 http 传输协议。安全是因为 http2.0 建立在 https 协议的基础上，高效是因为它是通过二进制分帧来进行数据传输。正因为这些特性，http2.0 协议也在被越来越多的网站支持。据统计，截止至 2018 年 8 月，已经有 27.9%的网站支持 http2.0。</p>
<p>本文将从<strong>概述、原理、实战及检测</strong>等方面来详细介绍 http2.0，希望能够加深你的理解。</p>
<p><strong>什么是 http2.0 协议？</strong></p>
<p>在 http2.0 官网 ① 的描述是：</p>
<p>http/2 is a replacement for how http is expressed “on the wire.” It is not a ground-up rewrite of the protocol; http methods, status codes and semantics are the same, and it should be possible to use the same APIs as http/1.x (possibly with some small additions) to represent the protocol.</p>
<p>The focus of the protocol is on performance; specifically, end-user perceived latency, network and server resource usage. One major goal is to allow the use of a single connection from browsers to a Web site.</p>
<p>The basis of the work was SPDY, but http/2 has evolved to take the community’s input into account, incorporating several improvements in the process.</p>
<p>中文总结一下就是：</p>
<p><strong>● 对 1.x 协议语意的完全兼容</strong></p>
<p>2.0 协议是在 1.x 基础上的升级而不是重写，1.x 协议的方法，状态及 api 在 2.0 协议里是一样的。</p>
<p><strong>● 性能的大幅提升</strong></p>
<p>2.0 协议重点是对终端用户的感知延迟、网络及服务器资源的使用等性能的优化。</p>
<p><strong>http2.0 优化内容</strong></p>
<p><strong>01</strong></p>
<p><strong>二进制分帧（Binary Format）- http2.0 的基石</strong></p>
<p>http2.0 之所以能够突破 http1.X 标准的性能限制，改进传输性能，实现低延迟和高吞吐量，就是因为其新增了二进制分帧层。</p>
<p>帧(frame)包含部分：类型 Type, 长度 Length, 标记 Flags, 流标识 Stream 和 frame payload 有效载荷。</p>
<p>消息(message)：一个完整的请求或者响应，比如请求、响应等，由一个或多个 Frame 组成。</p>
<p>流是连接中的一个虚拟信道，可以承载双向消息传输。每个流有唯一整数标识符。为了防止两端流 ID 冲突，客户端发起的流具有奇数 ID，服务器端发起的流具有偶数 ID。</p>
<p>流标识是描述二进制 frame 的格式，使得每个 frame 能够基于 http2 发送，与流标识联系的是一个流，每个流是一个逻辑联系，一个独立的双向的 frame 存在于客户端和服务器端之间的 http2 连接中。一个 http2 连接上可包含多个并发打开的流，这个并发流的数量能够由客户端设置。</p>
<p>在二进制分帧层上，http2.0 会将所有传输信息分割为更小的消息和帧，并对它们采用二进制格式的编码将其封装，新增的二进制分帧层同时也能够保证 http 的各种动词，方法，首部都不受影响，兼容上一代 http 标准。其中，http1.X 中的首部信息 header 封装到 Headers 帧中，而 request body 将被封装到 Data 帧中。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619340552914-6d85f416-ef90-425c-aadf-5b8012ea6a0e.jpeg#clientId=u148c49a8-157a-4&from=drop&height=328&id=ud9ea1c6a&margin=%5Bobject%20Object%5D&name=3.jpg&originHeight=328&originWidth=624&originalType=binary&size=27637&status=done&style=none&taskId=u5db12245-ba46-48b9-9407-0903347de64&width=624" alt="3.jpg"></p>
<p><strong>02</strong></p>
<p><strong>多路复用 (Multiplexing) / 连接共享</strong></p>
<p>在 http1.1 中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量的限制，超过限制数目的请求会被阻塞。这也是为何一些站点会有多个静态资源 CDN 域名的原因之一。</p>
<p>而 http2.0 中的多路复用优化了这一性能。多路复用允许同时通过单一的 http/2 连接发起多重的请求-响应消息。有了新的分帧机制后，http/2 不再依赖多个 TCP 连接去实现多流并行了。每个数据流都拆分成很多互不依赖的帧，而这些帧可以交错（乱序发送），还可以分优先级，最后再在另一端把它们重新组合起来。</p>
<p>http 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接（每个域名一个连接）即可。http2 连接可以承载数十或数百个流的复用，多路复用意味着来自很多流的数据包能够混合在一起通过同样连接传输。当到达终点时，再根据不同帧首部的流标识符重新连接将不同的数据流进行组装。</p>
<p>上图展示了一个连接上的多个传输数据流：客户端向服务端传输数据帧 stream5，同时服务端向客户端乱序发送 stream1 和 stream3。这次连接上有三个响应请求乱序并行交换。</p>
<p><img src="5.jpg#id=tSPAW&originalType=binary&status=done&style=none"></p>
<p>上图就是 http1.X 和 http2.0 在传输数据时的区别。以货物运输为例再现 http1.1 与 http2.0 的场景：</p>
<p>http1.1 过程：货轮 1 从 A 地到 B 地去取货物，取到货物后，从 B 地返回，然后货轮 2 在 A 返回并卸下货物后才开始再从 A 地出发取货返回，如此有序往返。</p>
<p>http2.0 过程：货轮 1、2、3、4、5 从 A 地无序全部出发，取货后返回，然后根据货轮号牌卸载对应货物。</p>
<p>显然，第二种方式运输货物多，河道的利用率高。</p>
<p>03</p>
<p><strong>头部压缩（Header Compression）</strong></p>
<p>http1.x 的头带有大量信息，而且每次都要重复发送。http/2 使用 encoder 来减少需要传输的 header 大小，通讯双方各自缓存一份头部字段表，既避免了重复 header 的传输，又减小了需要传输的大小。</p>
<p>对于相同的数据，不再通过每次请求和响应发送，通信期间几乎不会改变通用键-值对(用户代理、可接受的媒体类型，等等)只需发送一次。</p>
<p>事实上,如果请求中不包含首部(例如对同一资源的轮询请求)，那么，首部开销就是零字节，此时所有首部都自动使用之前请求发送的首部。</p>
<p>如果首部发生了变化，则只需将变化的部分加入到 header 帧中，改变的部分会加入到头部字段表中，首部表在 http 2.0 的连接存续期内始终存在，由客户端和服务器共同渐进地更新。</p>
<p>需要注意的是，http 2.0 关注的是首部压缩，而我们常用的 gzip 等是报文内容（body）的压缩，二者不仅不冲突，且能够一起达到更好的压缩效果。</p>
<p>http/2 使用的是专门为首部压缩而设计的 HPACK② 算法。</p>
<p><img src="6.jpg#id=F2mKG&originalType=binary&status=done&style=none"></p>
<p>从上图可以看到 http1.X 不支持首部压缩，而 http2.0 的压缩算法效果最好，发送和接受的数据量都是最少的。</p>
<p><strong>04</strong></p>
<p><strong>压缩原理</strong></p>
<p>用 header 字段表里的索引代替实际的 header。</p>
<p>http/2 的 HPACK 算法使用一份索引表来定义常用的 http Header，把常用的 http Header 存放在表里，请求的时候便只需要发送在表里的索引位置即可。</p>
<p>例如 :method=GET 使用索引值 2 表示，:path=/index.html 使用索引值 5 表示，如下图：</p>
<p><img src="7.png#id=k57oQ&originalType=binary&status=done&style=none"></p>
<p>完整的列表参考：HPACK Static Table③ 。</p>
<p>只要给服务端发送一个 Frame，该 Frame 的 Payload 部分存储 0x8285，Frame 的 Type 设置为 Header 类型，便可表示这个 Frame 属于 http Header，请求的内容是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1GET &#x2F;index.html</span><br></pre></td></tr></table></figure>

<p>为什么是 0x8285，而不是 0x0205？这是因为高位设置为 1 表示这个字节是一个完全索引值（key 和 value 都在索引中）。</p>
<p>类似的，通过高位的标志位可以区分出这个字节是属于一个完全索引值，还是仅索引了 key，还是 key 和 value 都没有索引(参见：HTTP/2 首部压缩的 OkHttp3 实现 ④)。</p>
<p>因为索引表的大小的是有限的，它仅保存了一些常用的 http Header，同时每次请求还可以在表的末尾动态追加新的 http Header 缓存，动态部分称之为 Dynamic Table。Static Table 和 Dynamic Table 在一起组合成了索引表：</p>
<p><img src="8.png#id=JO7UY&originalType=binary&status=done&style=none"></p>
<p>HPACK 不仅仅通过索引键值对来降低数据量，同时还会将字符串进行霍夫曼编码来压缩字符串大小。</p>
<p>以常用的 User-Agent 为例，它在静态表中的索引值是 58，它的值是不存在表中的，因为它的值是多变的。第一次请求的时候它的 key 用 58 表示，表示这是一个 User-Agent ，它的值部分会进行霍夫曼编码（如果编码后的字符串变更长了，则不采用霍夫曼编码）。</p>
<p>服务端收到请求后，会将这个 User-Agent 添加到 Dynamic Table 缓存起来，分配一个新的索引值。客户端下一次请求时，假设上次请求 User-Agent 的在表中的索引位置是 62， 此时只需要发送 0xBE（同样的，高位置 1），便可以代表：User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.146 Safari/537.36。</p>
<p>其过程如下图所示：</p>
<p><img src="9.png#id=nq66g&originalType=binary&status=done&style=none"></p>
<p>最终，相同的 Header 只需要发送索引值，新的 Header 会重新加入 Dynamic Table。</p>
<p><strong>05</strong></p>
<p><strong>请求优先级（Request Priorities）</strong></p>
<p>把 http 消息分为很多独立帧之后，就可以通过优化这些帧的交错和传输顺序进一步优化性能。每个流都可以带有一个 31 比特的优先值：0 表示最高优先级；2 的 31 次方-1 表示最低优先级。</p>
<p>服务器可以根据流的优先级，控制资源分配（CPU、内存、带宽），而在响应数据准备好之后，优先将最高优先级的帧发送给客户端。高优先级的流都应该优先发送，但又不会绝对的。绝对地准守，可能又会引入首队阻塞的问题：高优先级的请求慢导致阻塞其他资源交付。</p>
<p>分配处理资源和客户端与服务器间的带宽，不同优先级的混合也是必须的。客户端会指定哪个流是最重要的，有一些依赖参数，这样一个流可以依赖另外一个流。优先级别可以在运行时动态改变，当用户滚动页面时，可以告诉浏览器哪个图像是最重要的，你也可以在一组流中进行优先筛选，能够突然抓住重点流。</p>
<p>● 优先级最高：主要的 html</p>
<p>● 优先级高：CSS 文件</p>
<p>● 优先级中：js 文件</p>
<p>● 优先级低：图片</p>
<p><strong>06</strong></p>
<p><strong>服务端推送（Server Push）</strong></p>
<p>服务器可以对一个客户端请求发送多个响应，服务器向客户端推送资源无需客户端明确地请求。并且，服务端推送能把客户端所需要的资源伴随着 index.html 一起发送到客户端，省去了客户端重复请求的步骤。</p>
<p>正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。Server Push 让 http1.x 时代使用内嵌资源的优化手段变得没有意义；如果一个请求是由你的主页发起的，服务器很可能会响应主页内容、logo 以及样式表，因为它知道客户端会用到这些东西，这相当于在一个 HTML 文档内集合了所有的资源。</p>
<p>不过与之相比，服务器推送还有一个很大的优势：可以缓存！也让在遵循同源的情况下，不同页面之间可以共享缓存资源成为可能。</p>
<p><img src="10.png#id=CeWmD&originalType=binary&status=done&style=none"></p>
<p>注意两点：</p>
<p>1、推送遵循同源策略；</p>
<p>2、这种服务端的推送是基于客户端的请求响应来确定的。</p>
<p>当服务端需要主动推送某个资源时，便会发送一个 Frame Type 为 PUSH_PROMISE 的 Frame，里面带了 PUSH 需要新建的 Stream ID。意思是告诉客户端：接下来我要用这个 ID 向你发送东西，客户端准备好接着。客户端解析 Frame 时，发现它是一个 PUSH_PROMISE 类型，便会准备接收服务端要推送的流。</p>
<p><strong>http2.0 性能瓶颈</strong></p>
<p>启用 http2.0 后会给性能带来很大的提升，但同时也会带来新的性能瓶颈。因为现在所有的压力集中在底层一个 TCP 连接之上，TCP 很可能就是下一个性能瓶颈，比如 TCP 分组的队首阻塞问题，单个 TCP packet 丢失导致整个连接阻塞，无法逃避，此时所有消息都会受到影响。未来，服务器端针对 http 2.0 下的 TCP 配置优化至关重要。</p>
<p><strong>01</strong></p>
<p><strong>如何升级 http2.0 协议</strong></p>
<p>nginx 服务器升级 http2.0 协议需要满足如下条件：</p>
<p>1、nginx 版本高于 1.9.5；</p>
<p>2、–with-http_ssl_module 跟 –with-http_v2_module</p>
<p>–with-http_ssl_module 模块是因为 http2.0 协议是一种 https 协议。</p>
<p><strong>02</strong></p>
<p><strong>查看你的 nginx 配置</strong></p>
<p><code>nginx -V</code></p>
<p><img src="11.png#id=GIrmw&originalType=binary&status=done&style=none"></p>
<p>这个是已经添加了对应模块。没有这两个模块的需要手动编译安装。</p>
<p><strong>03</strong></p>
<p><strong>找到 nginx 文件目录</strong></p>
<p><img src="12.jpg#id=VFj3G&originalType=binary&status=done&style=none"></p>
<p><strong>04</strong></p>
<p><strong>编译安装 nginx 文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx  --with-http_stub_status_module  --with-http_ssl_module  --with-http_v2_module</span><br></pre></td></tr></table></figure>

<p><img src="13.jpg#id=SMiUA&originalType=binary&status=done&style=none"></p>
<p>然后执行如下命令，进行编译安装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1make2make install</span><br></pre></td></tr></table></figure>

<p><img src="14.jpg#id=FhnAB&originalType=binary&status=done&style=none"></p>
<p><img src="15.png#id=oWcYU&originalType=binary&status=done&style=none"></p>
<p><strong>05</strong></p>
<p><strong>更改 nginx 配置</strong></p>
<p>安装结束后将 nginx.config 文件中 443 端口添加 http2；</p>
<p><img src="16.png#id=KneJj&originalType=binary&status=done&style=none"></p>
<p><strong>06</strong></p>
<p><strong>启动 nginx</strong></p>
<p>最后一步，重启 nginx nginx restart（注意不要直接   nginx -s reload ）。这时候你的站点就升级为了 http2.0 协议了。</p>
<p><strong>检测</strong></p>
<p>升级完成后，怎么确定自己的站点是 http2.0 协议呢？一般有如下几种方法：</p>
<p><strong>●chrome devtool</strong></p>
<p>打开 chrome 调试工具，在 network 勾选 protocol 项，h2 代表的是 http2.0 协议，可以看到笔者的网站已经都升级好了；</p>
<p><strong>● 网站</strong></p>
<p>SSL lab⑤ 一个 SSL 服务器检测的网站，对网站进行安全评级，并将检测结果自动生成一个详细的评价报告；</p>
<p><strong>● 插件</strong></p>
<p>http/2 and SPDY indicator 这是一款检测 http2.0 和 SPDY 协议（Google 开发的基于 TCP 的会话层协议）的插件。</p>
<p>参考资料：</p>
<p>[1].<a target="_blank" rel="noopener" href="https://http2.github.io/">https://http2.github.io/</a></p>
<p>[2].<a target="_blank" rel="noopener" href="http://http2.github.io/http2-spec/compression.html">http://http2.github.io/http2-spec/compression.html</a></p>
<p>[3].<a target="_blank" rel="noopener" href="http://http2.github.io/http2-spec/compression.html#rfc.section.A">http://http2.github.io/http2-spec/compression.html#rfc.section.A</a></p>
<p>[4].<a target="_blank" rel="noopener" href="https://neyoufan.github.io/2017/01/06/android/OkHttp3%E4%B8%AD%E7%9A%84HTTP2%E9%A6%96%E9%83%A8%E5%8E%8B%E7%BC%A9/">https://neyoufan.github.io/2017/01/06/android/OkHttp3中的HTTP2首部压缩/</a></p>
<p>[5].<a target="_blank" rel="noopener" href="https://www.ssllabs.com/ssltest/analyze.html">https://www.ssllabs.com/ssltest/analyze.html</a></p>
<p><strong>也许你还想看</strong></p>
<p><strong>（▼ 点击文章标题或封面查看）</strong></p>
<p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzU3NTY3MTQzMg==%E2%88%A3=2247483791&idx=1&sn=f6fd2d66e35e93a27e5918b4ee4c5358&chksm=fd1edc68ca69557ef2d79b7b6bf4ea89de6affa6919c1c85e70d888464e007f9b8683f4e949a&scene=21#wechat_redirect">搜狐新闻推荐算法  |  呈现给你的，都是你所关心的</a></p>
<p>2018-08-30</p>
<p><img src="17.jpg#id=kCDUw&originalType=binary&status=done&style=none"></p>
<p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzU3NTY3MTQzMg==%E2%88%A3=2247484862&idx=1&sn=9e1723862ce80488dabc4d3535464cae&chksm=fd1ed859ca69514f02c055a5c8d636f8af2eddd6e7deb0d496d36bb1e5fd404aef90e435b50c&scene=21#wechat_redirect">新闻推荐系统的 CTR 预估模型</a></p>
<p>2019-04-18</p>
<p><img src="18.jpg#id=vtapY&originalType=binary&status=done&style=none"></p>
<p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzU3NTY3MTQzMg==%E2%88%A3=2247483690&idx=1&sn=7187cad324ad14821bf88fa8be4eebf0&chksm=fd1edccdca6955db28c8ce1f24c92367f06cbf81793b2125fa0d76c4692d4a7096f013ca695f&scene=21#wechat_redirect">互联网架构演进之路</a></p>
<p>2018-08-16</p>
<p><img src="19.jpg#id=aFn5I&originalType=binary&status=done&style=none"></p>
<p>加入<strong>搜狐技术作者天团</strong></p>
<p><strong>千元稿费等你来！</strong></p>
<p>戳这里！☛</p>
<p><img src="20.jpg#id=lQqww&originalType=binary&status=done&style=none"></p>
<p><img src="21.gif#id=e7aD0&originalType=binary&status=done&style=none"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/25/yuque/HTTPS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/25/yuque/HTTPS/" class="post-title-link" itemprop="url">HTTPS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-25 16:41:41 / 修改时间：16:49:30" itemprop="dateCreated datePublished" datetime="2021-04-25T16:41:41+08:00">2021-04-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>HTTP 是不安全的，我们的页面也被运营商插入过小黄图广告（数据被篡改），对于 HTTP 来说，再简单不过，只需要设定相应的 DNS，做一个中间人攻击，再将修改后的数据返回，这一方面可能泄露用户隐私数据，同时也对我们的品牌形象产生恶劣影响。<br>然而，当我们切换 HTTPS 时候，运营商的这些小九九就施展不开了，服务端认证不通过，浏览器不会展示相应的页面数据；运营商实施搞的这一套东东也就不能在用户不知情的情况下搞起来了，解决办法是去除相应的受污染的 DNS。<br>全球最大的成人网站 PornHub，YouPorn 都要全面切 HTTPS 了,我们还在犹豫什么了？</p>
<h3 id="安全的-HTTP-的需求"><a href="#安全的-HTTP-的需求" class="headerlink" title="安全的 HTTP 的需求"></a>安全的 HTTP 的需求</h3><p>对 HTTP 的安全需求：</p>
<ul>
<li>加密（客户端和服务器的对话是私密的，无须担心被窃听）</li>
<li>服务端认证（客户端知道它们是在与真正的而不是伪造的服务器通信）</li>
<li>客户端认证（服务器知道它们是在与真正的而不是伪造的客户端通信）</li>
<li>完整性（客户端和服务器的数据不会被修改）</li>
<li>效率（一个运行足够快的算法，一遍低端的客户端和服务器使用）</li>
<li>普适性（基本上所有的客户端和服务器都支持这些协议）</li>
<li>管理的可扩展性（在任何地方的任何人都可以立即进行安全通信）</li>
<li>适应性（能够支持当前最知名的安全方法）</li>
<li>在社会上的可行性（满足社会的政治文化需要），要有公众受信能力</li>
</ul>
<p>在这里面最重要的是前面几条</p>
<ul>
<li>数据加密 传输内容进行混淆</li>
<li>身份验证 通信双方验证对方的身份真实性</li>
<li>数据完整性保护 检测传输的内容是否被篡改或伪造</li>
</ul>
<h3 id="安全-HTTP-的实现"><a href="#安全-HTTP-的实现" class="headerlink" title="安全 HTTP 的实现"></a>安全 HTTP 的实现</h3><h4 id="加密方式的选择"><a href="#加密方式的选择" class="headerlink" title="加密方式的选择"></a>加密方式的选择</h4><p>共享密钥加密 对称密钥加密共享密钥加密方式使用相同的密钥进行加密解密，通信双方都需要接收对方的加密密钥进行数据解密，这种方式在通信过程中必须交互共享的密钥，同样无法避免被网络监听泄漏密钥的问题；同时对于众多客户端的服务器来说还需要分配和管理密钥，对于客户端来说也需要管理密钥，增加设计和实现的复杂度，同时也降低了通信的效率；不用看都不靠谱。<br>公开密钥加密公开密钥加密方式使用一对非对称的密钥对（私钥和公钥），不公开的作为私钥，随意分发的作为公钥；公钥和私钥都能进行数据加密和解密，公钥能解密私钥加密的数据，私钥也能解密公钥加密的数据；这样只需要一套密钥就能处理服务端和众多客户端直接的通信被网络监听泄漏密钥的问题，同时没有额外的管理成本；看起来挺合适。<br>没那么简单公开密钥加密安全性高，伴随着加密方式复杂，处理速度慢的问题。如果我们的通信都是用公开密钥的方式加密，那么通信效率会很低。<br>HTTPS 采用共享密钥加密和公开密钥加密混合的加密方式，在交换密钥对环节使用公开密钥加密方式（防止被监听泄漏密钥）加密共享的密钥，在随后的通信过程中使用共享密钥的方式使用共享的密钥进行加解密。</p>
<h4 id="认证方式实现"><a href="#认证方式实现" class="headerlink" title="认证方式实现"></a>认证方式实现</h4><p>数字证书数字签名是附加在报文上的特殊加密校验码，可以证明是作者编写了这条报文，前提是作者才会有私钥，才能算出这些校验码。如果传输的报文被篡改，则校验码不会匹配，因为校验码只有作者保存的私钥才能产生，所以前面可以保证报文的完整性。<br>数字证书认证机构（Certificate Authority CA）是客户端和服务器双方都可信赖的第三方机构。<br>服务器的运营人员向数字证书认证机构提出证书认证申请，数字证书认证机构在判明申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书（也叫数字证书或证书）后绑定在一起。服务器将这份有数字认证机构颁发的公钥证书发总给客户端，以进行公开密钥加密方式通信。<br>EV SSL（Extended Validation SSL Certificate）证书是基于国际标准的认证指导方针办法的证书，通过认证的 Web 网站能获得更高的认可度。持有 EV SSL 证书的 Web 网站的浏览器地址栏的背景色是绿色的，同时在地址栏的左侧显示了 SSL 证书中记录的组织名称及办法证书的认证机构的名称。<br>使用 OpenSSL，每个人都可以构建一套认证机构文件，同时可以用来给自己的证书请求进行签名，这种方式产生的证书称为自签名证书，这种证书通常是 CA 自己的证书，用户开发测试的正式，也可以像 12306 这样的，信不信由你。<br>证书信任的方式</p>
<ul>
<li>操作系统和浏览器内置每个操作系统和大多数浏览器都会内置一个知名证书颁发机构的名单。因此，你也会信任操作系统及浏览器提供商提供和维护的可信任机构。受信认证机构（也有不受信的，比如赛门铁克，沃通，或者像 2011 年被入侵的 DigiNotar 等）的证书一般会被操作系统或者浏览器在发行或者发布时内置。</li>
<li>证书颁发机构 CA（ Certificate Authority，证书颁发机构）是被证书接受者（拥有者）和依赖证书的一方共同信任的第三方。</li>
<li>手动指定证书所有浏览器和操作系统都提供了一种手工导入信任证书的机制。至于如何获得证书和验证完整性则完全由你自己来定。</li>
</ul>
<p>PKI（Public Key Infrastructure），即公开密钥基础设施，是国际上解决开放式互联网络信息安全需求的一套体系。PKI 支持身份认证，信息传输，存储的完整性，消息传输，存储的机密性以及操作的不可否认性。</p>
<h4 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h4><p>数字签名是只有信息发送者才能产生的别人无法伪造的一段文本，这段文本是对信息发送者发送信息真实性的一个有效证明，具有不可抵赖性。<br>报文的发送方从报文文本生成一个 128 位的散列值（或称为报文摘要活哈希值），发送方使用自己的私钥对这个摘要值进行加密来形成发送方的数字签名。然后这个数字签名将作为报文的附件一起发送给报文的接收方。报文的接收方首先从接收到的原始报文中计算出 128 位的散列值，再用发送方的公钥来对报文附加的数字签名进行解密。如果两次得到的结果是一致的那么接收方可以确认该数字签名是发送方的，同时确认信息是真实的 。</p>
<h3 id="HTTPS-数据交互过程"><a href="#HTTPS-数据交互过程" class="headerlink" title="HTTPS 数据交互过程"></a>HTTPS 数据交互过程</h3><p>HTTP 中没有加密机制，可以通过 SSL（Secure Socket Layer 安全套接层）或 TLS（Transport Layer Security 安全层传输协议）的组合使用，加密 HTTP 的通信内容。<br>HTTPS 是 HTTP Secure 或 HTTP over SSL。<br>SSL（Security Socket Layer）是最初由网景公司（NetScape）为了保障网上交易安全而开发的协议，该协议通过加密来保护客户个人资料，通过认证和完整性检查来确保交易安全。网景公司开发过 SSL3.0 之前的版本；目前主导权已转移给 IETF（Internet Engineering Task Force），IETF 以 SSL3.0 为原型，标准化并制定了 TSL1.0，TLS1.1，TLS1.2。但目前主流的还是 SSL3.0 和 TSL1.0。<br>SSL 工作在 OSI 七层模型中的表示层，TCP/IP 四层模型的应用层。<br>SSL 和 TLS 可以作为基础协议的一部分（对应用透明），也可以嵌入在特定的软件包中（比如 Web 服务器中的实现）。<br>SSL 基于 TCP，SSL 不是简单地单个协议，而是两层协议；SSL 记录协议（SSL Record Protocol）为多种高层协议（SSL 握手协议，SSL 修改密码参数协议，SSL 报警协议）提供基本的安全服务。HTTP 是为 Web 客户端/服务器交互提供传输服务的，它可以在 SSL 的顶层运行；SSL 记录协议为 SSL 链接提供两种服务，机密性：握手协议定义了一个共享密钥，用于 SSL 载荷的对称加密。 消息完整性：握手协议还定义了一个共享密钥，它用来产生一个消息认证码（Message Authentication Code，MAC）。</p>
<h4 id="SSL-记录协议操作"><a href="#SSL-记录协议操作" class="headerlink" title="SSL 记录协议操作"></a>SSL 记录协议操作</h4><ul>
<li>分段 将每个上层消息分解成不大于 2^14（16384）位，然后有选择的进行压缩</li>
<li>添加 MAC 在压缩数据的基础上计算 MAC</li>
<li>加密 消息加上 MAC 用对称加密方法加密</li>
<li>添加 SSL 记录头 内容类型（8 位），主版本（8 位），副版本（8 位），压缩长度（16 位）</li>
</ul>
<h4 id="SSL-握手过程"><a href="#SSL-握手过程" class="headerlink" title="SSL 握手过程"></a>SSL 握手过程</h4><ul>
<li>第一阶段 建立安全能力 包括协议版本 会话 Id 密码构件 压缩方法和初始随机数</li>
<li>第二阶段 服务器发送证书 密钥交换数据和证书请求，最后发送请求-相应阶段的结束信号</li>
<li>第三阶段 如果有证书请求客户端发送此证书 之后客户端发送密钥交换数据 也可以发送证书验证消息</li>
<li>第四阶段 变更密码构件和结束握手协议</li>
</ul>
<p>SSL 协议两个重要概念，SSL 会话，SSL 连接；SSL 连接是点到点的连接，而且每个连接都是瞬态的，每一个链接都与一个会话关联。SSL 会话是一个客户端和一个服务器之间的一种关联，会话由握手协议（Handshake Protocol）创建，所有会话都定义了一组密码安全参数，这些安全参数可以在多个连接之间共享，会话可以用来避免每一个链接需要进行的代价高昂的新的安全参数协商过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Client                                               Server</span><br><span class="line"></span><br><span class="line">   ClientHello:HandShake       --------&gt;</span><br><span class="line">                                                   ServerHello:Handshake</span><br><span class="line">                                                  Certificate*:Handshake</span><br><span class="line">                                            ServerKeyExchange*:Handshake</span><br><span class="line">                                           CertificateRequest*:Handshake</span><br><span class="line">                                &lt;--------      ServerHelloDone:Handshake</span><br><span class="line">   Certificate*:Handshake</span><br><span class="line">   ClientKeyExchange:Handshake</span><br><span class="line">   CertificateVerify*:Handshake</span><br><span class="line">   [ChangeCipherSpec]</span><br><span class="line">   Finished:Handshake           --------&gt;</span><br><span class="line">                                                      [ChangeCipherSpec]</span><br><span class="line">                                &lt;--------             Finished:Handshake</span><br><span class="line">   Application Data             &lt;-------&gt;               Application Data</span><br></pre></td></tr></table></figure>

<h3 id="客户端服务器数据交互实战"><a href="#客户端服务器数据交互实战" class="headerlink" title="客户端服务器数据交互实战"></a>客户端服务器数据交互实战</h3><h4 id="使用-openssl-命令"><a href="#使用-openssl-命令" class="headerlink" title="使用 openssl 命令"></a>使用 openssl 命令</h4><blockquote>
<p>openssl s_client -state -connect q.qunarzz.com:443</p>
</blockquote>
<p>该命令可以显示 SSL 握手过程，SSL 证书链，公钥证书以及其他相关的状态和属性信息。</p>
<h4 id="使用-Wireshark-抓取数据包"><a href="#使用-Wireshark-抓取数据包" class="headerlink" title="使用 Wireshark 抓取数据包"></a>使用 Wireshark 抓取数据包</h4><p>相关配置</p>
<ul>
<li><p>配置环境变量，同时保证文件路径存在</p>
<blockquote>
<p>SSLKEYLOG=/path/to/sslkeylog.log</p>
</blockquote>
</li>
<li><p>配置 Wireshark</p>
<blockquote>
<p>Wireshark-&gt;Preference-&gt;Protocols-&gt;SSL-&gt;(Pre)-Master-Secret log filename=&gt;选择上面的路径</p>
</blockquote>
</li>
</ul>
<p>抓包操作</p>
<ul>
<li><p>在命令行中打开 Chrome 或者 Firefox，确保环境变量被读取;如果不行就用 Chrome 或者 Firefox 的开发版。</p>
<blockquote>
<p>open /Applications/Firefox.app<br>open /Applications/Google\ Chrome.app</p>
</blockquote>
</li>
<li><p>确保$SSLKEYLOGFILE 里面有内容了，再往下进行。</p>
</li>
<li><p>选择对应网卡，抓包配置为 host<a href="https://link.zhihu.com/?target=http://q.qunarzz.com">http://q.qunarzz.com</a>，开始抓包</p>
</li>
<li><p>使用刚刚打开的浏览器访问一个对应 host<a href="https://link.zhihu.com/?target=http://q.qunarzz.com">http://q.qunarzz.com</a>下的某个资源，在抓包界面使用 ssl 过滤数据</p>
</li>
<li><p>在抓包界面可以看到对应的 SSL 握手信息，同时还能看到解密后的应用数据。</p>
</li>
</ul>
<h4 id="内容解析（不同的网络资源可能不完全一致，比如需要客户端证书）"><a href="#内容解析（不同的网络资源可能不完全一致，比如需要客户端证书）" class="headerlink" title="内容解析（不同的网络资源可能不完全一致，比如需要客户端证书）"></a>内容解析（不同的网络资源可能不完全一致，比如需要客户端证书）</h4><p>客户端 ⇒ 服务器</p>
<ul>
<li>Client Hello<ul>
<li>最高支持的协议版本 如 TLS 1.0</li>
<li>支持的加密算法列表(Cipher Suites)</li>
<li>支持的压缩算法列表(Compression Methods)</li>
<li>客户端生成的随机数，稍后用于生成会话密钥</li>
</ul>
</li>
</ul>
<p>服务器 ⇒ 客户端</p>
<ul>
<li>Server Hello<ul>
<li>选定的协议版本</li>
<li>选定的加密算法</li>
<li>选定的压缩方法</li>
<li>服务端生成的随机数，稍后用于生成会话密钥</li>
</ul>
</li>
<li>Certificate 证书内容</li>
<li>Server Key Exchange, Server Hello Done<ul>
<li>公钥</li>
<li>数字签名</li>
<li>Server Hello Done</li>
</ul>
</li>
</ul>
<p>客户端 ⇒ 服务器</p>
<ul>
<li>Client Key Exchange, Change Cipher Spec, Finished<ul>
<li>公钥</li>
<li>Change Cipher Spec</li>
<li>Finished</li>
</ul>
</li>
</ul>
<p>客户端 ⇒ 服务器</p>
<ul>
<li>HTTP GET</li>
</ul>
<p>服务端 ⇒ 客户端</p>
<ul>
<li><strong>内容的数据片段信息</strong></li>
<li>HTTP HTTP/1.1 200 OK</li>
</ul>
<p>服务端 ⇒ 客户端</p>
<ul>
<li>Encrypted Alert</li>
<li>Alert (Level Warning, Description: Close Notify)</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li>《Web 性能权威指南》</li>
<li>《RFC 2246》</li>
<li>《图解 HTTP》</li>
<li>《HTTP 权威指南》</li>
<li>《HTTPS 权威指南 在服务器和 Web 应用上部署 SSL/TLS 和 PKI》</li>
<li>《计算机网络系统方法》</li>
<li>《计算机网络自上而下方法》</li>
<li>《计算机安全原理与实践》</li>
<li>《网络安全基础-应用与标准》</li>
<li>《PKI/CA 与数字证书技术大全》</li>
<li>《SSL 与 TLS》</li>
<li>《OpenSSL 官方命令文档》</li>
<li>《OpenSSL 与网络信息安全-基础、结构和指令》</li>
<li>《OpenSSL 攻略》</li>
<li><a href="https://link.zhihu.com/?target=http://SSL%2520-%2520The%2520Wireshark%2520Wiki">Wireshark Doc SSL</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/25/yuque/HTTP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/25/yuque/HTTP/" class="post-title-link" itemprop="url">HTTP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-25 16:39:57 / 修改时间：16:49:30" itemprop="dateCreated datePublished" datetime="2021-04-25T16:39:57+08:00">2021-04-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>HTTP (Hypertext transfer protocol) 翻译成中文是超文本传输协议，是互联网上重要的一个协议，由欧洲核子研究委员会 CERN 的英国工程师<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Tim_Berners-Lee">Tim Berners-Lee</a>v 发明的，同时，他也是 WWW 的发明人，最初的主要是用于传递通过 HTML 封装过的数据。在 1991 年发布了 HTTP 0.9 版，在 1996 年发布 1.0 版，1997 年是 1.1 版，1.1 版也是到今天为止传输最广泛的版本（初始<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc2068">RFC 2068</a>在 1997 年发布， 然后在 1999 年被<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc2616">RFC 2616</a>取代，再在 2014 年被<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7230">RFC 7230</a>/<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7231">7231</a>/<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7232">7232</a>/<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7233">7233</a>/<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7234">7234</a>/<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7235">7235</a>取代），2015 年发布了 2.0 版，其极大的优化了 HTTP/1.1 的性能和安全性，而 2018 年发布的 3.0 版，继续优化 HTTP/2，激进地使用 UDP 取代 TCP 协议，目前，HTTP/3 在 2019 年 9 月 26 日 被 Chrome，Firefox，和 Cloudflare 支持，所以我想写下这篇文章，简单地说一下 HTTP 的前世今生，让大家学到一些知识，并希望可以在推动一下 HTTP 标准协议的发展。</p>
<h4 id="HTTP-0-9-1-0"><a href="#HTTP-0-9-1-0" class="headerlink" title="HTTP 0.9 / 1.0"></a>HTTP 0.9 / 1.0</h4><p>0.9 和 1.0 这两个版本，就是最传统的 request – response 的模式了，HTTP 0.9 版本的协议简单到极点，请求时，不支持请求头，只支持 GET 方法，没了。HTTP 1.0 扩展了 0.9 版，其中主要增加了几个变化：</p>
<ul>
<li>在请求中加入了 HTTP 版本号，如：GET /coolshell/index.html HTTP/1.0</li>
<li>HTTP 开始有 header 了，不管是 request 还是 response 都有 header 了。</li>
<li>增加了 HTTP Status Code 标识相关的状态码。</li>
<li>还有 Content-Type 可以传输其它的文件了。</li>
</ul>
<p>我们可以看到，HTTP 1.0 开始让这个协议变得很文明了，一种工程文明。因为：</p>
<ul>
<li>一个协议有没有版本管理，是一个工程化的象征。</li>
<li>header 是协议可以说是把元数据和业务数据解耦，也可以说是控制逻辑和业务逻辑的分离。</li>
<li>Status Code 的出现可以让请求双方以及第三方的监控或管理程序有了统一的认识。最关键是还是控制错误和业务错误的分离。</li>
</ul>
<p>（注：国内很多公司 HTTP 无论对错只返回 200，这种把 HTTP Status Code 全部抹掉完全是一种工程界的倒退）<br>但是，HTTP1.0 性能上有一个很大的问题，那就是每请求一个资源都要新建一个 TCP 链接，而且是串行请求，所以，就算网络变快了，打开网页的速度也还是很慢。所以，HTTP 1.0 应该是一个必需要淘汰的协议了。</p>
<h4 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h4><p>HTTP/1.1 主要解决了 HTTP 1.0 的网络性能的问题，以及增加了一些新的东西：</p>
<ul>
<li>可以设置 keepalive 来让 HTTP 重用 TCP 链接，重用 TCP 链接可以省了每次请求都要在广域网上进行的 TCP 的三次握手的巨大开销。这是所谓的“<strong>HTTP 长链接</strong>” 或是 “<strong>请求响应式的 HTTP 持久链接</strong>”。英文叫 HTTP Persistent connection.</li>
<li>然后支持 pipeline 网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。（注：非幂等的 POST 方法或是有依赖的请求是不能被 pipeline 化的）</li>
<li>支持 Chunked Responses ，也就是说，在 Response 的时候，不必说明 Content-Length 这样，客户端就不能断连接，直到收到服务端的 EOF 标识。这种技术又叫 “<strong>服务端 Push 模型</strong>”，或是 “<strong>服务端 Push 式的 HTTP 持久链接</strong>”</li>
<li>还增加了 cache control 机制。</li>
<li>协议头注增加了 Language, Encoding, Type 等等头，让客户端可以跟服务器端进行更多的协商。</li>
<li>还正式加入了一个很重要的头——<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Host">HOST</a>这样的话，服务器就知道你要请求哪个网站了。因为可以有多个域名解析到同一个 IP 上，要区分用户是请求的哪个域名，就需要在 HTTP 的协议中加入域名的信息，而不是被 DNS 转换过的 IP 信息。</li>
<li>正式加入了 OPTIONS 方法，其主要用于<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">CORS – Cross Origin Resource Sharing</a>应用。</li>
</ul>
<p>HTTP/1.1 应该分成两个时代，一个是 2014 年前，一个是 2014 年后，因为 2014 年 HTTP/1.1 有了一组 RFC（<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7230">7230</a>/<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7231">7231</a>/<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7232">7232</a>/<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7233">7233</a>/<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7234">7234</a>/<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7235">7235</a>），这组 RFC 又叫“HTTP/2 预览版”。其中影响 HTTP 发展的是两个大的需求：</p>
<ul>
<li>一个需要是加大了 HTTP 的安全性，这样就可以让 HTTP 应用得广泛，比如，使用 TLS 协议。</li>
<li>另一个是让 HTTP 可以支持更多的应用，在 HTTP/1.1 下，HTTP 已经支持四种网络协议：<ul>
<li>传统的短链接。</li>
<li>可重用 TCP 的的长链接模型。</li>
<li>服务端 push 的模型。</li>
<li>WebSocket 模型。</li>
</ul>
</li>
</ul>
<p>自从 2005 年以来，整个世界的应用 API 越来多，这些都造就了整个世界在推动 HTTP 的前进，我们可以看到，<strong>自 2014 的 HTTP/1.1 以来，这个世界基本的应用协议的标准基本上都是向 HTTP 看齐了，也许 2014 年前，还有一些专用的 RPC 协议，但是 2014 年以后，HTTP 协议的增强，让我们实在找不出什么理由不向标准靠拢，还要重新发明轮子了。</strong></p>
<h4 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h4><p>虽然 HTTP/1.1 已经开始变成应用层通讯协议的一等公民了，但是还是有性能问题，虽然 HTTP/1.1 可以重用 TCP 链接，但是请求还是一个一个串行发的，需要保证其顺序。然而，大量的网页请求中都是些资源类的东西，这些东西占了整个 HTTP 请求中最多的传输数据量。所以，理论上来说，如果能够并行这些请求，那就会增加更大的网络吞吐和性能。<br>另外，HTTP/1.1 传输数据时，是以文本的方式，借助耗 CPU 的 zip 压缩的方式减少网络带宽，但是耗了前端和后端的 CPU。这也是为什么很多 RPC 协议诟病 HTTP 的一个原因，就是数据传输的成本比较大。<br>其实，在 2010 年时，Google 就在搞一个实验型的协议，这个协议叫<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/SPDY">SPDY</a>，这个协议成为了 HTTP/2 的基础（也可以说成 HTTP/2 就是 SPDY 的复刻）。HTTP/2 基本上解决了之前的这些性能问题，其和 HTTP/1.1 最主要的不同是：</p>
<ul>
<li>HTTP/2 是一个二进制协议，增加了数据传输的效率。</li>
<li>HTTP/2 是可以在一个 TCP 链接中并发请求多个 HTTP 请求，移除了 HTTP/1.1 中的串行请求。</li>
<li>HTTP/2 会压缩头，如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。这就是所谓的 HPACK 算法（参看<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7541">RFC 7541</a>附录 A）</li>
<li>HTTP/2 允许服务端在客户端放 cache，又叫服务端 push，也就是说，你没有请求的东西，我服务端可以先送给你放在你的本地缓存中。比如，你请求 X，我服务端知道 X 依赖于 Y，虽然你没有的请求 Y，但我把把 Y 跟着 X 的请求一起返回客户端。</li>
</ul>
<p>对于这些性能上的改善，在 Medium 上有篇文章你可看一下相关的细节说明和测试“<a target="_blank" rel="noopener" href="https://medium.com/@factoryhr/http-2-the-difference-between-http-1-1-benefits-and-how-to-use-it-38094fa0e95b">HTTP/2: the difference between HTTP/1.1, benefits and how to use it</a>”<br>当然，还需要注意到的是 HTTP/2 的协议复杂度比之前所有的 HTTP 协议的复杂度都上升了许多许多，其内部还有很多看不见的东西，比如其需要维护一个“优先级树”来用于来做一些资源和请求的调度和控制。如此复杂的协议，自然会产生一些不同的声音，或是降低协议的可维护和可扩展性。所以也有一些争议。尽管如此，HTTP/2 还是很快地被世界所采用。<br>HTTP/2 是 2015 年推出的，其发布后，Google 宣布移除对 SPDY 的支持，拥抱标准的 HTTP/2。过了一年后，就有 8.7%的网站开启了 HTTP/2，根据<a target="_blank" rel="noopener" href="https://w3techs.com/technologies/details/ce-http2/all/all">这份报告</a>，截止至本文发布时（2019 年 10 月 1 日 ）， 在全世界范围内已经有 41%的网站开启了 HTTP/2。<br>HTTP/2 的官方组织在 Github 上维护了一份<a target="_blank" rel="noopener" href="https://github.com/http2/http2-spec/wiki/Implementations">各种语言对 HTTP/2 的实现列表</a>，大家可以去看看。<br>我们可以看到，HTTP/2 在性能上对 HTTP 有质的提高，所以，HTTP/2 被采用的也很快，所以，<strong>如果你在你的公司内负责架构的话，HTTP/2 是你一个非常重要的需要推动的一个事，除了因为性能上的问题，推动标准落地也是架构师的主要职责，因为，你企业内部的架构越标准，你可以使用到开源软件，或是开发方式就会越有效率，跟随着工业界的标准的发展，你的企业会非常自然的享受到标准所带来的红利。</strong></p>
<h4 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h4><p>然而，这个世界没有完美的解决方案，HTTP/2 也不例外，其主要的问题是：若干个 HTTP 的请求在复用一个 TCP 的连接，底层的 TCP 协议是不知道上层有多少个 HTTP 的请求的，所以，一旦发生丢包，造成的问题就是所有的 HTTP 请求都必需等待这个丢了的包被重传回来，哪怕丢的那个包不是我这个 HTTP 请求的。因为 TCP 底层是没有这个知识了。<br>这个问题又叫<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Head-of-line_blocking">Head-of-Line Blocking</a>问题，这也是一个比较经典的流量调度的问题。这个问题最早主要的发生的交换机上。下图来自 Wikipedia。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619340016971-6e74058e-b2cd-4cbf-beb0-72395835d6a5.png#clientId=u3004c439-86d6-4&from=paste&height=220&id=uf7bf408b&margin=%5Bobject%20Object%5D&originHeight=220&originWidth=423&originalType=url&status=done&style=none&taskId=ub4eb0e1b-6c53-4176-aae2-4fc02b731ed&width=423"><br>图中，左边的是输入队列，其中的 1，2，3，4 表示四个队列，四个队列中的 1，2，3，4 要去的右边的 output 的端口号。此时，第一个队列和第三个队列都要写右边的第四个端口，然后，一个时刻只能处理一个包，所以，一个队列只能在那等另一个队列写完后。然后，其此时的 3 号或 1 号端口是空闲的，而队列中的要去 1 和 3 号端号的数据，被第四号端口给 block 住了。这就是所谓的 HOL blocking 问题。<br>HTTP/1.1 中的 pipeline 中如果有一个请求 block 了，那么队列后请求也统统被 block 住了；HTTP/2 多请求复用一个 TCP 连接，一旦发生丢包，就会 block 住所有的 HTTP 请求。这样的问题很讨厌。好像基本无解了。<br>是的 TCP 是无解了，但是 UDP 是有解的 ！<strong>于是 HTTP/3 破天荒地把 HTTP 底层的 TCP 协议改成了 UDP！</strong><br>然后又是 Google 家的协议进入了标准 – QUIC （Quick UDP Internet Connections）。接下来是 QUIC 协议的几个重要的特性，为了讲清楚这些特性，我需要带着问题来讲（注：下面的网络知识，如果你看不懂的话，你需要学习一下《<a target="_blank" rel="noopener" href="https://book.douban.com/subject/1088054/">TCP/IP 详解</a>》一书（在我写 blog 的这 15 年里，这本书推荐了无数次了），或是看一下本站的《<a target="_blank" rel="noopener" href="https://coolshell.cn/articles/11564.html">TCP 的那些事</a>》。）：</p>
<ul>
<li>首先是上面的 Head-of-Line blocking 问题，在 UDP 的世界中，这个就没了。这个应该比较好理解，因为 UDP 不管顺序，不管丢包（当然，QUIC 的一个任务是要像 TCP 的一个稳定，所以 QUIC 有自己的丢包重传的机制）</li>
<li>TCP 是一个无私的协议，也就是说，如果网络上出现拥塞，大家都会丢包，于是大家都会进入拥塞控制的算法中，这个算法会让所有人都“冷静”下来，然后进入一个“慢启动”的过程，包括在 TCP 连接建立时，这个慢启动也在，所以导致 TCP 性能迸发地比较慢。QUIC 基于 UDP，使用更为激进的方式。同时，QUIC 有一套自己的丢包重传和拥塞控制的协，一开始 QUIC 是重新实现一 TCP 的 CUBIC 算法，但是随着 BBR 算法的成熟（BBR 也在借鉴 CUBIC 算法的数学模型），QUIC 也可以使用 BBR 算法。这里，多说几句，<strong>从模型来说，以前的 TCP 的拥塞控制算法玩的是数学模型，而新型的 TCP 拥塞控制算法是以 BBR 为代表的测量模型</strong>，理论上来说，后者会更好，但 QUIC 的团队在一开始觉得 BBR 不如 CUBIC 的算法好，所以没有用。现在的 BBR 2.x 借鉴了 CUBIC 数学模型让拥塞控制更公平。这里有文章大家可以一读“<a target="_blank" rel="noopener" href="https://medium.com/google-cloud/tcp-bbr-magic-dust-for-network-performance-57a5f1ccf437">TCP BBR : Magic dust for network performance.</a>”</li>
<li>接下来，现在要建立一个 HTTPS 的连接，先是 TCP 的三次握手，然后是 TLS 的三次握手，要整出六次网络交互，一个链接才建好，虽说 HTTP/1.1 和 HTTP/2 的连接复用解决这个问题，但是基于 UDP 后，UDP 也得要实现这个事。于是 QUIC 直接把 TCP 的和 TLS 的合并成了三次握手（对此，在 HTTP/2 的时候，是否默认开启 TLS 业内是有争议的，反对派说，TLS 在一些情况下是不需要的，比如企业内网的时候，而支持派则说，TLS 的那些开销，什么也不算了）。<table>
<thead>
<tr>
<th><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619340017332-1af02e02-b10f-448e-ac65-185fb884f598.png#clientId=u3004c439-86d6-4&from=paste&height=300&id=u97051975&margin=%5Bobject%20Object%5D&originHeight=300&originWidth=292&originalType=url&status=done&style=none&taskId=u37c6b49e-6a2e-486b-bda5-30b41af6465&width=292"></th>
<th><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619340018661-91c999e2-fa97-45fb-b47e-1f4fb74d8200.png#clientId=u3004c439-86d6-4&from=paste&height=215&id=u7bd4a36d&margin=%5Bobject%20Object%5D&originHeight=215&originWidth=300&originalType=url&status=done&style=none&taskId=uaa7f25e5-dd58-4049-a7bf-793849522ba&width=300"></th>
</tr>
</thead>
</table>
</li>
</ul>
<p>所以，QUIC 是一个在 UDP 之上的伪 TCP +TLS +HTTP/2 的多路复用的协议。<br>但是对于 UDP 还是有一些挑战的，这个挑战主要来自互联网上的各种网络设备，这些设备根本不知道是什么 QUIC，他们看 QUIC 就只能看到的就是 UDP，所以，在一些情况下，UDP 就是有问题的，</p>
<ul>
<li>比如在 NAT 的环境下，如果是 TCP 的话，NAT 路由或是代理服务器，可以通过记录 TCP 的四元组（源地址、源端口，目标地址，目标端口）来做连接映射的，然而，在 UDP 的情况下不行了。于是，QUIC 引入了个叫 connection id 的不透明的 ID 来标识一个链接，用这种业务 ID 很爽的一个事是，如果你从你的 3G/4G 的网络切到 WiFi 网络（或是反过来），你的链接不会断，因为我们用的是 connection id，而不是四元组。</li>
<li>然而就算引用了 connection id，也还是会有问题 ，比如一些不够“聪明”的等价路由交换机，这些交换机会通过四元组来做 hash 把你的请求的 IP 转到后端的实际的服务器上，然而，他们不懂 connection id，只懂四元组，这么导致属于同一个 connection id 但是四元组不同的网络包就转到了不同的服务器上，这就是导致数据不能传到同一台服务器上，数据不完整，链接只能断了。所以，你需要更聪明的算法（可以参看 Facebook 的<a target="_blank" rel="noopener" href="https://github.com/facebookincubator/katran">Katran</a>开源项目 ）</li>
</ul>
<p>好了，就算搞定上面的东西，还有一些业务层的事没解，这个事就是 HTTP/2 的头压缩算法 HPACK，HPACK 需要维护一个动态的字典表来分析请求的头中哪些是重复的，HPACK 的这个数据结构需要在 encoder 和 decoder 端同步这个东西。在 TCP 上，这种同步是透明的，然而在 UDP 上这个事不好干了。所以，这个事也必需要重新设计了，基于 QUIC 的 QPACK 就出来了，利用两个附加的 QUIC steam，一个用来发送这个字典表的更新给对方，另一个用来 ack 对方发过来的 update。<br>目前看下来，HTTP/3 目前看上去没有太多的协议业务逻辑上的东西，更多是 HTTP/2 + QUIC 协议。但，HTTP/3 因为动到了底层协议，所以，在普及方面上可能会比 HTTP/2 要慢的多的多。但是，可以看到 QUIC 协议的强大，细思及恐，QUIC 这个协议真对 TCP 是个威胁，如果 QUIC 成熟了，TCP 是不是会有可能成为历史呢？<br>未来十年，让我们看看 UDP 是否能够逆袭 TCP……</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/24/yuque/URL%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/24/yuque/URL%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2/" class="post-title-link" itemprop="url">URL到浏览器显示页面</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-24 23:46:03" itemprop="dateCreated datePublished" datetime="2021-04-24T23:46:03+08:00">2021-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-25 16:49:30" itemprop="dateModified" datetime="2021-04-25T16:49:30+08:00">2021-04-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>面试中常被问到的问题，此问题包含 web 开发中从前端到后端到运维的绝大多数知识，主要考察面试者知识的广度。本文会根据作者了解的程度增加不断更新，不足之处欢迎评论区补充。</p>
</blockquote>
<h2 id="浏览器中输入网址。"><a href="#浏览器中输入网址。" class="headerlink" title="浏览器中输入网址。"></a>浏览器中输入网址。</h2><ul>
<li>http 或 https</li>
<li>url 的组成：<a target="_blank" rel="noopener" href="https://blog.csdn.net/ergouge/article/details/8185219">详解 url 的组成</a></li>
</ul>
<h2 id="通过-DNS-解析域名的实际-IP-地址"><a href="#通过-DNS-解析域名的实际-IP-地址" class="headerlink" title="通过 DNS 解析域名的实际 IP 地址"></a>通过 DNS 解析域名的实际 IP 地址</h2><p>发送至 DNS 服务器并获得域名对应的 WEB 服务器的 ip 地址。</p>
<p>DNS 解析首先会从你的浏览器的缓存中去寻找是否有这个网址对应的 IP 地址，如果没有就向 OS 系统的 DNS 缓存中寻找，如果没有就是路由器的 DNS 缓存， 如果没有就是 ISP 的 DNS 缓存中寻找。</p>
<p>所以，缓存的寻找过程就是： 浏览器 -&gt; 系统 -&gt; 路由器 -&gt; ISP。</p>
<p>如果在某一个缓存中找到的话，就直接跳到下一步。</p>
<p>如果都没有找到的话，就会向 ISP 或者公共的域名解析服务发起 DNS 查找请求。这个查找的过程还是一个递归查询的过程。</p>
<h2 id="检查浏览器是否有缓存"><a href="#检查浏览器是否有缓存" class="headerlink" title="检查浏览器是否有缓存"></a>检查浏览器是否有缓存</h2><ol>
<li>通过<code>Cache-Control</code>和<code>Expires</code>来检查是否命中强缓存，命中则直接取本地磁盘的 html（状态码为 200 from disk(or memory)  cache，内存 or 磁盘）；</li>
<li>如果没有命中强缓存，则会向服务器发起请求（先进行下一步的 TCP 连接），服务器通过<code>Etag</code>和<code>Last-Modify</code>来与服务器确认返回的响应是否被更改（协商缓存），若无更改则返回状态码（304 Not Modified）,浏览器取本地缓存；</li>
<li>若强缓存和协商缓存都没有命中则返回请求结果。</li>
</ol>
<h2 id="与-WEB-服务器建立-TCP-连接。"><a href="#与-WEB-服务器建立-TCP-连接。" class="headerlink" title="与 WEB 服务器建立 TCP 连接。"></a>与 WEB 服务器建立 TCP 连接。</h2><p>TCP 协议通过三次握手建立连接。</p>
<ul>
<li>客户端通过 <code>SYN</code> 报文段发送连接请求，确定服务端是否开启端口准备连接。状态设置为 <code>SYN_SEND</code>;</li>
<li>服务器如果有开着的端口并且决定接受连接，就会返回一个 <code>SYN+ACK</code> 报文段给客户端，状态设置为 <code>SYN_RECV</code>；</li>
<li>客户端收到服务器的 <code>SYN+ACK</code> 报文段，向服务器发送 <code>ACK</code> 报文段表示确认。此时客户端和服务器都设置为 <code>ESTABLISHED</code> 状态。连接建立，可以开始数据传输了。</li>
</ul>
<p>翻译成大白话就是：</p>
<ol>
<li><strong>客户端</strong>：你能接收到我的消息吗？</li>
<li><strong>服务端</strong>：可以的，那你能接收到我的回复吗？</li>
<li><strong>客户端</strong>：可以，那我们开始聊正事吧。</li>
</ol>
<p><strong>为什么是 3 次？</strong>：避免历史连接，确认客户端发来的请求是这次通信的人。</p>
<p><strong>为什么不是 4 次？</strong>：3 次够了第四次浪费</p>
<h2 id="若协议是-https-则会做加密"><a href="#若协议是-https-则会做加密" class="headerlink" title="若协议是 https 则会做加密"></a>若协议是 https 则会做加密</h2><blockquote>
<p>HTTPS = HTTP + 加密 + 认证 + 完整性保护</p>
</blockquote>
<ol>
<li><p>要先申请 CA 证书，并安装在服务器上（一个文件，配置 nginx 支持监听 443 端口开启 ssl 并设置证书路径）</p>
</li>
<li><p>浏览器发送请求；</p>
</li>
<li><p>网站从浏览器发过来的加密规则中选一组自身也支持的加密算法和 hash 算法，并向浏览器发送带有公钥的证书，当然证书还包含了很多信息，如网站地址、证书的颁发机构、过期时间等。</p>
</li>
<li><p>浏览器解析证书。</p>
<ul>
<li>验证证书的合法性。如颁发机构是否合法、证书中的网站地址是否与访问的地址一致，若不合法，则浏览器提示证书不受信任，若合法，浏览器会显示一个小锁头。</li>
<li>若合法，或用户接受了不合法的证书，浏览器会生成一串随机数的密码（即密钥），并用证书中提供的公钥加密。</li>
<li>使用约定好的 hash 计算握手消息，并使用生成的随机数（即密钥）对消息进行加密，最后将之前生成的所有消息一并发送给网站服务器。</li>
</ul>
</li>
<li><p>网站服务器解析消息。用已有的私钥将密钥解密出来，然后用密钥解密发过来的握手消息，并验证是否跟浏览器传过来的一致。然后再用密钥加密一段握手消息，发送给浏览器。</p>
</li>
<li><p>浏览器解密并计算握手消息的 HASH，如果与服务端发来的 HASH 一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。这里浏览器与网站互相发送加密的握手消息并验证，目的是为了保证双方都获得了一致的密码，并且可以正常的加密解密数据，为后续真正数据的传输做一次测试。</p>
</li>
</ol>
<p>下图表示 https 加密通信的过程：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619279748279-f31b3afe-7532-46ab-8566-db4421ad1171.png#clientId=u37cc9bb2-9070-4&from=drop&height=481&id=u3acfa706&margin=%5Bobject%20Object%5D&name=1.png&originHeight=1018&originWidth=1688&originalType=binary&size=1094387&status=done&style=none&taskId=u520b97c5-3c75-443e-b18f-29d22756029&width=797" alt="1.png"></p>
<h2 id="浏览器发送请求获取页面-html"><a href="#浏览器发送请求获取页面-html" class="headerlink" title="浏览器发送请求获取页面 html"></a>浏览器发送请求获取页面 html</h2><p>浏览器向 WEB 服务器的 ip 地址发送相应的 http get 请求页面 html。</p>
<p>通常的请求行是: 请求的方式（<code>get</code>或<code>post</code>） + 请求的资源的位置<code>（url） + HTTP/[版本号](HTTP/1.1)</code></p>
<p>发起 http 请求的过程主要是组装 http 报文并将报文发向指定地址的过程。</p>
<p>http 协议的具体信息可以参考：<a target="_blank" rel="noopener" href="https://www.runoob.com/http/http-tutorial.html">HTTP 介绍教程</a></p>
<h2 id="服务器响应-html"><a href="#服务器响应-html" class="headerlink" title="服务器响应 html"></a>服务器响应 html</h2><p>这里的服务器可能是 server 或者是<code>cdn</code></p>
<p>注：cdn - 内容分发网络，可用来加快传输速度，主要用来存储静态文件，例如前端的 html、css、js、图片文件等。具体请参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a64675c6b73b">CDN 概念基本介绍</a></p>
<p>服务器上可能会通过<code>nginx</code>等设置静态资源代理，将 url 对应的 html 等静态资源返回。</p>
<p><code>nginx</code>是常用的反向代理服务器，介绍请见：<a target="_blank" rel="noopener" href="https://www.w3cschool.cn/nginx/">Nginx 入门指南</a></p>
<p>如果网站是博客或者其他需要<code>seo</code>友好的页面，就需要做<code>服务端渲染</code>，这时服务器会根据模版和数据渲染好 html 文件返回给前端。</p>
<p>常见的服务端渲染方案有：<code>ejs</code>、<code>art-template</code>、等模版语法，也有基于 vue、react 等框架的服务端渲染框架<code>nuxt.js</code>及<code>next.js</code>等。</p>
<h2 id="浏览器解析-HTML"><a href="#浏览器解析-HTML" class="headerlink" title="浏览器解析 HTML"></a>浏览器解析 HTML</h2><ul>
<li>浏览器下载 HTML 数据，将 html 文档解析成为一个个<code>标签</code>，这些标签组成了<code>树状结构</code></li>
<li>如果解析到<code>style</code>标签则开始解析 css，如果解析到 link 标签则先异步下载，完成后解析 css。</li>
<li>如果遇到<code>script</code>标签，判断是行内写法则直接解析执行，如果是 src 引入则<code>同步下载</code>脚本文件，下载完成<code>立即执行</code>，注意这里下载过程是<code>阻塞</code>的，其他流程都会等下载完成后执行。</li>
</ul>
<p>浏览器解析 HTML 文档过程内容较多，详情请看:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Alan_1550587588/article/details/80297765">浏览器解析 HTML 文档过程</a></li>
</ul>
<h2 id="浏览器渲染页面"><a href="#浏览器渲染页面" class="headerlink" title="浏览器渲染页面"></a>浏览器渲染页面</h2><p>浏览器渲染页面的过程主要是解析 html 文档组成<code>标签节点树</code>，解析 css 形成<code>样式规则树</code>，标签节点树和样式规则树共同组成<code>渲染树</code>，浏览器最终显示渲染树形成页面。</p>
<ol>
<li>浏览器会将 HTML 解析成一个 DOM 树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。（更具体的解析 HTML 过程看上一篇博客：点击打开链接）</li>
<li>将 CSS 解析成 CSS Rule Tree（css 规则树） 。</li>
<li>解析完成后，浏览器引擎会根据 DOM 树和 CSS 规则树来构造 Render Tree。注意：Render Tree 渲染树并不等同于 DOM 树，因为一些像 Header 或 display:none 的东西就没必要放在渲染树中了。</li>
<li>有了 Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的 CSS 定义以及他们的从属关系。下一步进行 layout，进入布局处理阶段，即计算出每个节点在屏幕中的位置。</li>
<li>再下一步就是绘制，即遍历 RenderTree，并使用用户界面后端层绘制每个节点。根据计算好的信息绘制整个页面。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619279754931-71e1b816-1df9-4270-9cd1-4bca4ac29922.png#clientId=u37cc9bb2-9070-4&from=drop&height=199&id=u9bc63186&margin=%5Bobject%20Object%5D&name=2.png&originHeight=199&originWidth=780&originalType=binary&size=51388&status=done&style=none&taskId=u65fb4878-9097-475e-9b3c-ccd72188738&width=780" alt="2.png"></p>
<p>注意：上述这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p>
<h2 id="浏览器解析执行-js-脚本"><a href="#浏览器解析执行-js-脚本" class="headerlink" title="浏览器解析执行 js 脚本"></a>浏览器解析执行 js 脚本</h2><p>这个过程中可能会有 dom 操作、ajax 发起的 http 网络请求等。</p>
<h2 id="浏览器发起网络请求"><a href="#浏览器发起网络请求" class="headerlink" title="浏览器发起网络请求"></a>浏览器发起网络请求</h2><p>web-socket、ajax 等，这个过程通常是为了获取数据</p>
<h2 id="服务器响应-ajax-请求"><a href="#服务器响应-ajax-请求" class="headerlink" title="服务器响应 ajax 请求"></a>服务器响应 ajax 请求</h2><ul>
<li>ajax 请求在到达真正的 server 之前，可能还会经过网关全线校验、消息队列或 nginx 等负载均衡处理</li>
<li>到达 server 后，后端会解析 http 请求报文，得到 url、请求参数、http 头、cookie 等等信息</li>
<li>登录校验、权限校验（cookie 校验、jwt 权限校验等）</li>
<li>可能会查询数据库，进行常用的 CRUD（增删改查）等操作</li>
<li>返回响应数据</li>
</ul>
<h2 id="浏览器处理事件循环等异步逻辑。"><a href="#浏览器处理事件循环等异步逻辑。" class="headerlink" title="浏览器处理事件循环等异步逻辑。"></a>浏览器处理事件循环等异步逻辑。</h2><p>setTimeout、setInterval、Promise 等宏任务、微任务队列</p>
<h3 id="不足之处，欢迎在评论区补充，作者会不断更新"><a href="#不足之处，欢迎在评论区补充，作者会不断更新" class="headerlink" title="不足之处，欢迎在评论区补充，作者会不断更新"></a>不足之处，欢迎在评论区补充，作者会不断更新</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/24/yuque/7%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/24/yuque/7%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">7层网络模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-24 23:08:25" itemprop="dateCreated datePublished" datetime="2021-04-24T23:08:25+08:00">2021-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-25 16:49:30" itemprop="dateModified" datetime="2021-04-25T16:49:30+08:00">2021-04-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="OSI-7-层模型"><a href="#OSI-7-层模型" class="headerlink" title="OSI 7 层模型"></a>OSI 7 层模型</h1><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619337764989-c0cc8a7f-0273-4277-9f96-cfc9212a794c.jpeg#clientId=ub0d3f151-ef7c-4&from=paste&height=471&id=u371344af&margin=%5Bobject%20Object%5D&originHeight=471&originWidth=733&originalType=url&status=done&style=none&taskId=u1d68eee8-a446-4557-a294-a07339a35e5&width=733"><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619339722536-9fca8fdc-3080-45a7-ab91-c29cdb0b9fab.jpeg#clientId=ub0d3f151-ef7c-4&from=paste&height=427&id=u55fa8a9d&margin=%5Bobject%20Object%5D&originHeight=427&originWidth=720&originalType=url&status=done&style=none&taskId=ued4cc0b2-afc7-4326-b897-8e392275d5e&width=720"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/24/yuque/promise_async_generator%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/24/yuque/promise_async_generator%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">promise_async_generator原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-24 18:48:01" itemprop="dateCreated datePublished" datetime="2021-04-24T18:48:01+08:00">2021-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-25 16:49:31" itemprop="dateModified" datetime="2021-04-25T16:49:31+08:00">2021-04-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>笔者刚接触<code>async/await</code>时，就被其暂停执行的特性吸引了，心想在没有原生 API 支持的情况下，await 居然能挂起当前方法，实现暂停执行，我感到十分好奇。好奇心驱使我一层一层剥开有关 JS 异步编程的一切。阅读完本文，读者应该能够了解：</p>
<ol>
<li><code>Promise</code>的实现原理</li>
<li><code>async/await</code>的实现原理</li>
<li><code>Generator</code>的实现原理</li>
</ol>
<h1 id="Promise-实现"><a href="#Promise-实现" class="headerlink" title="Promise 实现"></a>Promise 实现</h1><p>在成文过程中，笔者查阅了很多讲解 Promise 实现的文章，但感觉大多文章都很难称得上条理清晰，有的上来就放大段 Promise 规范翻译，有的在 Promise 基础使用上浪费篇幅，又或者把一个简单的东西长篇大论，过度讲解，我推荐头铁的同学直接拉到本章小结看最终实现，结合着注释直接啃代码也能理解十之八九</p>
<p>回归正题，文章开头我们先点一下 Promise 为我们解决了什么问题：在传统的异步编程中，如果异步之间存在依赖关系，我们就需要通过层层嵌套回调来满足这种依赖，如果嵌套层数过多，可读性和可维护性都变得很差，产生所谓“回调地狱”，而 Promise 将回调嵌套改为链式调用，增加可读性和可维护性。下面我们就来一步步实现一个 Promise：</p>
<h2 id="1-观察者模式"><a href="#1-观察者模式" class="headerlink" title="1. 观察者模式"></a>1. 观察者模式</h2><p>我们先来看一个最简单的 Promise 使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const p1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        resolve(&#39;result&#39;)</span><br><span class="line">    &#125;,</span><br><span class="line">    1000);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(res &#x3D;&gt; console.log(res), err &#x3D;&gt; console.log(err))</span><br></pre></td></tr></table></figure>

<p>观察这个例子，我们分析 Promise 的调用流程：</p>
<ul>
<li><code>Promise</code>的构造方法接收一个<code>executor()</code>，在<code>new Promise()</code>时就立刻执行这个 executor 回调</li>
<li><code>executor()</code>内部的异步任务被放入宏/微任务队列，等待执行</li>
<li><code>then()</code>被执行，收集成功/失败回调，放入成功/失败队列</li>
<li><code>executor()</code>的异步任务被执行，触发<code>resolve/reject</code>，从成功/失败队列中取出回调依次执行</li>
</ul>
<p>其实熟悉设计模式的同学，很容易就能意识到这是个<strong>观察者模式</strong>，这种<code>收集依赖 -&gt; 触发通知 -&gt; 取出依赖执行</code> 的方式，被广泛运用于观察者模式的实现，在 Promise 里，执行顺序是<code>then收集依赖 -&gt; 异步触发resolve -&gt; resolve执行依赖</code>。依此，我们可以勾勒出 Promise 的大致形状：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class MyPromise &#123;</span><br><span class="line">  &#x2F;&#x2F; 构造方法接收一个回调</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    this._resolveQueue &#x3D; []    &#x2F;&#x2F; then收集的执行成功的回调队列</span><br><span class="line">    this._rejectQueue &#x3D; []     &#x2F;&#x2F; then收集的执行失败的回调队列</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 由于resolve&#x2F;reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue</span><br><span class="line">    let _resolve &#x3D; (val) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 从成功队列里取出回调依次执行</span><br><span class="line">      while(this._resolveQueue.length) &#123;</span><br><span class="line">        const callback &#x3D; this._resolveQueue.shift()</span><br><span class="line">        callback(val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 实现同resolve</span><br><span class="line">    let _reject &#x3D; (val) &#x3D;&gt; &#123;</span><br><span class="line">      while(this._rejectQueue.length) &#123;</span><br><span class="line">        const callback &#x3D; this._rejectQueue.shift()</span><br><span class="line">        callback(val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; new Promise()时立即执行executor,并传入resolve和reject</span><br><span class="line">    executor(_resolve, _reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; then方法,接收一个成功的回调和一个失败的回调，并push进对应队列</span><br><span class="line">  then(resolveFn, rejectFn) &#123;</span><br><span class="line">    this._resolveQueue.push(resolveFn)</span><br><span class="line">    this._rejectQueue.push(rejectFn)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写完代码我们可以测试一下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const p1 &#x3D; new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    resolve(&#39;result&#39;)</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(res &#x3D;&gt; console.log(res))</span><br><span class="line">&#x2F;&#x2F;一秒后输出result</span><br></pre></td></tr></table></figure>

<p>我们运用观察者模式简单的实现了一下<code>then</code>和<code>resolve</code>，使我们能够在 then 方法的回调里取得异步操作的返回值，但我们这个 Promise 离最终实现还有很长的距离，下面我们来一步步补充这个 Promise：</p>
<h2 id="2-Promise-A-规范"><a href="#2-Promise-A-规范" class="headerlink" title="2. Promise A+规范"></a>2. Promise A+规范</h2><p>上面我们已经简单地实现了一个超低配版 Promise，但我们会看到很多文章和我们写的不一样，他们的 Promise 实现中还引入了各种状态控制，这是由于 ES6 的 Promise 实现需要遵循<a target="_blank" rel="noopener" href="https://promisesaplus.com/">Promise/A+规范</a>，是规范对 Promise 的状态控制做了要求。Promise/A+的规范比较长，这里只总结两条核心规则：</p>
<blockquote>
</blockquote>
<blockquote>
<ol>
<li>Promise 本质是一个状态机，且状态只能为以下三种：<code>Pending（等待态）</code>、<code>Fulfilled（执行态）</code>、<code>Rejected（拒绝态）</code>，状态的变更是单向的，只能从 Pending -&gt; Fulfilled 或 Pending -&gt; Rejected，状态变更不可逆</li>
<li><code>then方法</code>接收两个可选参数，分别对应状态改变时触发的回调。then 方法返回一个 promise。then 方法可以被同一个 promise 调用多次。</li>
</ol>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/21377586/1619261340785-d4ebe2d3-dbff-4710-96d6-bbc7abc32282.webp#clientId=u0787e3d2-71b0-4&from=drop&height=174&id=u478ca980&margin=%5Bobject%20Object%5D&name=1.webp&originHeight=174&originWidth=318&originalType=binary&size=6028&status=done&style=none&taskId=uf7f1c65c-14e0-4750-8395-a02cb223112&width=318" alt="1.webp"></p>
<p>根据规范，我们补充一下 Promise 的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Promise&#x2F;A+规范的三种状态</span><br><span class="line">const PENDING &#x3D; &#39;pending&#39;</span><br><span class="line">const FULFILLED &#x3D; &#39;fulfilled&#39;</span><br><span class="line">const REJECTED &#x3D; &#39;rejected&#39;</span><br><span class="line"></span><br><span class="line">class MyPromise &#123;</span><br><span class="line">  &#x2F;&#x2F; 构造方法接收一个回调</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    this._status &#x3D; PENDING     &#x2F;&#x2F; Promise状态</span><br><span class="line">    this._resolveQueue &#x3D; []    &#x2F;&#x2F; 成功队列, resolve时触发</span><br><span class="line">    this._rejectQueue &#x3D; []     &#x2F;&#x2F; 失败队列, reject时触发</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 由于resolve&#x2F;reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue</span><br><span class="line">    let _resolve &#x3D; (val) &#x3D;&gt; &#123;</span><br><span class="line">      if(this._status !&#x3D;&#x3D; PENDING) return   &#x2F;&#x2F; 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span><br><span class="line">      this._status &#x3D; FULFILLED              &#x2F;&#x2F; 变更状态</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 这里之所以使用一个队列来储存回调,是为了实现规范要求的 &quot;then 方法可以被同一个 promise 调用多次&quot;</span><br><span class="line">      &#x2F;&#x2F; 如果使用一个变量而非队列来储存回调,那么即使多次p1.then()也只会执行一次回调</span><br><span class="line">      while(this._resolveQueue.length) &#123;</span><br><span class="line">        const callback &#x3D; this._resolveQueue.shift()</span><br><span class="line">        callback(val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 实现同resolve</span><br><span class="line">    let _reject &#x3D; (val) &#x3D;&gt; &#123;</span><br><span class="line">      if(this._status !&#x3D;&#x3D; PENDING) return   &#x2F;&#x2F; 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span><br><span class="line">      this._status &#x3D; REJECTED               &#x2F;&#x2F; 变更状态</span><br><span class="line">      while(this._rejectQueue.length) &#123;</span><br><span class="line">        const callback &#x3D; this._rejectQueue.shift()</span><br><span class="line">        callback(val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; new Promise()时立即执行executor,并传入resolve和reject</span><br><span class="line">    executor(_resolve, _reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; then方法,接收一个成功的回调和一个失败的回调</span><br><span class="line">  then(resolveFn, rejectFn) &#123;</span><br><span class="line">    this._resolveQueue.push(resolveFn)</span><br><span class="line">    this._rejectQueue.push(rejectFn)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-then-的链式调用"><a href="#3-then-的链式调用" class="headerlink" title="3. then 的链式调用"></a>3. then 的链式调用</h2><p>补充完规范，我们接着来实现链式调用，这是 Promise 实现的重点和难点，我们先来看一下 then 是如何链式调用的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const p1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(1)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1</span><br><span class="line">  .then(res &#x3D;&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">    &#x2F;&#x2F;then回调中可以return一个Promise</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        resolve(2)</span><br><span class="line">      &#125;, 1000);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res &#x3D;&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">    &#x2F;&#x2F;then回调中也可以return一个值</span><br><span class="line">    return 3</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res &#x3D;&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>我们思考一下如何实现这种链式调用：</p>
<ol>
<li>显然<code>.then()</code>需要返回一个 Promise，这样才能找到 then 方法，所以我们会把 then 方法的返回值包装成 Promise。</li>
<li><code>.then()</code>的回调需要拿到上一个<code>.then()</code>的返回值</li>
<li><code>.then()</code>的回调需要顺序执行，以上面这段代码为例，虽然中间 return 了一个 Promise，但执行顺序仍要保证是 1-&gt;2-&gt;3。我们要等待当前 Promise 状态变更后，再执行下一个 then 收集的回调，这就要求我们对 then 的返回值分类讨论</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; then方法</span><br><span class="line">then(resolveFn, rejectFn) &#123;</span><br><span class="line">  &#x2F;&#x2F;return一个新的promise</span><br><span class="line">  return new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span><br><span class="line">    const fulfilledFn &#x3D; value &#x3D;&gt; &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        &#x2F;&#x2F;执行第一个(当前的)Promise的成功回调,并获取返回值</span><br><span class="line">        let x &#x3D; resolveFn(value)</span><br><span class="line">        &#x2F;&#x2F;分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span><br><span class="line">        &#x2F;&#x2F;这里resolve之后，就能被下一个.then()的回调获取到返回值，从而实现链式调用</span><br><span class="line">        x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">      &#125; catch (error) &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;把后续then收集的依赖都push进当前Promise的成功回调队列中(_rejectQueue), 这是为了保证顺序调用</span><br><span class="line">    this._resolveQueue.push(fulfilledFn)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;reject同理</span><br><span class="line">    const rejectedFn  &#x3D; error &#x3D;&gt; &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        let x &#x3D; rejectFn(error)</span><br><span class="line">        x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">      &#125; catch (error) &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    this._rejectQueue.push(rejectedFn)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们就能测试一下链式调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const p1 &#x3D; new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    resolve(1)</span><br><span class="line">  &#125;, 500);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1</span><br><span class="line">  .then(res &#x3D;&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">    return 2</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res &#x3D;&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">    return 3</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res &#x3D;&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出 1 2 3</span><br></pre></td></tr></table></figure>

<h2 id="4-值穿透-amp-状态已变更的情况"><a href="#4-值穿透-amp-状态已变更的情况" class="headerlink" title="4.值穿透 &amp; 状态已变更的情况"></a>4.值穿透 &amp; 状态已变更的情况</h2><p>我们已经初步完成了链式调用，但是对于 then() 方法，我们还要两个细节需要处理一下</p>
<ol>
<li><strong>值穿透</strong>：根据规范，如果 then() 接收的参数不是 function，那么我们应该忽略它。如果没有忽略，当 then()回调不为 function 时将会抛出异常，导致链式调用中断</li>
<li><strong>处理状态为 resolve/reject 的情况</strong>：其实我们上边 then() 的写法是对应状态为<code>padding</code>的情况，但是有些时候，resolve/reject 在 then() 之前就被执行（比如<code>Promise.resolve().then()</code>），如果这个时候还把 then()回调 push 进 resolve/reject 的执行队列里，那么回调将不会被执行，因此对于状态已经变为<code>fulfilled</code>或<code>rejected</code>的情况，我们直接执行 then 回调：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; then方法,接收一个成功的回调和一个失败的回调</span><br><span class="line">  then(resolveFn, rejectFn) &#123;</span><br><span class="line">    &#x2F;&#x2F; 根据规范，如果then的参数不是function，则我们需要忽略它, 让链式调用继续往下执行</span><br><span class="line">    typeof resolveFn !&#x3D;&#x3D; &#39;function&#39; ? resolveFn &#x3D; value &#x3D;&gt; value : null</span><br><span class="line">    typeof rejectFn !&#x3D;&#x3D; &#39;function&#39; ? rejectFn &#x3D; reason &#x3D;&gt; &#123;</span><br><span class="line">      throw new Error(reason instanceof Error? reason.message:reason);</span><br><span class="line">    &#125; : null</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; return一个新的promise</span><br><span class="line">    return new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span><br><span class="line">      const fulfilledFn &#x3D; value &#x3D;&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          &#x2F;&#x2F; 执行第一个(当前的)Promise的成功回调,并获取返回值</span><br><span class="line">          let x &#x3D; resolveFn(value)</span><br><span class="line">          &#x2F;&#x2F; 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span><br><span class="line">          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; reject同理</span><br><span class="line">      const rejectedFn  &#x3D; error &#x3D;&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          let x &#x3D; rejectFn(error)</span><br><span class="line">          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      switch (this._status) &#123;</span><br><span class="line">        &#x2F;&#x2F; 当状态为pending时,把then回调push进resolve&#x2F;reject执行队列,等待执行</span><br><span class="line">        case PENDING:</span><br><span class="line">          this._resolveQueue.push(fulfilledFn)</span><br><span class="line">          this._rejectQueue.push(rejectedFn)</span><br><span class="line">          break;</span><br><span class="line">        &#x2F;&#x2F; 当状态已经变为resolve&#x2F;reject时,直接执行then回调</span><br><span class="line">        case FULFILLED:</span><br><span class="line">          fulfilledFn(this._value)    &#x2F;&#x2F; this._value是上一个then回调return的值(见完整版代码)</span><br><span class="line">          break;</span><br><span class="line">        case REJECTED:</span><br><span class="line">          rejectedFn(this._value)</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-兼容同步任务"><a href="#5-兼容同步任务" class="headerlink" title="5.兼容同步任务"></a>5.兼容同步任务</h2><p>完成了 then 的链式调用以后，我们再处理一个前边的细节，然后放出完整代码。上文我们说过，Promise 的执行顺序是<code>new Promise -&gt; then()收集回调 -&gt; resolve/reject执行回调</code>，这一顺序是建立在<strong>executor 是异步任务</strong>的前提上的，如果 executor 是一个同步任务，那么顺序就会变成<code>new Promise -&gt; resolve/reject执行回调 -&gt; then()收集回调</code>，resolve 的执行跑到 then 之前去了，为了兼容这种情况，我们给<code>resolve/reject</code>执行回调的操作包一个 setTimeout，让它异步执行。</p>
<blockquote>
<p>这里插一句，有关这个 setTimeout，其实还有一番学问。虽然规范没有要求回调应该被放进宏任务队列还是微任务队列，但其实 Promise 的默认实现是放进了微任务队列，我们的实现（包括大多数 Promise 手动实现和 polyfill 的转化）都是使用 setTimeout 放入了宏任务队列（当然我们也可以用 MutationObserver 模拟微任务）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Promise&#x2F;A+规定的三种状态</span><br><span class="line">const PENDING &#x3D; &#39;pending&#39;</span><br><span class="line">const FULFILLED &#x3D; &#39;fulfilled&#39;</span><br><span class="line">const REJECTED &#x3D; &#39;rejected&#39;</span><br><span class="line"></span><br><span class="line">class MyPromise &#123;</span><br><span class="line">  &#x2F;&#x2F; 构造方法接收一个回调</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    this._status &#x3D; PENDING     &#x2F;&#x2F; Promise状态</span><br><span class="line">    this._value &#x3D; undefined    &#x2F;&#x2F; 储存then回调return的值</span><br><span class="line">    this._resolveQueue &#x3D; []    &#x2F;&#x2F; 成功队列, resolve时触发</span><br><span class="line">    this._rejectQueue &#x3D; []     &#x2F;&#x2F; 失败队列, reject时触发</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 由于resolve&#x2F;reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue</span><br><span class="line">    let _resolve &#x3D; (val) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F;把resolve执行回调的操作封装成一个函数,放进setTimeout里,以兼容executor是同步代码的情况</span><br><span class="line">      const run &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        if(this._status !&#x3D;&#x3D; PENDING) return   &#x2F;&#x2F; 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span><br><span class="line">        this._status &#x3D; FULFILLED              &#x2F;&#x2F; 变更状态</span><br><span class="line">        this._value &#x3D; val                     &#x2F;&#x2F; 储存当前value</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 这里之所以使用一个队列来储存回调,是为了实现规范要求的 &quot;then 方法可以被同一个 promise 调用多次&quot;</span><br><span class="line">        &#x2F;&#x2F; 如果使用一个变量而非队列来储存回调,那么即使多次p1.then()也只会执行一次回调</span><br><span class="line">        while(this._resolveQueue.length) &#123;</span><br><span class="line">          const callback &#x3D; this._resolveQueue.shift()</span><br><span class="line">          callback(val)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      setTimeout(run)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 实现同resolve</span><br><span class="line">    let _reject &#x3D; (val) &#x3D;&gt; &#123;</span><br><span class="line">      const run &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        if(this._status !&#x3D;&#x3D; PENDING) return   &#x2F;&#x2F; 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span><br><span class="line">        this._status &#x3D; REJECTED               &#x2F;&#x2F; 变更状态</span><br><span class="line">        this._value &#x3D; val                     &#x2F;&#x2F; 储存当前value</span><br><span class="line">        while(this._rejectQueue.length) &#123;</span><br><span class="line">          const callback &#x3D; this._rejectQueue.shift()</span><br><span class="line">          callback(val)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      setTimeout(run)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; new Promise()时立即执行executor,并传入resolve和reject</span><br><span class="line">    executor(_resolve, _reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; then方法,接收一个成功的回调和一个失败的回调</span><br><span class="line">  then(resolveFn, rejectFn) &#123;</span><br><span class="line">    &#x2F;&#x2F; 根据规范，如果then的参数不是function，则我们需要忽略它, 让链式调用继续往下执行</span><br><span class="line">    typeof resolveFn !&#x3D;&#x3D; &#39;function&#39; ? resolveFn &#x3D; value &#x3D;&gt; value : null</span><br><span class="line">    typeof rejectFn !&#x3D;&#x3D; &#39;function&#39; ? rejectFn &#x3D; reason &#x3D;&gt; &#123;</span><br><span class="line">      throw new Error(reason instanceof Error? reason.message:reason);</span><br><span class="line">    &#125; : null</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; return一个新的promise</span><br><span class="line">    return new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span><br><span class="line">      const fulfilledFn &#x3D; value &#x3D;&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          &#x2F;&#x2F; 执行第一个(当前的)Promise的成功回调,并获取返回值</span><br><span class="line">          let x &#x3D; resolveFn(value)</span><br><span class="line">          &#x2F;&#x2F; 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span><br><span class="line">          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; reject同理</span><br><span class="line">      const rejectedFn  &#x3D; error &#x3D;&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          let x &#x3D; rejectFn(error)</span><br><span class="line">          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      switch (this._status) &#123;</span><br><span class="line">        &#x2F;&#x2F; 当状态为pending时,把then回调push进resolve&#x2F;reject执行队列,等待执行</span><br><span class="line">        case PENDING:</span><br><span class="line">          this._resolveQueue.push(fulfilledFn)</span><br><span class="line">          this._rejectQueue.push(rejectedFn)</span><br><span class="line">          break;</span><br><span class="line">        &#x2F;&#x2F; 当状态已经变为resolve&#x2F;reject时,直接执行then回调</span><br><span class="line">        case FULFILLED:</span><br><span class="line">          fulfilledFn(this._value)    &#x2F;&#x2F; this._value是上一个then回调return的值(见完整版代码)</span><br><span class="line">          break;</span><br><span class="line">        case REJECTED:</span><br><span class="line">          rejectedFn(this._value)</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们可以测试一下这个 Promise：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const p1 &#x3D; new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(1)          &#x2F;&#x2F;同步executor测试</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1</span><br><span class="line">  .then(res &#x3D;&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">    return 2          &#x2F;&#x2F;链式调用测试</span><br><span class="line">  &#125;)</span><br><span class="line">  .then()             &#x2F;&#x2F;值穿透测试</span><br><span class="line">  .then(res &#x3D;&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">    return new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      resolve(3)      &#x2F;&#x2F;返回Promise测试</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res &#x3D;&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">    throw new Error(&#39;reject测试&#39;)   &#x2F;&#x2F;reject测试</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(() &#x3D;&gt; &#123;&#125;, err &#x3D;&gt; &#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F; 2</span><br><span class="line">&#x2F;&#x2F; 3</span><br><span class="line">&#x2F;&#x2F; Error: reject测试</span><br></pre></td></tr></table></figure>

<p>到这里，我们已经实现了 Promise 的主要功能<code>(｀∀´)Ψ</code>剩下的几个方法都非常简单，我们顺手收拾掉：</p>
<h2 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h2><blockquote>
<p><code>catch()方法</code>返回一个 Promise，并且处理拒绝的情况。它的行为与调用 Promise.prototype.then(undefined, onRejected) 相同。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;catch方法其实就是执行一下then的第二个回调</span><br><span class="line">catch(rejectFn) &#123;</span><br><span class="line">  return this.then(undefined, rejectFn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h2><blockquote>
<p><code>finally()方法</code>返回一个 Promise。在 promise 结束时，无论结果是 fulfilled 或者是 rejected，都会执行指定的回调函数。在 finally 之后，还可以继续 then。并且会将值原封不动的传递给后面的 then</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;finally方法</span><br><span class="line">finally(callback) &#123;</span><br><span class="line">  return this.then(</span><br><span class="line">    value &#x3D;&gt; MyPromise.resolve(callback()).then(() &#x3D;&gt; value),             &#x2F;&#x2F; MyPromise.resolve执行回调,并在then中return结果传递给后面的Promise</span><br><span class="line">    reason &#x3D;&gt; MyPromise.resolve(callback()).then(() &#x3D;&gt; &#123; throw reason &#125;)  &#x2F;&#x2F; reject同理</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS. 有同学问我<code>MyPromise.resolve(callback())</code>的意义，这里补充解释一下：这个写法其实涉及到一个<code>finally()</code>的使用细节，<strong>finally()如果 return 了一个 reject 状态的 Promise，将会改变当前 Promise 的状态</strong>，这个<code>MyPromise.resolve</code>就用于改变 Promise 状态，在 finally()没有返回 reject 态 Promise 或 throw 错误的情况下，去掉<code>MyPromise.resolve</code>也是一样的（欢迎大家向我提问，勘误的过程中也能很好地加深自己对 Promise 的理解，大家可以在各个交流群里直接@我）</p>
<blockquote>
<p>参考资料：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f0b94daf9bf7">对 Promise.prototype.finally() 的粗浅理解</a></p>
</blockquote>
<h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><blockquote>
<p><code>Promise.resolve(value)</code>方法返回一个以给定值解析后的 Promise 对象。如果该值为 promise，返回这个 promise；如果这个值是 thenable（即带有”then” 方法)），返回的 promise 会“跟随”这个 thenable 的对象，采用它的最终状态；否则返回的 promise 将以此值完成。此函数将类 promise 对象的多层嵌套展平。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;静态的resolve方法</span><br><span class="line">static resolve(value) &#123;</span><br><span class="line">  if(value instanceof MyPromise) return value &#x2F;&#x2F; 根据规范, 如果参数是Promise实例, 直接return这个实例</span><br><span class="line">  return new MyPromise(resolve &#x3D;&gt; resolve(value))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><blockquote>
<p><code>Promise.reject()</code>方法返回一个带有拒绝原因的 Promise 对象。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;静态的reject方法</span><br><span class="line">static reject(reason) &#123;</span><br><span class="line">  return new MyPromise((resolve, reject) &#x3D;&gt; reject(reason))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><blockquote>
<p><code>Promise.all(iterable)</code>方法返回一个 Promise 实例，此实例在 iterable 参数内所有的 promise 都“完成（resolved）”或参数中不包含 promise 时回调完成（resolve）；如果参数中 promise 有一个失败（rejected），此实例回调失败（reject），失败原因的是第一个失败 promise 的结果。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;静态的all方法</span><br><span class="line">static all(promiseArr) &#123;</span><br><span class="line">  let index &#x3D; 0</span><br><span class="line">  let result &#x3D; []</span><br><span class="line">  return new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    promiseArr.forEach((p, i) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F;Promise.resolve(p)用于处理传入值不为Promise的情况</span><br><span class="line">      MyPromise.resolve(p).then(</span><br><span class="line">        val &#x3D;&gt; &#123;</span><br><span class="line">          index++</span><br><span class="line">          result[i] &#x3D; val</span><br><span class="line">          &#x2F;&#x2F;所有then执行后, resolve结果</span><br><span class="line">          if(index &#x3D;&#x3D;&#x3D; promiseArr.length) &#123;</span><br><span class="line">            resolve(result)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        err &#x3D;&gt; &#123;</span><br><span class="line">          &#x2F;&#x2F;有一个Promise被reject时，MyPromise的状态变为reject</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><blockquote>
<p><code>Promise.race(iterable)</code>方法返回一个 promise，一旦迭代器中的某个 promise 解决或拒绝，返回的 promise 就会解决或拒绝。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static race(promiseArr) &#123;</span><br><span class="line">  return new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;同时执行Promise,如果有一个Promise的状态发生改变,就变更新MyPromise的状态</span><br><span class="line">    for (let p of promiseArr) &#123;</span><br><span class="line">      MyPromise.resolve(p).then(  &#x2F;&#x2F;Promise.resolve(p)用于处理传入值不为Promise的情况</span><br><span class="line">        value &#x3D;&gt; &#123;</span><br><span class="line">          resolve(value)        &#x2F;&#x2F;注意这个resolve是上边new MyPromise的</span><br><span class="line">        &#125;,</span><br><span class="line">        err &#x3D;&gt; &#123;</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Promise&#x2F;A+规定的三种状态</span><br><span class="line">const PENDING &#x3D; &#39;pending&#39;</span><br><span class="line">const FULFILLED &#x3D; &#39;fulfilled&#39;</span><br><span class="line">const REJECTED &#x3D; &#39;rejected&#39;</span><br><span class="line"></span><br><span class="line">class MyPromise &#123;</span><br><span class="line">  &#x2F;&#x2F; 构造方法接收一个回调</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    this._status &#x3D; PENDING     &#x2F;&#x2F; Promise状态</span><br><span class="line">    this._value &#x3D; undefined    &#x2F;&#x2F; 储存then回调return的值</span><br><span class="line">    this._resolveQueue &#x3D; []    &#x2F;&#x2F; 成功队列, resolve时触发</span><br><span class="line">    this._rejectQueue &#x3D; []     &#x2F;&#x2F; 失败队列, reject时触发</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 由于resolve&#x2F;reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue</span><br><span class="line">    let _resolve &#x3D; (val) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F;把resolve执行回调的操作封装成一个函数,放进setTimeout里,以兼容executor是同步代码的情况</span><br><span class="line">      const run &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        if(this._status !&#x3D;&#x3D; PENDING) return   &#x2F;&#x2F; 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span><br><span class="line">        this._status &#x3D; FULFILLED              &#x2F;&#x2F; 变更状态</span><br><span class="line">        this._value &#x3D; val                     &#x2F;&#x2F; 储存当前value</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 这里之所以使用一个队列来储存回调,是为了实现规范要求的 &quot;then 方法可以被同一个 promise 调用多次&quot;</span><br><span class="line">        &#x2F;&#x2F; 如果使用一个变量而非队列来储存回调,那么即使多次p1.then()也只会执行一次回调</span><br><span class="line">        while(this._resolveQueue.length) &#123;</span><br><span class="line">          const callback &#x3D; this._resolveQueue.shift()</span><br><span class="line">          callback(val)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      setTimeout(run)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 实现同resolve</span><br><span class="line">    let _reject &#x3D; (val) &#x3D;&gt; &#123;</span><br><span class="line">      const run &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        if(this._status !&#x3D;&#x3D; PENDING) return   &#x2F;&#x2F; 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span><br><span class="line">        this._status &#x3D; REJECTED               &#x2F;&#x2F; 变更状态</span><br><span class="line">        this._value &#x3D; val                     &#x2F;&#x2F; 储存当前value</span><br><span class="line">        while(this._rejectQueue.length) &#123;</span><br><span class="line">          const callback &#x3D; this._rejectQueue.shift()</span><br><span class="line">          callback(val)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      setTimeout(run)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; new Promise()时立即执行executor,并传入resolve和reject</span><br><span class="line">    executor(_resolve, _reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; then方法,接收一个成功的回调和一个失败的回调</span><br><span class="line">  then(resolveFn, rejectFn) &#123;</span><br><span class="line">    &#x2F;&#x2F; 根据规范，如果then的参数不是function，则我们需要忽略它, 让链式调用继续往下执行</span><br><span class="line">    typeof resolveFn !&#x3D;&#x3D; &#39;function&#39; ? resolveFn &#x3D; value &#x3D;&gt; value : null</span><br><span class="line">    typeof rejectFn !&#x3D;&#x3D; &#39;function&#39; ? rejectFn &#x3D; reason &#x3D;&gt; &#123;</span><br><span class="line">      throw new Error(reason instanceof Error? reason.message:reason);</span><br><span class="line">    &#125; : null</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; return一个新的promise</span><br><span class="line">    return new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span><br><span class="line">      const fulfilledFn &#x3D; value &#x3D;&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          &#x2F;&#x2F; 执行第一个(当前的)Promise的成功回调,并获取返回值</span><br><span class="line">          let x &#x3D; resolveFn(value)</span><br><span class="line">          &#x2F;&#x2F; 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span><br><span class="line">          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; reject同理</span><br><span class="line">      const rejectedFn  &#x3D; error &#x3D;&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          let x &#x3D; rejectFn(error)</span><br><span class="line">          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      switch (this._status) &#123;</span><br><span class="line">        &#x2F;&#x2F; 当状态为pending时,把then回调push进resolve&#x2F;reject执行队列,等待执行</span><br><span class="line">        case PENDING:</span><br><span class="line">          this._resolveQueue.push(fulfilledFn)</span><br><span class="line">          this._rejectQueue.push(rejectedFn)</span><br><span class="line">          break;</span><br><span class="line">        &#x2F;&#x2F; 当状态已经变为resolve&#x2F;reject时,直接执行then回调</span><br><span class="line">        case FULFILLED:</span><br><span class="line">          fulfilledFn(this._value)    &#x2F;&#x2F; this._value是上一个then回调return的值(见完整版代码)</span><br><span class="line">          break;</span><br><span class="line">        case REJECTED:</span><br><span class="line">          rejectedFn(this._value)</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;catch方法其实就是执行一下then的第二个回调</span><br><span class="line">  catch(rejectFn) &#123;</span><br><span class="line">    return this.then(undefined, rejectFn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;finally方法</span><br><span class="line">  finally(callback) &#123;</span><br><span class="line">    return this.then(</span><br><span class="line">      value &#x3D;&gt; MyPromise.resolve(callback()).then(() &#x3D;&gt; value),             &#x2F;&#x2F;执行回调,并returnvalue传递给后面的then</span><br><span class="line">      reason &#x3D;&gt; MyPromise.resolve(callback()).then(() &#x3D;&gt; &#123; throw reason &#125;)  &#x2F;&#x2F;reject同理</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;静态的resolve方法</span><br><span class="line">  static resolve(value) &#123;</span><br><span class="line">    if(value instanceof MyPromise) return value &#x2F;&#x2F;根据规范, 如果参数是Promise实例, 直接return这个实例</span><br><span class="line">    return new MyPromise(resolve &#x3D;&gt; resolve(value))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;静态的reject方法</span><br><span class="line">  static reject(reason) &#123;</span><br><span class="line">    return new MyPromise((resolve, reject) &#x3D;&gt; reject(reason))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;静态的all方法</span><br><span class="line">  static all(promiseArr) &#123;</span><br><span class="line">    let index &#x3D; 0</span><br><span class="line">    let result &#x3D; []</span><br><span class="line">    return new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      promiseArr.forEach((p, i) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F;Promise.resolve(p)用于处理传入值不为Promise的情况</span><br><span class="line">        MyPromise.resolve(p).then(</span><br><span class="line">          val &#x3D;&gt; &#123;</span><br><span class="line">            index++</span><br><span class="line">            result[i] &#x3D; val</span><br><span class="line">            if(index &#x3D;&#x3D;&#x3D; promiseArr.length) &#123;</span><br><span class="line">              resolve(result)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          err &#x3D;&gt; &#123;</span><br><span class="line">            reject(err)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;静态的race方法</span><br><span class="line">  static race(promiseArr) &#123;</span><br><span class="line">    return new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F;同时执行Promise,如果有一个Promise的状态发生改变,就变更新MyPromise的状态</span><br><span class="line">      for (let p of promiseArr) &#123;</span><br><span class="line">        MyPromise.resolve(p).then(  &#x2F;&#x2F;Promise.resolve(p)用于处理传入值不为Promise的情况</span><br><span class="line">          value &#x3D;&gt; &#123;</span><br><span class="line">            resolve(value)        &#x2F;&#x2F;注意这个resolve是上边new MyPromise的</span><br><span class="line">          &#125;,</span><br><span class="line">          err &#x3D;&gt; &#123;</span><br><span class="line">            reject(err)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>洋洋洒洒 150 多行的代码，到这里，我们终于可以给 Promise 的实现做一个结尾了。我们从一个最简单的 Promise 使用实例开始，通过对调用流程的分析，根据观察者模式实现了 Promise 的大致骨架，然后依据 Promise/A+规范填充代码，重点实现了 then 的链式调用，最后完成了 Promise 的静态/实例方法。其实 Promise 实现在整体上并没有太复杂的思想，但我们日常使用的时候往往忽略了很多 Promise 细节，因而很难写出一个符合规范的 Promise 实现，源码的实现过程，其实也是对 Promise 使用细节重新学习的过程。</p>
<h1 id="async-await-实现"><a href="#async-await-实现" class="headerlink" title="async/await 实现"></a>async/await 实现</h1><p>虽然前边花了这么多篇幅讲 Promise 的实现，不过探索<code>async/await</code>暂停执行的机制才是我们的初衷，下面我们就来进入这一块的内容。同样地，开头我们点一下 async/await 的使用意义。 在多个回调依赖的场景中，尽管 Promise 通过链式调用取代了回调嵌套，但过多的链式调用可读性仍然不佳，流程控制也不方便，ES7 提出的 async 函数，终于让 JS 对于异步操作有了终极解决方案，简洁优美地解决了以上两个问题。</p>
<blockquote>
<p>设想一个这样的场景，异步任务 a-&gt;b-&gt;c 之间存在依赖关系，如果我们通过 then 链式调用来处理这些关系，可读性并不是很好，如果我们想控制其中某个过程，比如在某些条件下，b 不往下执行到 c，那么也不是很方便控制</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(a)</span><br><span class="line">  .then(b &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(c &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是如果通过 async/await 来实现这个场景，可读性和流程控制都会方便不少。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async () &#x3D;&gt; &#123;</span><br><span class="line">  const a &#x3D; await Promise.resolve(a);</span><br><span class="line">  const b &#x3D; await Promise.resolve(b);</span><br><span class="line">  const c &#x3D; await Promise.resolve(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们要如何实现一个 async/await 呢，首先我们要知道，<strong>async/await 实际上是对 Generator（生成器）的封装</strong>，是一个语法糖。由于 Generator 出现不久就被 async/await 取代了，很多同学对 Generator 比较陌生，因此我们先来看看 Generator 的用法：</p>
<blockquote>
<p>ES6 新引入了 Generator 函数，可以通过 yield 关键字，把函数的执行流挂起，通过 next()方法可以切换到下一个状态，为改变执行流程提供了可能，从而为异步编程提供解决方案。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function* myGenerator() &#123;</span><br><span class="line">  yield &#39;1&#39;</span><br><span class="line">  yield &#39;2&#39;</span><br><span class="line">  return &#39;3&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const gen &#x3D; myGenerator();  &#x2F;&#x2F; 获取迭代器</span><br><span class="line">gen.next()  &#x2F;&#x2F;&#123;value: &quot;1&quot;, done: false&#125;</span><br><span class="line">gen.next()  &#x2F;&#x2F;&#123;value: &quot;2&quot;, done: false&#125;</span><br><span class="line">gen.next()  &#x2F;&#x2F;&#123;value: &quot;3&quot;, done: true&#125;</span><br></pre></td></tr></table></figure>

<p>也可以通过给<code>next()</code>传参, 让 yield 具有返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function* myGenerator() &#123;</span><br><span class="line">  console.log(yield &#39;1&#39;)  &#x2F;&#x2F;test1</span><br><span class="line">  console.log(yield &#39;2&#39;)  &#x2F;&#x2F;test2</span><br><span class="line">  console.log(yield &#39;3&#39;)  &#x2F;&#x2F;test3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取迭代器</span><br><span class="line">const gen &#x3D; myGenerator();</span><br><span class="line"></span><br><span class="line">gen.next()</span><br><span class="line">gen.next(&#39;test1&#39;)</span><br><span class="line">gen.next(&#39;test2&#39;)</span><br><span class="line">gen.next(&#39;test3&#39;)</span><br></pre></td></tr></table></figure>

<p>我们看到 Generator 的用法，应该️会感到很熟悉，<code>*/yield</code>和<code>async/await</code>看起来其实已经很相似了，它们都提供了暂停执行的功能，但二者又有三点不同：</p>
<ul>
<li><code>async/await</code>自带执行器，不需要手动调用 next()就能自动执行下一步</li>
<li><code>async</code>函数返回值是 Promise 对象，而 Generator 返回的是生成器对象</li>
<li><code>await</code>能够返回 Promise 的 resolve/reject 的值</li>
</ul>
<p><strong>我们对 async/await 的实现，其实也就是对应以上三点封装 Generator</strong></p>
<h2 id="1-自动执行"><a href="#1-自动执行" class="headerlink" title="1.自动执行"></a>1.自动执行</h2><p>我们先来看一下，对于这样一个 Generator，手动执行是怎样一个流程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function* myGenerator() &#123;</span><br><span class="line">  yield Promise.resolve(1);</span><br><span class="line">  yield Promise.resolve(2);</span><br><span class="line">  yield Promise.resolve(3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 手动执行迭代器</span><br><span class="line">const gen &#x3D; myGenerator()</span><br><span class="line">gen.next().value.then(val &#x3D;&gt; &#123;</span><br><span class="line">  console.log(val)</span><br><span class="line">  gen.next().value.then(val &#x3D;&gt; &#123;</span><br><span class="line">    console.log(val)</span><br><span class="line">    gen.next().value.then(val &#x3D;&gt; &#123;</span><br><span class="line">      console.log(val)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出1 2 3</span><br></pre></td></tr></table></figure>

<p>我们也可以通过给<code>gen.next()</code>传值的方式，让 yield 能返回 resolve 的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function* myGenerator() &#123;</span><br><span class="line">  console.log(yield Promise.resolve(1))   &#x2F;&#x2F;1</span><br><span class="line">  console.log(yield Promise.resolve(2))   &#x2F;&#x2F;2</span><br><span class="line">  console.log(yield Promise.resolve(3))   &#x2F;&#x2F;3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 手动执行迭代器</span><br><span class="line">const gen &#x3D; myGenerator()</span><br><span class="line">gen.next().value.then(val &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; console.log(val)</span><br><span class="line">  gen.next(val).value.then(val &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; console.log(val)</span><br><span class="line">    gen.next(val).value.then(val &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; console.log(val)</span><br><span class="line">      gen.next(val)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>显然，手动执行的写法看起来既笨拙又丑陋，我们希望生成器函数能自动往下执行，且 yield 能返回 resolve 的值，基于这两个需求，我们进行一个基本的封装，这里<code>async/await</code>是关键字，不能重写，我们用函数来模拟：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function run(gen) &#123;</span><br><span class="line">  var g &#x3D; gen()                     &#x2F;&#x2F;由于每次gen()获取到的都是最新的迭代器,因此获取迭代器操作要放在_next()之前,否则会进入死循环</span><br><span class="line"></span><br><span class="line">  function _next(val) &#123;             &#x2F;&#x2F;封装一个方法, 递归执行g.next()</span><br><span class="line">    var res &#x3D; g.next(val)           &#x2F;&#x2F;获取迭代器对象，并返回resolve的值</span><br><span class="line">    if(res.done) return res.value   &#x2F;&#x2F;递归终止条件</span><br><span class="line">    res.value.then(val &#x3D;&gt; &#123;         &#x2F;&#x2F;Promise的then方法是实现自动迭代的前提</span><br><span class="line">      _next(val)                    &#x2F;&#x2F;等待Promise完成就自动执行下一个next，并传入resolve的值</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  _next()  &#x2F;&#x2F;第一次执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于我们之前的例子，我们就能这样执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function* myGenerator() &#123;</span><br><span class="line">  console.log(yield Promise.resolve(1))   &#x2F;&#x2F;1</span><br><span class="line">  console.log(yield Promise.resolve(2))   &#x2F;&#x2F;2</span><br><span class="line">  console.log(yield Promise.resolve(3))   &#x2F;&#x2F;3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(myGenerator)</span><br></pre></td></tr></table></figure>

<p>这样我们就初步实现了一个<code>async/await</code>。上边的代码只有五六行，但并不是一下就能看明白的，我们之前用了四个例子来做铺垫，也是为了让读者更好地理解这段代码。 简单来说，我们封装了一个 run 方法，run 方法里我们把执行下一步的操作封装成<code>_next()</code>，每次 Promise.then()的时候都去执行<code>_next()</code>，实现自动迭代的效果。在迭代的过程中，我们还把 resolve 的值传入<code>gen.next()</code>，使得 yield 得以返回 Promise 的 resolve 的值</p>
<blockquote>
<p>这里插一句，是不是只有<code>.then方法</code>这样的形式才能完成我们自动执行的功能呢？答案是否定的，yield 后边除了接 Promise，还可以接<code>thunk函数</code>，thunk 函数不是一个新东西，所谓 thunk 函数，就是<strong>单参的只接受回调的函数</strong>，详细介绍可以看<a target="_blank" rel="noopener" href="https://user-gold-cdn.xitu.io/2020/3/15/170dc5e88df6c208">阮一峰 Thunk 函数的含义和用法</a>，无论是 Promise 还是 thunk 函数，其核心都是通过<strong>传入回调</strong>的方式来实现 Generator 的自动执行。thunk 函数只作为一个拓展知识，理解有困难的同学也可以跳过这里，并不影响后续理解。</p>
</blockquote>
<h2 id="2-返回-Promise-amp-异常处理"><a href="#2-返回-Promise-amp-异常处理" class="headerlink" title="2.返回 Promise &amp; 异常处理"></a>2.返回 Promise &amp; 异常处理</h2><p>虽然我们实现了 Generator 的自动执行以及让 yield 返回 resolve 的值，但上边的代码还存在着几点问题：</p>
<ol>
<li><strong>需要兼容基本类型</strong>：这段代码能自动执行的前提是<code>yield</code>后面跟 Promise，为了兼容后面跟着基本类型值的情况，我们需要把 yield 跟的内容(<code>gen().next.value</code>)都用<code>Promise.resolve()</code>转化一遍</li>
<li><strong>缺少错误处理</strong>：上边代码里的 Promise 如果执行失败，就会导致后续执行直接中断，我们需要通过调用<code>Generator.prototype.throw()</code>，把错误抛出来，才能被外层的 try-catch 捕获到</li>
<li><strong>返回值是 Promise</strong>：<code>async/await</code>的返回值是一个 Promise，我们这里也需要保持一致，给返回值包一个 Promise</li>
</ol>
<p>我们改造一下 run 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function run(gen) &#123;</span><br><span class="line">  &#x2F;&#x2F;把返回值包装成promise</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    var g &#x3D; gen()</span><br><span class="line"></span><br><span class="line">    function _next(val) &#123;</span><br><span class="line">      &#x2F;&#x2F;错误处理</span><br><span class="line">      try &#123;</span><br><span class="line">        var res &#x3D; g.next(val)</span><br><span class="line">      &#125; catch(err) &#123;</span><br><span class="line">        return reject(err);</span><br><span class="line">      &#125;</span><br><span class="line">      if(res.done) &#123;</span><br><span class="line">        return resolve(res.value);</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F;res.value包装为promise，以兼容yield后面跟基本类型的情况</span><br><span class="line">      Promise.resolve(res.value).then(</span><br><span class="line">        val &#x3D;&gt; &#123;</span><br><span class="line">          _next(val);</span><br><span class="line">        &#125;,</span><br><span class="line">        err &#x3D;&gt; &#123;</span><br><span class="line">          &#x2F;&#x2F;抛出错误</span><br><span class="line">          g.throw(err)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    _next();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们可以测试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function* myGenerator() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    console.log(yield Promise.resolve(1))</span><br><span class="line">    console.log(yield 2)   &#x2F;&#x2F;2</span><br><span class="line">    console.log(yield Promise.reject(&#39;error&#39;))</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    console.log(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const result &#x3D; run(myGenerator)     &#x2F;&#x2F;result是一个Promise</span><br><span class="line">&#x2F;&#x2F;输出 1 2 error</span><br></pre></td></tr></table></figure>

<p>到这里，一个<code>async/await</code>的实现基本完成了。最后我们可以看一下 babel 对 async/await 的转换结果，其实整体的思路是一样的，但是写法稍有不同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;相当于我们的run()</span><br><span class="line">function _asyncToGenerator(fn) &#123;</span><br><span class="line">  &#x2F;&#x2F; return一个function，和async保持一致。我们的run直接执行了Generator，其实是不太规范的</span><br><span class="line">  return function() &#123;</span><br><span class="line">    var self &#x3D; this</span><br><span class="line">    var args &#x3D; arguments</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">      var gen &#x3D; fn.apply(self, args);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;相当于我们的_next()</span><br><span class="line">      function _next(value) &#123;</span><br><span class="line">        asyncGeneratorStep(gen, resolve, reject, _next, _throw, &#39;next&#39;, value);</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F;处理异常</span><br><span class="line">      function _throw(err) &#123;</span><br><span class="line">        asyncGeneratorStep(gen, resolve, reject, _next, _throw, &#39;throw&#39;, err);</span><br><span class="line">      &#125;</span><br><span class="line">      _next(undefined);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    var info &#x3D; gen[key](arg);</span><br><span class="line">    var value &#x3D; info.value;</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  if (info.done) &#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    Promise.resolve(value).then(_next, _throw);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const foo &#x3D; _asyncToGenerator(function* () &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    console.log(yield Promise.resolve(1))   &#x2F;&#x2F;1</span><br><span class="line">    console.log(yield 2)                    &#x2F;&#x2F;2</span><br><span class="line">    return &#39;3&#39;</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    console.log(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">foo().then(res &#x3D;&gt; &#123;</span><br><span class="line">  console.log(res)                          &#x2F;&#x2F;3</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>有关<code>async/await</code>的实现，到这里就告一段落了。但是直到结尾，我们也不知道 await 到底是如何暂停执行的，有关 await 暂停执行的秘密，我们还要到 Generator 的实现中去寻找答案</p>
<h1 id="Generator-实现"><a href="#Generator-实现" class="headerlink" title="Generator 实现"></a>Generator 实现</h1><p>我们从一个简单的 Generator 使用实例开始，一步步探究 Generator 的实现原理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function* foo() &#123;</span><br><span class="line">  yield &#39;result1&#39;</span><br><span class="line">  yield &#39;result2&#39;</span><br><span class="line">  yield &#39;result3&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const gen &#x3D; foo()</span><br><span class="line">console.log(gen.next().value)</span><br><span class="line">console.log(gen.next().value)</span><br><span class="line">console.log(gen.next().value)</span><br></pre></td></tr></table></figure>

<p>我们可以在<a target="_blank" rel="noopener" href="https://babeljs.io/repl/#?browsers=&build=&builtIns=false&spec=false&loose=false&code_lz=GYVwdgxgLglg9mAVAAmHOAKAlMg3gKGWQE8YBTAGwBNkByAJzIGcQKoBGWwk86uxlmwBMXIqUo0GzVlADMXAL7d8EBEyjIA5mTDIAvKnTYVauBTIA6CnE0ZtYC2DIAPKNgsA3AIYUQZLCZgTGaW1rb2ji5uWJ4-fgGqQSFWNnY6ka7u3r7-QA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=false&fileSize=false&timeTravel=false&sourceType=module&lineWrap=true&presets=es2015%2Creact%2Cstage-2&prettier=false&targets=&version=7.5.5&externalPlugins=">babel 官网</a>上在线转化这段代码，看看 ES5 环境下是如何实现 Generator 的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">var _marked &#x3D;</span><br><span class="line">&#x2F;*#__PURE__*&#x2F;</span><br><span class="line">regeneratorRuntime.mark(foo);</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">  return regeneratorRuntime.wrap(function foo$(_context) &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">      switch (_context.prev &#x3D; _context.next) &#123;</span><br><span class="line">        case 0:</span><br><span class="line">          _context.next &#x3D; 2;</span><br><span class="line">          return &#39;result1&#39;;</span><br><span class="line"></span><br><span class="line">        case 2:</span><br><span class="line">          _context.next &#x3D; 4;</span><br><span class="line">          return &#39;result2&#39;;</span><br><span class="line"></span><br><span class="line">        case 4:</span><br><span class="line">          _context.next &#x3D; 6;</span><br><span class="line">          return &#39;result3&#39;;</span><br><span class="line"></span><br><span class="line">        case 6:</span><br><span class="line">        case &quot;end&quot;:</span><br><span class="line">          return _context.stop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, _marked);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var gen &#x3D; foo();</span><br><span class="line">console.log(gen.next().value);</span><br><span class="line">console.log(gen.next().value);</span><br><span class="line">console.log(gen.next().value);</span><br></pre></td></tr></table></figure>

<p>代码咋一看不长，但如果仔细观察会发现有两个不认识的东西 —— <code>regeneratorRuntime.mark</code>和<code>regeneratorRuntime.wrap</code>，这两者其实是 regenerator-runtime 模块里的两个方法，regenerator-runtime 模块来自 facebook 的 regenerator 模块，完整代码在<a target="_blank" rel="noopener" href="https://github.com/facebook/regenerator/blob/master/packages/regenerator-runtime/runtime.js">runtime.js</a>，这个 runtime 有 700 多行…-_-||，因此我们不能全讲，不太重要的部分我们就简单地过一下，重点讲解暂停执行相关部分代码</p>
<blockquote>
<p>个人觉得啃源码的效果不是很好，建议读者拉到末尾先看结论和简略版实现，源码作为一个补充理解</p>
</blockquote>
<h2 id="regeneratorRuntime-mark"><a href="#regeneratorRuntime-mark" class="headerlink" title="regeneratorRuntime.mark()"></a>regeneratorRuntime.mark()</h2><p><code>regeneratorRuntime.mark(foo)</code>这个方法在第一行被调用，我们先看一下 runtime 里 mark()方法的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;runtime.js里的定义稍有不同，多了一些判断，以下是编译后的代码</span><br><span class="line">runtime.mark &#x3D; function(genFun) &#123;</span><br><span class="line">  genFun.__proto__ &#x3D; GeneratorFunctionPrototype;</span><br><span class="line">  genFun.prototype &#x3D; Object.create(Gp);</span><br><span class="line">  return genFun;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里边<code>GeneratorFunctionPrototype</code>和<code>Gp</code>我们都不认识，他们被定义在 runtime 里，不过没关系，我们只要知道<code>mark()方法</code>为生成器函数（foo）绑定了一系列原型就可以了，这里就简单地过了</p>
<h2 id="regeneratorRuntime-wrap"><a href="#regeneratorRuntime-wrap" class="headerlink" title="regeneratorRuntime.wrap()"></a>regeneratorRuntime.wrap()</h2><p>从上面 babel 转化的代码我们能看到，执行<code>foo()</code>，其实就是执行<code>wrap()</code>，那么这个方法起到什么作用呢，他想包装一个什么东西呢，我们先来看看 wrap 方法的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;runtime.js里的定义稍有不同，多了一些判断，以下是编译后的代码</span><br><span class="line">function wrap(innerFn, outerFn, self) &#123;</span><br><span class="line">  var generator &#x3D; Object.create(outerFn.prototype);</span><br><span class="line">  var context &#x3D; new Context([]);</span><br><span class="line">  generator._invoke &#x3D; makeInvokeMethod(innerFn, self, context);</span><br><span class="line"></span><br><span class="line">  return generator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>wrap 方法先是创建了一个 generator，并继承<code>outerFn.prototype</code>；然后 new 了一个<code>context对象</code>；<code>makeInvokeMethod方法</code>接收<code>innerFn(对应foo$)</code>、<code>context</code>和<code>this</code>，并把返回值挂到<code>generator._invoke</code>上；最后 return 了 generator。<strong>其实 wrap()相当于是给 generator 增加了一个_invoke 方法</strong></p>
<p>这段代码肯定让人产生很多疑问，outerFn.prototype 是什么，Context 又是什么，makeInvokeMethod 又做了哪些操作。下面我们就来一一解答：</p>
<blockquote>
<p><code>outerFn.prototype</code>其实就是<code>genFun.prototype</code>，</p>
</blockquote>
<p>这个我们结合一下上面的代码就能知道</p>
<blockquote>
<p><code>context</code>可以直接理解为这样一个全局对象，用于储存各种状态和上下文：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var ContinueSentinel &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">var context &#x3D; &#123;</span><br><span class="line">  done: false,</span><br><span class="line">  method: &quot;next&quot;,</span><br><span class="line">  next: 0,</span><br><span class="line">  prev: 0,</span><br><span class="line">  abrupt: function(type, arg) &#123;</span><br><span class="line">    var record &#x3D; &#123;&#125;;</span><br><span class="line">    record.type &#x3D; type;</span><br><span class="line">    record.arg &#x3D; arg;</span><br><span class="line"></span><br><span class="line">    return this.complete(record);</span><br><span class="line">  &#125;,</span><br><span class="line">  complete: function(record, afterLoc) &#123;</span><br><span class="line">    if (record.type &#x3D;&#x3D;&#x3D; &quot;return&quot;) &#123;</span><br><span class="line">      this.rval &#x3D; this.arg &#x3D; record.arg;</span><br><span class="line">      this.method &#x3D; &quot;return&quot;;</span><br><span class="line">      this.next &#x3D; &quot;end&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ContinueSentinel;</span><br><span class="line">  &#125;,</span><br><span class="line">  stop: function() &#123;</span><br><span class="line">    this.done &#x3D; true;</span><br><span class="line">    return this.rval;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>makeInvokeMethod</code>的定义如下，它 return 了一个<code>invoke方法</code>，invoke 用于判断当前状态和执行下一步，其实就是我们调用的<code>next()</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;以下是编译后的代码</span><br><span class="line">function makeInvokeMethod(innerFn, context) &#123;</span><br><span class="line">  &#x2F;&#x2F; 将状态置为start</span><br><span class="line">  var state &#x3D; &quot;start&quot;;</span><br><span class="line"></span><br><span class="line">  return function invoke(method, arg) &#123;</span><br><span class="line">    &#x2F;&#x2F; 已完成</span><br><span class="line">    if (state &#x3D;&#x3D;&#x3D; &quot;completed&quot;) &#123;</span><br><span class="line">      return &#123; value: undefined, done: true &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    context.method &#x3D; method;</span><br><span class="line">    context.arg &#x3D; arg;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 执行中</span><br><span class="line">    while (true) &#123;</span><br><span class="line">      state &#x3D; &quot;executing&quot;;</span><br><span class="line"></span><br><span class="line">      var record &#x3D; &#123;</span><br><span class="line">        type: &quot;normal&quot;,</span><br><span class="line">        arg: innerFn.call(self, context)    &#x2F;&#x2F; 执行下一步,并获取状态(其实就是switch里边return的值)</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      if (record.type &#x3D;&#x3D;&#x3D; &quot;normal&quot;) &#123;</span><br><span class="line">        &#x2F;&#x2F; 判断是否已经执行完成</span><br><span class="line">        state &#x3D; context.done ? &quot;completed&quot; : &quot;yield&quot;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; ContinueSentinel其实是一个空对象,record.arg &#x3D;&#x3D;&#x3D; &#123;&#125;则跳过return进入下一个循环</span><br><span class="line">        &#x2F;&#x2F; 什么时候record.arg会为空对象呢, 答案是没有后续yield语句或已经return的时候,也就是switch返回了空值的情况(跟着上面的switch走一下就知道了)</span><br><span class="line">        if (record.arg &#x3D;&#x3D;&#x3D; ContinueSentinel) &#123;</span><br><span class="line">          continue;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; next()的返回值</span><br><span class="line">        return &#123;</span><br><span class="line">          value: record.arg,</span><br><span class="line">          done: context.done</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么<code>generator._invoke</code>实际上就是<code>gen.next</code>呢，因为在 runtime 对于 next()的定义中，next()其实就 return 了_invoke 方法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Helper for defining the .next, .throw, and .return methods of the</span><br><span class="line">&#x2F;&#x2F; Iterator interface in terms of a single ._invoke method.</span><br><span class="line">function defineIteratorMethods(prototype) &#123;</span><br><span class="line">    [&quot;next&quot;, &quot;throw&quot;, &quot;return&quot;].forEach(function(method) &#123;</span><br><span class="line">      prototype[method] &#x3D; function(arg) &#123;</span><br><span class="line">        return this._invoke(method, arg);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defineIteratorMethods(Gp);</span><br></pre></td></tr></table></figure>

<h2 id="低配实现-amp-调用流程分析"><a href="#低配实现-amp-调用流程分析" class="headerlink" title="低配实现 &amp; 调用流程分析"></a>低配实现 &amp; 调用流程分析</h2><p>这么一遍源码下来，估计很多读者还是懵逼的，毕竟源码中纠集了很多概念和封装，一时半会不好完全理解，让我们跳出源码，实现一个简单的 Generator，然后再回过头看源码，会得到更清晰的认识</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 生成器函数根据yield语句将代码分割为switch-case块，后续通过切换_context.prev和_context.next来分别执行各个case</span><br><span class="line">function gen$(_context) &#123;</span><br><span class="line">  while (1) &#123;</span><br><span class="line">    switch (_context.prev &#x3D; _context.next) &#123;</span><br><span class="line">      case 0:</span><br><span class="line">        _context.next &#x3D; 2;</span><br><span class="line">        return &#39;result1&#39;;</span><br><span class="line"></span><br><span class="line">      case 2:</span><br><span class="line">        _context.next &#x3D; 4;</span><br><span class="line">        return &#39;result2&#39;;</span><br><span class="line"></span><br><span class="line">      case 4:</span><br><span class="line">        _context.next &#x3D; 6;</span><br><span class="line">        return &#39;result3&#39;;</span><br><span class="line"></span><br><span class="line">      case 6:</span><br><span class="line">      case &quot;end&quot;:</span><br><span class="line">        return _context.stop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 低配版context</span><br><span class="line">var context &#x3D; &#123;</span><br><span class="line">  next:0,</span><br><span class="line">  prev: 0,</span><br><span class="line">  done: false,</span><br><span class="line">  stop: function stop () &#123;</span><br><span class="line">    this.done &#x3D; true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 低配版invoke</span><br><span class="line">let gen &#x3D; function() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    next: function() &#123;</span><br><span class="line">      value &#x3D; context.done ? undefined: gen$(context)</span><br><span class="line">      done &#x3D; context.done</span><br><span class="line">      return &#123;</span><br><span class="line">        value,</span><br><span class="line">        done</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 测试使用</span><br><span class="line">var g &#x3D; gen()</span><br><span class="line">g.next()  &#x2F;&#x2F; &#123;value: &quot;result1&quot;, done: false&#125;</span><br><span class="line">g.next()  &#x2F;&#x2F; &#123;value: &quot;result2&quot;, done: false&#125;</span><br><span class="line">g.next()  &#x2F;&#x2F; &#123;value: &quot;result3&quot;, done: false&#125;</span><br><span class="line">g.next()  &#x2F;&#x2F; &#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码并不难理解，我们分析一下调用流程：</p>
<ol>
<li><p>我们定义的<code>function*</code>生成器函数被转化为以上代码</p>
</li>
<li><p>转化后的代码分为三大块：</p>
<ul>
<li><code>gen$(_context)</code>由 yield 分割生成器函数代码而来</li>
<li><code>context对象</code>用于储存函数执行上下文</li>
<li><code>invoke()方法</code>定义 next()，用于执行 gen$(_context)来跳到下一步</li>
</ul>
</li>
<li><p>当我们调用<code>g.next()</code>，就相当于调用<code>invoke()方法</code>，执行<code>gen$(_context)</code>，进入 switch 语句，switch 根据 context 的标识，执行对应的 case 块，return 对应结果</p>
</li>
<li><p>当生成器函数运行到末尾（没有下一个 yield 或已经 return），switch 匹配不到对应代码块，就会 return 空值，这时<code>g.next()</code>返回<code>&#123;value: undefined, done: true&#125;</code></p>
</li>
</ol>
<p>从中我们可以看出，<strong>Generator 实现的核心在于</strong><code>**上下文的保存**</code><strong>，函数并没有真的被挂起，每一次 yield，其实都执行了一遍传入的生成器函数，只是在这个过程中间用了一个 context 对象储存上下文，使得每次执行生成器函数的时候，都可以从上一个执行结果开始执行，看起来就像函数被挂起了一样</strong></p>
<h1 id="总结-amp-致谢"><a href="#总结-amp-致谢" class="headerlink" title="总结 &amp; 致谢"></a>总结 &amp; 致谢</h1><p>有关 Promise、async/await、Generator 的原理就实现到这里了，感谢大家能够跟我一起走完全程，不知不觉，我们花了近 9 千字来讲述有关异步编程的故事，异步编程的世界环环相扣，一开始，笔者只是出于对 await 挂起机制的好奇，后来，从一个 “await 是如何实现暂停执行” 的小问题，引出了对异步编程的一系列思考和实现原理。三者的实现，其实也是前端异步编程一步步演化推进的过程。</p>
<p>成文过程中得到很多大佬的帮助，这四篇参考文章都是我阅读了很多相关文章后精选的四篇，建议大家结合阅读，大佬们写的比我好很多，另外感谢冴羽大佬在 Generator 机制上给予的解惑~</p>
<blockquote>
<p>前端技匠：<a target="_blank" rel="noopener" href="https://juejin.im/post/6844903989083897870">各种源码实现，你想要的这里都有</a></p>
</blockquote>
<p>神三元：<a target="_blank" rel="noopener" href="https://juejin.im/post/6844903702457925640">我如何实现 Promise</a></p>
<p>winty：<a target="_blank" rel="noopener" href="https://juejin.im/post/6844903988584775693#heading-0">async/await 原理及执行顺序分析</a></p>
<p>冴羽：<a target="_blank" rel="noopener" href="https://juejin.im/post/6844903701908291592">ES6 系列之 Babel 将 Generator 编译成了什么样子</a></p>
<p><strong>最后卑微求个赞 Thanks♪(･ω･)ﾉ</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619261369471-9f4febb6-72fb-41b7-a3bb-60cfeb077c95.jpeg#clientId=u0787e3d2-71b0-4&from=drop&id=u5e819ff0&margin=%5Bobject%20Object%5D&name=2.jpg&originHeight=380&originWidth=714&originalType=binary&size=85453&status=done&style=none&taskId=ua85c3f64-ca03-48e4-bfca-25b503824f6" alt="2.jpg"></p>
<blockquote>
<p>往期文章</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/6844904036013965325">10 行代码看尽 redux 实现 —— 全面剖析 redux &amp; react-redux &amp; redux 中间件设计实现 | 8k 字</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/6844904006175686669">红黑树上红黑果，红黑树下你和我 —— 红黑树入门 | 6k 字</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/6844904000387563533">SSR 从入门到放弃 —— 深入 React 服务端渲染原理 | 1W 字</a>？</li>
</ol>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/23/yuque/%E5%8A%A8%E7%94%BB%E6%80%A7%E8%83%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/23/yuque/%E5%8A%A8%E7%94%BB%E6%80%A7%E8%83%BD/" class="post-title-link" itemprop="url">动画性能</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-23 13:33:32" itemprop="dateCreated datePublished" datetime="2021-04-23T13:33:32+08:00">2021-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-25 16:49:31" itemprop="dateModified" datetime="2021-04-25T16:49:31+08:00">2021-04-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>先总结几个要点<br><strong>精简 DOM，合理布局</strong><br><strong>使用 transform 代替 left、top 减少使用引起页面重排的属性</strong><br><strong>开启硬件加速</strong><br><strong>尽量避免浏览器创建不必要的图形层</strong><br><strong>尽量减少 js 动画，如需要，使用对性能友好的 requestAnimationFrame</strong><br><strong>使用 chrome performance 工具调试动画性能</strong></p>
<p>我们知道网页动画的每一帧都是一次重新渲染，每秒低于 24 镇的动画，人眼就能感受到停顿，每秒 30-60 帧才能比较流畅 浏览器会按照大多数显示器的刷新频率 60Hz 来刷新动画， 如果想达到 60FPS,就意味着每一帧的任务耗时不能高于 16 毫秒。</p>
<p>通过下图我们可以了解浏览器渲染每一帧的过程<br><img src="https://cdn.nlark.com/yuque/0/2021/webp/21377586/1619156045002-3bd51fc7-149d-4148-8cdb-8f69404dc3db.webp#clientId=u31f05833-5d5b-4&from=paste&height=343&id=u16107b32&margin=%5Bobject%20Object%5D&originHeight=343&originWidth=720&originalType=url&status=done&style=none&taskId=u333ca95c-b807-450e-8286-cfd761dd888&width=720"></p>
<ul>
<li>1.JavaScript。一般来说，我们会使用 JavaScript 来实现一些视觉变化的效果。比如用 jQuery 的 animate 函数做一个动画、对一个数据集进行排序或者往页面里添加一些 DOM 元素等。当然，除了 JavaScript，还有其他一些常用方法也可以实现视觉变化效果，比如：CSS Animations、Transitions 和 Web Animation API。</li>
<li>2.样式计算。此过程是根据匹配选择器（例如 .headline 或 .nav &gt; .nav__item）计算出哪些元素应用哪些 CSS 3. 规则的过程。从中知道规则之后，将应用规则并计算每个元素的最终样式。</li>
<li>3.布局。在知道对一个元素应用哪些规则之后，浏览器即可开始计算它要占据的空间大小及其在屏幕的位置。网页的布局模式意味着一个元素可能影响其他元素，例如 元素的宽度一般会影响其子元素的宽度以及树中各处的节点，因此对于浏览器来说，布局过程是经常发生的。</li>
<li>4.绘制。绘制是填充像素的过程。它涉及绘出文本、颜色、图像、边框和阴影，基本上包括元素的每个可视部分。绘制一般是在多个表面（通常称为层）上完成的。</li>
<li>5.合成。由于页面的各部分可能被绘制到多层，由此它们需要按正确顺序绘制到屏幕上，以便正确渲染页面。对于与另一元素重叠的元素来说，这点特别重要，因为一个错误可能使一个元素错误地出现在另一个元素的上层。</li>
<li>“生成布局”（flow）和”绘制”（paint）这两步，合称为”渲染”（render）。重新渲染就是需要重新生成布局和重新绘制。 有上述的渲染流水线我们可以得知重绘不一定需要重排，重排必然导致重绘</li>
<li>重排和重绘会不断触发，这是不可避免的。但是，它们非常耗费资源，是导致网页性能低下的根本原因。 提高网页性能，就是要降低”重排”和”重绘”的频率和成本，尽量少触发重新渲染。</li>
<li>重排还重绘会消耗大量的 CPU 和 GPU 资源，前端新能优化最主要的优化点就是尽量减少重绘和重排。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/21377586/1619156083886-901015cf-1400-451a-ba59-92d020065dcb.webp#clientId=u31f05833-5d5b-4&from=paste&height=343&id=u1605db33&margin=%5Bobject%20Object%5D&originHeight=343&originWidth=720&originalType=url&status=done&style=none&taskId=udccd0b91-b739-46c6-9380-cb2ecd9cfc4&width=720"></p>
<h1 id="影响网页渲染的因素"><a href="#影响网页渲染的因素" class="headerlink" title="影响网页渲染的因素"></a>影响网页渲染的因素</h1><p>其中最简单的，样式表越简单，重绘和重排越快，重绘和重排的 DOM 元素层级越高，成本就越高，所以我们在开发前端页面时就需要精简 DOM 元素，合理布局。<br>另外 Table 元素的重排和重绘成本要高于 div，所以我们提倡使用 div+css 布局，尽量避免使用 table 布局。<br>还有其他对渲染性能有影响的操作，比如：</p>
<ul>
<li>DOM 元素读写分离</li>
<li>让进行大量动画的元素脱离文档流，减少重排开销</li>
<li>通过改变元素的 class 或 csstext 一次性的更改样式</li>
<li>缓存 DOM 元素的位置信息，避免不必要的属性读取</li>
<li>尽量使用离线 DOM</li>
<li>使用 css3 transform 优化动画性能</li>
</ul>
<h1 id="使用-css3-transform"><a href="#使用-css3-transform" class="headerlink" title="使用 css3 transform"></a>使用 css3 transform</h1><p>该 CSS 属性可以旋转，缩放，倾斜，或者上传给定的元素。这是通过修改 CSS 可视格式模型的坐标空间来实现的。<br>如果该属性的值不是 none，则会创建一个堆叠上下文。在这种情况下，该对象将充当 position: fixed 的包含块（所以 position: fixed 的元素将会被他覆盖）。</p>
<p><strong>css3 transform 的执行效率</strong><br>我们通过一个例子来解释为什么 transform 的动画执行效果更佳。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 对应图<span class="number">1</span>-- &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">transition</span>: height <span class="number">1s</span> linear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 对应图<span class="number">2</span> -- &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">transition</span>: transform <span class="number">1s</span> linear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个从 height: 100px 到 height: 200px 的 动画按照下面的流程图来执行各种操作 橙色方框的操作比较耗时，绿色方框的操作比较快速<br><img src="https://cdn.nlark.com/yuque/0/2021/webp/21377586/1619156167485-d5405de1-1137-43f6-a0fb-4f771e179840.webp#clientId=u31f05833-5d5b-4&from=paste&height=1025&id=uc382e09a&margin=%5Bobject%20Object%5D&originHeight=1025&originWidth=455&originalType=url&status=done&style=none&taskId=u1c0285ca-7c7f-4067-8a14-431f977d49d&width=455"><br><img src="https://cdn.nlark.com/yuque/0/2021/webp/21377586/1619156180032-59cfbfa7-4237-41ed-8435-2d49044fabfe.webp#clientId=u31f05833-5d5b-4&from=paste&height=844&id=udfd3f826&margin=%5Bobject%20Object%5D&originHeight=844&originWidth=510&originalType=url&status=done&style=none&taskId=u9a529281-896c-46be-9a13-9eaeec7a309&width=510"><br>因为每一帧的变化浏览器都在进行布局、绘制、把新的位图交给 GPU 内存，但是在将位图加载到 GPU 内存中的操作是个相对耗时的操作。<br>GPU 在如下方面很快：</p>
<ul>
<li>绘制位图到屏幕上</li>
<li>可不断的绘制相同的位图</li>
<li>将同一位图进行位移、旋转、缩放</li>
</ul>
<p>我们看使用了 transform 属性的动画执行过程（图二），这个无疑是效率最优的执行方式。</p>
<h1 id="层的引入（参考-无线性能优化：Composite）"><a href="#层的引入（参考-无线性能优化：Composite）" class="headerlink" title="层的引入（参考-无线性能优化：Composite）"></a>层的引入（<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://taobaofed.org/blog/2016/04/25/performance-composite/">参考-无线性能优化：Composite</a>）</h1><p>页面一旦在装入并解析完成后，就会表示为许多 Web 开发者所熟悉的结构：DOM。然而，在页面的渲染过程中，浏览器还具有一系列并不直接暴露给开发者的页面中间表示方式。这些表示方式中最重要的结构就是层。<br>在 Chrome 中实际上有几种不同类型的层：掌管 DOM 子树的渲染层（RenderLayer）以及掌管渲染层子树的图形层（GraphicsLayer），某些特殊的渲染层会被认为是合成层（Compositing Layers，合成层拥有单独的 GraphicsLayer。<br>拥有单独 GraphicsLayer 的层，都会将位图存储在共享内存中，作为纹理上传到 GPU 中，最后由 GPU 将多个位图进行合成，然后 draw 到屏幕上。<br>什么渲染层会提升为合成层？Chrome 在这方面采用的规则仍在随着时间推移逐渐发展变化，但在目前下面这些因素都会引起 Chrome 创建层：</p>
<ul>
<li>进行 3D 或者透视变换的 CSS 属性</li>
<li>使用硬件加速视频解码的<video>元素</li>
<li>具有 3D（WebGL）上下文或者硬件加速的 2D 上下文的<canvas>元素</li>
<li>组合型插件（即 Flash）</li>
<li>具有有 CSS 透明度动画或者使用动画式 Webkit 变换的元素</li>
<li>具有硬件加速的 CSS 滤镜的元素</li>
<li>子元素中存在具有组合层的元素的元素（换句话说，就是存在具有自己的层的子元素的元素）</li>
<li>同级元素中有 Z 索引比其小的元素，而且该 Z 索引比较小的元素具有组合层（换句话说就是在组合层之上进行渲染的元素）</li>
</ul>
<p>提升为合成层简单说来有以下几点好处</p>
<ul>
<li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快</li>
<li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</li>
<li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li>
</ul>
<p>合成层的好处是不会影响到其他元素的绘制，因此，为了减少动画元素对其他元素的影响，从而减少 paint，我们需要把动画效果中的元素提升为合成层。<br>提升合成层的最好方式是使用 CSS 的 will-change 属性。从上一节合成层产生原因中，可以知道 will-change 设置为 opacity、transform、top、left、bottom、right 可以将元素提升为合成层。<br>对于那些目前还不支持 will-change 属性的浏览器，目前常用的是使用一个 3D transform 属性来强制提升为合成层：transofrm: translateZ(0)<br>通常情况下开启硬件加速会提高动画的流畅性，但是过多的合成层也会造成性能瓶颈，过多的合成层会占用大量的内存空间，<br>对于合成层占用内存的问题，这里有两个 demo 进行了验证。<br><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://taobaofed.github.io/demo/performance-composite-demo/memory/multi-layers-expect.html">demo 1</a> 和 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://taobaofed.github.io/demo/performance-composite-demo/memory/multi-layers.html">demo 2</a> 中，会创建 2000 个同样的 div 元素，不同的是 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://taobaofed.github.io/demo/performance-composite-demo/memory/multi-layers.html">demo 2</a> 中的元素通过 will-change 都提升为了合成层，而两个 demo 页面的内存消耗却有很明显的差别。<br><img src="https://cdn.nlark.com/yuque/0/2021/webp/21377586/1619156221113-60d5de53-69da-44b1-8baa-f44ed8ba14a2.webp#clientId=u31f05833-5d5b-4&from=paste&height=436&id=u51e4f365&margin=%5Bobject%20Object%5D&originHeight=485&originWidth=947&originalType=url&status=done&style=none&taskId=u740ae6c5-5d30-4705-a621-dd62062dcc7&width=851.5"></p>
<h1 id="网页动画的渲染"><a href="#网页动画的渲染" class="headerlink" title="网页动画的渲染"></a>网页动画的渲染</h1><p>有一些 JavaScript 方法可以调节重新渲染，大幅提高网页性能。<br>其中最重要的，就是 window.requestAnimationFrame() 方法。它可以将某些代码放到下一次重新渲染时执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.requestAnimationFrame(fn);</span><br></pre></td></tr></table></figure>

<p>****window.requestIdleCallback()****也可以用来调节重新渲染。它指定只有当一帧的末尾有空闲时间，才会执行回调函数。只有当前帧的运行时间小于 16.66ms 时，函数 fn 才会执行。否则，就推迟到下一帧，如果下一帧也没有空闲时间，就推迟到下下一帧，以此类推</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestIdleCallback(fn);</span><br></pre></td></tr></table></figure>

<p>它还可以接受第二个参数，表示指定的毫秒数。如果在指定 的这段时间之内，每一帧都没有空闲时间，那么函数 fn 将会强制执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestIdleCallback(fn, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure>

<h1 id="Chrome-Devtool-Performance"><a href="#Chrome-Devtool-Performance" class="headerlink" title="Chrome Devtool Performance"></a>Chrome Devtool Performance</h1><p>怎么去分析页面运行时的性能表现，Chrome Devtool Performance 是一个很好的选择。这里请大家参考这篇文章<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://zhuanlan.zhihu.com/p/29879682">全新 Chrome Devtool Performance 使用指南</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/23/yuque/%E5%A4%A7%E9%87%8F%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/23/yuque/%E5%A4%A7%E9%87%8F%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">大量图片加载优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-23 12:51:07" itemprop="dateCreated datePublished" datetime="2021-04-23T12:51:07+08:00">2021-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-25 16:49:31" itemprop="dateModified" datetime="2021-04-25T16:49:31+08:00">2021-04-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>饿了么 App 中新零售项目主要是以图片展示为主，引导用户点击轮播广告栏或者店铺列表进入指定的商品页面，因此页面中包含了大量图片，如搜索框下面的轮播广告栏、中部的促销栏以及底部的店铺列表，这些区域中都有大量的展示图片。因此图片的加载速率直接影响页面的加载速度。下面将从图片加载存在的问题和原因、解决方案两个方面来阐述如何优化新零售图片的加载。<br>本文所有数据及图片都是通过<strong>Charles</strong>模拟 256 kbps ISDN/DSL 网络环境获取到的。在本案例中只考虑位图，因此文本中提及的图片都是指位图而非矢量图。</p>
<h2 id="图片加载存在的问题和原因"><a href="#图片加载存在的问题和原因" class="headerlink" title="图片加载存在的问题和原因"></a><strong>图片加载存在的问题和原因</strong></h2><p><strong>问题一</strong>：启动页面时加载过多图片<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619153486011-145891ec-7533-447d-b37b-6f016bcf2b43.jpeg#clientId=uc716cf97-bcfe-4&from=paste&height=629&id=ub4ea3c13&margin=%5Bobject%20Object%5D&originHeight=629&originWidth=720&originalType=url&status=done&style=none&taskId=ud5c99b57-f1f0-4c88-add8-1a4d8e4cc19&width=720"><br><strong>图 1</strong>： 新零售图片请求瀑布图<br><strong>问题原因分析：</strong>如上图所示，页面启动时加载了大约 49 张图片（具体图片数量会根据后端返回数据而变化），而这些图片请求几乎是并发的，在 Chrome 浏览器，对于同一个域名，最多支持 6 个请求的并发，其他的请求将会推入到队列中等待或者停滞不前，直到六个请求之一完成后，队列中新的请求才会发出。上面的瀑布图中，在绿色的标记框中，我们看到不同长度的白色横柱，这些都是请求的图片资源排队等待时间。</p>
<p><strong>问题二</strong>：部分图片体积过大<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619153789647-3253d48a-a3bc-4500-b720-6d185883da54.jpeg#clientId=uc716cf97-bcfe-4&from=paste&height=397&id=ufd4c09a4&margin=%5Bobject%20Object%5D&originHeight=498&originWidth=1050&originalType=url&status=done&style=none&taskId=u2e8adb8b-92bb-4682-85af-359c994c07d&width=836"><br><strong>图 2.<strong>顶部轮播图中的一张图片加载图<br><strong>问题原因分析：</strong>如图 1，红框中是搜索框下部的轮播广告中的一张图片，通过图 2 可以看到，该图片主要耗时在 Conent Download 阶段。在下载阶段耗时 13.50s。而该请求的总共时间也就 13.78s。产生该问题的原因从图 1 也能看出一些端倪，该图片体积 76.2KB，</strong>图片体积过大</strong>，直接导致了下载图片时间过长。</p>
<h2 id="前端解决方案"><a href="#前端解决方案" class="headerlink" title="前端解决方案"></a><strong>前端解决方案</strong></h2><p><strong>针对问题一的解决方案</strong><br>由于新零售首页展示展示大量图片，其实在这大约 49 张图片中，大部分图片都不是首屏所需的，因此可以延迟首屏不需要的图片加载，而优先加载首屏所需图片。这儿<strong>首屏</strong>的含义是指打开新零售首页首先进入屏幕视窗内的区域范围。<br>判断图片是否是首屏内图片，首先想到的肯定是通过 getBoundingClientRect 方法，获取到图片的位置信息，判断其是否在 viewport 内部。可能的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inViewport = <span class="function">(<span class="params">el</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> rect = el.getBoundingClientRect();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    rect.top &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">    rect.bottom &lt; <span class="built_in">window</span>.innerHeight &amp;&amp;</span><br><span class="line">    rect.left &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">    rect.right &lt; <span class="built_in">window</span>.innerWidth</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是在项目中，我们并没有采用该方案来判断是否在首屏，其原因在于，只有当 DOM 元素插入到 DOM 树中，并且页面进行重排和重绘后，我们才能够知道该元素是否在首屏中。在项目中我们使用了<a href="https://link.zhihu.com/?target=https://github.com/ElemeFE/vue-img">v-img</a>指令（新零售项目使用该指令对图片进行加载、并且将 hash 转换成 Url。项目已开源，在符合需求前提下欢迎使用），在 Vue 指令中包含两个钩子函数 bind 和 inserted。官网对这两个钩子函数进行如下解释：</p>
<ul>
<li>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</li>
<li>inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</li>
</ul>
<p>由上面解释可知，我们只能够在 inserted 钩子函数中才能够获取到元素的位置，并且判断其是否在首屏中。在新零售项目中，经过笔者测试，这两个钩子函数的触发时差大约是 200ms，因此如果在 inserted 钩子函数内再去加载图片就会比在 bind 钩子函数中加载晚大约 200ms，在 4G 网络环境下，200ms 对于很多图片来说已经足够用来加载了，因此我们最终放弃了在 inserted 钩子函数中加载首屏图片的方案。</p>
<p><strong>如果元素没有插入到 DOM 树中并渲染，怎么能够判断其是否在首屏中呢？</strong></p>
<blockquote>
<img v-img="{ hash: 'xxx', defer: true }">
</blockquote>
<p>项目中使用了一种比较笨的方式来判断哪些是首屏图片，新零售页面布局是确定的，轮播广告栏下面是促销栏、再下面是店铺列表，这些组件的高度也都相对固定，因此这些组件是否在首屏中其实我们是事先知道的。因此在实际使用<a href="https://link.zhihu.com/?target=https://github.com/ElemeFE/vue-img">v-img</a>指令的时候，通过传 defer 配置项来告诉 v-img 哪些图片需要提前加载，哪些图片等待提前加载的图片加载完毕后再加载。这样我们就能够在 bind 钩子函数中加载优先加载的图片了。比如说，轮播组件图片、促销组件图片、前两个店铺中的展示图片需要先加载，除此以外的其他图片，需等待首屏图片完全加载后再进行请求加载。实际实现代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = []; <span class="comment">// 用来存储优先加载的图片</span></span><br><span class="line">Vue.directive(<span class="string">&quot;img&quot;</span>, &#123;</span><br><span class="line">  <span class="function"><span class="title">bind</span>(<span class="params">el, binding, vnode</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> &#123; defer &#125; = binding.value;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (!defer) &#123;</span><br><span class="line">      promises.push(update(el, binding, vnode));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">inserted</span>(<span class="params">el, binding, vnode</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; defer &#125; = binding.value;</span><br><span class="line">    <span class="keyword">if</span> (!defer) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (inViewport(el)) &#123;</span><br><span class="line">      promises.push(update(el, binding, vnode));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Vue.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">Promise</span>.all(promises)</span><br><span class="line">          .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            promises.length = <span class="number">0</span>;</span><br><span class="line">            update(el, binding, vnode);</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>首先通过声明一个数组 promises 用于存储优先加载的图片，在 bind 钩子函数内部，如果 defer 配置项为 false，说明不延时加载，那么就在 bind 钩子函数内部加载该图片，且将返回的 promise 推入到 promises 数组中。在 inserted 钩子函数内，对于延迟加载的图片（defer 为 true），但是其又在首屏内，那么也有优先加载权，在 inseted 钩子函数调用时就对其加载。而对于非首屏且延迟加载的图片等待 promises 数组内部所有的图片都加载完成后才加载。当然在实际代码中还会考虑容错机制，比如上面某张图片加载失败、或者加载时间太长等。因此我们可以配置一个最大等待时间。<br>优化后的图片加载瀑布图如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619154236444-47386cf6-0b09-40ee-b395-4b4d4584cba4.jpeg#clientId=uc716cf97-bcfe-4&from=paste&height=732&id=ue2cc6cb2&margin=%5Bobject%20Object%5D&originHeight=732&originWidth=720&originalType=url&status=done&style=none&taskId=u778a9e8a-2981-4ffa-9a6c-4dc6e9d9663&width=720"><br><strong>图 3</strong>. 图片按需加载的瀑布图<br>如上图所示，下面红框的图片不是首屏图片，因此进行了延迟加载。可以看出，其是在上面所有图片（包括上面的红框中耗时最长的那张图）加载完成之后进行加载的。这样减少了首屏加载时的网络消耗，提升了图片下载速度。<br><strong>优化前后对比</strong><br>通过上面的优化方案，在预设的网络环境下（参见文末注），分别对优化前和优化后进行了 5 次平行清空缓存加载，平均数据如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619154254755-bcd04db3-16bf-4846-8819-9e80588679bf.jpeg#clientId=uc716cf97-bcfe-4&from=paste&height=130&id=u00930861&margin=%5Bobject%20Object%5D&originHeight=130&originWidth=720&originalType=url&status=done&style=none&taskId=uac8e2e49-a999-4b0e-9e3c-e6b7b96b23c&width=720"><br>通过上面表格可以看出，DOMContentLoaded 和 Loaded 并没有多大参考价值，首屏的完整展现所需要的时间依然由加载最慢（一般都是体积最大那张图片）的图片决定，也就是上表的 Max_size_image 决定，上表可以看出，优化后比优化前最大体积图片的加载时间缩短了<strong>5.74s</strong>。提速了整整**41.41%**。加载最慢的图片加载速度的变化也很好的反应了首屏时间的变化。<br>当然上面的数据也不能够完全反应线上场景，毕竟测试的时间点及后端数据都有所不同。我们也不能够在同一时间点、同一网络环境下对优化前、优化后进行同时数据采集。<br><strong>针对问题一还有些后续的解决方案：</strong></p>
<ul>
<li>在 HTTP/1.0 和 HTTP/1.1 协议下，由于 Chrome 只支持同域同时发送 6 个并发请求，可以进行域名切分，来提升并发的请求数量，或者使用 HTTP/2 协议。</li>
</ul>
<p><strong>针对问题二的解决方案</strong><br><strong>图片体积过大，导致下载时间过长。</strong>在保证清晰度的前提下尽量使用体积较小的图片。而一张图片的体积由两个因素决定，该图片总的像素数目和编码单位像素所需的字节数。因此一张图片的文件大小就等于图片总像素数目乘以编码单位像素所需字节数，也就是如下等式：<br>FileSize = Total Number Pixels _ Bytes of Encode single Pixels<br>举个例子：<br>一张 100px _ 100px 像素的图片，其包含该 100 _ 100 = 10000 个像素点，而每个像素点通过 RGBA 颜色值进行存储，R\G\B\A 每个色道都有 0~255 个取值，也就是 2^8 = 256。正好是 8 位 1byte。而每个像素点有四个色道，每个像素点需要 4bytes。因此该图片体积为：10000 _ 4bytes = 40000bytes = 39KB。<br>有了上面的背景知识后，我们就知道怎么去优化一张图片了，无非就两个方向：</p>
<ul>
<li>一方面是减少单位像素所需的字节数</li>
<li>另一方面是减少一张图片总的像素个数</li>
</ul>
<p><strong>单位像素优化</strong>：单位像素的优化也有两个方向，一个方向是「有损」的删除一些像素数据，另一个方面是做一些「无损」的图片像素压缩。正如上面例子所说，RGBA 颜色值可以表示 256^4 种颜色，这是一个很大的数字，往往我们不需要这么多颜色值，因此我们是否可以减少色板中的颜色种类呢？这样表示单位像素的字节数就减少了。而「无损」压缩是通过一些算法，存储像素数据不变的前提下，尽量减少图片存储体积。比如一张图片中的某一个像素点和其周围的像素点很接近，比如一张蓝天的图片，因此我们可以存储两个像素点颜色值的差值（当然实际算法中可能不止考虑两个像素点也许更多），这样既保证了像素数据的「无损」，同时也减少了存储体积。不过也增加了图片解压缩的开销。<br>针对单位像素的优化，衍生出了不同的图片格式，jpeg、png、gif、webp。不同的图片格式都有自己的减少单位像素体积的算法。同时也有各自的优势和劣势，比如 jpeg 和 png 不支持动画效果，jpeg 图片体积小但是不支持透明度等。因此项目在选择图片格式上的策略就是，在满足自己需求的前提下选择体积最小的图片格式，新零售项目中已经统一使用的 WebP 格式，和 jpeg 格式相比，其体积更减少 30%，同时还支持动画和透明度。<br><strong>图片像素总数优化</strong>：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619154330747-73f2544a-2ed5-4ff1-9ee2-ed1ad86eb358.png#clientId=uc716cf97-bcfe-4&from=paste&height=116&id=ude860fbe&margin=%5Bobject%20Object%5D&originHeight=116&originWidth=331&originalType=url&status=done&style=none&taskId=u4ee0138b-0e4d-4eef-9734-d1d71cddb27&width=331"><br><strong>图 4</strong>：图片加载尺寸和实际渲染尺寸对比<br>上图是新零售类目页在 Chrome 浏览器中的 iPhone 6 模拟器加载后的轮播展示的图片之一，展示的图片是 750 _ 188 像素，但是图片的实际尺寸为 1440 _ 360 像素，也就是说我们根本不需要这么大的图片，大图片不仅造成了图片加载的时长增加（后面会有数据说明），同时由于图片尺寸需要缩小增加 CPU 的负担。<br>上文中已经提及，项目中我们使用的 v-img 指令来加载项目中的所需图片，如果我们能够根据设备的尺寸来加载不同尺寸（像素总数不同）的图片，也就是说在保证图片清晰度的前提下，尽量使用体积小的图片，问题就迎刃而解了。项目中我们使用的是七牛的图片服务，<a href="https://link.zhihu.com/?target=https://developer.qiniu.com/dora/manual/1270/the-advanced-treatment-of-images-imagemogr2">七牛图片服务</a>提供了图片格式转换、按尺寸裁剪等图片处理功能。只需要对 v-img 指令添加图片宽、高的配置，那么我们是不是可以对不同的设备加载不同尺寸的图片呢？<br>项目中我们使用的<a href="https://link.zhihu.com/?target=https://github.com/amfe/lib-flexible">lib-flexible</a>来对不同的移动端设备进行适配，lib-flexible 库在我们页面的 html 元素添加了两个属性，data-dpr 和 style。这儿我们主要会用到 style 中的 font-size 值，在一定的设备范围内其正好是 html 元素宽度的十分之一（具体原理参见：<a href="https://link.zhihu.com/?target=http://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html">使用 Flexible 实现手淘 H5 页面的终端适配</a>），也就是说我们可以通过 style 属性大概获取到设备的宽度。同时设计稿又是以 iPhone6 为基础进行设计的，也就是设计稿是宽度为 750px 的设计图，这样在设计图中的图片大小我们也就能够转换成其他设备中所需的图片大小了。<br>举个例子：<br>设计稿中一张宽 200px 的图片，其对应的 iPhone 6 设备的宽度为 750px。我们通过 html 元素的 style 属性计算出 iPhone6 plus 的宽度为 1242px。这样也就能够计算中 iPhone6 plus 所需图片尺寸。计算如下：<br>200 * 1242 / 750 = 331.2px<br>实现代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resize = <span class="function">(<span class="params">size</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> viewWidth;</span><br><span class="line">  <span class="keyword">const</span> dpr = <span class="built_in">window</span>.devicePixelRatio;</span><br><span class="line">  <span class="keyword">const</span> html = <span class="built_in">document</span>.documentElement;</span><br><span class="line">  <span class="keyword">const</span> dataDpr = html.getAttribute(<span class="string">&quot;data-dpr&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> ratio = dataDpr ? dpr / dataDpr : dpr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    viewWidth = +(html.getAttribute(<span class="string">&quot;style&quot;</span>).match(<span class="regexp">/(\d+)/</span>) || [])[<span class="number">1</span>];</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">const</span> w = html.offsetWidth;</span><br><span class="line">    <span class="keyword">if</span> (w / dpr &gt; <span class="number">540</span>) &#123;</span><br><span class="line">      viewWidth = (<span class="number">540</span> * dpr) / <span class="number">10</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      viewWidth = w / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  viewWidth = viewWidth * ratio;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Number</span>(viewWidth) &gt;= <span class="number">0</span> &amp;&amp; <span class="keyword">typeof</span> viewWidth === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (size * viewWidth) / <span class="number">75</span>; <span class="comment">// 75 is the 1/10 iphone6 deivce width pixel</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面 resize 方法用于将配置的宽、高值转换为实际所需的图片尺寸，也就是说，size 参数是 iphone 6 设计稿中的尺寸，resize 的返回值就是当前设备所需的尺寸，再把该尺寸配置到图片服务器的传参中，这样我们就能够获取到按设备裁剪后的图片了。<br><strong>优化前后效果对比</strong>，有了上面的基础，我们在 Chrome 中的不同的移动端模拟器上进行了实验，我们对新零售类目页中的一张体积最大的广告图片在不同设备中的加载进行了数据统计（平行三次清空缓存加载），为什么选择体积最大的图片，上文也已经说过，其决定了首屏展现所需的时间。<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619154382774-f516ce8a-aed1-4a7f-9653-22d2d2a9df0f.jpeg#clientId=uc716cf97-bcfe-4&from=paste&height=285&id=u71f6c189&margin=%5Bobject%20Object%5D&originHeight=285&originWidth=720&originalType=url&status=done&style=none&taskId=ud752b764-d81b-44c4-8e9b-89083237490&width=720"><br>上表格中，除去最后一行是未优化的加载数据，从上到下，设备屏幕尺寸逐渐变大，加载的图片尺寸也从 23.2kb 增加到 65.5kb。而加载时间和下载时长也跟随着图片体积的加大而增加，下面的折线图更能够反应图片尺寸、加载时长、下载时长之间的正相关关系。TTFB（从发送请求到接收到第一个字节所需时长）却和图片大小没有明显的正相关关系，可能对于图片服务器在裁剪上述不同尺寸的图片所需时长差异不大。<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619154382719-89420942-d084-4bd2-b8ea-ea9fb2fc338c.jpeg#clientId=uc716cf97-bcfe-4&from=paste&height=300&id=ufa56ddca&margin=%5Bobject%20Object%5D&originHeight=300&originWidth=720&originalType=url&status=done&style=none&taskId=u92216d5c-ddd9-4719-87ef-028fcbc54d1&width=720"><br><strong>图 5</strong>：不同设备中对同一张图片进行加载，文件大小、加载和下载时长的折线变化<br>由上折线图我们还能看到，对于小屏幕设备的效果尤为明显，在不优化下，iPhone5 中图片的加载需要 14.85s，而优化后，加载时长缩短到了 3.90s。加载时长整整缩短了**73.73%<strong>。而对于大屏幕的 iPhone6 plus 也有</strong>26.00%<strong>时长优化。<br>当然上面的数据是建立在 256 kbps ISDN/DSL 的网络环境下的，该低速网络环境下，图片的加载时间主要是由于下载时间决定的，因此通过优化图片体积能够达到很好的效果。在 4G（Charles 模拟）环境下，iPhone5 中的优化效果就会有些折扣，加载时长缩短</strong>69.15%**。其实也很容易想到，在高速的网络环境下，TTFB 对加载时长的影响会比低速网络环境下影响要大一些。</p>
<h2 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a><strong>最后总结</strong></h2><p>通过上面的研究及数据结果表明，新零售图片加载缓慢的优化策略：</p>
<ul>
<li>首屏图片优先加载，等首屏图片加载完全后再去加载非首屏图片。</li>
<li>对大部分图片，特别是轮播广告中的图片进行按设备尺寸裁剪，减少图片体积，减少网络开销，加快下载速率。</li>
</ul>
<p>本文中没有过多的讨论代码实现细节，而是把重点放在了图片加载缓慢的原因分析，以及优化前后效果对比的数据分析上，如果想看更多代码细节，请移步<a href="https://link.zhihu.com/?target=https://github.com/ElemeFE/vue-img">vue-img</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/23/yuque/%E7%99%BD%E5%B1%8F%E6%97%B6%E9%97%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/23/yuque/%E7%99%BD%E5%B1%8F%E6%97%B6%E9%97%B4/" class="post-title-link" itemprop="url">白屏时间</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-23 12:22:29" itemprop="dateCreated datePublished" datetime="2021-04-23T12:22:29+08:00">2021-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-25 16:49:31" itemprop="dateModified" datetime="2021-04-25T16:49:31+08:00">2021-04-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该篇文章会为您分享在前端性能优化中非常重要的一环-白屏时间，将从白屏时间的概念、重要性以及白屏的过程一一进行阐述，同时提供性能优化的策略与实践。</p>
<h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p>白屏时间：即用户点击一个链接或打开浏览器输入 URL 地址后，从屏幕空白到显示第一个画面的时间。<br>白屏时间的长短将直接影响用户对该网站的第一印象。</p>
<h2 id="二、白屏时间的重要性"><a href="#二、白屏时间的重要性" class="headerlink" title="二、白屏时间的重要性"></a>二、白屏时间的重要性</h2><p>当用户点开一个链接或者是直接在浏览器中输入 URL 开始进行访问时，就开始等待页面的展示。页面渲染的时间越短，用户等待的时间就越短，用户感知到页面的速度就越快。这样可以极大的提升用户的体验，减少用户的跳出，提升页面的留存率。<br>打开一个页面就像你的女票召唤你一样，你出现的越迅速，女票肯定会愈加欣喜！反之，你千呼万唤始出来，那么你的女票很可能又要抛弃你了(为什么要对你说又呢? …)</p>
<h2 id="三、白屏是一个怎样的过程呢？"><a href="#三、白屏是一个怎样的过程呢？" class="headerlink" title="三、白屏是一个怎样的过程呢？"></a>三、白屏是一个怎样的过程呢？</h2><p>让我们一起来揭秘：从打开一个页面，到页面的画面展示经历了怎样的过程！</p>
<h3 id="1-DNS-Lookup"><a href="#1-DNS-Lookup" class="headerlink" title="1. DNS Lookup"></a>1. DNS Lookup</h3><p>DNS Lookup 即浏览器从 DNS 服务器中进行域名查询。<br>浏览器会先对页面进行<a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/cns?from=10680">域名解析</a>，获取到服务器的 IP 地址后，进而和服务器进行通信。<br>Tips: 通常在整个加载页面的过程中，浏览器会多次进行 DNS Lookup，包括页面本身的域名查询以及在解析 HTML 页面时加载的 JS、CSS、Image、Video 等资源产生的域名查询。</p>
<h3 id="2-建立-TCP-请求连接"><a href="#2-建立-TCP-请求连接" class="headerlink" title="2. 建立 TCP 请求连接"></a>2. 建立 TCP 请求连接</h3><p>浏览器和服务端 TCP 请求建立的过程，是基于 TCP/IP，该协议由网络层的 IP 和传输层的 TCP 组成。IP 是每一台互联网设备在互联网中的唯一地址。<br>TCP 通过三次握手建立连接，并提供可靠的数据传输服务。</p>
<h3 id="3-服务端请求处理响应"><a href="#3-服务端请求处理响应" class="headerlink" title="3. 服务端请求处理响应"></a>3. 服务端请求处理响应</h3><p>在 TCP 连接建立后，Web 服务器接受请求，开始进行处理，同时浏览器端开始等待服务器的处理响应。<br>Web 服务器根据请求类型的不同，进行相应的处理。静态资源如图片、CSS 文件、静态 HTML 直接进行响应；如其他注册的请求转发给相应的应用服务器，进行如数据处理、缓存中取数据，将数据按照约定好的格式响应给浏览器。<br>在大型应用中，通常为分布式服务架构，应用服务器的处理有可能经过很多个系统的中间件，最终获取到需要的数据</p>
<h3 id="4-客户端下载、解析、渲染显示页面"><a href="#4-客户端下载、解析、渲染显示页面" class="headerlink" title="4. 客户端下载、解析、渲染显示页面"></a>4. 客户端下载、解析、渲染显示页面</h3><p>在服务器返回数据后，客户端浏览器接收数据，进行 HTML 下载、解析、渲染显示。</p>
<ul>
<li>a. 如果是 Gzip 包，则先解压为 HTML</li>
<li>b. 解析 HTML 的头部代码，下载头部代码中的样式资源文件或脚本资源文件</li>
<li>c. 解析 HTML 代码和样式文件代码，构建 HTML 的 DOM 树以及与 CSS 相关的 CSSOM 树</li>
<li>d. 通过遍历 DOM 树和 CSSOM 树，浏览器依次计算每个节点的大小、坐标、颜色等样式，构造渲染树</li>
<li>e. 根据渲染树完成绘制过程</li>
</ul>
<p>浏览器下载 HTML 后，首先解析头部代码，进行样式表下载，然后继续向下解析 HTML 代码，构建 DOM 树，同时进行样式下载。当 DOM 树构建完成后，立即开始构造 CSSOM 树。理想情况下，样式表下载速度够快，DOM 树和 CSSOM 树进入一个并行的过程，当两棵树构建完毕，构建渲染树，然后进行绘制。<br>Tips:浏览器安全解析策略对解析 HTML 造成的影响：</p>
<ul>
<li>当解析 HTML 时遇到内联 JS 代码，会阻塞 DOM 树的构建</li>
<li>特别悲惨的情况： 当 CSS 样式文件没有下载完成时，浏览器解析 HTML 遇到了内联 JS 代码，此时！！！根据浏览器的安全解析策略，浏览器暂停 JS 脚本执行，暂停 HTML 解析。直到 CSS 文件下载完成，完成 CSSOM 树构建，重新恢复原来的解析。<br>一定要合理放置 JS 代码！！！</li>
</ul>
<h2 id="四、白屏-性能优化"><a href="#四、白屏-性能优化" class="headerlink" title="四、白屏-性能优化"></a>四、白屏-性能优化</h2><p>至此，我们已经了解了从浏览器在打开一个链接开始，到屏幕展示的过程-白屏时间的历程，那这对每个环节中发生的事情，我们可以有针对性的进行相关的优化。</p>
<h3 id="1-DNS-解析优化"><a href="#1-DNS-解析优化" class="headerlink" title="1. DNS 解析优化"></a>1. DNS 解析优化</h3><p>针对 DNS Lookup 环节，我们可以针对性的进行 DNS 解析优化。</p>
<ul>
<li>DNS 缓存优化</li>
<li>DNS 预加载策略</li>
<li>稳定可靠的 DNS 服务器</li>
</ul>
<h3 id="2-TCP-网络链路优化"><a href="#2-TCP-网络链路优化" class="headerlink" title="2. TCP 网络链路优化"></a>2. TCP 网络链路优化</h3><p>针对网络链路的优化，好像除了花钱没有什么更好的方式！</p>
<h3 id="3-服务端处理优化"><a href="#3-服务端处理优化" class="headerlink" title="3. 服务端处理优化"></a>3. 服务端处理优化</h3><p>服务端的处理优化，是一个非常庞大的话题，会涉及到如<a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/crs?from=10680">Redis</a>缓存、数据库存储优化或是系统内的各种中间件以及 Gzip 压缩等…</p>
<h3 id="4-浏览器下载、解析、渲染页面优化"><a href="#4-浏览器下载、解析、渲染页面优化" class="headerlink" title="4. 浏览器下载、解析、渲染页面优化"></a>4. 浏览器下载、解析、渲染页面优化</h3><p>根据浏览器对页面的下载、解析、渲染过程，可以考虑一下的优化处理：</p>
<ul>
<li>尽可能的精简 HTML 的代码和结构</li>
<li>尽可能的优化 CSS 文件和结构</li>
<li>一定要合理的放置 JS 代码，尽量不要使用内联的 JS 代码</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Adam Blog</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Adam Blog</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
