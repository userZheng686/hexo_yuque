<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Adam">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Adam">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Adam Blog">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Adam</title>
  <meta name="referrer" content="no-referrer" />
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Adam</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/29/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/29/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-29 18:35:30" itemprop="dateCreated datePublished" datetime="2021-04-29T18:35:30+08:00">2021-04-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/29/yuque/String%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95api/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/29/yuque/String%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95api/" class="post-title-link" itemprop="url">String常用方法api</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-29 13:06:47 / 修改时间：18:36:13" itemprop="dateCreated datePublished" datetime="2021-04-29T13:06:47+08:00">2021-04-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-String-fromCharCode"><a href="#1-String-fromCharCode" class="headerlink" title="1.String.fromCharCode()"></a>1.String.fromCharCode()</h1><p><strong>String 对象提供的静态方法（即定义在对象本身，而不是定义在对象实例的方法），主要是 String.fromCharCode()。该方法的参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">104</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>);</span><br><span class="line"><span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="2-String-prototype-length"><a href="#2-String-prototype-length" class="headerlink" title="2.String.prototype.length"></a>2.String.prototype.length</h1><p>字符串实例的 length 属性返回字符串的长度。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;abc&quot;</span>.length; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h1 id="3-String-prototype-charAt"><a href="#3-String-prototype-charAt" class="headerlink" title="3.String.prototype.charAt()"></a>3.String.prototype.charAt()</h1><p>charAt 方法返回指定位置的字符，参数是从 0 开始编号的位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">s.charAt();</span><br><span class="line">a;</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br><span class="line"><span class="comment">// String &#123;&quot;abc&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="4-String-prototype-charCodeAt"><a href="#4-String-prototype-charCodeAt" class="headerlink" title="4.String.prototype.charCodeAt()"></a>4.String.prototype.charCodeAt()</h1><p><strong>charCodeAt()方法返回字符串指定位置的 Unicode 码点（十进制表示），相当于 String.fromCharCode()的逆操作。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;abc&quot;</span>.charCodeAt(<span class="number">1</span>); <span class="comment">// 98</span></span><br></pre></td></tr></table></figure>

<h1 id="5-String-prototype-concat"><a href="#5-String-prototype-concat" class="headerlink" title="5.String.prototype.concat()"></a>5.String.prototype.concat()</h1><p><strong>concat 方法用于连接两个字符串，返回一个新字符串，不改变原字符串。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;abc&quot;</span>.concat(<span class="string">&quot;bcd&quot;</span>);</span><br><span class="line"><span class="comment">// &quot;abcbcd&quot;</span></span><br><span class="line"><span class="string">&quot;abc&quot;</span>.concat(<span class="string">&quot;bcd&quot;</span>, <span class="string">&quot;dss&quot;</span>);</span><br><span class="line"><span class="comment">// &quot;abcbcddss&quot;</span></span><br><span class="line"><span class="string">&quot;abc&quot;</span>.concat(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// &quot;abc123&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="6-String-prototype-slice"><a href="#6-String-prototype-slice" class="headerlink" title="6.String.prototype.slice()"></a>6.String.prototype.slice()</h1><p><strong>slice()方法用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;JavaScript&quot;</span>.slice(<span class="number">0</span>, <span class="number">4</span>); <span class="comment">// &quot;Java&quot;</span></span><br><span class="line"><span class="string">&quot;JavaScript&quot;</span>.slice(<span class="number">4</span>); <span class="comment">// &quot;Script&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="7-String-prototype-substring"><a href="#7-String-prototype-substring" class="headerlink" title="7.String.prototype.substring()"></a>7.String.prototype.substring()</h1><p><strong>substring 方法用于从原字符串取出子字符串并返回，不改变原字符串，跟 slice 方法很相像。它的第一个参数表示子字符串的开始位置，第二个位置表示结束位置（返回结果不含该位置）</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Javascript&quot;</span>.substring(<span class="number">0</span>, <span class="number">4</span>); <span class="comment">// &quot;Java&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="8-String-prototype-substr"><a href="#8-String-prototype-substr" class="headerlink" title="8.String.prototype.substr()"></a>8.String.prototype.substr()</h1><p><strong>substr 方法用于从原字符串取出子字符串并返回，不改变原字符串，跟 slice 和 substring 方法的作用相同。</strong><br><strong>substr 方法的第一个参数是子字符串的开始位置（从 0 开始计算），第二个参数是子字符串的长度</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Javascript&quot;</span>.substr(<span class="number">0</span>, <span class="number">4</span>); <span class="comment">// &quot;Java&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="9-String-prototype-indexOf-，String-prototype-lastIndexOf"><a href="#9-String-prototype-indexOf-，String-prototype-lastIndexOf" class="headerlink" title="9.String.prototype.indexOf()，String.prototype.lastIndexOf()"></a>9.String.prototype.indexOf()，String.prototype.lastIndexOf()</h1><p><strong>indexOf 方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回-1，就表示不匹配。</strong><br><strong>indexOf 方法还可以接受第二个参数，表示从该位置开始向后匹配。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;hello&quot;</span>.indexOf(<span class="string">&quot;o&quot;</span>); <span class="comment">// 4</span></span><br><span class="line"><span class="string">&quot;hello&quot;</span>.indexOf(<span class="string">&quot;h&quot;</span>, <span class="number">1</span>); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<p><strong>lastIndexOf 方法的用法跟 indexOf 方法一致，主要的区别是 lastIndexOf 从尾部开始匹配，indexOf 则是从头部开始匹配。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;hello world&quot;</span>.lastIndexOf(<span class="string">&quot;o&quot;</span>); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

<h1 id="10-String-prototype-trim"><a href="#10-String-prototype-trim" class="headerlink" title="10.String.prototype.trim()"></a>10.String.prototype.trim()</h1><p><strong>trim 方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。</strong><br><strong>该方法去除的不仅是空格，还包括制表符（\t、\v）、换行符（\n）和回车符（\r）。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;  hello world  &quot;</span>.trim();</span><br><span class="line"><span class="comment">// &quot;hello world&quot;</span></span><br><span class="line"><span class="string">&quot;\r\nabc \t&quot;</span>.trim(); <span class="comment">// &#x27;abc&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="11-String-prototype-toLowerCase-，String-prototype-toUpperCase"><a href="#11-String-prototype-toLowerCase-，String-prototype-toUpperCase" class="headerlink" title="11.String.prototype.toLowerCase()，String.prototype.toUpperCase()"></a>11.String.prototype.toLowerCase()，String.prototype.toUpperCase()</h1><p><strong>toLowerCase 方法用于将一个字符串全部转为小写，toUpperCase 则是全部转为大写。它们都返回一个新字符串，不改变原字符串。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Hello World&quot;</span>.toLowerCase();</span><br><span class="line"><span class="comment">// &quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Hello World&quot;</span>.toUpperCase();</span><br><span class="line"><span class="comment">// &quot;HELLO WORLD&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="12-String-prototype-match"><a href="#12-String-prototype-match" class="headerlink" title="12.String.prototype.match()"></a>12.String.prototype.match()</h1><p><strong>match 方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回 null。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;hello&quot;</span>.match(<span class="string">&quot;ll&quot;</span>);</span><br><span class="line"><span class="comment">// [&quot;ll&quot;, index: 2, input: &quot;hello&quot;, groups: undefined]</span></span><br><span class="line"><span class="string">&quot;hello&quot;</span>.match(<span class="string">&quot;;;&quot;</span>);</span><br><span class="line"><span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p><strong>返回的数组还有 index 属性和 input 属性，分别表示匹配字符串开始的位置和原始字符串。</strong></p>
<h1 id="13-String-prototype-search-，String-prototype-replace"><a href="#13-String-prototype-search-，String-prototype-replace" class="headerlink" title="13.String.prototype.search()，String.prototype.replace()"></a>13.String.prototype.search()，String.prototype.replace()</h1><p><strong>search 方法的用法基本等同于 match，但是返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;hello&quot;</span>.search(<span class="string">&quot;ll&quot;</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h1 id="14-String-prototype-split"><a href="#14-String-prototype-split" class="headerlink" title="14.String.prototype.split()"></a>14.String.prototype.split()</h1><p><strong>split 方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;a|b|c&quot;</span>.split(<span class="string">&quot;|&quot;</span>); <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"><span class="string">&quot;a|b|c&quot;</span>.split(<span class="string">&quot;&quot;</span>); <span class="comment">// [&quot;a&quot;, &quot;|&quot;, &quot;b&quot;, &quot;|&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure>

<p><strong>replace 方法用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有 g 修饰符的正则表达式）。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;aaa&quot;</span>.replace(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>); <span class="comment">// &quot;baa&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="15-String-prototype-localeCompare"><a href="#15-String-prototype-localeCompare" class="headerlink" title="15.String.prototype.localeCompare()"></a>15.String.prototype.localeCompare()</h1><p><strong>localeCompare 方法用于比较两个字符串。它返回一个整数，如果小于 0，表示第一个字符串小于第二个字符串；如果等于 0，表示两者相等；如果大于 0，表示第一个字符串大于第二个字符串。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;apple&quot;</span>.localeCompare(<span class="string">&quot;banana&quot;</span>); <span class="comment">// -1</span></span><br><span class="line"><span class="string">&quot;apple&quot;</span>.localeCompare(<span class="string">&quot;apple&quot;</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h1 id="16-repeat"><a href="#16-repeat" class="headerlink" title="16.repeat()"></a>16.repeat()</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/29/yuque/uglify%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/29/yuque/uglify%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">uglify原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-29 13:03:10 / 修改时间：18:36:13" itemprop="dateCreated datePublished" datetime="2021-04-29T13:03:10+08:00">2021-04-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-AST（抽象语法树）"><a href="#1-AST（抽象语法树）" class="headerlink" title="1. AST（抽象语法树）"></a>1. AST（抽象语法树）</h2><p>要想了解 JS 的压缩原理，需要首先了解 AST。<br>抽象语法树：AST（Abstract Syntax Tree)，是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。树上的每个节点都表示源代码中的一种结构。之所以说语法是「抽象」的，是因为这里的语法并不会表示出真实语法中出现的每个细节。<br>举个例子：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619672668724-5d3358d3-d081-4ee0-8dfb-5ea211241701.png#clientId=u345a0e7d-2a1d-4&from=paste&height=288&id=u08c9713a&margin=%5Bobject%20Object%5D&originHeight=288&originWidth=800&originalType=url&status=done&style=none&taskId=u7b2e6f9e-7023-443f-bad2-85b82471e5d&width=800"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619672668632-dfb7a922-3e21-4aa2-a90e-1f63de20b25d.png#clientId=u345a0e7d-2a1d-4&from=paste&height=599&id=u35c87bbd&margin=%5Bobject%20Object%5D&originHeight=599&originWidth=800&originalType=url&status=done&style=none&taskId=u89688d6a-a0a1-46a2-8ea2-8032c37b70d&width=800"><br>从上面两个例子中，可以看出 AST 是源代码根据其语法结构，省略一些细节（比如：括号没有生成节点），抽象成树形表达。抽象语法树在计算机科学中有很多应用，比如编译器、IDE、压缩代码、格式化代码等。[1]</p>
<h2 id="2-代码压缩原理"><a href="#2-代码压缩原理" class="headerlink" title="2. 代码压缩原理"></a>2. 代码压缩原理</h2><p>了解了 AST 之后，我们再分析一下 JS 的代码压缩原理。简单的说，就是</p>
<ol>
<li>将 code 转换成 AST</li>
<li>将 AST 进行优化，生成一个更小的 AST</li>
<li>将新生成的 AST 再转化成 code<br>PS：具体的 AST 树大家可以在 astexplorer 上在线获得<br>babel，eslint，v8 的逻辑均与此类似，下图是我们引用了 babel 的转化示意图：<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619672668742-e01926f8-b6e2-484e-8199-be950d1dc148.jpeg#clientId=u345a0e7d-2a1d-4&from=paste&height=332&id=uea97fb66&margin=%5Bobject%20Object%5D&originHeight=332&originWidth=800&originalType=url&status=done&style=none&taskId=ubdc3cbe5-e218-40ee-9e90-498a01e57ba&width=800"><br>以我们之前被质疑的代码为例，看看它在 uglify 中是怎么样一步一步被压缩的：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uglify-js的版本需要为2.x, 3.0之后uglifyjs不再暴露Compressor api</span></span><br><span class="line"><span class="comment">// 2.x的uglify不能自动解析es6，所以这里先切换成es5</span></span><br><span class="line"><span class="comment">// npm install uglify-js@2.x</span></span><br><span class="line"><span class="keyword">var</span> UglifyJS = <span class="built_in">require</span>(<span class="string">&quot;uglify-js&quot;</span>);</span><br><span class="line"><span class="comment">// 原始代码</span></span><br><span class="line"><span class="keyword">var</span> code = <span class="string">`var a;</span></span><br><span class="line"><span class="string">var x = &#123; b: 123 &#125;;</span></span><br><span class="line"><span class="string">a = 123,</span></span><br><span class="line"><span class="string">delete x`</span>;</span><br><span class="line"><span class="comment">// 通过 UglifyJS 把代码解析为 AST</span></span><br><span class="line"><span class="keyword">var</span> ast = UglifyJS.parse(code);</span><br><span class="line">ast.figure_out_scope();</span><br><span class="line"><span class="comment">// 转化为一颗更小的 AST 树</span></span><br><span class="line">compressor = UglifyJS.Compressor();</span><br><span class="line">ast = ast.transform(compressor);</span><br><span class="line"><span class="comment">// 再把 AST 转化为代码</span></span><br><span class="line">code = ast.print_to_string();</span><br><span class="line"><span class="comment">// var a,x=&#123;b:123&#125;;a=123,delete x;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;code&quot;</span>, code);</span><br></pre></td></tr></table></figure>

<p>到这里，我们已经了解了 uglifyjs 的代码压缩原理，但是还没有解决一个问题——为什么某些语句间的分号会被转换为逗号，某些不会转换。这就涉及到了 uglifyjs 的压缩规则。</p>
<h2 id="3-代码压缩规则"><a href="#3-代码压缩规则" class="headerlink" title="3. 代码压缩规则"></a>3. 代码压缩规则</h2><p>由于 uglifyjs 的代码压缩规则很多，我们这里只分析与本文中相关的部分:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uglifyjs的全部压缩规则可以参见：</span><br><span class="line">《[解读uglifyJS（四）——Javascript代码压缩](https:&#x2F;&#x2F;rapheal.sinaapp.com&#x2F;2014&#x2F;05&#x2F;22&#x2F;uglifyjs-squeeze&#x2F;#more-705)》</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619672718992-6f322231-e031-4622-9fe6-93c5bed01720.png#clientId=u345a0e7d-2a1d-4&from=paste&height=145&id=u42935634&margin=%5Bobject%20Object%5D&originHeight=145&originWidth=800&originalType=url&status=done&style=none&taskId=u9312dfff-ac37-4f6a-b034-b454e30c000&width=800"><br>PS：在线 demo<br>这其中需要注意的是只有“表达式语句”才能被合并，那么什么是表达式语句呢？<br><strong>表达式 VS 语句 VS 表达式语句</strong><br>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a; <span class="comment">//返回a的值</span></span><br><span class="line">b + <span class="number">3</span>; <span class="comment">// 返回b+3的结果</span></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; arr.length; i ++) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   A();</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;();</span><br><span class="line"><span class="keyword">delete</span> x.b;</span><br><span class="line">b = b + <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>综上所述，因为 a = 123 和 delete x 都是表达式语句，所以分号被转换为逗号。而 var x = {b:123}则因为是声明语句，所以和 a=123 不会合并，分号不会被转换。但 var x = {b:123}和第一行 var a 又触发了另外一条规则，<br>所以第一行和第二行会被合并为 var a,x={b:123}</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>在本文中，我们讨论了什么是抽象语法树，uglifyjs 的压缩原理，以及相应的压缩规则，最终明晰了为什么代码会被压缩成我们得到的样子，希望对大家有所帮助。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/28/yuque/Array%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95api/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/28/yuque/Array%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95api/" class="post-title-link" itemprop="url">Array常用方法api</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-28 13:22:31" itemprop="dateCreated datePublished" datetime="2021-04-28T13:22:31+08:00">2021-04-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 18:36:13" itemprop="dateModified" datetime="2021-04-29T18:36:13+08:00">2021-04-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-扩展运算符"><a href="#1-扩展运算符" class="headerlink" title="1.扩展运算符"></a>1.扩展运算符</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 1 2</span></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> arr3 = arr1.concat(arr2);</span><br><span class="line"><span class="built_in">console</span>.log(...[arr3]); <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span></span><br><span class="line"><span class="keyword">const</span> [a, b, c] = [...arr3];</span><br><span class="line"><span class="comment">// a : &quot;a&quot;</span></span><br><span class="line"><span class="comment">// b : &quot;b&quot;</span></span><br><span class="line"><span class="comment">// c : &quot;c&quot;</span></span><br><span class="line"><span class="keyword">const</span> d = [...<span class="string">&quot;hello&quot;</span>];</span><br><span class="line"><span class="comment">// [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]</span></span><br></pre></td></tr></table></figure>

<h1 id="2-Array-from"><a href="#2-Array-from" class="headerlink" title="2.Array.from()"></a>2.Array.from()</h1><p><strong>Array.from 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arraylike = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">  length: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(arraylike);</span><br><span class="line"><span class="comment">// [&quot;1&quot;, &quot;2&quot;]</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="string">&quot;hello&quot;</span>); <span class="comment">//[&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]</span></span><br><span class="line"><span class="keyword">let</span> nameSet = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>]);</span><br><span class="line"><span class="built_in">Array</span>.from(nameSet); <span class="comment">// [&quot;a&quot;, &quot;b&quot;]</span></span><br></pre></td></tr></table></figure>

<p><strong>Array.from 还可以接受第二个参数，作用类似于数组的 map 方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">x</span>) =&gt;</span> x * x); <span class="comment">// [1, 4, 9]</span></span><br><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).map(<span class="function">(<span class="params">x</span>) =&gt;</span> x * x); <span class="comment">// [1, 4, 9]</span></span><br></pre></td></tr></table></figure>

<h1 id="3-Array-of"><a href="#3-Array-of" class="headerlink" title="3.Array.of()"></a>3.Array.of()</h1><p><strong>Array.of()方法用于将一组值，转换为数组。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1，2，3]</span></span><br></pre></td></tr></table></figure>

<h1 id="4-数组实例的-copyWithin"><a href="#4-数组实例的-copyWithin" class="headerlink" title="4.数组实例的 copyWithin()"></a>4.数组实例的 copyWithin()</h1><p>数组实例的 copyWithin()方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.copyWithin(target, (start = <span class="number">0</span>), (end = <span class="built_in">this</span>.length));</span><br></pre></td></tr></table></figure>

<p>它接受三个参数。</p>
<ul>
<li>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</li>
<li>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。</li>
</ul>
<p>这三个参数都应该是数值，如果不是，会自动转为数值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">  .copyWithin(<span class="number">0</span>, <span class="number">3</span>) <span class="comment">// [4, 5, 3, 4, 5]</span></span><br><span class="line">  [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)].copyWithin(<span class="number">0</span>, <span class="number">4</span>); <span class="comment">// [5, 5, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<h1 id="5-数组实例的-find-和-findIndex"><a href="#5-数组实例的-find-和-findIndex" class="headerlink" title="5.数组实例的 find() 和 findIndex()"></a>5.数组实例的 find() 和 findIndex()</h1><p><strong>数组实例的 find 方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 true 的成员，然后返回该成员。如果没有符合条件的成员，则返回 undefined。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line">  .find(<span class="function">(<span class="params">n</span>) =&gt;</span> n &gt; <span class="number">0</span>) <span class="comment">// 1</span></span><br><span class="line">  [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>)].find(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">  [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>)].find(<span class="function"><span class="keyword">function</span> (<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value &gt; <span class="number">1</span>;</span><br><span class="line">  &#125;); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p><strong>上面代码中，find 方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</strong><br><strong>数组实例的 findIndex 方法的用法与 find 方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].findIndex(<span class="function"><span class="keyword">function</span> (<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p><strong>这两个方法都可以接受第二个参数，用来绑定回调函数的 this 对象。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v &gt; <span class="built_in">this</span>.age;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">19</span>, <span class="number">27</span>].find(f, &#123; <span class="attr">age</span>: <span class="number">26</span> &#125;); <span class="comment">// 27</span></span><br></pre></td></tr></table></figure>

<h1 id="6-数组实例的-fill"><a href="#6-数组实例的-fill" class="headerlink" title="6.数组实例的 fill()"></a>6.数组实例的 fill()</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>].fill(<span class="number">7</span>); <span class="comment">// [7,7,7]</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">1</span>); <span class="comment">// [1,1,1]</span></span><br></pre></td></tr></table></figure>

<p><strong>fill 方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>].fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;, 7, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><strong>上面代码表示，fill 方法从 1 号位开始，向原数组填充 7，到 2 号位之前结束。</strong><br><strong>注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(&#123; <span class="attr">name</span>: <span class="string">&quot;Mike&quot;</span> &#125;);</span><br><span class="line">arr[<span class="number">0</span>].name = <span class="string">&quot;Ben&quot;</span>;</span><br><span class="line">arr;</span><br><span class="line"><span class="comment">// [&#123;name: &quot;Ben&quot;&#125;, &#123;name: &quot;Ben&quot;&#125;, &#123;name: &quot;Ben&quot;&#125;]</span></span><br></pre></td></tr></table></figure>

<h1 id="7-数组实例的-entries-，keys-和-values"><a href="#7-数组实例的-entries-，keys-和-values" class="headerlink" title="7.数组实例的 entries()，keys() 和 values()"></a>7.数组实例的 entries()，keys() 和 values()</h1><p><strong>ES6 提供三个新的方法——entries()，keys()和 values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用 for…of 循环进行遍历，唯一的区别是 keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>].keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>].values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>].entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 &quot;a&quot;</span></span><br><span class="line"><span class="comment">// 1 &quot;b&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>如果不使用 for…of 循环，可以手动调用遍历器对象的 next 方法，进行遍历。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> letter = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> entries = letter.entries();</span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [0, &#x27;a&#x27;]</span></span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [1, &#x27;b&#x27;]</span></span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [2, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<h1 id="8-数组实例的-includes"><a href="#8-数组实例的-includes" class="headerlink" title="8.数组实例的 includes()"></a>8.数组实例的 includes()</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">  .includes(<span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line">  [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)].includes(<span class="number">0</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><strong>该方法的第二个参数表示搜索的起始位置，默认为 0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为 3），则会重置为从 0 开始。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>, <span class="number">3</span>); <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>, -<span class="number">1</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h1 id="9-数组实例的-flat-，flatMap"><a href="#9-数组实例的-flat-，flatMap" class="headerlink" title="9.数组实例的 flat()，flatMap()"></a>9.数组实例的 flat()，flatMap()</h1><p><strong>数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]].flat() <span class="comment">// [1,2,3,4]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>,[<span class="number">4</span>],[<span class="number">5</span>]]].flat(<span class="number">2</span>) <span class="comment">//  [1, 2, 3, 4, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>]]].flat(<span class="literal">Infinity</span>) <span class="comment">// [1,2,3]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, , <span class="number">4</span>, <span class="number">5</span>].flat() <span class="comment">// [1,2,4,5]</span></span><br></pre></td></tr></table></figure>

<p><strong>flatMap()方法对原数组的每个成员执行一个函数（相当于执行 Array.prototype.map()），然后对返回值组成的数组执行 flat()方法。该方法返回一个新数组，不改变原数组。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].flatMap(<span class="function">(<span class="params">x</span>) =&gt;</span> x * x); <span class="comment">// [4, 9, 16]</span></span><br></pre></td></tr></table></figure>

<h1 id="10-Array-prototype-sort-的排序稳定性"><a href="#10-Array-prototype-sort-的排序稳定性" class="headerlink" title="10.Array.prototype.sort() 的排序稳定性"></a>10.Array.prototype.sort() 的排序稳定性</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">  .sort(<span class="function"><span class="keyword">function</span> (<span class="params">a1, a2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a1 - a2;</span><br><span class="line">  &#125;) <span class="comment">// [1, 2, 4, 10]</span></span><br><span class="line">  [(<span class="number">1</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">2</span>)].sort(<span class="function"><span class="keyword">function</span> (<span class="params">a1, a2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a2 - a1;</span><br><span class="line">  &#125;); <span class="comment">// [10, 4, 2, 1]</span></span><br></pre></td></tr></table></figure>

<h1 id="11-Array-isArray"><a href="#11-Array-isArray" class="headerlink" title="11.Array.isArray()"></a>11.Array.isArray()</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray(&#123;&#125;); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Array</span>.isArray([]); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h1 id="12-valueOf-，toString"><a href="#12-valueOf-，toString" class="headerlink" title="12.valueOf()，toString()"></a>12.valueOf()，toString()</h1><p><strong>valueOf 方法是一个所有对象都拥有的方法，表示对该对象求值。不同对象的 valueOf 方法不尽一致，数组的 valueOf 方法返回数组本身。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].valueOf()[</span><br><span class="line">  <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line">  (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">].toString();</span><br><span class="line"><span class="comment">// &quot;1,2,3,4&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="13-push-，pop"><a href="#13-push-，pop" class="headerlink" title="13.push()，pop()"></a>13.push()，pop()</h1><p><strong>push 方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。</strong><br><strong>pop 方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr2.push(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// [1,2,3,4]</span></span><br><span class="line">arr2.pop();</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<h1 id="14-shift-，unshift"><a href="#14-shift-，unshift" class="headerlink" title="14.shift()，unshift()"></a>14.shift()，unshift()</h1><p>shift()方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">b.shift(); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// [2,3]</span></span><br></pre></td></tr></table></figure>

<p><strong>unshift()方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">c.unshift(<span class="number">5</span>); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(c);</span><br><span class="line"><span class="comment">// [1,2,3,5]</span></span><br></pre></td></tr></table></figure>

<h1 id="15-join"><a href="#15-join" class="headerlink" title="15.join()"></a>15.join()</h1><p><strong>join()方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">a.join();</span><br><span class="line"><span class="comment">// 1,2,3,4</span></span><br><span class="line">a.join(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="comment">// 1 2 3 4</span></span><br></pre></td></tr></table></figure>

<p><strong>如果数组成员是 undefined 或 null 或空位，会被转成空字符串。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">undefined</span>, <span class="literal">null</span>].join(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">// &quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="16-concat"><a href="#16-concat" class="headerlink" title="16.concat()"></a>16.concat()</h1><p><strong>concat 方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> g = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">g.concat(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// [1,2,3,4]</span></span><br><span class="line">g.concat([<span class="number">5</span>]);</span><br><span class="line"><span class="comment">// [1, 2, 3, 5]</span></span><br></pre></td></tr></table></figure>

<p><strong>如果数组成员包括对象，concat 方法返回当前数组的一个浅拷贝。所谓“浅拷贝”，指的是新数组拷贝的是对象的引用。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> g = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> b = &#123; <span class="attr">a</span>: <span class="string">&quot;123&quot;</span> &#125;;</span><br><span class="line">g = g.concat(b);</span><br><span class="line"><span class="comment">// [1, 2, 3, &#123;…&#125;]</span></span><br><span class="line"><span class="built_in">console</span>.log(g[<span class="number">3</span>].a);</span><br><span class="line"><span class="comment">// &#123;a: &quot;123&quot;&#125;</span></span><br><span class="line">g3.a = <span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// a : &#x27;1&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="17-reverse"><a href="#17-reverse" class="headerlink" title="17.reverse()"></a>17.reverse()</h1><p><strong>reverse 方法用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> h = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>];</span><br><span class="line">h.reverse();</span><br><span class="line"><span class="comment">// [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</span></span><br></pre></td></tr></table></figure>

<h1 id="18-slice"><a href="#18-slice" class="headerlink" title="18.slice()"></a>18.slice()</h1><p><strong>slice()方法用于提取目标数组的一部分，返回一个新数组，原数组不变。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.slice(start, end);</span><br></pre></td></tr></table></figure>

<p><strong>它的第一个参数为起始位置（从 0 开始，会包括在返回的新数组之中），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">a.slice(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// [2,3,4]</span></span><br></pre></td></tr></table></figure>

<p><strong>slice()方法的一个重要应用，是将类似数组的对象转为真正的数组。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice.call(&#123; <span class="number">0</span>: <span class="string">&quot;1&quot;</span>, <span class="number">1</span>: <span class="string">&quot;2&quot;</span>, <span class="attr">length</span>: <span class="number">2</span> &#125;);</span><br><span class="line"><span class="comment">// [&quot;1&quot;, &quot;2&quot;]</span></span><br></pre></td></tr></table></figure>

<h1 id="19-splice"><a href="#19-splice" class="headerlink" title="19.splice()"></a>19.splice()</h1><p><strong>splice()方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.splice(start, count, addElement1, addElement2, ...);</span><br></pre></td></tr></table></figure>

<p><strong>splice 的第一个参数是删除的起始位置（从 0 开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> u = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">u.splice(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// [2,3]</span></span><br><span class="line"><span class="built_in">console</span>.log(u);</span><br><span class="line"><span class="comment">// [1,4]</span></span><br><span class="line">u.push(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// [1,4,2,3]</span></span><br><span class="line">u.splice(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// [4,2]</span></span><br><span class="line"><span class="built_in">console</span>.log(u);</span><br><span class="line"><span class="comment">// [1, 1, 1, 3]</span></span><br></pre></td></tr></table></figure>

<h1 id="20-sort"><a href="#20-sort" class="headerlink" title="20.sort()"></a>20.sort()</h1><p><strong>sort 方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&quot;d&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;a&quot;</span>]</span><br><span class="line">  .sort() <span class="comment">// [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;]</span></span><br><span class="line">  [(<span class="number">5</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">0</span>)].sort(); <span class="comment">// [0,1,5,8]</span></span><br></pre></td></tr></table></figure>

<h1 id="21-map"><a href="#21-map" class="headerlink" title="21.map()"></a>21.map()</h1><p><strong>map 方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> m1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">m1.map(<span class="function"><span class="keyword">function</span> (<span class="params">elem, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> elem * index;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [0,2,6]</span></span><br></pre></td></tr></table></figure>

<h1 id="22-forEach"><a href="#22-forEach" class="headerlink" title="22.forEach()"></a>22.forEach()</h1><p><strong>forEach 方法与 map 方法很相似，也是对数组的所有成员依次执行参数函数。但是，forEach 方法不返回值，只用来操作数据。这就是说，如果数组遍历的目的是为了得到返回值，那么使用 map 方法，否则使用 forEach 方法。</strong><br><strong>forEach 的用法与 map 方法一致，参数是一个函数，该函数同样接受三个参数：当前值、当前位置、整个数组。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> out = [];</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">elem</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.push(elem * elem);</span><br><span class="line">&#125;, out);</span><br><span class="line"><span class="comment">// [1,4,9]</span></span><br></pre></td></tr></table></figure>

<p><strong>注意，forEach 方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用 for 循环。</strong></p>
<h1 id="23-filter"><a href="#23-filter" class="headerlink" title="23.filter()"></a>23.filter()</h1><p><strong>filter 方法用于过滤数组成员，满足条件的成员组成一个新数组返回。</strong><br><strong>它的参数是一个函数，所有数组成员依次执行该函数，返回结果为 true 的成员组成一个新数组返回。该方法不会改变原数组。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].filter(<span class="function"><span class="keyword">function</span> (<span class="params">elem, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> elem &gt; <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [2,3,4,5]</span></span><br></pre></td></tr></table></figure>

<h1 id="24-some-，every"><a href="#24-some-，every" class="headerlink" title="24.some()，every()"></a>24.some()，every()</h1><p><strong>这两个方法类似“断言”（assert），返回一个布尔值，表示判断数组成员是否符合某种条件。</strong><br><strong>它们接受一个函数作为参数，所有数组成员依次执行该函数。该函数接受三个参数：当前成员、当前位置和整个数组，然后返回一个布尔值。</strong><br><strong>some 方法是只要一个成员的返回值是 true，则整个 some 方法的返回值就是 true，否则返回 false。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].some(<span class="function"><span class="keyword">function</span> (<span class="params">elem</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> elem &gt; <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>every 方法是所有成员的返回值都是 true，整个 every 方法才返回 true，否则返回 false。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].every(<span class="function"><span class="keyword">function</span> (<span class="params">elem</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> elem &gt; <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h1 id="25-reduce-，reduceRight"><a href="#25-reduce-，reduceRight" class="headerlink" title="25.reduce()，reduceRight()"></a>25.reduce()，reduceRight()</h1><p><strong>reduce 方法和 reduceRight 方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，reduce 是从左到右处理（从第一个成员到最后一个成员），reduceRight 则是从右到左（从最后一个成员到第一个成员），其他完全一样。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].reduce(<span class="function"><span class="keyword">function</span> (<span class="params">a1, a2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a1 + a2;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<h1 id="26-indexOf-，lastIndexOf"><a href="#26-indexOf-，lastIndexOf" class="headerlink" title="26.indexOf()，lastIndexOf()"></a>26.indexOf()，lastIndexOf()</h1><p>**indexOf 方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1 **<br><strong>indexOf 方法还可以接受第二个参数，表示搜索的开始位置。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].indexOf(<span class="number">1</span>)[</span><br><span class="line">  <span class="comment">// 0</span></span><br><span class="line">  (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">].indexOf(<span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p><strong>lastIndexOf 方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].lastIndexOf(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<h1 id="27-总结图"><a href="#27-总结图" class="headerlink" title="27.总结图"></a>27.总结图</h1><p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619672235917-33ae37b0-6740-4040-af97-6b80eb16a7ac.png#clientId=u5f198714-ef64-4&from=paste&height=912&id=uf6695a7d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=917&originWidth=823&originalType=binary&size=524360&status=done&style=none&taskId=u459400e2-8921-4dd7-a229-92597137029&width=818.5" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619672246144-2a807e43-11a5-421f-b3e7-e72920d0c788.png#clientId=u5f198714-ef64-4&from=paste&height=1908&id=ud045c8ec&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1946&originWidth=1080&originalType=binary&size=865562&status=done&style=none&taskId=u7c8d3621-8d81-49e1-9257-e047cc5ab3b&width=1059" alt="image.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/26/yuque/Tree-Shaking%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5-%E5%AE%9E%E8%B7%B5%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/26/yuque/Tree-Shaking%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5-%E5%AE%9E%E8%B7%B5%E7%AF%87/" class="post-title-link" itemprop="url">Tree-Shaking性能优化实践-实践篇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-26 14:05:39" itemprop="dateCreated datePublished" datetime="2021-04-26T14:05:39+08:00">2021-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 18:36:13" itemprop="dateModified" datetime="2021-04-29T18:36:13+08:00">2021-04-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上一篇文章 <a target="_blank" rel="noopener" href="https://juejin.im/post/6844903544756109319">Tree-Shaking 性能优化实践 - 原理篇</a> 介绍了 tree-shaking 的原理，本文主要介绍 tree-shaking 的实践</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417176669-626362ab-6164-4bb3-b700-463db3ee8027.jpeg#clientId=ue71f5aac-b372-4&from=drop&height=120&id=u706055df&margin=%5Bobject%20Object%5D&name=1.jpg&originHeight=120&originWidth=180&originalType=binary&size=6581&status=done&style=none&taskId=uec8d1f6e-41b1-4021-8111-765498ed4c7&width=180" alt="1.jpg"></p>
<h2 id="三-tree-shaking-实践"><a href="#三-tree-shaking-实践" class="headerlink" title="三. tree-shaking 实践"></a>三. tree-shaking 实践</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417185298-aebd7e76-9d26-404e-8510-758287b50fb9.jpeg#clientId=ue71f5aac-b372-4&from=drop&id=u5729f233&margin=%5Bobject%20Object%5D&name=2.jpg&originHeight=405&originWidth=720&originalType=binary&size=6650&status=done&style=none&taskId=u06c1c936-fc57-4b44-a3e1-96901b03f42" alt="2.jpg"></p>
<p>webpack2 发布，宣布支持 tree-shaking，webpack 3 发布，支持作用域提升，生成的 bundle 文件更小。 再没有升级 webpack 之前，增幻想我们的性能又要大幅提升了，对升级充满了期待。实际上事实是这样的</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417191922-3d9e77c7-2db8-4669-ab41-cf0322d484ef.jpeg#clientId=ue71f5aac-b372-4&from=drop&id=u4d97b1fb&margin=%5Bobject%20Object%5D&name=3.jpg&originHeight=405&originWidth=720&originalType=binary&size=11332&status=done&style=none&taskId=u9d5ca2ab-b4c9-489e-8b48-37dd15af1b0" alt="3.jpg"></p>
<p>升级完之后，bundle 文件大小并没有大幅减少，当时有较大的心理落差，然后去研究了为什么效果不理想，原因见 <a target="_blank" rel="noopener" href="https://juejin.im/post/6844903544756109319">Tree-Shaking 性能优化实践 - 原理篇</a> 。</p>
<p>优化还是要继续的，虽然工具自带的 tree-shaking 不能去除太多无用代码，在去除无用代码这一方面也还是有可以做的事情。我们从三个方面做里一些优化。</p>
<h2 id="（1）对组件库引用的优化"><a href="#（1）对组件库引用的优化" class="headerlink" title="（1）对组件库引用的优化"></a>（1）对组件库引用的优化</h2><p>先来看一个问题</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417203100-cbcd535b-d7af-49ff-900c-c4b7827caa01.jpeg#clientId=ue71f5aac-b372-4&from=drop&id=ue93e7c8a&margin=%5Bobject%20Object%5D&name=4.jpg&originHeight=376&originWidth=720&originalType=binary&size=21516&status=done&style=none&taskId=u0abbe6ec-1ad4-4b1d-870a-50dd2fbb7be" alt="4.jpg"></p>
<p>当我们使用组件库的时候，import {Button} from ‘element-ui’，相对于 Vue.use(elementUI)，已经是具有性能意识，是比较推荐的做法，但如果我们写成右边的形式，具体到文件的引用，打包之后的区别是非常大的，以 antd 为例，右边形式 bundle 体积减少约 80%。</p>
<p>这个引用也属于有副作用，webpack 不能把其他组件进行 tree-shaking。既然工具本身是做不了，那我们可以做工具把左边代码自动改成右边代码这种形式。这个工具 antd 库本身也是提供的。我在 antd 的工具基础上做了少量的修改，不用任何配置，原生支持我们自己的组件库， <a href="http://link.zhihu.com/?target=https://w-ui.github.io/%23/doc">wui</a> 和 <a href="http://link.zhihu.com/?target=https://wmfe.github.io/xcui/%23/home">xcui</a> 以及一些其他常用的库</p>
<p><strong>babel-plugin-import-fix ，缩小引用范围</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417213027-2a680ba0-7647-447f-a9d6-4c963ef6ad09.jpeg#clientId=ue71f5aac-b372-4&from=drop&id=uea1764cc&margin=%5Bobject%20Object%5D&name=5.jpg&originHeight=198&originWidth=720&originalType=binary&size=10817&status=done&style=none&taskId=u95bc3c68-97a5-4c25-8190-d9499856cc0" alt="5.jpg"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417217960-614afe7b-13a3-40f0-a7ca-2e2ca2dc3126.jpeg#clientId=ue71f5aac-b372-4&from=drop&id=ueef65da2&margin=%5Bobject%20Object%5D&name=6.jpg&originHeight=120&originWidth=120&originalType=binary&size=4686&status=done&style=none&taskId=u9463d119-35ae-49e5-8df3-582361fd628" alt="6.jpg"></p>
<p><a href="http://link.zhihu.com/?target=https://github.com/lin-xi/babel-plugin-import-fix">lin-xi/babel-plugin-import-fix</a></p>
<p>下面介绍一下原理</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417223638-fa9c6c05-7a28-424f-bb5b-8cf4f83a21ed.jpeg#clientId=ue71f5aac-b372-4&from=drop&id=ub1729c08&margin=%5Bobject%20Object%5D&name=7.jpg&originHeight=405&originWidth=720&originalType=binary&size=12869&status=done&style=none&taskId=u743db0cb-9d20-4bfa-8079-ac5c78ddbd5" alt="7.jpg"></p>
<p>这是一个 babel 的插件，babel 通过核心 babylon 将 ES6 代码转换成 AST 抽象语法树，然后插件遍历语法树找出类似 import {Button} from ‘element-ui’这样的语句，进行转换，最后重新生成代码。</p>
<p>babel-plugin-import-fix 默认支持 antd，element，meterial-UI，wui，xcui 和 d3，只需要再.babelrc 中配置插件本身就可以。</p>
<p>.babelrc</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    [&quot;es2015&quot;, &#123; &quot;modules&quot;: false &#125;], &quot;react&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;plugins&quot;: [&quot;import-fix&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417230775-fcf865d2-f123-4214-adc6-8914952dfb5d.jpeg#clientId=ue71f5aac-b372-4&from=drop&id=u45ca0143&margin=%5Bobject%20Object%5D&name=8.jpg&originHeight=405&originWidth=720&originalType=binary&size=9224&status=done&style=none&taskId=ud6b209ce-caac-4800-980e-5a61e12d7ec" alt="8.jpg"></p>
<p>其实是想把所有常用的库都默认支持，但很多常用的库却不支持缩小引用范围。因为没有独立输出各个子模块，不能把引用修改为对单个子模块的引用。</p>
<h2 id="（2）CSS-Tree-shaking"><a href="#（2）CSS-Tree-shaking" class="headerlink" title="（2）CSS Tree-shaking"></a>（2）CSS Tree-shaking</h2><p>我们前面所说的 tree-shaking 都是针对 js 文件，通过静态分析，尽可能消除无用的代码，那对于 css 我们能做 tree-shaking 吗？</p>
<p>随着 CSS3，LESS，SASS 等各种 css 预处理语言的普及，css 文件在整个工程中占比是不可忽视的。随着大项目功能的不停迭代，导致 css 中可能就存在着无用的代码。我实现了一个 webpack 插件来解决这个问题，找出 css 代码无用的代码。</p>
<p><a href="http://link.zhihu.com/?target=https://github.com/lin-xi/webpack-css-treeshaking-plugin"><strong>webpack-css-treeshaking-plugin</strong></a><strong>，对 css 进行 tree-shaking</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417236617-b3f1bf5c-e32d-4c56-b932-71b640794f3e.jpeg#clientId=ue71f5aac-b372-4&from=drop&id=u816fab64&margin=%5Bobject%20Object%5D&name=9.jpg&originHeight=120&originWidth=120&originalType=binary&size=4686&status=done&style=none&taskId=ub99c9de7-84c5-4a61-b523-140015afd27" alt="9.jpg"></p>
<p>[webpack-css-treeshaking-plugin</p>
<p>](<a href="http://link.zhihu.com/?target=https://github.com/lin-xi/webpack-css-treeshaking-plugin">http://link.zhihu.com/?target=https%3A//github.com/lin-xi/webpack-css-treeshaking-plugin</a>)</p>
<p>下面介绍一下原理</p>
<p>整体思路是这样的，遍历所有的 css 文件中的 selector 选择器，然后去所有 js 代码中匹配，如果选择器没有在代码出现过，则认为该选择器是无用代码。</p>
<p><strong>首先面临的问题是，如何优雅的遍历所有的选择器呢？难道要用正则表达式很苦逼的去匹配分割吗？</strong></p>
<p>babel 是 js 世界的福星，其实 css 世界也有利器，那就是 postCss。</p>
<p>PostCSS 提供了一个解析器，它能够将 CSS 解析成 AST 抽象语法树。然后我们能写各种插件，对抽象语法树做处理，最终生成新的 css 文件，以达到对 css 进行精确修改的目的。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417244857-2cc0e501-2546-4a96-83e9-07236d806d89.jpeg#clientId=ue71f5aac-b372-4&from=drop&id=uc818a839&margin=%5Bobject%20Object%5D&name=10.jpg&originHeight=394&originWidth=720&originalType=binary&size=16294&status=done&style=none&taskId=ua622f1ee-12ee-48b4-9122-14c9b3aba66" alt="10.jpg"></p>
<p>整体又是一个 webpack 的插件，架构图如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417249458-955d4c96-c638-47e5-a97a-b7092d5f18dc.jpeg#clientId=ue71f5aac-b372-4&from=drop&id=u9c2e7c64&margin=%5Bobject%20Object%5D&name=11.jpg&originHeight=405&originWidth=720&originalType=binary&size=17641&status=done&style=none&taskId=u184075c6-13de-4115-ae5b-f3ee4d2fce4" alt="11.jpg"></p>
<p>主要流程：</p>
<ul>
<li>插件监听 webapck 编译完成事件，webpack 编译完成之后，从 compilation 中找出所有的 css 文件和 js 文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apply (compiler) &#123;</span><br><span class="line">    compiler.plugin(&#39;after-emit&#39;, (compilation, callback) &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">      let styleFiles &#x3D; Object.keys(compilation.assets).filter(asset &#x3D;&gt; &#123;</span><br><span class="line">        return &#x2F;\.css$&#x2F;.test(asset)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      let jsFiles &#x3D; Object.keys(compilation.assets).filter(asset &#x3D;&gt; &#123;</span><br><span class="line">        return &#x2F;\.(js|jsx)$&#x2F;.test(asset)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">     ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将所有的 css 文件送至 postCss 处理，找出无用代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let tasks &#x3D; []</span><br><span class="line"> styleFiles.forEach((filename) &#x3D;&gt; &#123;</span><br><span class="line">     const source &#x3D; compilation.assets[filename].source()</span><br><span class="line">     let listOpts &#x3D; &#123;</span><br><span class="line">       include: &#39;&#39;,</span><br><span class="line">       source: jsContents,  &#x2F;&#x2F;传入全部js文件</span><br><span class="line">       opts: this.options   &#x2F;&#x2F;插件配置选项</span><br><span class="line">     &#125;</span><br><span class="line">     tasks.push(postcss(treeShakingPlugin(listOpts)).process(source).then(result &#x3D;&gt; &#123;</span><br><span class="line">       let css &#x3D; result.toString()  &#x2F;&#x2F; postCss处理后的css AST</span><br><span class="line">       &#x2F;&#x2F;替换webpack的编译产物compilation</span><br><span class="line">       compilation.assets[filename] &#x3D; &#123;</span><br><span class="line">         source: () &#x3D;&gt; css,</span><br><span class="line">         size: () &#x3D;&gt; css.length</span><br><span class="line">       &#125;</span><br><span class="line">       return result</span><br><span class="line">     &#125;))</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>postCss 遍历，匹配，删除过程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; postcss.plugin(&#39;list-selectors&#39;, function (options) &#123;</span><br><span class="line">   &#x2F;&#x2F; 从根节点开始遍历</span><br><span class="line">   cssRoot.walkRules(function (rule) &#123;</span><br><span class="line">     &#x2F;&#x2F; Ignore keyframes, which can log e.g. 10%, 20% as selectors</span><br><span class="line">     if (rule.parent.type &#x3D;&#x3D;&#x3D; &#39;atrule&#39; &amp;&amp; &#x2F;keyframes&#x2F;.test(rule.parent.name)) return</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; 对每一个规则进行处理</span><br><span class="line">     checkRule(rule).then(result &#x3D;&gt; &#123;</span><br><span class="line">       if (result.selectors.length &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">         &#x2F;&#x2F; 选择器全部被删除</span><br><span class="line">         let log &#x3D; &#39; ✂️ [&#39; + rule.selector + &#39;] shaked, [1]&#39;</span><br><span class="line">         console.log(log)</span><br><span class="line">         if (config.remove) &#123;</span><br><span class="line">           rule.remove()</span><br><span class="line">         &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         &#x2F;&#x2F; 选择器被部分删除</span><br><span class="line">         let shaked &#x3D; rule.selectors.filter(item &#x3D;&gt; &#123;</span><br><span class="line">           return result.selectors.indexOf(item) &#x3D;&#x3D;&#x3D; -1</span><br><span class="line">         &#125;)</span><br><span class="line">         if (shaked &amp;&amp; shaked.length &gt; 0) &#123;</span><br><span class="line">           let log &#x3D; &#39; ✂️ [&#39; + shaked.join(&#39; &#39;) + &#39;] shaked, [2]&#39;</span><br><span class="line">           console.log(log)</span><br><span class="line">         &#125;</span><br><span class="line">         if (config.remove) &#123;</span><br><span class="line">           &#x2F;&#x2F; 修改AST抽象语法树</span><br><span class="line">           rule.selectors &#x3D; result.selectors</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>

<p>checkRule 处理每一个规则核心代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">let checkRule &#x3D; (rule) &#x3D;&gt; &#123;</span><br><span class="line">      return new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">        let secs &#x3D; rule.selectors.filter(function (selector) &#123;</span><br><span class="line">          let result &#x3D; true</span><br><span class="line">          let processor &#x3D; parser(function (selectors) &#123;</span><br><span class="line">            for (let i &#x3D; 0, len &#x3D; selectors.nodes.length; i &lt; len; i++) &#123;</span><br><span class="line">              let node &#x3D; selectors.nodes[i]</span><br><span class="line">              if (_.includes([&#39;comment&#39;, &#39;combinator&#39;, &#39;pseudo&#39;], node.type)) continue</span><br><span class="line">              for (let j &#x3D; 0, len2 &#x3D; node.nodes.length; j &lt; len2; j++) &#123;</span><br><span class="line">                let n &#x3D; node.nodes[j]</span><br><span class="line">                if (!notCache[n.value]) &#123;</span><br><span class="line">                  switch (n.type) &#123;</span><br><span class="line">                    case &#39;tag&#39;:</span><br><span class="line">                      &#x2F;&#x2F; nothing</span><br><span class="line">                      break</span><br><span class="line">                    case &#39;id&#39;:</span><br><span class="line">                    case &#39;class&#39;:</span><br><span class="line">                      if (!classInJs(n.value)) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 调用classInJs判断是否在JS中出现过</span><br><span class="line">                        notCache[n.value] &#x3D; true</span><br><span class="line">                        result &#x3D; false</span><br><span class="line">                        break</span><br><span class="line">                      &#125;</span><br><span class="line">                      break</span><br><span class="line">                    default:</span><br><span class="line">                      &#x2F;&#x2F; nothing</span><br><span class="line">                      break</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                  result &#x3D; false</span><br><span class="line">                  break</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">          ...</span><br><span class="line">        &#125;)</span><br><span class="line">        ...</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到其实我只处理里 id 选择器和 class 选择器，id 和 class 相对来说副作用小，引起样式异常的可能性相对较小。</p>
<p>判断 css 是否再 js 中出现过，是使用正则匹配。</p>
<p>其实，后续还可以继续优化，比如对 tag 类的选择器，可以配置是否再 html，jsx，template 中出现过，如果出现过，没有出现过也可以认为是无用代码。</p>
<p>当然，插件能正常工作还是的有一些前提和约束。我们可以在代码中动态改变 css，比如再 react 和 vue 中，可以这么写</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417258077-ca5886f8-045c-4b99-89da-b063e43149bf.jpeg#clientId=ue71f5aac-b372-4&from=drop&id=u456c9f5e&margin=%5Bobject%20Object%5D&name=12.jpg&originHeight=219&originWidth=720&originalType=binary&size=11908&status=done&style=none&taskId=u0422f285-8f06-45f7-826c-a8a4256f1f5" alt="12.jpg"></p>
<p>这样是比较推荐的方式，选择器作为字符或变量名出现在代码中，下面这样动态生成选择器的情况就会导致匹配失败</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">  this.stateClass &#x3D; &#39;state-&#39; + this.state &#x3D;&#x3D; 2 ? &#39;open&#39; : &#39;close&#39;</span><br><span class="line">  return &lt;div class&#x3D;&#123;this.stateClass&#125;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中这样情况很容易避免</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">  this.stateClass &#x3D; this.state &#x3D;&#x3D; 2 ? &#39;state-open&#39; : &#39;state-close&#39;</span><br><span class="line">  return &lt;div class&#x3D;&#123;this.stateClass&#125;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以有一个好的编码规范的约束，插件能更好的工作。</p>
<h2 id="（3）webpack-bundle-文件去重"><a href="#（3）webpack-bundle-文件去重" class="headerlink" title="（3）webpack bundle 文件去重"></a>（3）webpack bundle 文件去重</h2><p>如果 webpack 打包后的 bundle 文件中存在着相同的模块，也属于无用代码的一种。也应该被去除掉</p>
<p>首先我们需要一个能对 bundle 文件定性分析的工具，能发现问题，能看出优化效果。</p>
<p>webpack-bundle-analyzer 这个插件完全能满足我们的需求，他能以图形化的方式展示 bundle 中所有的模块的构成的各构成的大小。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417264814-7e9330da-796e-4ff8-8f4c-5b598ac4e667.jpeg#clientId=ue71f5aac-b372-4&from=drop&id=ua801459f&margin=%5Bobject%20Object%5D&name=13.jpg&originHeight=405&originWidth=720&originalType=binary&size=18473&status=done&style=none&taskId=u56e06f26-6d1b-4d5d-909e-00c99647abe" alt="13.jpg"></p>
<p>其次，需求对通用模块进行提取，CommonsChunkPlugin 是最被人熟知的用于提供通用模块的插件。早期的时候，我并不完全了解他的功能，并没有发挥最大的功效。</p>
<p>下面介绍 CommonsChunkPlugin 的正确用法</p>
<p><strong>自动提取所有的 node_moudles 或者引用次数两次以上的模块</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417270065-ff9e3f12-cb26-48d7-b81c-7ac3f51eb0da.jpeg#clientId=ue71f5aac-b372-4&from=drop&id=u4893c42d&margin=%5Bobject%20Object%5D&name=14.jpg&originHeight=192&originWidth=720&originalType=binary&size=9906&status=done&style=none&taskId=ud7ac520f-f577-4128-80b8-8d82d0b2ea3" alt="14.jpg"></p>
<p>minChunks 可以接受一个数值或者函数，如果是函数，可自定义打包规则</p>
<p>但使用上面记载的配置之后，并不能高枕无忧。因为这个配置只能提取所有 entry 打包后的文件中的通用模块。而现实是，有了提高性能，我们会按需加载，通过 webpack 提供的 import（…）方法，这种按需加载的文件并不会存在于 entry 之中，所以按需加载的异步模块中的通用模块并没有提取。</p>
<p><strong>如何提取按需加载的异步模块里的通用模块呢？</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417275241-489bbef7-42df-46b3-bac9-580cf920a8ab.jpeg#clientId=ue71f5aac-b372-4&from=drop&id=u6bea9d0b&margin=%5Bobject%20Object%5D&name=15.jpg&originHeight=331&originWidth=720&originalType=binary&size=21512&status=done&style=none&taskId=uf770f890-910a-41c2-b268-98db8a669d7" alt="15.jpg"></p>
<p>配置另一个 CommonsChunkPlugin，添加 async 属性，async 可以接受布尔值或字符串。当时字符串时，默认是输出文件的名称。</p>
<p>names 是所有异步模块的名称</p>
<p>这里还涉及一个给异步模块命名的知识点。我是这样做的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const Edit &#x3D; resolve &#x3D;&gt; &#123; import( &#x2F;* webpackChunkName: &quot;EditPage&quot; *&#x2F; &#39;.&#x2F;pages&#x2F;Edit&#x2F;Edit&#39;).then((mod) &#x3D;&gt; &#123; resolve(mod.default); &#125;) &#125;;</span><br><span class="line">const PublishPage &#x3D; resolve &#x3D;&gt; &#123; import( &#x2F;* webpackChunkName: &quot;Publish&quot; *&#x2F; &#39;.&#x2F;pages&#x2F;Publish&#x2F;Publish&#39;).then((mod) &#x3D;&gt; &#123; resolve(mod); &#125;) &#125;;</span><br><span class="line">const Models &#x3D; resolve &#x3D;&gt; &#123; import( &#x2F;* webpackChunkName: &quot;Models&quot; *&#x2F; &#39;.&#x2F;pages&#x2F;Models&#x2F;Models&#39;).then((mod) &#x3D;&gt; &#123; resolve(mod.default); &#125;) &#125;;</span><br><span class="line">const MediaUpload &#x3D; resolve &#x3D;&gt; &#123; import( &#x2F;* webpackChunkName: &quot;MediaUpload&quot; *&#x2F; &#39;.&#x2F;pages&#x2F;Media&#x2F;MediaUpload&#39;).then((mod) &#x3D;&gt; &#123; resolve(mod); &#125;) &#125;;</span><br><span class="line">const RealTime &#x3D; resolve &#x3D;&gt; &#123; import( &#x2F;* webpackChunkName: &quot;RealTime&quot; *&#x2F; &#39;.&#x2F;pages&#x2F;RealTime&#x2F;RealTime&#39;).then((mod) &#x3D;&gt; &#123; resolve(mod.default); &#125;) &#125;;</span><br></pre></td></tr></table></figure>

<p>没错，在 import 里添加注释。/_ webpackChunkName: “EditPage” _/ ，虽然看着不舒服，但是管用。</p>
<p>贴一个项目的优化效果对比图</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417280783-55fb56f0-e13e-4424-b662-b11bfe12a00e.jpeg#clientId=ue71f5aac-b372-4&from=drop&id=u9ecfab79&margin=%5Bobject%20Object%5D&name=16.jpg&originHeight=405&originWidth=720&originalType=binary&size=27747&status=done&style=none&taskId=u81f9d6e0-0583-4bca-90ed-a793591757b" alt="16.jpg"></p>
<p>优化效果还是比较明显。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417285132-f56688f8-be56-4545-bba3-2687b8398459.jpeg#clientId=ue71f5aac-b372-4&from=drop&id=u5e535843&margin=%5Bobject%20Object%5D&name=17.jpg&originHeight=405&originWidth=720&originalType=binary&size=25678&status=done&style=none&taskId=ud6da4518-ff37-4958-982e-7abf2ff05fc" alt="17.jpg"></p>
<p>优化前 bundle</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417289834-408cd2e7-ef19-496a-9125-5ac4ad04656a.jpeg#clientId=ue71f5aac-b372-4&from=drop&id=uad419791&margin=%5Bobject%20Object%5D&name=18.jpg&originHeight=405&originWidth=720&originalType=binary&size=24291&status=done&style=none&taskId=u3f99a4c5-7841-4d8d-b8dc-74be296417f" alt="18.jpg"></p>
<p>优化后 bundle</p>
<p><strong>最后思考一个问题：</strong></p>
<p><strong>不同 entry 模块或按需加载的异步模块需不需要提取通用模块？</strong></p>
<p>这个需要看场景了，比如模块都是在线加载的，如果通用模块提取粒度过小，会导致首页首屏需要的文件变多，很多可能是首屏用不到的，导致首屏过慢，二级或三级页面加载会大幅提升。所以这个就需要根据业务场景做权衡，控制通用模块提取的粒度。</p>
<p>百度外卖的移动端应用场景是这样的，我们所有的移动端页面都做了离线化的处理。离线之后，加载本地的 js 文件，与网络无关，基本上可以忽略文件大小，所以更关注整个离线包的大小。离线包越小，耗费用户的流量就越小，用户体验更好，所以离线化的场景是非常适合最小粒提取通用模块的，即将所有 entry 模块和异步加载模块的引用大于 2 的模块都提取，这样能获得最小的输出文件，最小的离线包。</p>
<p>1 月 20 日，我将在掘金分享《百度外卖前端离线化实践》，有兴趣的可以关注一下。</p>
<p>文本提到的插件都是开源的，链接汇总，欢迎交流，欢迎戳 ❤</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619417305159-1c75e841-c2cd-42d8-a345-ec8541f4dbba.jpeg#clientId=ue71f5aac-b372-4&from=drop&id=u91704679&margin=%5Bobject%20Object%5D&name=19.jpg&originHeight=120&originWidth=120&originalType=binary&size=4686&status=done&style=none&taskId=u5836fcec-3272-40dc-9088-0ee4d96214a" alt="19.jpg"></p>
<p><a href="http://link.zhihu.com/?target=https://github.com/lin-xi/babel-plugin-import-fix">lin-xi/babel-plugin-import-fix</a></p>
<p><a href="http://link.zhihu.com/?target=https://github.com/lin-xi/webpack-css-treeshaking-plugin">lin-xi/webpack-css-treeshaking-plugin</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/26/yuque/Tree-Shaking%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5%20%E5%8E%9F%E7%90%86%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/26/yuque/Tree-Shaking%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5%20%E5%8E%9F%E7%90%86%E7%AF%87/" class="post-title-link" itemprop="url">Tree-Shaking性能优化实践 原理篇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-26 01:04:35" itemprop="dateCreated datePublished" datetime="2021-04-26T01:04:35+08:00">2021-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 18:36:13" itemprop="dateModified" datetime="2021-04-29T18:36:13+08:00">2021-04-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一-什么是-Tree-shaking"><a href="#一-什么是-Tree-shaking" class="headerlink" title="一. 什么是 Tree-shaking"></a>一. 什么是 Tree-shaking</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415487699-2976267a-70a5-4dc4-8642-c5c9722d10cd.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=uaa735294&margin=%5Bobject%20Object%5D&name=1.jpg&originHeight=405&originWidth=720&originalType=binary&size=6737&status=done&style=none&taskId=ub91413ec-e2c7-4325-a62e-122f16394cf" alt="1.jpg"></p>
<p>先来看一下 Tree-shaking 原始的本意</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/gif/21377586/1619415501641-bbf5f45d-3a0c-4811-9919-761bbc00e701.gif#clientId=u022f3b9a-a5ad-4&from=drop&id=ubfb99f78&margin=%5Bobject%20Object%5D&name=2.gif&originHeight=341&originWidth=606&originalType=binary&size=3761493&status=done&style=none&taskId=u70618439-fddd-42cc-bf2f-a38d6a58d38" alt="2.gif"></p>
<p>上图形象的解释了 Tree-shaking 的本意，本文所说的前端中的 tree-shaking 可以理解为通过工具”摇”我们的 JS 文件，将其中用不到的代码”摇”掉，是一个性能优化的范畴。具体来说，在 webpack 项目中，有一个入口文件，相当于一棵树的主干，入口文件有很多依赖的模块，相当于树枝。实际情况中，虽然依赖了某个模块，但其实只使用其中的某些功能。通过 tree-shaking，将没有使用的模块摇掉，这样来达到删除无用代码的目的。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415504181-f5f2cce4-ceef-4702-9da5-c6a11f90d8e3.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=uc32a1b51&margin=%5Bobject%20Object%5D&name=3.jpg&originHeight=405&originWidth=720&originalType=binary&size=12958&status=done&style=none&taskId=u2e02d442-f1cc-487d-b7f4-a35c40e2d7c" alt="3.jpg"></p>
<p>Tree-shaking 较早由 Rich_Harris 的 rollup 实现，后来，webpack2 也增加了 tree-shaking 的功能。其实在更早，google closure compiler 也做过类似的事情。三个工具的效果和使用各不相同，使用方法可以通过官网文档去了解，三者的效果对比，后文会详细介绍。</p>
<h2 id="二-tree-shaking-的原理"><a href="#二-tree-shaking-的原理" class="headerlink" title="二. tree-shaking 的原理"></a>二. tree-shaking 的原理</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415508232-a021a71e-e50c-448d-b9f3-f1a442fb8592.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=u47b707e4&margin=%5Bobject%20Object%5D&name=4.jpg&originHeight=405&originWidth=720&originalType=binary&size=6384&status=done&style=none&taskId=u1f413566-615e-45aa-bfe6-19178616240" alt="4.jpg"></p>
<p>Tree-shaking 的本质是消除无用的 js 代码。无用代码消除在广泛存在于传统的编程语言编译器中，编译器可以判断出某些代码根本不影响输出，然后消除这些代码，这个称之为 DCE（dead code elimination）。</p>
<p>Tree-shaking 是 DCE 的一种新的实现，Javascript 同传统的编程语言不同的是，javascript 绝大多数情况需要通过网络进行加载，然后执行，加载的文件大小越小，整体执行时间更短，所以去除无用代码以减少文件体积，对 javascript 来说更有意义。</p>
<p>Tree-shaking 和传统的 DCE 的方法又不太一样，传统的 DCE 消灭不可能执行的代码，而 Tree-shaking 更关注宇消除没有用到的代码。下面详细介绍一下 DCE 和 Tree-shaking。</p>
<p><strong>（1）先来看一下 DCE 消除大法</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415512124-bdf2b8d6-a44d-48c5-b4cd-7e832d3b6c66.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=u5c04aa5e&margin=%5Bobject%20Object%5D&name=5.jpg&originHeight=405&originWidth=720&originalType=binary&size=13053&status=done&style=none&taskId=u994cfb70-3fbb-4acd-a721-79e4fca1cec" alt="5.jpg"></p>
<p>Dead Code 一般具有以下几个特征</p>
<p>•代码不会被执行，不可到达</p>
<p>•代码执行的结果不会被用到</p>
<p>•代码只会影响死变量（只写不读）</p>
<p>下面红框标示的代码就属于死码，满足以上特征</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415515648-7a8ef020-4e11-4040-9745-5729523c8cdc.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=u0baad115&margin=%5Bobject%20Object%5D&name=6.jpg&originHeight=405&originWidth=720&originalType=binary&size=16079&status=done&style=none&taskId=udfcd44cf-a7e4-40bf-a2ec-bab6467e90d" alt="6.jpg"></p>
<p>图 4</p>
<p>传统编译型的语言中，都是由编译器将 Dead Code 从 AST（抽象语法树）中删除，那 javascript 中是由谁做 DCE 呢？</p>
<p>首先肯定不是浏览器做 DCE，因为当我们的代码送到浏览器，那还谈什么消除无法执行的代码来优化呢，所以肯定是送到浏览器之前的步骤进行优化。</p>
<p>其实也不是上面提到的三个工具，rollup，webpack，cc 做的，而是著名的代码压缩优化工具 uglify，uglify 完成了 javascript 的 DCE，下面通过一个实验来验证一下。</p>
<blockquote>
<p>以下所有的示例代码都能在我们的 github 中找到，欢迎戳 ❤</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/lin-xi/treeshaking/tree/master/rollup-webpack">https://github.com/lin-xi/treeshaking/tree/master/rollup-webpack</a></p>
<p><strong>分别用 rollup 和 webpack 将图 4 中的代码进行打包</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415520261-c9810972-e615-475e-b2da-6b2320929fb6.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=u204a249f&margin=%5Bobject%20Object%5D&name=7.jpg&originHeight=438&originWidth=720&originalType=binary&size=23130&status=done&style=none&taskId=u5c0f07c6-ff5e-4124-8ef9-1776c7af118" alt="7.jpg"></p>
<p>图 5</p>
<p>中间是 rollup 打包的结果，右边是 webpack 打包的结果</p>
<p>可以发现，rollup 将无用的代码 foo 函数和 unused 函数消除了，但是仍然保留了不会执行到的代码，而 webpack 完整的保留了所有的无用代码和不会执行到的代码。</p>
<p><strong>分别用 rollup + uglify 和 webpack + uglify 将图 4 中的代码进行打包</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415524659-a3f45414-4a9a-43b4-a539-4fb74268e2a8.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=ub23d203b&margin=%5Bobject%20Object%5D&name=8.jpg&originHeight=463&originWidth=720&originalType=binary&size=40456&status=done&style=none&taskId=uff6d2484-b35d-4c91-9ad8-f9888347565" alt="8.jpg"></p>
<p>图 6</p>
<p>中间是配置文件，右侧是结果</p>
<p>可以看到右侧最终打包结果中都去除了无法执行到的代码，结果符合我们的预期。</p>
<p><strong>(2) 再来看一下 Tree-shaking 消除大法</strong></p>
<p>前面提到了 tree-shaking 更关注于无用模块的消除，消除那些引用了但并没有被使用的模块。</p>
<p>先思考一个问题，为什么 tree-shaking 是最近几年流行起来了？而前端模块化概念已经有很多年历史了，其实 tree-shaking 的消除原理是依赖于 ES6 的模块特性。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415529275-6678a338-f495-4b4b-aec0-34f7fd52fc7d.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=u2646efa9&margin=%5Bobject%20Object%5D&name=9.jpg&originHeight=405&originWidth=720&originalType=binary&size=19655&status=done&style=none&taskId=u1d25af48-af5f-4cd8-b795-d3887492aac" alt="9.jpg"></p>
<p>ES6 module 特点：</p>
<ul>
<li>只能作为模块顶层的语句出现</li>
<li>import 的模块名只能是字符串常量</li>
<li>import binding 是 immutable 的</li>
</ul>
<p>ES6 模块依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析，这就是 tree-shaking 的基础。</p>
<p>所谓静态分析就是不执行代码，从字面量上对代码进行分析，ES6 之前的模块化，比如我们可以动态 require 一个模块，只有执行后才知道引用的什么模块，这个就不能通过静态分析去做优化。</p>
<p>这是 ES6 modules 在设计时的一个重要考量，也是为什么没有直接采用 CommonJS，正是基于这个基础上，才使得 tree-shaking 成为可能，这也是为什么 rollup 和 webpack 2 都要用 ES6 module syntax 才能 tree-shaking。</p>
<p>我们还是通过例子来详细了解一下</p>
<p>面向过程编程函数和面向对象编程是 javascript 最常用的编程模式和代码组织方式，从这两个方面来实验：</p>
<ul>
<li>函数消除实验</li>
<li>类消除实验</li>
</ul>
<p><strong>先看下函数消除实验</strong></p>
<p>utils 中 get 方法没有被使用到，我们期望的是 get 方法最终被消除。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415534000-a1a9637c-2995-4449-89d8-514b596f70db.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=u49a3465b&margin=%5Bobject%20Object%5D&name=10.jpg&originHeight=646&originWidth=720&originalType=binary&size=16134&status=done&style=none&taskId=u79851800-4d14-4761-8c88-28e86aba6c4" alt="10.jpg"></p>
<p>注意，uglify 目前不会跨文件去做 DCE，所以上面这种情况，uglify 是不能优化的。</p>
<p><strong>先看看 rollup 的打包结果</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415537651-2f568864-b6ec-4658-a01e-7a65eb402363.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=uca06a248&margin=%5Bobject%20Object%5D&name=11.jpg&originHeight=343&originWidth=720&originalType=binary&size=18232&status=done&style=none&taskId=ud208b28f-157f-4401-802e-2ba8c4ad76f" alt="11.jpg"></p>
<p>完全符合预期，最终结果中没有 get 方法</p>
<p><strong>再看看 webpack 的结果</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415541004-8eb43d30-08e8-4365-a7a4-6b75d1760a0f.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=u87646e1e&margin=%5Bobject%20Object%5D&name=12.jpg&originHeight=962&originWidth=720&originalType=binary&size=67249&status=done&style=none&taskId=u0d35bad0-09c2-4a6f-9274-92606112252" alt="12.jpg"></p>
<p>也符合预期，最终结果中没有 get 方法</p>
<p>可以看到 rollup 打包的结果比 webpack 更优化</p>
<blockquote>
<p>函数消除实验中，rollup 和 webpack 都通过，符合预期</p>
</blockquote>
<p><strong>再来看下类消除实验</strong></p>
<p>增加了对 menu.js 的引用，但其实代码中并没有用到 menu 的任何方法和变量，所以我们的期望是，最终代码中 menu.js 里的内容被消除</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415546773-c2ab6200-6b6a-4822-b98b-6beb2edb14fd.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=u1e2d25c7&margin=%5Bobject%20Object%5D&name=13.jpg&originHeight=446&originWidth=720&originalType=binary&size=14514&status=done&style=none&taskId=u00b6a7f8-c295-4a64-b196-ee3fba81903" alt="13.jpg"></p>
<p>main.js</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415551742-449c1ac0-dec7-4dcb-8099-180d2b28b5a5.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=u5de75d50&margin=%5Bobject%20Object%5D&name=14.jpg&originHeight=507&originWidth=720&originalType=binary&size=17925&status=done&style=none&taskId=u15268bf2-b626-45f8-b48a-f07a7451cda" alt="14.jpg"></p>
<p>menu.js</p>
<p><strong>rollup 打包结果</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415555773-5ac8b3e7-6822-4d17-9cf6-c399e4c11d8a.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=ucd7802ee&margin=%5Bobject%20Object%5D&name=15.jpg&originHeight=499&originWidth=720&originalType=binary&size=48979&status=done&style=none&taskId=u5d04d8e1-7bde-4e29-91d4-258ec3596f2" alt="15.jpg"></p>
<p>包中竟然包含了 menu.js 的全部代码</p>
<p><strong>webpack 打包结果</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415560732-7edb865f-1721-4fa8-b382-a7e560c849de.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=u70238c69&margin=%5Bobject%20Object%5D&name=16.jpg&originHeight=831&originWidth=720&originalType=binary&size=84376&status=done&style=none&taskId=u9c8d019c-d5f4-4cd1-9543-8c562d70068" alt="16.jpg"></p>
<p>包中竟然也包含了 menu.js 的全部代码</p>
<blockquote>
<p>类消除实验中，rollup，webpack 全军覆没，都没有达到预期</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415568229-847f4002-321b-4113-8a11-20dcb8b89efa.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=u6424d3bf&margin=%5Bobject%20Object%5D&name=17.jpg&originHeight=534&originWidth=521&originalType=binary&size=18147&status=done&style=none&taskId=u1b710400-a506-4982-afda-5d2a62011ff" alt="17.jpg"></p>
<p>what happend？</p>
<p>这跟我们想象的完全不一样啊？为什么呢？无用的类不能消除，这还能叫做 tree-shaking 吗？我当时一度怀疑自己的 demo 有问题，后来各种网上搜索，才明白 demo 没有错。</p>
<p>下面摘取了 rollup 核心贡献者的的一些回答：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415572931-7c587419-fc3a-4b62-993c-22e2f267c188.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=u4870e358&margin=%5Bobject%20Object%5D&name=18.jpg&originHeight=482&originWidth=720&originalType=binary&size=30357&status=done&style=none&taskId=u826a695b-c38e-433b-a27e-b714d1e71ba" alt="18.jpg"></p>
<p>图 7</p>
<ul>
<li>rollup 只处理函数和顶层的 import/export 变量，不能把没用到的类的方法消除掉</li>
<li>javascript 动态语言的特性使得静态分析比较困难</li>
<li>图 7 下部分的代码就是副作用的一个例子，如果静态分析的时候删除里 run 或者 jump，程序运行时就可能报错，那就本末倒置了，我们的目的是优化，肯定不能影响执行</li>
</ul>
<p>再举个例子说明下为什么不能消除 menu.js，比如下面这个场景</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Menu() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Menu.prototype.show &#x3D; function() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array.prototype.unique &#x3D; function() &#123;</span><br><span class="line">    &#x2F;&#x2F; 将 array 中的重复元素去除</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Menu;</span><br></pre></td></tr></table></figure>

<p>如果删除里 menu.js，那对 Array 的扩展也会被删除，就会影响功能。那也许你会问，难道 rollup，webpack 不能区分是定义 Menu 的 proptotype 还是定义 Array 的 proptotype 吗？当然如果代码写成上面这种形式是可以区分的，如果我写成这样呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Menu() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Menu.prototype.show &#x3D; function() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a &#x3D; &#39;Arr&#39; + &#39;ay&#39;</span><br><span class="line">var b</span><br><span class="line">if(a &#x3D;&#x3D; &#39;Array&#39;) &#123;</span><br><span class="line">    b &#x3D; Array</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    b &#x3D; Menu</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b.prototype.unique &#x3D; function() &#123;</span><br><span class="line">    &#x2F;&#x2F; 将 array 中的重复元素去除</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Menu;</span><br></pre></td></tr></table></figure>

<p>这种代码，静态分析是分析不了的，就算能静态分析代码，想要正确完全的分析也比较困难。</p>
<p>更多关于副作用的讨论，可以看这个</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415584766-5e4c8d34-b5e3-4055-9ceb-d3cdf65cdc0c.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=u8859213e&margin=%5Bobject%20Object%5D&name=19.jpg&originHeight=120&originWidth=120&originalType=binary&size=6543&status=done&style=none&taskId=uaf2b39e5-32bc-4452-8a7c-509e86bde83" alt="19.jpg"></p>
<p><a href="http://link.zhihu.com/?target=https://github.com/rollup/rollup/issues/349">Tree shaking class methods · Issue #349 · rollup/rollupgithub.com</a></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415594094-0ad21064-9164-4717-8e7b-a3fac32c32fc.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=u880b8ec5&margin=%5Bobject%20Object%5D&name=20.jpg&originHeight=405&originWidth=720&originalType=binary&size=15712&status=done&style=none&taskId=u70554999-8e4f-48bc-96da-ada236ab9b5" alt="20.jpg"></p>
<blockquote>
<p>tree-shaking 对函数效果较好</p>
</blockquote>
<p>函数的副作用相对较少，顶层函数相对来说更容易分析，加上 babel 默认都是”use strict”严格模式，减少顶层函数的动态访问的方式，也更容易分析</p>
<p>我们开始说的三个工具，rollup 和 webpack 表现不理想，那 closure compiler 又如何呢？</p>
<p>将示例中的代码用 cc 打包后得到的结果如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415606997-0930df34-d241-4fe3-896d-064756351b99.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=u919ddbe8&margin=%5Bobject%20Object%5D&name=21.jpg&originHeight=405&originWidth=720&originalType=binary&size=17714&status=done&style=none&taskId=u7bdca274-c8e7-4dae-beb6-412b706c473" alt="21.jpg"></p>
<p>天啊，这不就是我们要的结果吗？完美消除所有无用代码的结果，输出的结果非常性感</p>
<blockquote>
<p>closure compiler， tree-shaking 的结果完美！</p>
</blockquote>
<p>可是不能高兴得太早，能得到这么完美结果是需要条件的，那就是 cc 的侵入式约束规范。必须在代码里添加这样的代码，看红线框标示的</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415613494-0a044226-4eee-4ec9-9588-3135701029ba.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=ue1d60932&margin=%5Bobject%20Object%5D&name=22.jpg&originHeight=261&originWidth=720&originalType=binary&size=19369&status=done&style=none&taskId=u9847ceb1-7e7a-41a3-ab4e-b5bba4893dd" alt="22.jpg"></p>
<p>google 定义一整套注解规范 Annotating JavaScript for the Closure Compiler，想更多了解的，可以去看下官网。</p>
<p>侵入式这个就让人很不爽，google Closure Compiler 是 java 写的，和我们基于 node 的各种构建库不可能兼容（不过目前好像已经有 nodejs 版 Closure Compiler），Closure Compiler 使用起来也比较麻烦，所以虽然效果很赞，但比较难以应用到项目中，迁移成本较大。</p>
<p><strong>说了这么多，总结一下：</strong></p>
<p>三大工具的 tree-shaking 对于无用代码，无用模块的消除，都是有限的，有条件的。closure compiler 是最好的，但与我们日常的基于 node 的开发流很难兼容。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415618300-5633fb7e-a976-41d6-aa8a-2bf6594aaf2c.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=uc3f28788&margin=%5Bobject%20Object%5D&name=23.jpg&originHeight=405&originWidth=720&originalType=binary&size=6175&status=done&style=none&taskId=u2a5dacca-7a51-4245-a236-beef0048988" alt="23.jpg"></p>
<p>tree-shaking 对 web 意义重大，是一个极致优化的理想世界，是前端进化的又一个终极理想。</p>
<p>理想是美好的，但目前还处在发展阶段，还比较困难，有各个方面的，甚至有目前看来无法解</p>
<p>决的问题，但还是应该相信新技术能带来更好的前端世界。</p>
<p>优化是一种态度，不因小而不为，不因艰而不攻。</p>
<blockquote>
<p>知识有限，如果错误，请不惜指正，谢谢</p>
</blockquote>
<p>下一篇将继续介绍 <a target="_blank" rel="noopener" href="https://juejin.im/post/6844903544760336398">Tree-Shaking 性能优化实践 - 实践篇</a></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/21377586/1619415622789-70d6d885-0b51-4a90-beab-dac792588f41.webp#clientId=u022f3b9a-a5ad-4&from=drop&id=ud6bae893&margin=%5Bobject%20Object%5D&name=24.webp&originHeight=120&originWidth=180&originalType=binary&size=3120&status=done&style=none&taskId=u157a1607-0193-4ba3-a16c-ebf3c82baf4" alt="24.webp"></p>
<blockquote>
<p>本文中示例代码都能在我们的 github 中找到，欢迎戳 ❤</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619415628594-b9024704-66a8-422f-bf1b-d2ce8af8060a.jpeg#clientId=u022f3b9a-a5ad-4&from=drop&id=u9b1ca6b3&margin=%5Bobject%20Object%5D&name=25.jpg&originHeight=120&originWidth=120&originalType=binary&size=4686&status=done&style=none&taskId=u8270d645-c494-4431-a0d7-c42824bb91f" alt="25.jpg"></p>
<p><a href="http://link.zhihu.com/?target=https://github.com/lin-xi/treeshaking/tree/master/rollup-webpack">lin-xi/treeshakinggithub.com</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/26/yuque/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/26/yuque/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/" class="post-title-link" itemprop="url">前端模块化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-26 00:26:40" itemprop="dateCreated datePublished" datetime="2021-04-26T00:26:40+08:00">2021-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 18:36:14" itemprop="dateModified" datetime="2021-04-29T18:36:14+08:00">2021-04-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在 JavaScript 发展初期就是为了实现简单的页面交互逻辑，寥寥数语即可；如今 CPU、浏览器性能得到了极大的提升，很多页面逻辑迁移到了客户端（表单验证等），随着 web2.0 时代的到来，Ajax 技术得到广泛应用，jQuery 等前端库层出不穷，前端代码日益膨胀，此时在 JS 方面就会考虑使用模块化规范去管理。本文内容主要有理解模块化，为什么要模块化，模块化的优缺点以及模块化规范,并且介绍下开发中最流行的 CommonJS, AMD, ES6、CMD 规范。本文试图站在小白的角度，用通俗易懂的笔调介绍这些枯燥无味的概念，希望诸君阅读后，对模块化编程有个全新的认识和理解！</p>
<p><strong>建议下载本文源代码，自己动手敲一遍，请猛戳</strong><a target="_blank" rel="noopener" href="https://github.com/ljianshu/Blog">GitHub 个人博客</a><br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619368031111-ae8eeeb9-6592-4649-b5ad-301fb9aeec79.png#clientId=u650f5481-1581-4&from=paste&height=333&id=u02eadb23&margin=%5Bobject%20Object%5D&name=image.png&originHeight=333&originWidth=732&originalType=binary&size=101358&status=done&style=none&taskId=ua9ac1d85-8e29-4203-ad78-0e38ec391cd&width=732" alt="image.png"></p>
<h2 id="一、模块化的理解"><a href="#一、模块化的理解" class="headerlink" title="一、模块化的理解"></a>一、模块化的理解</h2><h3 id="1-什么是模块"><a href="#1-什么是模块" class="headerlink" title="1.什么是模块?"></a>1.什么是模块?</h3><ul>
<li>将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起</li>
<li>块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信</li>
</ul>
<h3 id="2-模块化的进化过程"><a href="#2-模块化的进化过程" class="headerlink" title="2.模块化的进化过程"></a>2.模块化的进化过程</h3><ul>
<li><strong>全局 function 模式 : 将不同的功能封装成不同的全局函数</strong><ul>
<li>编码: 将不同的功能封装成不同的全局函数</li>
<li>问题: 污染全局命名空间, 容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>namespace 模式 : 简单对象封装</strong><ul>
<li>作用: 减少了全局变量，解决命名冲突</li>
<li>问题: 数据不安全(外部可以直接修改模块内部的数据)</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myModule = &#123;</span><br><span class="line">  data: <span class="string">&quot;www.baidu.com&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`foo() <span class="subst">$&#123;<span class="built_in">this</span>.data&#125;</span>`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">bar</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`bar() <span class="subst">$&#123;<span class="built_in">this</span>.data&#125;</span>`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">myModule.data = <span class="string">&quot;other data&quot;</span>; <span class="comment">//能直接修改模块内部的数据</span></span><br><span class="line">myModule.foo(); <span class="comment">// foo() other data</span></span><br></pre></td></tr></table></figure>

<p>这样的写法会暴露所有模块成员，内部状态可以被外部改写。</p>
<ul>
<li><strong>IIFE 模式：匿名函数自调用(闭包)</strong><ul>
<li>作用: 数据是私有的, 外部只能通过暴露的方法操作</li>
<li>编码: 将数据和行为封装到一个函数内部, 通过给 window 添加属性来向外暴露接口</li>
<li>问题: 如果当前这个模块依赖另一个模块怎么办?</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.html文件</span></span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;module.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    myModule.foo()</span><br><span class="line">    myModule.bar()</span><br><span class="line">    <span class="built_in">console</span>.log(myModule.data) <span class="comment">//undefined 不能访问模块内部数据</span></span><br><span class="line">    myModule.data = <span class="string">&#x27;xxxx&#x27;</span> <span class="comment">//不是修改的模块内部的data</span></span><br><span class="line">    myModule.foo() <span class="comment">//没有改变</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">window</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = <span class="string">&quot;www.baidu.com&quot;</span>;</span><br><span class="line">  <span class="comment">//操作数据的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//用于暴露有函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`foo() <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//用于暴露有函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`bar() <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">    otherFun(); <span class="comment">//内部调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">otherFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//内部私有的函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;otherFun()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//暴露行为</span></span><br><span class="line">  <span class="built_in">window</span>.myModule = &#123; foo, bar &#125;; <span class="comment">//ES6写法</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>

<p>最后得到的结果：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619368117913-22682704-66d2-497e-9f2b-34f1efafc980.png#clientId=u0cc1c904-12a0-4&from=paste&height=105&id=uc27c29db&margin=%5Bobject%20Object%5D&name=image.png&originHeight=105&originWidth=419&originalType=binary&size=4563&status=done&style=none&taskId=u463fad66-1d12-44cc-84c0-8faaec2403e&width=419" alt="image.png"></p>
<ul>
<li><strong>IIFE 模式增强 : 引入依赖</strong></li>
</ul>
<p>这就是现代模块实现的基石</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">window</span>, $</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = <span class="string">&quot;www.baidu.com&quot;</span>;</span><br><span class="line">  <span class="comment">//操作数据的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//用于暴露有函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`foo() <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">    $(<span class="string">&quot;body&quot;</span>).css(<span class="string">&quot;background&quot;</span>, <span class="string">&quot;red&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//用于暴露有函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`bar() <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">    otherFun(); <span class="comment">//内部调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">otherFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//内部私有的函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;otherFun()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//暴露行为</span></span><br><span class="line">  <span class="built_in">window</span>.myModule = &#123; foo, bar &#125;;</span><br><span class="line">&#125;)(<span class="built_in">window</span>, jQuery);</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// index.html文件</span><br><span class="line"><span class="comment">&lt;!-- 引入的js必须有一定顺序 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;jquery-1.10.1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;module.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line">  myModule.foo();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上例子通过 jquery 方法将页面的背景颜色改成红色，所以必须先引入 jQuery 库，就把这个库当作参数传入。<strong>这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显</strong>。</p>
<h3 id="3-模块化的好处"><a href="#3-模块化的好处" class="headerlink" title="3. 模块化的好处"></a>3. 模块化的好处</h3><ul>
<li>避免命名冲突(减少命名空间污染)</li>
<li>更好的分离, 按需加载</li>
<li>更高复用性</li>
<li>高可维护性</li>
</ul>
<h3 id="4-引入多个后出现出现问题"><a href="#4-引入多个后出现出现问题" class="headerlink" title="4. 引入多个后出现出现问题"></a>4. 引入多个<script>后出现出现问题</h3><ul>
<li>请求过多</li>
</ul>
<p>首先我们要依赖多个模块，那样就会发送多个请求，导致请求过多</p>
<ul>
<li>依赖模糊</li>
</ul>
<p>我们不知道他们的具体依赖关系是什么，也就是说很容易因为不了解他们之间的依赖关系导致加载先后顺序出错。</p>
<ul>
<li>难以维护</li>
</ul>
<p>以上两种原因就导致了很难维护，很可能出现牵一发而动全身的情况导致项目出现严重的问题。模块化固然有多个好处，然而一个页面需要引入多个 js 文件，就会出现以上这些问题。而这些问题可以通过模块化规范来解决，下面介绍开发中最流行的 commonjs, AMD, ES6, CMD 规范。</p>
<h2 id="二、模块化规范"><a href="#二、模块化规范" class="headerlink" title="二、模块化规范"></a>二、模块化规范</h2><h3 id="1-CommonJS"><a href="#1-CommonJS" class="headerlink" title="1.CommonJS"></a>1.CommonJS</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="(1)概述"></a>(1)概述</h4><p>Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。<strong>在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。</strong></p>
<h4 id="2-特点"><a href="#2-特点" class="headerlink" title="(2)特点"></a>(2)特点</h4><ul>
<li>所有代码都运行在模块作用域，不会污染全局作用域。</li>
<li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li>
<li>模块加载的顺序，按照其在代码中出现的顺序。</li>
</ul>
<h4 id="3-基本语法"><a href="#3-基本语法" class="headerlink" title="(3)基本语法"></a>(3)基本语法</h4><ul>
<li>暴露模块：module.exports = value 或 exports.xxx = value</li>
<li>引入模块：require(xxx),如果是第三方模块，xxx 为模块名；如果是自定义模块，xxx 为模块文件路径</li>
</ul>
<p>此处我们有个疑问：<strong>CommonJS 暴露的模块到底是什么?<strong>CommonJS 规范规定，每个模块内部，module 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即 module.exports）是对外的接口。</strong>加载某个模块，其实是加载该模块的 module.exports 属性</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example.js</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> addX = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value + x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports.x = x;</span><br><span class="line"><span class="built_in">module</span>.exports.addX = addX;</span><br></pre></td></tr></table></figure>

<p>上面代码通过 module.exports 输出变量 x 和函数 addX。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = <span class="built_in">require</span>(<span class="string">&quot;./example.js&quot;</span>); <span class="comment">//如果参数字符串以“./”开头，则表示加载的是一个位于相对路径</span></span><br><span class="line"><span class="built_in">console</span>.log(example.x); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(example.addX(<span class="number">1</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>require 命令用于加载模块文件。<strong>require 命令的基本功能是，读入并执行一个 JavaScript 文件，然后返回该模块的 exports 对象。如果没有发现指定模块，会报错</strong>。</p>
<h4 id="4-模块的加载机制"><a href="#4-模块的加载机制" class="headerlink" title="(4)模块的加载机制"></a>(4)模块的加载机制</h4><p><strong>CommonJS 模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值</strong>。这点与 ES6 模块化有重大差异（下文会介绍），请看下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  counter: counter,</span><br><span class="line">  incCounter: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码输出内部变量 counter 和改写这个变量的内部方法 incCounter。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="built_in">require</span>(<span class="string">&quot;./lib&quot;</span>).counter;</span><br><span class="line"><span class="keyword">var</span> incCounter = <span class="built_in">require</span>(<span class="string">&quot;./lib&quot;</span>).incCounter;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>上面代码说明，counter 输出以后，lib.js 模块内部的变化就影响不到 counter 了。<strong>这是因为 counter 是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值</strong>。</p>
<h4 id="5-服务器端实现"><a href="#5-服务器端实现" class="headerlink" title="(5)服务器端实现"></a>(5)服务器端实现</h4><h4 id="①-下载安装-node-js"><a href="#①-下载安装-node-js" class="headerlink" title="① 下载安装 node.js"></a>① 下载安装 node.js</h4><h4 id="②-创建项目结构"><a href="#②-创建项目结构" class="headerlink" title="② 创建项目结构"></a>② 创建项目结构</h4><p><strong>注意：用 npm init 自动生成 package.json 时，package name(包名)不能有中文和大写</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|-modules</span><br><span class="line">  |-module1.js</span><br><span class="line">  |-module2.js</span><br><span class="line">  |-module3.js</span><br><span class="line">|-app.js</span><br><span class="line">|-package.json</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;commonJS-node&quot;,</span><br><span class="line">    &quot;version&quot;: &quot;1.0.0&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="③-下载第三方模块"><a href="#③-下载第三方模块" class="headerlink" title="③ 下载第三方模块"></a>③ 下载第三方模块</h4><p>npm install uniq –save // 用于数组去重</p>
<h4 id="④-定义模块代码"><a href="#④-定义模块代码" class="headerlink" title="④ 定义模块代码"></a>④ 定义模块代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module1.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  msg: <span class="string">&quot;module1&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.msg);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module2.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;module2&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module3.js</span></span><br><span class="line"><span class="built_in">exports</span>.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;foo() module3&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">exports</span>.arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js文件</span></span><br><span class="line"><span class="comment">// 引入第三方库，应该放置在最前面</span></span><br><span class="line"><span class="keyword">let</span> uniq = <span class="built_in">require</span>(<span class="string">&quot;uniq&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> module1 = <span class="built_in">require</span>(<span class="string">&quot;./modules/module1&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> module2 = <span class="built_in">require</span>(<span class="string">&quot;./modules/module2&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> module3 = <span class="built_in">require</span>(<span class="string">&quot;./modules/module3&quot;</span>);</span><br><span class="line"></span><br><span class="line">module1.foo(); <span class="comment">//module1</span></span><br><span class="line">module2(); <span class="comment">//module2</span></span><br><span class="line">module3.foo(); <span class="comment">//foo() module3</span></span><br><span class="line"><span class="built_in">console</span>.log(uniq(module3.arr)); <span class="comment">//[ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>

<h4 id="⑤-通过-node-运行-app-js"><a href="#⑤-通过-node-运行-app-js" class="headerlink" title="⑤ 通过 node 运行 app.js"></a>⑤ 通过 node 运行 app.js</h4><p>命令行输入 node app.js，运行 JS 文件</p>
<h4 id="6-浏览器端实现-借助-Browserify"><a href="#6-浏览器端实现-借助-Browserify" class="headerlink" title="(6)浏览器端实现(借助 Browserify)"></a>(6)浏览器端实现(借助 Browserify)</h4><h4 id="①-创建项目结构"><a href="#①-创建项目结构" class="headerlink" title="① 创建项目结构"></a>① 创建项目结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|-js</span><br><span class="line">  |-dist &#x2F;&#x2F;打包生成文件的目录</span><br><span class="line">  |-src &#x2F;&#x2F;源码所在的目录</span><br><span class="line">    |-module1.js</span><br><span class="line">    |-module2.js</span><br><span class="line">    |-module3.js</span><br><span class="line">    |-app.js &#x2F;&#x2F;应用主源文件</span><br><span class="line">|-index.html &#x2F;&#x2F;运行于浏览器上</span><br><span class="line">|-package.json</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;browserify-test&quot;,</span><br><span class="line">    &quot;version&quot;: &quot;1.0.0&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="②-下载-browserify"><a href="#②-下载-browserify" class="headerlink" title="② 下载 browserify"></a>② 下载 browserify</h4><ul>
<li>全局: npm install browserify -g</li>
<li>局部: npm install browserify –save-dev</li>
</ul>
<h4 id="③-定义模块代码-同服务器端"><a href="#③-定义模块代码-同服务器端" class="headerlink" title="③ 定义模块代码(同服务器端)"></a>③ 定义模块代码(同服务器端)</h4><p>注意：index.html 文件要运行在浏览器上，需要借助 browserify 将 app.js 文件打包编译，如果直接在 index.html 引入 app.js 就会报错！</p>
<h4 id="④-打包处理-js"><a href="#④-打包处理-js" class="headerlink" title="④ 打包处理 js"></a>④ 打包处理 js</h4><p>根目录下运行 browserify js/src/app.js -o js/dist/bundle.js</p>
<h4 id="⑤-页面使用引入"><a href="#⑤-页面使用引入" class="headerlink" title="⑤ 页面使用引入"></a>⑤ 页面使用引入</h4><p>在 index.html 文件中引入<script type="text/javascript" src="js/dist/bundle.js"></script></p>
<h3 id="2-AMD"><a href="#2-AMD" class="headerlink" title="2.AMD"></a>2.AMD</h3><p>CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD 规范则是非同步加载模块，允许指定回调函数。由于 Node.js 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 CommonJS 规范比较适用。但是，<strong>如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用 AMD 规范</strong>。此外 AMD 规范比 CommonJS 规范在浏览器端实现要来着早。</p>
<h4 id="1-AMD-规范基本语法"><a href="#1-AMD-规范基本语法" class="headerlink" title="(1)AMD 规范基本语法"></a>(1)AMD 规范基本语法</h4><p><strong>定义暴露模块</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义没有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> 模块;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义有依赖的模块</span></span><br><span class="line">define([<span class="string">&quot;module1&quot;</span>, <span class="string">&quot;module2&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">m1, m2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> 模块;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>引入使用模块</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">&quot;module1&quot;</span>, <span class="string">&quot;module2&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">m1, m2</span>) </span>&#123;</span><br><span class="line">  使用m1 / m2;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="2-未使用-AMD-规范与使用-require-js"><a href="#2-未使用-AMD-规范与使用-require-js" class="headerlink" title="(2)未使用 AMD 规范与使用 require.js"></a>(2)未使用 AMD 规范与使用 require.js</h4><p>通过比较两者的实现方法，来说明使用 AMD 规范的好处。</p>
<ul>
<li>未使用 AMD 规范</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dataService.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">window</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> msg = <span class="string">&quot;www.baidu.com&quot;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> msg.toUpperCase();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">window</span>.dataService = &#123; getMsg &#125;;</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alerter.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">window</span>, dataService</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">showMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(dataService.getMsg() + <span class="string">&quot;, &quot;</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">window</span>.alerter = &#123; showMsg &#125;;</span><br><span class="line">&#125;)(<span class="built_in">window</span>, dataService);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">alerter</span>) </span>&#123;</span><br><span class="line">  alerter.showMsg();</span><br><span class="line">&#125;)(alerter);</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// index.html文件</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Modular Demo 1: 未使用AMD(require.js)<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/modules/dataService.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/modules/alerter.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后得到如下结果：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619368360078-dea15769-8e59-4cf4-9798-8bd4173960da.png#clientId=u0cc1c904-12a0-4&from=paste&height=170&id=u8e06bb4f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=170&originWidth=508&originalType=binary&size=8509&status=done&style=none&taskId=u1e0ddbef-4733-45d3-ac12-2e8c1bc5b9f&width=508" alt="image.png"><br>这种方式缺点很明显：<strong>首先会发送多个请求，其次引入的 js 文件顺序不能搞错，否则会报错！</strong></p>
<ul>
<li>使用 require.js</li>
</ul>
<p>RequireJS 是一个工具库，主要用于客户端的模块管理。它的模块管理遵守 AMD 规范，<strong>RequireJS 的基本思想是，通过 define 方法，将代码定义为模块；通过 require 方法，实现代码的模块加载</strong>。接下来介绍 AMD 规范在浏览器实现的步骤：</p>
<h4 id="①-下载-require-js-并引入"><a href="#①-下载-require-js-并引入" class="headerlink" title="① 下载 require.js, 并引入"></a>① 下载 require.js, 并引入</h4><ul>
<li>官网:<a target="_blank" rel="noopener" href="http://www.requirejs.cn/">http://www.requirejs.cn/</a></li>
<li>github :<a target="_blank" rel="noopener" href="https://github.com/requirejs/requirejs">https://github.com/requirejs/requirejs</a></li>
</ul>
<p>然后将 require.js 导入项目: js/libs/require.js</p>
<h4 id="②-创建项目结构-1"><a href="#②-创建项目结构-1" class="headerlink" title="② 创建项目结构"></a>② 创建项目结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|-js</span><br><span class="line">  |-libs</span><br><span class="line">    |-require.js</span><br><span class="line">  |-modules</span><br><span class="line">    |-alerter.js</span><br><span class="line">    |-dataService.js</span><br><span class="line">  |-main.js</span><br><span class="line">|-index.html</span><br></pre></td></tr></table></figure>

<h4 id="③-定义-require-js-的模块代码"><a href="#③-定义-require-js-的模块代码" class="headerlink" title="③ 定义 require.js 的模块代码"></a>③ 定义 require.js 的模块代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dataService.js文件</span></span><br><span class="line"><span class="comment">// 定义没有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> msg = <span class="string">&quot;www.baidu.com&quot;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> msg.toUpperCase();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; getMsg &#125;; <span class="comment">// 暴露模块</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//alerter.js文件</span></span><br><span class="line"><span class="comment">// 定义有依赖的模块</span></span><br><span class="line">define([<span class="string">&quot;dataService&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">dataService</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">showMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(dataService.getMsg() + <span class="string">&quot;, &quot;</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 暴露模块</span></span><br><span class="line">  <span class="keyword">return</span> &#123; showMsg &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">require</span>.config(&#123;</span><br><span class="line">    baseUrl: <span class="string">&quot;js/&quot;</span>, <span class="comment">//基本路径 出发点在根目录下</span></span><br><span class="line">    paths: &#123;</span><br><span class="line">      <span class="comment">//映射: 模块标识名: 路径</span></span><br><span class="line">      alerter: <span class="string">&quot;./modules/alerter&quot;</span>, <span class="comment">//此处不能写成alerter.js,会报错</span></span><br><span class="line">      dataService: <span class="string">&quot;./modules/dataService&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">require</span>([<span class="string">&quot;alerter&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">alerter</span>) </span>&#123;</span><br><span class="line">    alerter.showMsg();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// index.html文件</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Modular Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入require.js并指定js主文件的入口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">data-main</span>=<span class="string">&quot;js/main&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/libs/require.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="④-页面引入-require-js-模块"><a href="#④-页面引入-require-js-模块" class="headerlink" title="④ 页面引入 require.js 模块:"></a>④ 页面引入 require.js 模块:</h4><p>在 index.html 引入<script data-main="js/main" src="js/libs/require.js"></script><br><strong>此外在项目中如何引入第三方库？</strong>只需在上面代码的基础稍作修改：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alerter.js文件</span></span><br><span class="line">define([<span class="string">&quot;dataService&quot;</span>, <span class="string">&quot;jquery&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">dataService, $</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">showMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(dataService.getMsg() + <span class="string">&quot;, &quot;</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line">  $(<span class="string">&quot;body&quot;</span>).css(<span class="string">&quot;background&quot;</span>, <span class="string">&quot;green&quot;</span>);</span><br><span class="line">  <span class="comment">// 暴露模块</span></span><br><span class="line">  <span class="keyword">return</span> &#123; showMsg &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">require</span>.config(&#123;</span><br><span class="line">    baseUrl: <span class="string">&quot;js/&quot;</span>, <span class="comment">//基本路径 出发点在根目录下</span></span><br><span class="line">    paths: &#123;</span><br><span class="line">      <span class="comment">//自定义模块</span></span><br><span class="line">      alerter: <span class="string">&quot;./modules/alerter&quot;</span>, <span class="comment">//此处不能写成alerter.js,会报错</span></span><br><span class="line">      dataService: <span class="string">&quot;./modules/dataService&quot;</span>,</span><br><span class="line">      <span class="comment">// 第三方库模块</span></span><br><span class="line">      jquery: <span class="string">&quot;./libs/jquery-1.10.1&quot;</span>, <span class="comment">//注意：写成jQuery会报错</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">require</span>([<span class="string">&quot;alerter&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">alerter</span>) </span>&#123;</span><br><span class="line">    alerter.showMsg();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>上例是在 alerter.js 文件中引入 jQuery 第三方库，main.js 文件也要有相应的路径配置。<strong>小结</strong>：通过两者的比较，可以得出<strong>AMD 模块定义的方法非常清晰，不会污染全局环境，能够清楚地显示依赖关系</strong>。AMD 模式可以用于浏览器环境，并且允许非同步加载模块，也可以根据需要动态加载模块。</p>
<h3 id="3-CMD"><a href="#3-CMD" class="headerlink" title="3.CMD"></a>3.CMD</h3><p>CMD 规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD 规范整合了 CommonJS 和 AMD 规范的特点。在 Sea.js 中，所有 JavaScript 模块都遵循 CMD 模块定义规范。</p>
<h4 id="1-CMD-规范基本语法"><a href="#1-CMD-规范基本语法" class="headerlink" title="(1)CMD 规范基本语法"></a>(1)CMD 规范基本语法</h4><p><strong>定义暴露模块：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义没有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">exports</span>.xxx = value;</span><br><span class="line">  <span class="built_in">module</span>.exports = value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//引入依赖模块(同步)</span></span><br><span class="line">  <span class="keyword">var</span> module2 = <span class="built_in">require</span>(<span class="string">&quot;./module2&quot;</span>);</span><br><span class="line">  <span class="comment">//引入依赖模块(异步)</span></span><br><span class="line">  <span class="built_in">require</span>.async(<span class="string">&quot;./module3&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m3</span>) </span>&#123;&#125;);</span><br><span class="line">  <span class="comment">//暴露模块</span></span><br><span class="line">  <span class="built_in">exports</span>.xxx = value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>引入使用模块：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> m1 = <span class="built_in">require</span>(<span class="string">&quot;./module1&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> m4 = <span class="built_in">require</span>(<span class="string">&quot;./module4&quot;</span>);</span><br><span class="line">  m1.show();</span><br><span class="line">  m4.show();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="2-sea-js-简单使用教程"><a href="#2-sea-js-简单使用教程" class="headerlink" title="(2)sea.js 简单使用教程"></a>(2)sea.js 简单使用教程</h4><h4 id="①-下载-sea-js-并引入"><a href="#①-下载-sea-js-并引入" class="headerlink" title="① 下载 sea.js, 并引入"></a>① 下载 sea.js, 并引入</h4><ul>
<li>官网:<a target="_blank" rel="noopener" href="http://seajs.org/">http://seajs.org/</a></li>
<li>github :<a target="_blank" rel="noopener" href="https://github.com/seajs/seajs">https://github.com/seajs/seajs</a></li>
</ul>
<p>然后将 sea.js 导入项目: js/libs/sea.js</p>
<h4 id="②-创建项目结构-2"><a href="#②-创建项目结构-2" class="headerlink" title="② 创建项目结构"></a>② 创建项目结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|-js</span><br><span class="line">  |-libs</span><br><span class="line">    |-sea.js</span><br><span class="line">  |-modules</span><br><span class="line">    |-module1.js</span><br><span class="line">    |-module2.js</span><br><span class="line">    |-module3.js</span><br><span class="line">    |-module4.js</span><br><span class="line">    |-main.js</span><br><span class="line">|-index.html</span><br></pre></td></tr></table></figure>

<h4 id="③-定义-sea-js-的模块代码"><a href="#③-定义-sea-js-的模块代码" class="headerlink" title="③ 定义 sea.js 的模块代码"></a>③ 定义 sea.js 的模块代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module1.js文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//内部变量数据</span></span><br><span class="line">  <span class="keyword">var</span> data = <span class="string">&quot;atguigu.com&quot;</span>;</span><br><span class="line">  <span class="comment">//内部函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;module1 show() &quot;</span> + data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//向外暴露</span></span><br><span class="line">  <span class="built_in">exports</span>.show = show;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module2.js文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    msg: <span class="string">&quot;I Will Back&quot;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module3.js文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> API_KEY = <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line">  <span class="built_in">exports</span>.API_KEY = API_KEY;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module4.js文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//引入依赖模块(同步)</span></span><br><span class="line">  <span class="keyword">var</span> module2 = <span class="built_in">require</span>(<span class="string">&quot;./module2&quot;</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;module4 show() &quot;</span> + module2.msg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exports</span>.show = show;</span><br><span class="line">  <span class="comment">//引入依赖模块(异步)</span></span><br><span class="line">  <span class="built_in">require</span>.async(<span class="string">&quot;./module3&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m3</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;异步引入依赖模块3  &quot;</span> + m3.API_KEY);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> m1 = <span class="built_in">require</span>(<span class="string">&quot;./module1&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> m4 = <span class="built_in">require</span>(<span class="string">&quot;./module4&quot;</span>);</span><br><span class="line">  m1.show();</span><br><span class="line">  m4.show();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="④-在-index-html-中引入"><a href="#④-在-index-html-中引入" class="headerlink" title="④ 在 index.html 中引入"></a>④ 在 index.html 中引入</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/libs/sea.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  seajs.use(<span class="string">&quot;./js/modules/main&quot;</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后得到结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619368668530-d6477aad-29fa-4012-b354-27d275f9c9f5.png#clientId=u0cc1c904-12a0-4&from=paste&height=84&id=ud03b9b5b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=84&originWidth=430&originalType=binary&size=4381&status=done&style=none&taskId=u4003f26a-2c46-4c19-a106-ff39fe4dbbb&width=430" alt="image.png"></p>
<h3 id="4-ES6-模块化"><a href="#4-ES6-模块化" class="headerlink" title="4.ES6 模块化"></a>4.ES6 模块化</h3><p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p>
<h4 id="1-ES6-模块化语法"><a href="#1-ES6-模块化语法" class="headerlink" title="(1)ES6 模块化语法"></a>(1)ES6 模块化语法</h4><p>export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 定义模块 math.js **/</span></span><br><span class="line"><span class="keyword">var</span> basicNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; basicNum, add &#125;;</span><br><span class="line"><span class="comment">/** 引用模块 **/</span></span><br><span class="line"><span class="keyword">import</span> &#123; basicNum, add &#125; <span class="keyword">from</span> <span class="string">&quot;./math&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">ele</span>) </span>&#123;</span><br><span class="line">  ele.textContent = add(<span class="number">99</span> + basicNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上例所示，使用 import 命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到 export default 命令，为模块指定默认输出。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import-default.js</span></span><br><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">&quot;./export-default&quot;</span>;</span><br><span class="line">customName(); <span class="comment">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure>

<p>模块默认输出, 其他模块加载该模块时，import 命令可以为该匿名函数指定任意名字。</p>
<h4 id="2-ES6-模块与-CommonJS-模块的差异"><a href="#2-ES6-模块与-CommonJS-模块的差异" class="headerlink" title="(2)ES6 模块与 CommonJS 模块的差异"></a>(2)ES6 模块与 CommonJS 模块的差异</h4><p>它们有两个重大差异：<br><strong>① CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用</strong>。<br><strong>② CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</strong>。<br>第二个差异是因为 CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。<br>下面重点解释第一个差异，我们还是举上面那个 CommonJS 模块的加载机制例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">&quot;./lib&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>ES6 模块的运行机制与 CommonJS 不一样。<strong>ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块</strong>。</p>
<h4 id="3-ES6-Babel-Browserify-使用教程"><a href="#3-ES6-Babel-Browserify-使用教程" class="headerlink" title="(3) ES6-Babel-Browserify 使用教程"></a>(3) ES6-Babel-Browserify 使用教程</h4><p>简单来说就一句话：<strong>使用 Babel 将 ES6 编译为 ES5 代码，使用 Browserify 编译打包 js</strong>。</p>
<h4 id="①-定义-package-json-文件"><a href="#①-定义-package-json-文件" class="headerlink" title="① 定义 package.json 文件"></a>① 定义 package.json 文件</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;es6-babel-browserify&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="②-安装-babel-cli-babel-preset-es2015-和-browserify"><a href="#②-安装-babel-cli-babel-preset-es2015-和-browserify" class="headerlink" title="② 安装 babel-cli, babel-preset-es2015 和 browserify"></a>② 安装 babel-cli, babel-preset-es2015 和 browserify</h4><ul>
<li>npm install babel-cli browserify -g</li>
<li>npm install babel-preset-es2015 –save-dev</li>
<li>preset 预设(将 es6 转换成 es5 的所有插件打包)</li>
</ul>
<h4 id="③-定义-babelrc-文件"><a href="#③-定义-babelrc-文件" class="headerlink" title="③ 定义.babelrc 文件"></a>③ 定义.babelrc 文件</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;presets&quot;</span>: [<span class="string">&quot;es2015&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="④-定义模块代码-1"><a href="#④-定义模块代码-1" class="headerlink" title="④ 定义模块代码"></a>④ 定义模块代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module1.js文件</span></span><br><span class="line"><span class="comment">// 分别暴露</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;foo() module1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;bar() module1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module2.js文件</span></span><br><span class="line"><span class="comment">// 统一暴露</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;fun1() module2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;fun2() module2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; fun1, fun2 &#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module3.js文件</span></span><br><span class="line"><span class="comment">// 默认暴露 可以暴露任意数据类项，暴露什么数据，接收到就是什么数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;默认暴露&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js文件</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">&quot;./module1&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; fun1, fun2 &#125; <span class="keyword">from</span> <span class="string">&quot;./module2&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> module3 <span class="keyword">from</span> <span class="string">&quot;./module3&quot;</span>;</span><br><span class="line">foo();</span><br><span class="line">bar();</span><br><span class="line">fun1();</span><br><span class="line">fun2();</span><br><span class="line">module3();</span><br></pre></td></tr></table></figure>

<h4 id="⑤-编译并在-index-html-中引入"><a href="#⑤-编译并在-index-html-中引入" class="headerlink" title="⑤ 编译并在 index.html 中引入"></a>⑤ 编译并在 index.html 中引入</h4><ul>
<li>使用 Babel 将 ES6 编译为 ES5 代码(但包含 CommonJS 语法) :babel js/src -d js/lib</li>
<li>使用 Browserify 编译 js :browserify js/lib/app.js -o js/lib/bundle.js</li>
</ul>
<p>然后在 index.html 文件中引入</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/lib/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后得到如下结果：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619369029376-9a9914a3-75c0-42cb-8c31-0f64a14a78a4.png#clientId=u0cc1c904-12a0-4&from=paste&height=102&id=ua6b37741&margin=%5Bobject%20Object%5D&name=image.png&originHeight=102&originWidth=437&originalType=binary&size=3646&status=done&style=none&taskId=u7cfa784c-d662-4080-8701-81af1964f53&width=437" alt="image.png"><br><strong>此外第三方库(以 jQuery 为例)如何引入呢</strong>？<br>首先安装依赖 npm install jquery@1<br>然后在 app.js 文件中引入</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//app.js文件 import &#123; foo, bar &#125; from &#x27;./module1&#x27; import &#123; fun1, fun2 &#125; from</span><br><span class="line">&#x27;./module2&#x27; import module3 from &#x27;./module3&#x27; import $ from &#x27;jquery&#x27; foo() bar()</span><br><span class="line">fun1() fun2() module3() $(&#x27;body&#x27;).css(&#x27;background&#x27;, &#x27;green&#x27;)</span><br></pre></td></tr></table></figure>

<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><ul>
<li>CommonJS 规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了 AMD CMD 解决方案。</li>
<li>AMD 规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD 规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。</li>
<li>CMD 规范与 AMD 规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在 Node.js 中运行。不过，依赖 SPM 打包，模块的加载逻辑偏重</li>
<li><strong>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案</strong>。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/25/yuque/%E6%B8%B2%E6%9F%93%E5%90%88%E6%88%90%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/25/yuque/%E6%B8%B2%E6%9F%93%E5%90%88%E6%88%90%E5%B1%82/" class="post-title-link" itemprop="url">渲染合成层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-25 23:11:28" itemprop="dateCreated datePublished" datetime="2021-04-25T23:11:28+08:00">2021-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 18:36:14" itemprop="dateModified" datetime="2021-04-29T18:36:14+08:00">2021-04-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="梳理浏览器渲染流程"><a href="#梳理浏览器渲染流程" class="headerlink" title="梳理浏览器渲染流程"></a>梳理浏览器渲染流程</h2><p>首先简单了解一下浏览器请求、加载、渲染一个页面的大致过程：</p>
<ul>
<li>DNS 查询</li>
<li>TCP 连接</li>
<li>HTTP 请求即响应</li>
<li>服务器响应</li>
<li>客户端渲染</li>
</ul>
<p>这里主要将客户端渲染展开梳理一下，从浏览器器内核拿到内容（渲染线程接收请求，加载网页并渲染网页），渲染大概可以划分成以下几个步骤：</p>
<ul>
<li>解析 html 建立 dom 树</li>
<li>解析 css 构建 render 树（将 CSS 代码解析成树形的数据结构，然后结合 DOM 合并成 render 树）</li>
<li>布局 render 树（Layout/reflow），负责各元素尺寸、位置的计算</li>
<li>绘制 render 树（paint），绘制页面像素信息</li>
<li>浏览器会将各层的信息发送给 GPU（GPU 进程：最多一个，用于 3D 绘制等），GPU 会将各层合成（composite），显示在屏幕上。</li>
</ul>
<p>参考一张图（webkit 渲染主要流程）：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619363642174-481e16d9-9a43-4096-b6e3-0d05efa9c009.png#clientId=u5af2961a-f81b-4&from=paste&height=289&id=u4f533940&margin=%5Bobject%20Object%5D&name=image.png&originHeight=289&originWidth=624&originalType=binary&size=39586&status=done&style=none&taskId=u9daf1abb-fe8b-4964-9127-e58530ea4e2&width=624" alt="image.png"><br>这里先解释一下几个概念，方便大家理解：<br>　　 DOM Tree：浏览器将 HTML 解析成树形的数据结构。<br>　　 CSS Rule Tree：浏览器将 CSS 解析成树形的数据结构。<br>　　 Render Tree: DOM 和 CSSOM 合并后生成 Render Tree。<br>　　 layout: 有了 Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的 CSS 定义以及他们的从属关系，从而去计算出每个节点在屏幕中的位置。<br>　　 painting: 按照算出来的规则，通过显卡，把内容画到屏幕上。<br>　　 reflow（回流）：当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，内行称这个回退的过程叫 reflow。reflow 会从 <html> 这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置。reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。<br>　　 repaint（重绘）：改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。<br>注意：</p>
<ol>
<li>display:none 的节点不会被加入 Render Tree，而 visibility: hidden 则会，所以，如果某个节点最开始是不显示的，设为 display:none 是更优的。</li>
<li>display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发现位置变化。</li>
<li>有些情况下，比如修改了元素的样式，浏览器并不会立刻 reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次 reflow，这又叫异步 reflow 或增量异步 reflow。但是在有些情况下，比如 resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。</li>
</ol>
<p>再参考一张图理解一下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619363668703-951a22f8-23c8-4b9b-9abf-c3c4e82ddb6a.png#clientId=u5af2961a-f81b-4&from=paste&height=111&id=u4e02cff7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=111&originWidth=700&originalType=binary&size=56388&status=done&style=none&taskId=u5b23f9b4-f095-42f4-8ee4-9785c055796&width=700" alt="image.png"><br>细致分离两个环节，其他环节参考上述概念注解：<br>JavaScript：JavaScript 实现动画效果，DOM 元素操作等。Composite（渲染层合并）：对页面中 DOM 元素的绘制是在多个层上进行的。在每个层上完成绘制过程之后，浏览器会将所有层按照合理的顺序合并成一个图层，然后显示在屏幕上。对于有位置重叠的元素的页面，这个过程尤其重要，因为一旦图层的合并顺序出错，将会导致元素显示异常。<br>在实际场景下，大致会出现三种常见的渲染流程（Layout 和 Paint 步骤是可避免的，可参考上一张图的注意部分理解）：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619363684549-4c380d60-da59-499e-802f-040741adf294.png#clientId=u5af2961a-f81b-4&from=paste&height=381&id=u6450f303&margin=%5Bobject%20Object%5D&name=image.png&originHeight=381&originWidth=580&originalType=binary&size=140788&status=done&style=none&taskId=u978aeeac-ffc9-4a25-a9fb-86a97c01760&width=580" alt="image.png"></p>
<hr>
<h2 id="Composite"><a href="#Composite" class="headerlink" title="Composite"></a>Composite</h2><h4 id="了解层"><a href="#了解层" class="headerlink" title="了解层"></a>了解层</h4><p><strong>注意：首先说明，这里讨论的是 WebKit，描述的是 Chrome 的实现细节，而并非是 web 平台的功能，因此这里介绍的内容不一定适用于其他浏览器。</strong></p>
<ul>
<li>Chrome 拥有两套不同的渲染路径(rendering path)：硬件加速路径和旧软件路径(older software path)</li>
<li>Chrome 中有不同类型的层： RenderLayer(负责 DOM 子树)和 GraphicsLayer(负责 RenderLayer 的子树)，只有 GraphicsLayer 是作为纹理(texture)上传给 GPU 的。</li>
<li>什么是纹理？可以把它想象成一个从主存储器(例如 RAM)移动到图像存储器(例如 GPU 中的 VRAM)的位图图像(bitmapimage)</li>
<li>Chrome 使用纹理来从 GPU 上获得大块的页面内容。通过将纹理应用到一个非常简单的矩形网格就能很容易匹配不同的位置(position)和变形(transformation)。这也就是 3DCSS 的工作原理，它对于快速滚动也十分有效。</li>
</ul>
<p>整个图：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619363614081-e37ca74c-d966-423f-8242-1a40e169b31b.png#clientId=u5af2961a-f81b-4&from=paste&height=268&id=u13b8f6dd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=268&originWidth=650&originalType=binary&size=57852&status=done&style=none&taskId=u99e5ce91-02ad-4872-8d3e-5dec17afbb9&width=650" alt="image.png"><br>在 Chrome 中其实有几种不同的层类型：</p>
<ul>
<li>RenderLayers 渲染层，这是负责对应 DOM 子树</li>
<li>GraphicsLayers 图形层，这是负责对应 RenderLayers 子树。</li>
</ul>
<p>在浏览器渲染流程中提到了 composite 概念，在 DOM 树中每个节点都会对应一个 LayoutObject，当他们的 LayoutObject 处于相同的坐标空间时，就会形成一个 RenderLayers ，也就是渲染层。RenderLayers 来保证页面元素以正确的顺序合成，这时候就会出现层合成（composite），从而正确处理透明元素和重叠元素的显示。<br>某些特殊的渲染层会被认为是合成层（Compositing Layers），合成层拥有单独的 GraphicsLayer，而其他不是合成层的渲染层，则和其第一个拥有 GraphicsLayer 父层公用一个。<br>而每个 GraphicsLayer（合成层单独拥有的图层） 都有一个 GraphicsContext，GraphicsContext 会负责输出该层的位图，位图是存储在共享内存中，作为纹理上传到 GPU 中，最后由 GPU 将多个位图进行合成，然后显示到屏幕上。</p>
<h2 id="如何变成合成层"><a href="#如何变成合成层" class="headerlink" title="如何变成合成层"></a>如何变成合成层</h2><h4 id="合成层创建标准"><a href="#合成层创建标准" class="headerlink" title="合成层创建标准"></a>合成层创建标准</h4><p>什么情况下能使元素获得自己的层？虽然 Chrome 的启发式方法(heuristic)随着时间在不断发展进步，但是从目前来说，满足以下任意情况便会创建层：</p>
<ul>
<li>3D 或透视变换(perspective transform) CSS 属性</li>
<li>使用加速视频解码的 <video> 元素 拥有 3D</li>
<li>(WebGL) 上下文或加速的 2D 上下文的 <canvas> 元素</li>
<li>混合插件(如 Flash)</li>
<li>对自己的 opacity 做 CSS 动画或使用一个动画变换的元素</li>
<li>拥有加速 CSS 过滤器的元素</li>
<li>元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)</li>
<li>元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)</li>
</ul>
<h2 id="合成层的优点"><a href="#合成层的优点" class="headerlink" title="合成层的优点"></a>合成层的优点</h2><p><a target="_blank" rel="noopener" href="http://taobaofed.org/blog/2016/04/25/performance-composite/">淘宝的栗子</a>举的很详细，值得一看，里面提到了一旦 renderLayer 提升为了合成层就会有自己的绘图上下文，并且会开启硬件加速，有利于性能提升,里面列举了一些特点</p>
<ul>
<li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快</li>
<li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</li>
<li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li>
</ul>
<p><strong>注意：</strong></p>
<ol>
<li>提升到合成层后合成层的位图会交 GPU 处理，但请注意，仅仅只是合成的处理（把绘图上下文的位图输出进行组合）需要用到 GPU，生成合成层的位图处理（绘图上下文的工作）是需要 CPU。</li>
<li>当需要 repaint 的时候可以只 repaint 本身，不影响其他层，但是 paint 之前还有 style， layout,那就意味着即使合成层只是 repaint 了自己，但 style 和 layout 本身就很占用时间。</li>
<li>仅仅是 transform 和 opacity 不会引发 layout 和 paint，那么其他的属性不确定。</li>
</ol>
<p>总结合成层的优势：一般一个元素开启硬件加速后会变成合成层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能。<br><strong>性能优化点：</strong></p>
<ol>
<li>提升动画效果的元素 合成层的好处是不会影响到其他元素的绘制，因此，为了减少动画元素对其他元素的影响，从而减少 paint，我们需要把动画效果中的元素提升为合成层。提升合成层的最好方式是使用 CSS 的 will-change 属性。从上一节合成层产生原因中，可以知道 will-change 设置为 opacity、transform、top、left、bottom、right 可以将元素提升为合成层。</li>
<li>使用 transform 或者 opacity 来实现动画效果, 这样只需要做合成层的合并就好了。</li>
<li>减少绘制区域 对于不需要重新绘制的区域应尽量避免绘制，以减少绘制区域，比如一个 fix 在页面顶部的固定不变的导航 header，在页面内容某个区域 repaint 时，整个屏幕包括 fix 的 header 也会被重绘。而对于固定不变的区域，我们期望其并不会被重绘，因此可以通过之前的方法，将其提升为独立的合成层。减少绘制区域，需要仔细分析页面，区分绘制区域，减少重绘区域甚至避免重绘。</li>
</ol>
<h2 id="利用合成层可能踩到的坑"><a href="#利用合成层可能踩到的坑" class="headerlink" title="利用合成层可能踩到的坑"></a>利用合成层可能踩到的坑</h2><ol>
<li>合成层占用内存的问题</li>
<li>层爆炸，由于某些原因可能导致产生大量不在预期内的合成层，虽然有浏览器的层压缩机制，但是也有很多无法进行压缩的情况，这就可能出现层爆炸的现象（简单理解就是，很多不需要提升为合成层的元素因为某些不当操作成为了合成层）。解决层爆炸的问题，最佳方案是打破 overlap 的条件，也就是说让其他元素不要和合成层元素重叠。简单直接的方式：使用 3D 硬件加速提升动画性能时，最好给元素增加一个 z-index 属性，人为干扰合成的排序，可以有效减少 chrome 创建不必要的合成层，提升渲染性能，移动端优化效果尤为明显。在这篇<a target="_blank" rel="noopener" href="http://div.io/topic/1348">文章</a>中的<a target="_blank" rel="noopener" href="http://fouber.github.io/test/layer/">demo</a>可以看出其中厉害。</li>
</ol>
<p>用 chremo 打开 demo 页面后，开启浏览器的开发者模式，再按照<strong>如图操作</strong>打开查看工具：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619363731138-9a26cf8b-8104-43dc-a945-f5e0e011277f.png#clientId=u5af2961a-f81b-4&from=paste&height=732&id=u92de5f1d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=732&originWidth=569&originalType=binary&size=174228&status=done&style=none&taskId=ufa589ae5-a274-4ce8-a4b3-00deb5dffaa&width=569" alt="image.png"><br>开启 Rendering 的 Layer borders 后 观察点击为动画元素设置 z-index 复选框的页面提示变化：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619363714774-f2da0ca4-e51e-4fbc-91f7-307d4388cf87.png#clientId=u5af2961a-f81b-4&from=paste&height=732&id=u9e699078&margin=%5Bobject%20Object%5D&name=image.png&originHeight=732&originWidth=641&originalType=binary&size=154880&status=done&style=none&taskId=ubf52f35a-428c-4da3-be16-f3031b35920&width=641" alt="image.png"><br>上图中可以明显看出：页面中设置了一个 h1 标题，应用了 translate3d 动画，使得它被放到 composited layer 中渲染，然后在这个元素后面创建了 2000 个 list。在不为 h1 元素设置 z-index 的情况下，使得本不需要提升到合成层的 ul 元素下的每个 li 元素都提升为一个单独合成层（每个 li 元素的黄色提示边框），最终会导致 GPU 资源过度消耗页面滑动时很卡，尤其在移动端（安卓）上更加明显。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619363748135-c0ff102e-1850-410e-81dd-77d7afe77610.png#clientId=u5af2961a-f81b-4&from=paste&height=732&id=u13441047&margin=%5Bobject%20Object%5D&name=image.png&originHeight=732&originWidth=653&originalType=binary&size=187431&status=done&style=none&taskId=uced4698a-1d9a-4209-8b1c-a91dad1df24&width=653" alt="image.png"><br>如上图操作选中为动画元素设置 z-index，可以看出 ul 下的每个 li 都回归到普通渲染层，不再是合成层也就不会消耗 GPU 资源去渲染，从而达到了优化页面性能优化的目的。<br>大家可以用支持『硬件加速』的『安卓』手机浏览器测试上述页面，给动画元素加 z-index 前后的性能差距非常明显。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>在实际的前端开发中尤其是移动端开发，很多小伙伴都很喜欢使用类似 translateZ(0)等属性来进行所谓的硬件加速，以提升性能，达到优化页面动态效果的目的，但还是要注意凡事过犹不及，应用硬件加速的同时也要注意到千万别踩坑。关于合成层的更细致具体的讲解，可以仔细学习下下面的参考文章（尤其是前三篇哦）。最后祝愿热爱技术的你我始终坚持在探索技术的路上奋力前行！<br><strong>参考文章：</strong><a target="_blank" rel="noopener" href="http://taobaofed.org/blog/2016/04/25/performance-composite/">无线性能优化：Composite</a><a target="_blank" rel="noopener" href="https://www.html5rocks.com/zh/tutorials/speed/layers/">DOM to Screen</a><a target="_blank" rel="noopener" href="https://www.smashingmagazine.com/2016/12/gpu-animation-doing-it-right/">CSS GPU Animation: Doing It Right</a><a target="_blank" rel="noopener" href="https://github.com/hello2dj/blog/blob/master/%08web%E4%BC%98%E5%8C%96%E4%B9%8Bcomposite.md">web 优化之 composite</a><a target="_blank" rel="noopener" href="https://juejin.im/entry/59dc9aedf265da43200232f9">详谈层合成（composite）</a><a target="_blank" rel="noopener" href="http://div.io/topic/1348">CSS3 硬件加速也有坑</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/t/chrome">chrome</a><a target="_blank" rel="noopener" href="https://segmentfault.com/t/html5">html5</a><a target="_blank" rel="noopener" href="https://segmentfault.com/t/html">html</a><a target="_blank" rel="noopener" href="https://segmentfault.com/t/css">css</a><a target="_blank" rel="noopener" href="https://segmentfault.com/t/javascript">javascript</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/25/yuque/UDP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/25/yuque/UDP/" class="post-title-link" itemprop="url">UDP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-25 22:40:45" itemprop="dateCreated datePublished" datetime="2021-04-25T22:40:45+08:00">2021-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 18:36:14" itemprop="dateModified" datetime="2021-04-29T18:36:14+08:00">2021-04-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>UDP 数据报<strong>一、UDP 的概述</strong>（<strong>User Datagram Protocol，用户数据报协议</strong>）UDP 是<strong>传输层</strong>的协议，功能即为在 IP 的数据报服务之上增加了最基本的服务：<strong>复用</strong>和<strong>分用</strong>以及<strong>差错检测</strong>。UDP 提供<strong>不可靠</strong>服务，具有 TCP 所没有的<strong>优势</strong>：</p>
<ul>
<li>UDP<strong>无连接</strong>，时间上<strong>不存在建立连接需要的时延</strong>。空间上，TCP 需要在端系统中<strong>维护连接</strong>状态，需要一定的开销。此连接装入包括接收和发送缓存，拥塞控制参数和序号与确认号的参数。UCP 不维护连接状态，也不跟踪这些参数，开销小。空间和时间上都具有优势。举个例子：DNS 如果运行在 TCP 之上而不是 UDP，那么 DNS 的速度将会慢很多。HTTP 使用 TCP 而不是 UDP，是因为对于基于文本数据的 Web 网页来说，<strong>可靠性</strong>很重要。同一种专用应用服务器在支持 UDP 时，一定能支持更多的活动客户机。</li>
<li>分组首部开销小**，TCP 首部 20 字节，UDP 首部 8 字节。</li>
<li><strong>UDP 没有拥塞控制</strong>，应用层能够更好的控制要发送的数据和发送时间，网络中的拥塞控制也不会影响主机的发送速率。某些实时应用要求以稳定的速度发送，<strong>能容 忍一些数据的丢失，但是不能允许有较大的时延</strong>（比如实时视频，直播等）</li>
<li>UDP<strong>提供尽最大努力的交付</strong>，不保证可靠交付。所有维护传输可靠性的工作需要用户在<strong>应用层</strong>来完成。没有 TCP 的确认机制、重传机制。如果因为网络原因没有传送到对端，UDP 也不会给应用层返回错误信息</li>
<li>UDP 是<strong>面向报文</strong>的，对应用层交下来的报文，添加首部后直接向下交付为 IP 层，既不合并，也不拆分，保留这些报文的边界。对 IP 层交上来 UDP 用户数据报，在去除首部后就原封不动地交付给上层应用进程，报文不可分割，是 UDP 数据报处理的最小单位。正是因为这样，UDP 显得不够灵活，不能控制读写数据的次数和数量。比如我们要发送 100 个字节的报文，我们调用一次 sendto 函数就会发送 100 字节，对端也需要用 recvfrom 函数一次性接收 100 字节，不能使用循环每次获取 10 个字节，获取十次这样的做法。</li>
<li>UDP<strong>常用一次性传输比较少量数据的网络应用</strong>，如 DNS,SNMP 等，因为对于这些应用，若是采用 TCP，为连接的创建，维护和拆除带来不小的开销。UDP 也常用于多媒体应用（如 IP 电话，实时视频会议，流媒体等）数据的可靠传输对他们而言并不重要，TCP 的拥塞控制会使他们有较大的延迟，也是不可容忍的</li>
</ul>
<p><strong>二、UDP 的首部格式</strong>UDP 数据报分为<strong>首部</strong>和<strong>用户数据部分</strong>，整个 UDP 数据报作为 IP 数据报的数据部分封装在 IP 数据报中，UDP 数据报文结构如图所示：<br><img src="https://cdn.nlark.com/yuque/0/2021/jpg/21377586/1619361667214-2e9fb5f8-10e5-4e4d-bcf9-a232a777c3db.jpg#clientId=uf766e91f-7da9-4&from=paste&height=434&id=uc13cee0b&margin=%5Bobject%20Object%5D&originHeight=434&originWidth=1121&originalType=url&status=done&style=none&taskId=ucab3cb07-e1f4-49d7-a7a2-56d5143d585&width=1121"><br>UDP 首部有 8 个字节，由 4 个字段构成，每个字段都是两个字节，1.<strong>源端口</strong>： 源端口号，需要对方回信时选用，不需要时全部置 0.2.<strong>目的端口</strong>：目的端口号，在终点交付报文的时候需要用到。3.<strong>长度</strong>：UDP 的数据报的长度（包括首部和数据）其最小值为 8（只有首部）4.<strong>校验和</strong>：检测 UDP 数据报在传输中是否有错，有错则丢弃。该字段是可选的，当源主机不想计算校验和，则直接令该字段全为 0.当传输层从 IP 层收到 UDP 数据报时，就根据首部中的目的端口，把 UDP 数据报通过相应的端口，上交给应用进程。如果接收方 UDP 发现收到的报文中的目的端口号不正确（不存在对应端口号的应用进程 0,），就丢弃该报文，并由 ICMP 发送“端口不可达”差错报文给对方。UDP 校验在计算校验和的时候，需要在 UDP 数据报之前增加<strong>12 字节的伪首部</strong>，伪首部并不是 UDP 真正的首部。只是在计算校验和，临时添加在 UDP 数据报的前面，得到一个临时的 UDP 数据报。校验和就是按照这个临时的 UDP 数据报计算的。伪首部既不向下传送也不向上递交，而<strong>仅仅是为了计算校验和</strong>。这样的校验和，既<strong>检查了 UDP 数据报，又对 IP 数据报的源 IP 地址和目的 IP 地址进行了检验。</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619361667396-09c2b15d-e2c0-4254-b729-d4987d18a9b3.jpeg#clientId=uf766e91f-7da9-4&from=paste&height=521&id=u0b96cd49&margin=%5Bobject%20Object%5D&originHeight=521&originWidth=720&originalType=url&status=done&style=none&taskId=u6a91d411-a507-43da-a0b9-046e4cfe127&width=720"><br>UDP 校验和的计算方法和 IP 数据报首部校验和的计算方法相似，都使用二进制反码运算求和再取反，但不同的是：IP 数据报的校验和之检验 IP 数据报和首部，但 UDP 的校验和是把首部和数据部分一起校验。发送方，首先是把<strong>全零放入校验和字段</strong>并且添加<strong>伪首部</strong>，然后把 UDP 数据报看成是由许多 16 位的子串连接起来，若 UDP 数据报的数据部分不是偶数个字节，则要在数据部分末尾增加一个全零字节（此字节不发送），接下来就按照二进制反码计算出这些 16 位字的和。将此和的二进制反码写入校验和字段。在接收方，把收到得 UDP 数据报加上伪首部（如果不为偶数个字节，还需要补上全零字节）后，按二进制反码计算出这些 16 位字的和。<strong>当无差错时其结果全为 1</strong>,。否则就表明有差错出现，接收方应该丢弃这个 UDP 数据报。<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619361667438-0f18033d-fc51-4edd-a53a-b8a608f63d22.jpeg#clientId=uf766e91f-7da9-4&from=paste&height=454&id=u21c6ee63&margin=%5Bobject%20Object%5D&originHeight=454&originWidth=720&originalType=url&status=done&style=none&taskId=ucb722cc4-afb5-4088-81f6-28fdb315bda&width=720"><br>注意：1.校验时，若 UDP 数据报部分的长度不是偶数个字节，则需要填入一个全 0 字节，但是次字节和伪首部一样，是不发送的。2.如果 UDP 校验和校验出 UDP 数据报是错误的，可以丢弃，也可以交付上层，但是要附上错误报告，告诉上层这是错误的数据报。3.通过伪首部，不仅可以检查源端口号，目的端口号和 UDP 用户数据报的数据部分，还可以检查 IP 数据报的源 IP 地址和目的地址。这种差错检验的检错能力不强，但是简单，速度快</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/25/yuque/TCP%20%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%EF%BC%88%E4%B8%8B%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/25/yuque/TCP%20%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%EF%BC%88%E4%B8%8B%EF%BC%89/" class="post-title-link" itemprop="url">TCP 的那些事儿（下）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-25 22:24:44" itemprop="dateCreated datePublished" datetime="2021-04-25T22:24:44+08:00">2021-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 18:36:14" itemprop="dateModified" datetime="2021-04-29T18:36:14+08:00">2021-04-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这篇文章是下篇，所以如果你对 TCP 不熟悉的话，还请你先看看上篇《<a target="_blank" rel="noopener" href="https://coolshell.cn/articles/11564.html">TCP 的那些事儿（上）</a>》 上篇中，我们介绍了 TCP 的协议头、状态机、数据重传中的东西。但是 TCP 要解决一个很大的事，那就是要在一个网络根据不同的情况来动态调整自己的发包的速度，小则让自己的连接更稳定，大则让整个网络更稳定。在你阅读下篇之前，你需要做好准备，本篇文章有好些算法和策略，可能会引发你的各种思考，让你的大脑分配很多内存和计算资源，所以，不适合在厕所中阅读。</p>
<h1 id="TCP-的-RTT-算法"><a href="#TCP-的-RTT-算法" class="headerlink" title="TCP 的 RTT 算法"></a>TCP 的 RTT 算法</h1><p>从前面的 TCP 重传机制我们知道 Timeout 的设置对于重传非常重要。</p>
<ul>
<li>设长了，重发就慢，丢了老半天才重发，没有效率，性能差；</li>
<li>设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li>
</ul>
<p>而且，这个超时时间在不同的网络的情况下，根本没有办法设置一个死的值。只能动态地设置。 为了动态地设置，TCP 引入了 RTT——Round Trip Time，也就是一个数据包从发出去到回来的时间。这样发送端就大约知道需要多少的时间，从而可以方便地设置 Timeout——RTO（Retransmission TimeOut），以让我们的重传机制更高效。 听起来似乎很简单，好像就是在发送端发包时记下 t0，然后接收端再把这个 ack 回来时再记一个 t1，于是 RTT = t1 – t0。没那么简单，这只是一个采样，不能代表普遍情况。</p>
<h2 id="经典算法"><a href="#经典算法" class="headerlink" title="经典算法"></a>经典算法</h2><p><a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc793">RFC793</a>  中定义的经典算法是这样的：<br>1）首先，先采样 RTT，记下最近好几次的 RTT 值。<br>2）然后做平滑计算 SRTT（ Smoothed RTT）。公式为：（其中的 α 取值在 0.8 到 0.9 之间，这个算法英文叫 Exponential weighted moving average，中文叫：加权移动平均）</p>
<blockquote>
<p><strong>SRTT = ( α _ SRTT ) + ((1- α) _ RTT)</strong></p>
</blockquote>
<p>3）开始计算 RTO。公式如下：</p>
<blockquote>
<p><strong>RTO = min [ UBOUND,  max [ LBOUND,   (β * SRTT) ]  ]</strong></p>
</blockquote>
<p>其中：</p>
<ul>
<li>UBOUND 是最大的 timeout 时间，上限值</li>
<li>LBOUND 是最小的 timeout 时间，下限值</li>
<li>β 值一般在 1.3 到 2.0 之间。</li>
</ul>
<h2 id="Karn-Partridge-算法"><a href="#Karn-Partridge-算法" class="headerlink" title="Karn / Partridge 算法"></a>Karn / Partridge 算法</h2><p>但是上面的这个算法在重传的时候会出有一个终极问题——你是用第一次发数据的时间和 ack 回来的时间做 RTT 样本值，还是用重传的时间和 ACK 回来的时间做 RTT 样本值？<br>这个问题无论你选那头都是按下葫芦起了瓢。 如下图所示：</p>
<ul>
<li>情况（a）是 ack 没回来，所以重传。如果你计算第一次发送和 ACK 的时间，那么，明显算大了。</li>
<li>情况（b）是 ack 回来慢了，但是导致了重传，但刚重传不一会儿，之前 ACK 就回来了。如果你是算重传的时间和 ACK 回来的时间的差，就会算短了。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619360709603-b1b4a5a5-fd6f-4578-8ef1-195181201ece.jpeg#clientId=u6f576584-d24a-4&from=paste&height=166&id=uce4be580&margin=%5Bobject%20Object%5D&originHeight=332&originWidth=745&originalType=url&status=done&style=none&taskId=ufc3d1fc5-bfdc-481e-a012-79e1502cfb7&width=372.5"><br>所以 1987 年的时候，搞了一个叫<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Karn's_Algorithm">Karn / Partridge Algorithm</a>，这个算法的最大特点是——<strong>忽略重传，不把重传的 RTT 做采样</strong>（你看，你不需要去解决不存在的问题）。<br>但是，这样一来，又会引发一个大 BUG——<strong>如果在某一时间，网络闪动，突然变慢了，产生了比较大的延时，这个延时导致要重转所有的包（因为之前的 RTO 很小），于是，因为重转的不算，所以，RTO 就不会被更新，这是一个灾难</strong>。 于是 Karn 算法用了一个取巧的方式——只要一发生重传，就对现有的 RTO 值翻倍（这就是所谓的  Exponential backoff），很明显，这种死规矩对于一个需要估计比较准确的 RTT 也不靠谱。</p>
<h2 id="Jacobson-Karels-算法"><a href="#Jacobson-Karels-算法" class="headerlink" title="Jacobson / Karels 算法"></a>Jacobson / Karels 算法</h2><p>前面两种算法用的都是“加权移动平均”，这种方法最大的毛病就是如果 RTT 有一个大的波动的话，很难被发现，因为被平滑掉了。所以，1988 年，又有人推出来了一个新的算法，这个算法叫 Jacobson / Karels Algorithm（参看<a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc6298">RFC6289</a>）。这个算法引入了最新的 RTT 的采样和平滑过的 SRTT 的差距做因子来计算。 公式如下：（其中的 DevRTT 是 Deviation RTT 的意思）<br>**SRTT = SRTT + α(RTT – SRTT)  **—— 计算平滑 RTT<br>**DevRTT = (1-β)<em>DevRTT + β</em>(|RTT-SRTT|)**——计算平滑 RTT 和真实的差距（加权移动平均）<br>**RTO= µ * SRTT + ∂ *DevRTT**—— 神一样的公式<br>（其中：在 Linux 下，α = 0.125，β = 0.25， μ = 1，∂ = 4 ——这就是算法中的“调得一手好参数”，nobody knows why, it just works…） 最后的这个算法在被用在今天的 TCP 协议中（Linux 的源代码在：<a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/net/ipv4/tcp_input.c?v=2.6.32#L609">tcp_rtt_estimator</a>）。</p>
<h1 id="TCP-滑动窗口"><a href="#TCP-滑动窗口" class="headerlink" title="TCP 滑动窗口"></a>TCP 滑动窗口</h1><p>需要说明一下，如果你不了解 TCP 的滑动窗口这个事，你等于不了解 TCP 协议。我们都知道，<strong>TCP 必需要解决的可靠传输以及包乱序（reordering）的问题</strong>，所以，TCP 必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。<br>所以，TCP 引入了一些技术和设计来做网络流控，Sliding Window 是其中一个技术。 前面我们说过，<strong>TCP 头里有一个字段叫 Window，又叫 Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据</strong>。<strong>于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来</strong>。 为了说明滑动窗口，我们需要先看一下 TCP 缓冲区的一些数据结构：<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619360709691-99063d87-cbcd-4b7e-afe1-483a70de3f4c.jpeg#clientId=u6f576584-d24a-4&from=paste&height=300&id=ud1be6304&margin=%5Bobject%20Object%5D&originHeight=361&originWidth=906&originalType=url&status=done&style=none&taskId=u6def94ed-edcb-415f-ba41-b4814d42fb3&width=752"><br>上图中，我们可以看到：</p>
<ul>
<li>接收端 LastByteRead 指向了 TCP 缓冲区中读到的位置，NextByteExpected 指向的地方是收到的连续包的最后一个位置，LastByteRcved 指向的是收到的包的最后一个位置，我们可以看到中间有些数据还没有到达，所以有数据空白区。</li>
<li>发送端的 LastByteAcked 指向了被接收端 Ack 过的位置（表示成功发送确认），LastByteSent 表示发出去了，但还没有收到成功确认的 Ack，LastByteWritten 指向的是上层应用正在写的地方。</li>
</ul>
<p>于是：</p>
<ul>
<li>接收端在给发送端回 ACK 中会汇报自己的 AdvertisedWindow = MaxRcvBuffer – LastByteRcvd – 1;</li>
<li>而发送方会根据这个窗口来控制发送数据的大小，以保证接收方可以处理。</li>
</ul>
<p>下面我们来看一下发送方的滑动窗口示意图：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619360709607-365d12f9-613c-4a0f-8c7b-b960f3ce4c78.png#clientId=u6f576584-d24a-4&from=paste&height=270&id=ud4273986&margin=%5Bobject%20Object%5D&originHeight=270&originWidth=660&originalType=url&status=done&style=none&taskId=uf069525e-1120-4c5f-98ad-e5f5498d983&width=660"><br>（<a target="_blank" rel="noopener" href="http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo-6.htm">图片来源</a>）<br>上图中分成了四个部分，分别是：（其中那个黑模型就是滑动窗口）</p>
<ul>
<li>#1 已收到 ack 确认的数据。</li>
<li>#2 发还没收到 ack 的。</li>
<li>#3 在窗口中还没有发出的（接收方还有空间）。</li>
<li>#4 窗口以外的数据（接收方没空间）</li>
</ul>
<p>下面是个滑动后的示意图（收到 36 的 ack，并发出了 46-51 的字节）：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619360709766-9861b05c-aef1-430a-b230-6c9a03f9ca33.png#clientId=u6f576584-d24a-4&from=paste&height=210&id=uf0d3e0ab&margin=%5Bobject%20Object%5D&originHeight=210&originWidth=660&originalType=url&status=done&style=none&taskId=u037ab23b-7d6a-4a43-896d-3fd26808699&width=660"><br>下面我们来看一个接受端控制发送端的图示：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619360709741-26b260ab-1f10-4f23-8c1e-c8664d5e02e5.png#clientId=u6f576584-d24a-4&from=paste&height=836&id=u76b6d6e1&margin=%5Bobject%20Object%5D&originHeight=836&originWidth=666&originalType=url&status=done&style=none&taskId=ufb60f2ea-587c-4c9c-8a36-ab3bd8a8436&width=666"><br>（<a target="_blank" rel="noopener" href="http://www.tcpipguide.com/free/t_TCPWindowSizeAdjustmentandFlowControl-2.htm">图片来源</a>）</p>
<h2 id="Zero-Window"><a href="#Zero-Window" class="headerlink" title="Zero Window"></a>Zero Window</h2><p>上图，我们可以看到一个处理缓慢的 Server（接收端）是怎么把 Client（发送端）的 TCP Sliding Window 给降成 0 的。此时，你一定会问，如果 Window 变成 0 了，TCP 会怎么样？是不是发送端就不发数据了？是的，发送端就不发数据了，你可以想像成“Window Closed”，那你一定还会问，如果发送端不发数据了，接收方一会儿 Window size 可用了，怎么通知发送端呢？<br>解决这个问题，TCP 使用了 Zero Window Probe 技术，缩写为 ZWP，也就是说，发送端在窗口变成 0 后，会发 ZWP 的包给接收方，让接收方来 ack 他的 Window 尺寸，一般这个值会设置成 3 次，第次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后还是 0 的话，有的 TCP 实现就会发 RST 把链接断了。<br><strong>注意</strong>：只要有等待的地方都可能出现 DDoS 攻击，Zero Window 也不例外，一些攻击者会在和 HTTP 建好链发完 GET 请求后，就把 Window 设置为 0，然后服务端就只能等待进行 ZWP，于是攻击者会并发大量的这样的请求，把服务器端的资源耗尽。（关于这方面的攻击，大家可以移步看一下<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Sockstress">Wikipedia 的 SockStress 词条</a>）<br>另外，Wireshark 中，你可以使用 tcp.analysis.zero_window 来过滤包，然后使用右键菜单里的 follow TCP stream，你可以看到 ZeroWindowProbe 及 ZeroWindowProbeAck 的包。</p>
<h2 id="Silly-Window-Syndrome"><a href="#Silly-Window-Syndrome" class="headerlink" title="Silly Window Syndrome"></a>Silly Window Syndrome</h2><p>Silly Window Syndrome 翻译成中文就是“糊涂窗口综合症”。正如你上面看到的一样，如果我们的接收方太忙了，来不及取走 Receive Windows 里的数据，那么，就会导致发送方越来越小。到最后，如果接收方腾出几个字节并告诉发送方现在有几个字节的 window，而我们的发送方会义无反顾地发送这几个字节。<br>要知道，我们的 TCP+IP 头有 40 个字节，为了几个字节，要达上这么大的开销，这太不经济了。<br>另外，你需要知道网络上有个 MTU，对于以太网来说，MTU 是 1500 字节，除去 TCP+IP 头的 40 个字节，真正的数据传输可以有 1460，这就是所谓的 MSS（Max Segment Size）注意，TCP 的 RFC 定义这个 MSS 的默认值是 536，这是因为<a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc791">RFC 791</a>里说了任何一个 IP 设备都得最少接收 576 尺寸的大小（实际上来说 576 是拨号的网络的 MTU，而 576 减去 IP 头的 20 个字节就是 536）。<br><strong>如果你的网络包可以塞满 MTU，那么你可以用满整个带宽，如果不能，那么你就会浪费带宽</strong>。（大于 MTU 的包有两种结局，一种是直接被丢了，另一种是会被重新分块打包发送） 你可以想像成一个 MTU 就相当于一个飞机的最多可以装的人，如果这飞机里满载的话，带宽最高，如果一个飞机只运一个人的话，无疑成本增加了，也而相当二。<br>所以，<strong>Silly Windows Syndrome 这个现像就像是你本来可以坐 200 人的飞机里只做了一两个人</strong>。 要解决这个问题也不难，就是避免对小的 window size 做出响应，直到有足够大的 window size 再响应，这个思路可以同时实现在 sender 和 receiver 两端。</p>
<ul>
<li>如果这个问题是由 Receiver 端引起的，那么就会使用  David D Clark’s 方案。在 receiver 端，如果收到的数据导致 window size 小于某个值，可以直接 ack(0)回 sender，这样就把 window 给关闭了，也阻止了 sender 再发数据过来，等到 receiver 端处理了一些数据后 windows size 大于等于了 MSS，或者，receiver buffer 有一半为空，就可以把 window 打开让 send 发送数据过来。</li>
<li>如果这个问题是由 Sender 端引起的，那么就会使用著名的<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Nagle%27s_algorithm">Nagle’s algorithm</a>。这个算法的思路也是延时处理，他有两个主要的条件：1）要等到 Window Size&gt;=MSS 或是 Data Size &gt;=MSS，2）收到之前发送数据的 ack 回包，他才会发数据，否则就是在攒数据。</li>
</ul>
<p>另外，Nagle 算法默认是打开的，所以，对于一些需要小包场景的程序——<strong>比如像 telnet 或 ssh 这样的交互性比较强的程序，你需要关闭这个算法</strong>。你可以在 Socket 设置 TCP_NODELAY 选项来关闭这个算法（关闭 Nagle 算法没有全局参数，需要根据每个应用自己的特点来关闭）</p>
<blockquote>
<p>setsockopt(sock_fd, IPPROTO_TCP, TCP_NODELAY, (<strong>char</strong> *)&amp;value,sizeof(<strong>int</strong>));</p>
</blockquote>
<p>另外，网上有些文章说 TCP_CORK 的 socket option 是也关闭 Nagle 算法，这不对。<strong>TCP_CORK 其实是更新激进的 Nagle 算汉，完全禁止小包发送，而 Nagle 算法没有禁止小包发送，只是禁止了大量的小包发送</strong>。最好不要两个选项都设置。</p>
<h1 id="TCP-的拥塞处理-–-Congestion-Handling"><a href="#TCP-的拥塞处理-–-Congestion-Handling" class="headerlink" title="TCP 的拥塞处理 – Congestion Handling"></a>TCP 的拥塞处理 – Congestion Handling</h1><p>上面我们知道了，TCP 通过 Sliding Window 来做流控（Flow Control），但是 TCP 觉得这还不够，因为 Sliding Window 需要依赖于连接的发送端和接收端，其并不知道网络中间发生了什么。TCP 的设计者觉得，一个伟大而牛逼的协议仅仅做到流控并不够，因为流控只是网络模型 4 层以上的事，TCP 的还应该更聪明地知道整个网络上的事。<br>具体一点，我们知道 TCP 通过一个 timer 采样了 RTT 并计算 RTO，但是，<strong>如果网络上的延时突然增加，那么，TCP 对这个事做出的应对只有重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，于是，这个情况就会进入恶性循环被不断地放大。试想一下，如果一个网络内有成千上万的 TCP 连接都这么行事，那么马上就会形成“网络风暴”，TCP 这个协议就会拖垮整个网络。</strong>这是一个灾难。<br>所以，TCP 不能忽略网络上发生的事情，而无脑地一个劲地重发数据，对网络造成更大的伤害。对此 TCP 的设计理念是：<strong>TCP 不是一个自私的协议，当拥塞发生的时候，要做自我牺牲。就像交通阻塞一样，每个车都应该把路让出来，而不要再去抢路了。</strong><br>关于拥塞控制的论文请参看《<a target="_blank" rel="noopener" href="http://ee.lbl.gov/papers/congavoid.pdf">Congestion Avoidance and Control</a>》(PDF)<br>拥塞控制主要是四个算法：<strong>1）慢启动</strong>，<strong>2）拥塞避免</strong>，<strong>3）拥塞发生</strong>，<strong>4）快速恢复</strong>。这四个算法不是一天都搞出来的，这个四算法的发展经历了很多时间，到今天都还在优化中。 备注:</p>
<ul>
<li>1988 年，TCP-Tahoe 提出了 1）慢启动，2）拥塞避免，3）拥塞发生时的快速重传</li>
<li>1990 年，TCP Reno 在 Tahoe 的基础上增加了 4）快速恢复</li>
</ul>
<h2 id="慢热启动算法-–-Slow-Start"><a href="#慢热启动算法-–-Slow-Start" class="headerlink" title="慢热启动算法 – Slow Start"></a>慢热启动算法 – Slow Start</h2><p>首先，我们来看一下 TCP 的慢热启动。慢启动的意思是，刚刚加入网络的连接，一点一点地提速，不要一上来就像那些特权车一样霸道地把路占满。新同学上高速还是要慢一点，不要把已经在高速上的秩序给搞乱了。<br>慢启动的算法如下(cwnd 全称 Congestion Window)：<br>1）连接建好的开始先初始化 cwnd = 1，表明可以传一个 MSS 大小的数据。<br>2）每当收到一个 ACK，cwnd++; 呈线性上升<br>3）每当过了一个 RTT，cwnd = cwnd*2; 呈指数让升<br>4）还有一个 ssthresh（slow start threshold），是一个上限，当 cwnd &gt;= ssthresh 时，就会进入“拥塞避免算法”（后面会说这个算法）<br>所以，我们可以看到，如果网速很快的话，ACK 也会返回得快，RTT 也会短，那么，这个慢启动就一点也不慢。下图说明了这个过程。<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619360710925-01185c73-f485-4be8-98f0-5fe748057a7c.jpeg#clientId=u6f576584-d24a-4&from=paste&height=194&id=ufd70501a&margin=%5Bobject%20Object%5D&originHeight=388&originWidth=662&originalType=url&status=done&style=none&taskId=u8b627dde-5740-4010-941a-b5fd27fba47&width=331"><br>这里，我需要提一下的是一篇 Google 的论文《<a target="_blank" rel="noopener" href="http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36640.pdf">An Argument for Increasing TCP’s Initial Congestion Window</a>》Linux 3.0 后采用了这篇论文的建议——把 cwnd 初始化成了 10 个 MSS。而 Linux 3.0 以前，比如 2.6，Linux 采用了<a target="_blank" rel="noopener" href="http://www.rfc-editor.org/rfc/rfc3390.txt">RFC3390</a>，cwnd 是跟 MSS 的值来变的，如果 MSS&lt; 1095，则 cwnd = 4；如果 MSS&gt;2190，则 cwnd=2；其它情况下，则是 3。</p>
<h2 id="拥塞避免算法-–-Congestion-Avoidance"><a href="#拥塞避免算法-–-Congestion-Avoidance" class="headerlink" title="拥塞避免算法 – Congestion Avoidance"></a>拥塞避免算法 – Congestion Avoidance</h2><p>前面说过，还有一个 ssthresh（slow start threshold），是一个上限，当 cwnd &gt;= ssthresh 时，就会进入“拥塞避免算法”。一般来说 ssthresh 的值是 65535，单位是字节，当 cwnd 达到这个值时后，算法如下：<br>1）收到一个 ACK 时，cwnd = cwnd + 1/cwnd<br>2）当每过一个 RTT 时，cwnd = cwnd + 1<br>这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。很明显，是一个线性上升的算法。</p>
<h2 id="拥塞状态时的算法"><a href="#拥塞状态时的算法" class="headerlink" title="拥塞状态时的算法"></a>拥塞状态时的算法</h2><p>前面我们说过，当丢包的时候，会有两种情况：<br>1）等到 RTO 超时，重传数据包。TCP 认为这种情况太糟糕，反应也很强烈。</p>
<ul>
<li>sshthresh =  cwnd /2</li>
<li>cwnd 重置为 1</li>
<li>进入慢启动过程</li>
</ul>
<p>2）Fast Retransmit 算法，也就是在收到 3 个 duplicate ACK 时就开启重传，而不用等到 RTO 超时。</p>
<ul>
<li>TCP Tahoe 的实现和 RTO 超时一样。</li>
<li>TCP Reno 的实现是：<ul>
<li>cwnd = cwnd /2</li>
<li>sshthresh = cwnd</li>
<li>进入快速恢复算法——Fast Recovery</li>
</ul>
</li>
</ul>
<p>上面我们可以看到 RTO 超时后，sshthresh 会变成 cwnd 的一半，这意味着，如果 cwnd&lt;=sshthresh 时出现的丢包，那么 TCP 的 sshthresh 就会减了一半，然后等 cwnd 又很快地以指数级增涨爬到这个地方时，就会成慢慢的线性增涨。我们可以看到，TCP 是怎么通过这种强烈地震荡快速而小心得找到网站流量的平衡点的。</p>
<h2 id="快速恢复算法-–-Fast-Recovery"><a href="#快速恢复算法-–-Fast-Recovery" class="headerlink" title="快速恢复算法 – Fast Recovery"></a>快速恢复算法 – Fast Recovery</h2><p><strong>TCP Reno</strong><br>这个算法定义在<a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc5681">RFC5681</a>。快速重传和快速恢复算法一般同时使用。快速恢复算法是认为，你还有 3 个 Duplicated Acks 说明网络也不那么糟糕，所以没有必要像 RTO 超时那么强烈。注意，正如前面所说，进入 Fast Recovery 之前，cwnd 和 sshthresh 已被更新：</p>
<ul>
<li>cwnd = cwnd /2</li>
<li>sshthresh = cwnd</li>
</ul>
<p>然后，真正的 Fast Recovery 算法如下：</p>
<ul>
<li>cwnd = sshthresh  + 3 * MSS （3 的意思是确认有 3 个数据包被收到了）</li>
<li>重传 Duplicated ACKs 指定的数据包</li>
<li>如果再收到 duplicated Acks，那么 cwnd = cwnd +1</li>
<li>如果收到了新的 Ack，那么，cwnd = sshthresh ，然后就进入了拥塞避免的算法了。</li>
</ul>
<p>如果你仔细思考一下上面的这个算法，你就会知道，<strong>上面这个算法也有问题，那就是——它依赖于 3 个重复的 Acks</strong>。注意，3 个重复的 Acks 并不代表只丢了一个数据包，很有可能是丢了好多包。但这个算法只会重传一个，而剩下的那些包只能等到 RTO 超时，于是，进入了恶梦模式——超时一个窗口就减半一下，多个超时会超成 TCP 的传输速度呈级数下降，而且也不会触发 Fast Recovery 算法了。<br>通常来说，正如我们前面所说的，SACK 或 D-SACK 的方法可以让 Fast Recovery 或 Sender 在做决定时更聪明一些，但是并不是所有的 TCP 的实现都支持 SACK（SACK 需要两端都支持），所以，需要一个没有 SACK 的解决方案。而通过 SACK 进行拥塞控制的算法是 FACK（后面会讲）<br><strong>TCP New Reno</strong><br>于是，1995 年，TCP New Reno（参见  <a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc6582">RFC 6582</a> ）算法提出来，主要就是在没有 SACK 的支持下改进 Fast Recovery 算法的——</p>
<ul>
<li>当 sender 这边收到了 3 个 Duplicated Acks，进入 Fast Retransimit 模式，开发重传重复 Acks 指示的那个包。如果只有这一个包丢了，那么，重传这个包后回来的 Ack 会把整个已经被 sender 传输出去的数据 ack 回来。如果没有的话，说明有多个包丢了。我们叫这个 ACK 为 Partial ACK。</li>
<li>一旦 Sender 这边发现了 Partial ACK 出现，那么，sender 就可以推理出来有多个包被丢了，于是乎继续重传 sliding window 里未被 ack 的第一个包。直到再也收不到了 Partial Ack，才真正结束 Fast Recovery 这个过程</li>
</ul>
<p>我们可以看到，这个“Fast Recovery 的变更”是一个非常激进的玩法，他同时延长了 Fast Retransmit 和 Fast Recovery 的过程。</p>
<h2 id="算法示意图"><a href="#算法示意图" class="headerlink" title="算法示意图"></a>算法示意图</h2><p>下面我们来看一个简单的图示以同时看一下上面的各种算法的样子：<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619360711007-954db5a2-33c1-46b8-88d1-876b1ba3bc41.jpeg#clientId=u6f576584-d24a-4&from=paste&height=180&id=u228560e9&margin=%5Bobject%20Object%5D&originHeight=359&originWidth=1024&originalType=url&status=done&style=none&taskId=u8a97b8d9-dad4-4106-9e6b-660badfae83&width=512"></p>
<h2 id="FACK-算法"><a href="#FACK-算法" class="headerlink" title="FACK 算法"></a>FACK 算法</h2><p>FACK 全称 Forward Acknowledgment 算法，论文地址在这里（PDF）<a target="_blank" rel="noopener" href="http://conferences.sigcomm.org/sigcomm/1996/papers/mathis.pdf">Forward Acknowledgement: Refining TCP Congestion Control</a>这个算法是其于 SACK 的，前面我们说过 SACK 是使用了 TCP 扩展字段 Ack 了有哪些数据收到，哪些数据没有收到，他比 Fast Retransmit 的 3 个 duplicated acks 好处在于，前者只知道有包丢了，不知道是一个还是多个，而 SACK 可以准确的知道有哪些包丢了。 所以，SACK 可以让发送端这边在重传过程中，把那些丢掉的包重传，而不是一个一个的传，但这样的一来，如果重传的包数据比较多的话，又会导致本来就很忙的网络就更忙了。所以，FACK 用来做重传过程中的拥塞流控。</p>
<ul>
<li>这个算法会把 SACK 中最大的 Sequence Number 保存在<strong>snd.fack</strong>这个变量中，snd.fack 的更新由 ack 带秋，如果网络一切安好则和 snd.una 一样（snd.una 就是还没有收到 ack 的地方，也就是前面 sliding window 里的 category #2 的第一个地方）</li>
<li>然后定义一个<strong>awnd = snd.nxt – snd.fack</strong>（snd.nxt 指向发送端 sliding window 中正在要被发送的地方——前面 sliding windows 图示的 category#3 第一个位置），这样 awnd 的意思就是在网络上的数据。（所谓 awnd 意为：actual quantity of data outstanding in the network）</li>
<li>如果需要重传数据，那么，<strong>awnd = snd.nxt – snd.fack + retran_data</strong>，也就是说，awnd 是传出去的数据 + 重传的数据。</li>
<li>然后触发 Fast Recovery 的条件是： (** ( snd.fack – snd.una ) &gt; (3*MSS) **) || (dupacks == 3) ) 。这样一来，就不需要等到 3 个 duplicated acks 才重传，而是只要 sack 中的最大的一个数据和 ack 的数据比较长了（3 个 MSS），那就触发重传。在整个重传过程中 cwnd 不变。直到当第一次丢包的 snd.nxt&lt;=snd.una（也就是重传的数据都被确认了），然后进来拥塞避免机制——cwnd 线性上涨。</li>
</ul>
<p>我们可以看到如果没有 FACK 在，那么在丢包比较多的情况下，原来保守的算法会低估了需要使用的 window 的大小，而需要几个 RTT 的时间才会完成恢复，而 FACK 会比较激进地来干这事。 但是，FACK 如果在一个网络包会被 reordering 的网络里会有很大的问题。</p>
<h1 id="其它拥塞控制算法简介"><a href="#其它拥塞控制算法简介" class="headerlink" title="其它拥塞控制算法简介"></a>其它拥塞控制算法简介</h1><h2 id="TCP-Vegas-拥塞控制算法"><a href="#TCP-Vegas-拥塞控制算法" class="headerlink" title="TCP Vegas 拥塞控制算法"></a>TCP Vegas 拥塞控制算法</h2><p>这个算法 1994 年被提出，它主要对 TCP Reno 做了些修改。这个算法通过对 RTT 的非常重的监控来计算一个基准 RTT。然后通过这个基准 RTT 来估计当前的网络实际带宽，如果实际带宽比我们的期望的带宽要小或是要多的活，那么就开始线性地减少或增加 cwnd 的大小。如果这个计算出来的 RTT 大于了 Timeout 后，那么，不等 ack 超时就直接重传。（Vegas 的核心思想是用 RTT 的值来影响拥塞窗口，而不是通过丢包） 这个算法的论文是《<a target="_blank" rel="noopener" href="http://www.cs.cmu.edu/~srini/15-744/F02/readings/BP95.pdf">TCP Vegas: End to End Congestion Avoidance on a Global Internet</a>》这篇论文给了 Vegas 和 New Reno 的对比：<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619360711090-1050cc4c-22d7-4ff9-a5e0-a357a2dbb4aa.jpeg#clientId=u6f576584-d24a-4&from=paste&height=278&id=u74444425&margin=%5Bobject%20Object%5D&originHeight=555&originWidth=1024&originalType=url&status=done&style=none&taskId=ub3b4ce85-9fe7-411e-8b38-8ce61da93c8&width=512"><br>关于这个算法实现，你可以参看 Linux 源码：<a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/net/ipv4/tcp_vegas.h">/net/ipv4/tcp_vegas.h</a>， <a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/net/ipv4/tcp_vegas.c">/net/ipv4/tcp_vegas.c</a></p>
<h2 id="HSTCP-High-Speed-TCP-算法"><a href="#HSTCP-High-Speed-TCP-算法" class="headerlink" title="HSTCP(High Speed TCP) 算法"></a>HSTCP(High Speed TCP) 算法</h2><p>这个算法来自<a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc3649">RFC 3649</a>（<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/HSTCP">Wikipedia 词条</a>）。其对最基础的算法进行了更改，他使得 Congestion Window 涨得快，减得慢。其中：</p>
<ul>
<li>拥塞避免时的窗口增长方式： cwnd = cwnd + α(cwnd) / cwnd</li>
<li>丢包后窗口下降方式：cwnd = (1- β(cwnd))*cwnd</li>
</ul>
<p>注：α(cwnd)和 β(cwnd)都是函数，如果你要让他们和标准的 TCP 一样，那么让 α(cwnd)=1，β(cwnd)=0.5 就可以了。 对于 α(cwnd)和 β(cwnd)的值是个动态的变换的东西。 关于这个算法的实现，你可以参看 Linux 源码：<a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/net/ipv4/tcp_highspeed.c">/net/ipv4/tcp_highspeed.c</a></p>
<h2 id="TCP-BIC-算法"><a href="#TCP-BIC-算法" class="headerlink" title="TCP BIC 算法"></a>TCP BIC 算法</h2><p>2004 年，产内出 BIC 算法。现在你还可以查得到相关的新闻《Google：<a target="_blank" rel="noopener" href="https://www.google.com/search?lr=lang_zh-CN%7Clang_zh-TW&newwindow=1&biw=1366&bih=597&tbs=lr:lang_1zh-CN%7Clang_1zh-TW&q=%E7%BE%8E%E7%A7%91%E5%AD%A6%E5%AE%B6%E7%A0%94%E5%8F%91BIC-TCP%E5%8D%8F%E8%AE%AE+%E9%80%9F%E5%BA%A6%E6%98%AFDSL%E5%85%AD%E5%8D%83%E5%80%8D&oq=%E7%BE%8E%E7%A7%91%E5%AD%A6%E5%AE%B6%E7%A0%94%E5%8F%91BIC-TCP%E5%8D%8F%E8%AE%AE+%E9%80%9F%E5%BA%A6%E6%98%AFDSL%E5%85%AD%E5%8D%83%E5%80%8D">美科学家研发 BIC-TCP 协议 速度是 DSL 六千倍</a>》 BIC 全称<a target="_blank" rel="noopener" href="http://research.csc.ncsu.edu/netsrv/?q=content/bic-and-cubic">Binary Increase Congestion control</a>，在 Linux 2.6.8 中是默认拥塞控制算法。BIC 的发明者发这么多的拥塞控制算法都在努力找一个合适的 cwnd – Congestion Window，而且 BIC-TCP 的提出者们看穿了事情的本质，其实这就是一个搜索的过程，所以 BIC 这个算法主要用的是 Binary Search——二分查找来干这个事。 关于这个算法实现，你可以参看 Linux 源码：<a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/net/ipv4/tcp_bic.c">/net/ipv4/tcp_bic.c</a></p>
<h2 id="TCP-WestWood-算法"><a href="#TCP-WestWood-算法" class="headerlink" title="TCP WestWood 算法"></a>TCP WestWood 算法</h2><p>westwood 采用和 Reno 相同的慢启动算法、拥塞避免算法。westwood 的主要改进方面：在发送端做带宽估计，当探测到丢包时，根据带宽值来设置拥塞窗口、慢启动阈值。那么，这个算法是怎么测量带宽的？每个 RTT 时间，会测量一次带宽，测量带宽的公式很简单，就是这段 RTT 内成功被 ack 了多少字节。因为，这个带宽和用 RTT 计算 RTO 一样，也是需要从每个样本来平滑到一个值的——也是用一个加权移平均的公式。 另外，我们知道，如果一个网络的带宽是每秒可以发送 X 个字节，而 RTT 是一个数据发出去后确认需要的时候，所以，X _ RTT 应该是我们缓冲区大小。所以，在这个算法中，ssthresh 的值就是 est_BD _ min-RTT(最小的 RTT 值)，如果丢包是 Duplicated ACKs 引起的，那么如果 cwnd &gt; ssthresh，则 cwin = ssthresh。如果是 RTO 引起的，cwnd = 1，进入慢启动。   关于这个算法实现，你可以参看 Linux 源码： <a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/net/ipv4/tcp_westwood.c">/net/ipv4/tcp_westwood.c</a></p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>更多的算法，你可以从 Wikipedia 的  <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/TCP_congestion-avoidance_algorithm">TCP Congestion Avoidance Algorithm</a>词条中找到相关的线索</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>好了，到这里我想可以结束了，TCP 发展到今天，里面的东西可以写上好几本书。本文主要目的，还是把你带入这些古典的基础技术和知识中，希望本文能让你了解 TCP，更希望本文能让你开始有学习这些基础或底层知识的兴趣和信心。<br>当然，TCP 东西太多了，不同的人可能有不同的理解，而且本文可能也会有一些荒谬之言甚至错误，还希望得到您的反馈和批评。<br>（全文完）<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619360711160-b492d96c-152c-4165-bf3d-c36362fc2359.jpeg#clientId=u6f576584-d24a-4&from=paste&height=129&id=ue1e91874&margin=%5Bobject%20Object%5D&originHeight=258&originWidth=258&originalType=url&status=done&style=none&taskId=u14a5554b-c21f-4e12-afa9-09d00a50397&width=129"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619360711264-17fc4846-2b4e-45b6-9f8b-9c594ed37469.jpeg#clientId=u6f576584-d24a-4&from=paste&height=129&id=u6b4d50ab&margin=%5Bobject%20Object%5D&originHeight=258&originWidth=258&originalType=url&status=done&style=none&taskId=u906dd6ed-944c-48a7-9251-a32a7d166f8&width=129">关注 CoolShell 微信公众账号和微信小程序</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Adam Blog</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">64</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Adam Blog</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
