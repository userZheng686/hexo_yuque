<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Adam">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Adam">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Adam Blog">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Adam</title>
  <meta name="referrer" content="no-referrer" />
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Adam</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/24/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/24/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-24 18:50:37" itemprop="dateCreated datePublished" datetime="2021-04-24T18:50:37+08:00">2021-04-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/24/yuque/promise_async_generator%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/24/yuque/promise_async_generator%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">promise_async_generator原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-24 18:48:01 / 修改时间：18:51:14" itemprop="dateCreated datePublished" datetime="2021-04-24T18:48:01+08:00">2021-04-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>笔者刚接触<code>async/await</code>时，就被其暂停执行的特性吸引了，心想在没有原生 API 支持的情况下，await 居然能挂起当前方法，实现暂停执行，我感到十分好奇。好奇心驱使我一层一层剥开有关 JS 异步编程的一切。阅读完本文，读者应该能够了解：</p>
<ol>
<li><code>Promise</code>的实现原理</li>
<li><code>async/await</code>的实现原理</li>
<li><code>Generator</code>的实现原理</li>
</ol>
<h1 id="Promise-实现"><a href="#Promise-实现" class="headerlink" title="Promise 实现"></a>Promise 实现</h1><p>在成文过程中，笔者查阅了很多讲解 Promise 实现的文章，但感觉大多文章都很难称得上条理清晰，有的上来就放大段 Promise 规范翻译，有的在 Promise 基础使用上浪费篇幅，又或者把一个简单的东西长篇大论，过度讲解，我推荐头铁的同学直接拉到本章小结看最终实现，结合着注释直接啃代码也能理解十之八九</p>
<p>回归正题，文章开头我们先点一下 Promise 为我们解决了什么问题：在传统的异步编程中，如果异步之间存在依赖关系，我们就需要通过层层嵌套回调来满足这种依赖，如果嵌套层数过多，可读性和可维护性都变得很差，产生所谓“回调地狱”，而 Promise 将回调嵌套改为链式调用，增加可读性和可维护性。下面我们就来一步步实现一个 Promise：</p>
<h2 id="1-观察者模式"><a href="#1-观察者模式" class="headerlink" title="1. 观察者模式"></a>1. 观察者模式</h2><p>我们先来看一个最简单的 Promise 使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const p1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        resolve(&#39;result&#39;)</span><br><span class="line">    &#125;,</span><br><span class="line">    1000);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(res &#x3D;&gt; console.log(res), err &#x3D;&gt; console.log(err))</span><br></pre></td></tr></table></figure>

<p>观察这个例子，我们分析 Promise 的调用流程：</p>
<ul>
<li><code>Promise</code>的构造方法接收一个<code>executor()</code>，在<code>new Promise()</code>时就立刻执行这个 executor 回调</li>
<li><code>executor()</code>内部的异步任务被放入宏/微任务队列，等待执行</li>
<li><code>then()</code>被执行，收集成功/失败回调，放入成功/失败队列</li>
<li><code>executor()</code>的异步任务被执行，触发<code>resolve/reject</code>，从成功/失败队列中取出回调依次执行</li>
</ul>
<p>其实熟悉设计模式的同学，很容易就能意识到这是个<strong>观察者模式</strong>，这种<code>收集依赖 -&gt; 触发通知 -&gt; 取出依赖执行</code> 的方式，被广泛运用于观察者模式的实现，在 Promise 里，执行顺序是<code>then收集依赖 -&gt; 异步触发resolve -&gt; resolve执行依赖</code>。依此，我们可以勾勒出 Promise 的大致形状：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class MyPromise &#123;</span><br><span class="line">  &#x2F;&#x2F; 构造方法接收一个回调</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    this._resolveQueue &#x3D; []    &#x2F;&#x2F; then收集的执行成功的回调队列</span><br><span class="line">    this._rejectQueue &#x3D; []     &#x2F;&#x2F; then收集的执行失败的回调队列</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 由于resolve&#x2F;reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue</span><br><span class="line">    let _resolve &#x3D; (val) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 从成功队列里取出回调依次执行</span><br><span class="line">      while(this._resolveQueue.length) &#123;</span><br><span class="line">        const callback &#x3D; this._resolveQueue.shift()</span><br><span class="line">        callback(val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 实现同resolve</span><br><span class="line">    let _reject &#x3D; (val) &#x3D;&gt; &#123;</span><br><span class="line">      while(this._rejectQueue.length) &#123;</span><br><span class="line">        const callback &#x3D; this._rejectQueue.shift()</span><br><span class="line">        callback(val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; new Promise()时立即执行executor,并传入resolve和reject</span><br><span class="line">    executor(_resolve, _reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; then方法,接收一个成功的回调和一个失败的回调，并push进对应队列</span><br><span class="line">  then(resolveFn, rejectFn) &#123;</span><br><span class="line">    this._resolveQueue.push(resolveFn)</span><br><span class="line">    this._rejectQueue.push(rejectFn)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写完代码我们可以测试一下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const p1 &#x3D; new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    resolve(&#39;result&#39;)</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(res &#x3D;&gt; console.log(res))</span><br><span class="line">&#x2F;&#x2F;一秒后输出result</span><br></pre></td></tr></table></figure>

<p>我们运用观察者模式简单的实现了一下<code>then</code>和<code>resolve</code>，使我们能够在 then 方法的回调里取得异步操作的返回值，但我们这个 Promise 离最终实现还有很长的距离，下面我们来一步步补充这个 Promise：</p>
<h2 id="2-Promise-A-规范"><a href="#2-Promise-A-规范" class="headerlink" title="2. Promise A+规范"></a>2. Promise A+规范</h2><p>上面我们已经简单地实现了一个超低配版 Promise，但我们会看到很多文章和我们写的不一样，他们的 Promise 实现中还引入了各种状态控制，这是由于 ES6 的 Promise 实现需要遵循<a target="_blank" rel="noopener" href="https://promisesaplus.com/">Promise/A+规范</a>，是规范对 Promise 的状态控制做了要求。Promise/A+的规范比较长，这里只总结两条核心规则：</p>
<blockquote>
</blockquote>
<blockquote>
<ol>
<li>Promise 本质是一个状态机，且状态只能为以下三种：<code>Pending（等待态）</code>、<code>Fulfilled（执行态）</code>、<code>Rejected（拒绝态）</code>，状态的变更是单向的，只能从 Pending -&gt; Fulfilled 或 Pending -&gt; Rejected，状态变更不可逆</li>
<li><code>then方法</code>接收两个可选参数，分别对应状态改变时触发的回调。then 方法返回一个 promise。then 方法可以被同一个 promise 调用多次。</li>
</ol>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/21377586/1619261340785-d4ebe2d3-dbff-4710-96d6-bbc7abc32282.webp#clientId=u0787e3d2-71b0-4&from=drop&height=174&id=u478ca980&margin=%5Bobject%20Object%5D&name=1.webp&originHeight=174&originWidth=318&originalType=binary&size=6028&status=done&style=none&taskId=uf7f1c65c-14e0-4750-8395-a02cb223112&width=318" alt="1.webp"></p>
<p>根据规范，我们补充一下 Promise 的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Promise&#x2F;A+规范的三种状态</span><br><span class="line">const PENDING &#x3D; &#39;pending&#39;</span><br><span class="line">const FULFILLED &#x3D; &#39;fulfilled&#39;</span><br><span class="line">const REJECTED &#x3D; &#39;rejected&#39;</span><br><span class="line"></span><br><span class="line">class MyPromise &#123;</span><br><span class="line">  &#x2F;&#x2F; 构造方法接收一个回调</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    this._status &#x3D; PENDING     &#x2F;&#x2F; Promise状态</span><br><span class="line">    this._resolveQueue &#x3D; []    &#x2F;&#x2F; 成功队列, resolve时触发</span><br><span class="line">    this._rejectQueue &#x3D; []     &#x2F;&#x2F; 失败队列, reject时触发</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 由于resolve&#x2F;reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue</span><br><span class="line">    let _resolve &#x3D; (val) &#x3D;&gt; &#123;</span><br><span class="line">      if(this._status !&#x3D;&#x3D; PENDING) return   &#x2F;&#x2F; 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span><br><span class="line">      this._status &#x3D; FULFILLED              &#x2F;&#x2F; 变更状态</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 这里之所以使用一个队列来储存回调,是为了实现规范要求的 &quot;then 方法可以被同一个 promise 调用多次&quot;</span><br><span class="line">      &#x2F;&#x2F; 如果使用一个变量而非队列来储存回调,那么即使多次p1.then()也只会执行一次回调</span><br><span class="line">      while(this._resolveQueue.length) &#123;</span><br><span class="line">        const callback &#x3D; this._resolveQueue.shift()</span><br><span class="line">        callback(val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 实现同resolve</span><br><span class="line">    let _reject &#x3D; (val) &#x3D;&gt; &#123;</span><br><span class="line">      if(this._status !&#x3D;&#x3D; PENDING) return   &#x2F;&#x2F; 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span><br><span class="line">      this._status &#x3D; REJECTED               &#x2F;&#x2F; 变更状态</span><br><span class="line">      while(this._rejectQueue.length) &#123;</span><br><span class="line">        const callback &#x3D; this._rejectQueue.shift()</span><br><span class="line">        callback(val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; new Promise()时立即执行executor,并传入resolve和reject</span><br><span class="line">    executor(_resolve, _reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; then方法,接收一个成功的回调和一个失败的回调</span><br><span class="line">  then(resolveFn, rejectFn) &#123;</span><br><span class="line">    this._resolveQueue.push(resolveFn)</span><br><span class="line">    this._rejectQueue.push(rejectFn)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-then-的链式调用"><a href="#3-then-的链式调用" class="headerlink" title="3. then 的链式调用"></a>3. then 的链式调用</h2><p>补充完规范，我们接着来实现链式调用，这是 Promise 实现的重点和难点，我们先来看一下 then 是如何链式调用的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const p1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(1)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1</span><br><span class="line">  .then(res &#x3D;&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">    &#x2F;&#x2F;then回调中可以return一个Promise</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        resolve(2)</span><br><span class="line">      &#125;, 1000);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res &#x3D;&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">    &#x2F;&#x2F;then回调中也可以return一个值</span><br><span class="line">    return 3</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res &#x3D;&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>我们思考一下如何实现这种链式调用：</p>
<ol>
<li>显然<code>.then()</code>需要返回一个 Promise，这样才能找到 then 方法，所以我们会把 then 方法的返回值包装成 Promise。</li>
<li><code>.then()</code>的回调需要拿到上一个<code>.then()</code>的返回值</li>
<li><code>.then()</code>的回调需要顺序执行，以上面这段代码为例，虽然中间 return 了一个 Promise，但执行顺序仍要保证是 1-&gt;2-&gt;3。我们要等待当前 Promise 状态变更后，再执行下一个 then 收集的回调，这就要求我们对 then 的返回值分类讨论</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; then方法</span><br><span class="line">then(resolveFn, rejectFn) &#123;</span><br><span class="line">  &#x2F;&#x2F;return一个新的promise</span><br><span class="line">  return new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span><br><span class="line">    const fulfilledFn &#x3D; value &#x3D;&gt; &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        &#x2F;&#x2F;执行第一个(当前的)Promise的成功回调,并获取返回值</span><br><span class="line">        let x &#x3D; resolveFn(value)</span><br><span class="line">        &#x2F;&#x2F;分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span><br><span class="line">        &#x2F;&#x2F;这里resolve之后，就能被下一个.then()的回调获取到返回值，从而实现链式调用</span><br><span class="line">        x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">      &#125; catch (error) &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;把后续then收集的依赖都push进当前Promise的成功回调队列中(_rejectQueue), 这是为了保证顺序调用</span><br><span class="line">    this._resolveQueue.push(fulfilledFn)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;reject同理</span><br><span class="line">    const rejectedFn  &#x3D; error &#x3D;&gt; &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        let x &#x3D; rejectFn(error)</span><br><span class="line">        x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">      &#125; catch (error) &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    this._rejectQueue.push(rejectedFn)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们就能测试一下链式调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const p1 &#x3D; new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    resolve(1)</span><br><span class="line">  &#125;, 500);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1</span><br><span class="line">  .then(res &#x3D;&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">    return 2</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res &#x3D;&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">    return 3</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res &#x3D;&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出 1 2 3</span><br></pre></td></tr></table></figure>

<h2 id="4-值穿透-amp-状态已变更的情况"><a href="#4-值穿透-amp-状态已变更的情况" class="headerlink" title="4.值穿透 &amp; 状态已变更的情况"></a>4.值穿透 &amp; 状态已变更的情况</h2><p>我们已经初步完成了链式调用，但是对于 then() 方法，我们还要两个细节需要处理一下</p>
<ol>
<li><strong>值穿透</strong>：根据规范，如果 then() 接收的参数不是 function，那么我们应该忽略它。如果没有忽略，当 then()回调不为 function 时将会抛出异常，导致链式调用中断</li>
<li><strong>处理状态为 resolve/reject 的情况</strong>：其实我们上边 then() 的写法是对应状态为<code>padding</code>的情况，但是有些时候，resolve/reject 在 then() 之前就被执行（比如<code>Promise.resolve().then()</code>），如果这个时候还把 then()回调 push 进 resolve/reject 的执行队列里，那么回调将不会被执行，因此对于状态已经变为<code>fulfilled</code>或<code>rejected</code>的情况，我们直接执行 then 回调：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; then方法,接收一个成功的回调和一个失败的回调</span><br><span class="line">  then(resolveFn, rejectFn) &#123;</span><br><span class="line">    &#x2F;&#x2F; 根据规范，如果then的参数不是function，则我们需要忽略它, 让链式调用继续往下执行</span><br><span class="line">    typeof resolveFn !&#x3D;&#x3D; &#39;function&#39; ? resolveFn &#x3D; value &#x3D;&gt; value : null</span><br><span class="line">    typeof rejectFn !&#x3D;&#x3D; &#39;function&#39; ? rejectFn &#x3D; reason &#x3D;&gt; &#123;</span><br><span class="line">      throw new Error(reason instanceof Error? reason.message:reason);</span><br><span class="line">    &#125; : null</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; return一个新的promise</span><br><span class="line">    return new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span><br><span class="line">      const fulfilledFn &#x3D; value &#x3D;&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          &#x2F;&#x2F; 执行第一个(当前的)Promise的成功回调,并获取返回值</span><br><span class="line">          let x &#x3D; resolveFn(value)</span><br><span class="line">          &#x2F;&#x2F; 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span><br><span class="line">          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; reject同理</span><br><span class="line">      const rejectedFn  &#x3D; error &#x3D;&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          let x &#x3D; rejectFn(error)</span><br><span class="line">          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      switch (this._status) &#123;</span><br><span class="line">        &#x2F;&#x2F; 当状态为pending时,把then回调push进resolve&#x2F;reject执行队列,等待执行</span><br><span class="line">        case PENDING:</span><br><span class="line">          this._resolveQueue.push(fulfilledFn)</span><br><span class="line">          this._rejectQueue.push(rejectedFn)</span><br><span class="line">          break;</span><br><span class="line">        &#x2F;&#x2F; 当状态已经变为resolve&#x2F;reject时,直接执行then回调</span><br><span class="line">        case FULFILLED:</span><br><span class="line">          fulfilledFn(this._value)    &#x2F;&#x2F; this._value是上一个then回调return的值(见完整版代码)</span><br><span class="line">          break;</span><br><span class="line">        case REJECTED:</span><br><span class="line">          rejectedFn(this._value)</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-兼容同步任务"><a href="#5-兼容同步任务" class="headerlink" title="5.兼容同步任务"></a>5.兼容同步任务</h2><p>完成了 then 的链式调用以后，我们再处理一个前边的细节，然后放出完整代码。上文我们说过，Promise 的执行顺序是<code>new Promise -&gt; then()收集回调 -&gt; resolve/reject执行回调</code>，这一顺序是建立在<strong>executor 是异步任务</strong>的前提上的，如果 executor 是一个同步任务，那么顺序就会变成<code>new Promise -&gt; resolve/reject执行回调 -&gt; then()收集回调</code>，resolve 的执行跑到 then 之前去了，为了兼容这种情况，我们给<code>resolve/reject</code>执行回调的操作包一个 setTimeout，让它异步执行。</p>
<blockquote>
<p>这里插一句，有关这个 setTimeout，其实还有一番学问。虽然规范没有要求回调应该被放进宏任务队列还是微任务队列，但其实 Promise 的默认实现是放进了微任务队列，我们的实现（包括大多数 Promise 手动实现和 polyfill 的转化）都是使用 setTimeout 放入了宏任务队列（当然我们也可以用 MutationObserver 模拟微任务）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Promise&#x2F;A+规定的三种状态</span><br><span class="line">const PENDING &#x3D; &#39;pending&#39;</span><br><span class="line">const FULFILLED &#x3D; &#39;fulfilled&#39;</span><br><span class="line">const REJECTED &#x3D; &#39;rejected&#39;</span><br><span class="line"></span><br><span class="line">class MyPromise &#123;</span><br><span class="line">  &#x2F;&#x2F; 构造方法接收一个回调</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    this._status &#x3D; PENDING     &#x2F;&#x2F; Promise状态</span><br><span class="line">    this._value &#x3D; undefined    &#x2F;&#x2F; 储存then回调return的值</span><br><span class="line">    this._resolveQueue &#x3D; []    &#x2F;&#x2F; 成功队列, resolve时触发</span><br><span class="line">    this._rejectQueue &#x3D; []     &#x2F;&#x2F; 失败队列, reject时触发</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 由于resolve&#x2F;reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue</span><br><span class="line">    let _resolve &#x3D; (val) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F;把resolve执行回调的操作封装成一个函数,放进setTimeout里,以兼容executor是同步代码的情况</span><br><span class="line">      const run &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        if(this._status !&#x3D;&#x3D; PENDING) return   &#x2F;&#x2F; 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span><br><span class="line">        this._status &#x3D; FULFILLED              &#x2F;&#x2F; 变更状态</span><br><span class="line">        this._value &#x3D; val                     &#x2F;&#x2F; 储存当前value</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 这里之所以使用一个队列来储存回调,是为了实现规范要求的 &quot;then 方法可以被同一个 promise 调用多次&quot;</span><br><span class="line">        &#x2F;&#x2F; 如果使用一个变量而非队列来储存回调,那么即使多次p1.then()也只会执行一次回调</span><br><span class="line">        while(this._resolveQueue.length) &#123;</span><br><span class="line">          const callback &#x3D; this._resolveQueue.shift()</span><br><span class="line">          callback(val)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      setTimeout(run)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 实现同resolve</span><br><span class="line">    let _reject &#x3D; (val) &#x3D;&gt; &#123;</span><br><span class="line">      const run &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        if(this._status !&#x3D;&#x3D; PENDING) return   &#x2F;&#x2F; 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span><br><span class="line">        this._status &#x3D; REJECTED               &#x2F;&#x2F; 变更状态</span><br><span class="line">        this._value &#x3D; val                     &#x2F;&#x2F; 储存当前value</span><br><span class="line">        while(this._rejectQueue.length) &#123;</span><br><span class="line">          const callback &#x3D; this._rejectQueue.shift()</span><br><span class="line">          callback(val)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      setTimeout(run)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; new Promise()时立即执行executor,并传入resolve和reject</span><br><span class="line">    executor(_resolve, _reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; then方法,接收一个成功的回调和一个失败的回调</span><br><span class="line">  then(resolveFn, rejectFn) &#123;</span><br><span class="line">    &#x2F;&#x2F; 根据规范，如果then的参数不是function，则我们需要忽略它, 让链式调用继续往下执行</span><br><span class="line">    typeof resolveFn !&#x3D;&#x3D; &#39;function&#39; ? resolveFn &#x3D; value &#x3D;&gt; value : null</span><br><span class="line">    typeof rejectFn !&#x3D;&#x3D; &#39;function&#39; ? rejectFn &#x3D; reason &#x3D;&gt; &#123;</span><br><span class="line">      throw new Error(reason instanceof Error? reason.message:reason);</span><br><span class="line">    &#125; : null</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; return一个新的promise</span><br><span class="line">    return new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span><br><span class="line">      const fulfilledFn &#x3D; value &#x3D;&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          &#x2F;&#x2F; 执行第一个(当前的)Promise的成功回调,并获取返回值</span><br><span class="line">          let x &#x3D; resolveFn(value)</span><br><span class="line">          &#x2F;&#x2F; 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span><br><span class="line">          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; reject同理</span><br><span class="line">      const rejectedFn  &#x3D; error &#x3D;&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          let x &#x3D; rejectFn(error)</span><br><span class="line">          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      switch (this._status) &#123;</span><br><span class="line">        &#x2F;&#x2F; 当状态为pending时,把then回调push进resolve&#x2F;reject执行队列,等待执行</span><br><span class="line">        case PENDING:</span><br><span class="line">          this._resolveQueue.push(fulfilledFn)</span><br><span class="line">          this._rejectQueue.push(rejectedFn)</span><br><span class="line">          break;</span><br><span class="line">        &#x2F;&#x2F; 当状态已经变为resolve&#x2F;reject时,直接执行then回调</span><br><span class="line">        case FULFILLED:</span><br><span class="line">          fulfilledFn(this._value)    &#x2F;&#x2F; this._value是上一个then回调return的值(见完整版代码)</span><br><span class="line">          break;</span><br><span class="line">        case REJECTED:</span><br><span class="line">          rejectedFn(this._value)</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们可以测试一下这个 Promise：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const p1 &#x3D; new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(1)          &#x2F;&#x2F;同步executor测试</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1</span><br><span class="line">  .then(res &#x3D;&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">    return 2          &#x2F;&#x2F;链式调用测试</span><br><span class="line">  &#125;)</span><br><span class="line">  .then()             &#x2F;&#x2F;值穿透测试</span><br><span class="line">  .then(res &#x3D;&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">    return new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      resolve(3)      &#x2F;&#x2F;返回Promise测试</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res &#x3D;&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">    throw new Error(&#39;reject测试&#39;)   &#x2F;&#x2F;reject测试</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(() &#x3D;&gt; &#123;&#125;, err &#x3D;&gt; &#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F; 2</span><br><span class="line">&#x2F;&#x2F; 3</span><br><span class="line">&#x2F;&#x2F; Error: reject测试</span><br></pre></td></tr></table></figure>

<p>到这里，我们已经实现了 Promise 的主要功能<code>(｀∀´)Ψ</code>剩下的几个方法都非常简单，我们顺手收拾掉：</p>
<h2 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h2><blockquote>
<p><code>catch()方法</code>返回一个 Promise，并且处理拒绝的情况。它的行为与调用 Promise.prototype.then(undefined, onRejected) 相同。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;catch方法其实就是执行一下then的第二个回调</span><br><span class="line">catch(rejectFn) &#123;</span><br><span class="line">  return this.then(undefined, rejectFn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h2><blockquote>
<p><code>finally()方法</code>返回一个 Promise。在 promise 结束时，无论结果是 fulfilled 或者是 rejected，都会执行指定的回调函数。在 finally 之后，还可以继续 then。并且会将值原封不动的传递给后面的 then</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;finally方法</span><br><span class="line">finally(callback) &#123;</span><br><span class="line">  return this.then(</span><br><span class="line">    value &#x3D;&gt; MyPromise.resolve(callback()).then(() &#x3D;&gt; value),             &#x2F;&#x2F; MyPromise.resolve执行回调,并在then中return结果传递给后面的Promise</span><br><span class="line">    reason &#x3D;&gt; MyPromise.resolve(callback()).then(() &#x3D;&gt; &#123; throw reason &#125;)  &#x2F;&#x2F; reject同理</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS. 有同学问我<code>MyPromise.resolve(callback())</code>的意义，这里补充解释一下：这个写法其实涉及到一个<code>finally()</code>的使用细节，<strong>finally()如果 return 了一个 reject 状态的 Promise，将会改变当前 Promise 的状态</strong>，这个<code>MyPromise.resolve</code>就用于改变 Promise 状态，在 finally()没有返回 reject 态 Promise 或 throw 错误的情况下，去掉<code>MyPromise.resolve</code>也是一样的（欢迎大家向我提问，勘误的过程中也能很好地加深自己对 Promise 的理解，大家可以在各个交流群里直接@我）</p>
<blockquote>
<p>参考资料：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f0b94daf9bf7">对 Promise.prototype.finally() 的粗浅理解</a></p>
</blockquote>
<h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><blockquote>
<p><code>Promise.resolve(value)</code>方法返回一个以给定值解析后的 Promise 对象。如果该值为 promise，返回这个 promise；如果这个值是 thenable（即带有”then” 方法)），返回的 promise 会“跟随”这个 thenable 的对象，采用它的最终状态；否则返回的 promise 将以此值完成。此函数将类 promise 对象的多层嵌套展平。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;静态的resolve方法</span><br><span class="line">static resolve(value) &#123;</span><br><span class="line">  if(value instanceof MyPromise) return value &#x2F;&#x2F; 根据规范, 如果参数是Promise实例, 直接return这个实例</span><br><span class="line">  return new MyPromise(resolve &#x3D;&gt; resolve(value))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><blockquote>
<p><code>Promise.reject()</code>方法返回一个带有拒绝原因的 Promise 对象。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;静态的reject方法</span><br><span class="line">static reject(reason) &#123;</span><br><span class="line">  return new MyPromise((resolve, reject) &#x3D;&gt; reject(reason))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><blockquote>
<p><code>Promise.all(iterable)</code>方法返回一个 Promise 实例，此实例在 iterable 参数内所有的 promise 都“完成（resolved）”或参数中不包含 promise 时回调完成（resolve）；如果参数中 promise 有一个失败（rejected），此实例回调失败（reject），失败原因的是第一个失败 promise 的结果。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;静态的all方法</span><br><span class="line">static all(promiseArr) &#123;</span><br><span class="line">  let index &#x3D; 0</span><br><span class="line">  let result &#x3D; []</span><br><span class="line">  return new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    promiseArr.forEach((p, i) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F;Promise.resolve(p)用于处理传入值不为Promise的情况</span><br><span class="line">      MyPromise.resolve(p).then(</span><br><span class="line">        val &#x3D;&gt; &#123;</span><br><span class="line">          index++</span><br><span class="line">          result[i] &#x3D; val</span><br><span class="line">          &#x2F;&#x2F;所有then执行后, resolve结果</span><br><span class="line">          if(index &#x3D;&#x3D;&#x3D; promiseArr.length) &#123;</span><br><span class="line">            resolve(result)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        err &#x3D;&gt; &#123;</span><br><span class="line">          &#x2F;&#x2F;有一个Promise被reject时，MyPromise的状态变为reject</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><blockquote>
<p><code>Promise.race(iterable)</code>方法返回一个 promise，一旦迭代器中的某个 promise 解决或拒绝，返回的 promise 就会解决或拒绝。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static race(promiseArr) &#123;</span><br><span class="line">  return new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;同时执行Promise,如果有一个Promise的状态发生改变,就变更新MyPromise的状态</span><br><span class="line">    for (let p of promiseArr) &#123;</span><br><span class="line">      MyPromise.resolve(p).then(  &#x2F;&#x2F;Promise.resolve(p)用于处理传入值不为Promise的情况</span><br><span class="line">        value &#x3D;&gt; &#123;</span><br><span class="line">          resolve(value)        &#x2F;&#x2F;注意这个resolve是上边new MyPromise的</span><br><span class="line">        &#125;,</span><br><span class="line">        err &#x3D;&gt; &#123;</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Promise&#x2F;A+规定的三种状态</span><br><span class="line">const PENDING &#x3D; &#39;pending&#39;</span><br><span class="line">const FULFILLED &#x3D; &#39;fulfilled&#39;</span><br><span class="line">const REJECTED &#x3D; &#39;rejected&#39;</span><br><span class="line"></span><br><span class="line">class MyPromise &#123;</span><br><span class="line">  &#x2F;&#x2F; 构造方法接收一个回调</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    this._status &#x3D; PENDING     &#x2F;&#x2F; Promise状态</span><br><span class="line">    this._value &#x3D; undefined    &#x2F;&#x2F; 储存then回调return的值</span><br><span class="line">    this._resolveQueue &#x3D; []    &#x2F;&#x2F; 成功队列, resolve时触发</span><br><span class="line">    this._rejectQueue &#x3D; []     &#x2F;&#x2F; 失败队列, reject时触发</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 由于resolve&#x2F;reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue</span><br><span class="line">    let _resolve &#x3D; (val) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F;把resolve执行回调的操作封装成一个函数,放进setTimeout里,以兼容executor是同步代码的情况</span><br><span class="line">      const run &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        if(this._status !&#x3D;&#x3D; PENDING) return   &#x2F;&#x2F; 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span><br><span class="line">        this._status &#x3D; FULFILLED              &#x2F;&#x2F; 变更状态</span><br><span class="line">        this._value &#x3D; val                     &#x2F;&#x2F; 储存当前value</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 这里之所以使用一个队列来储存回调,是为了实现规范要求的 &quot;then 方法可以被同一个 promise 调用多次&quot;</span><br><span class="line">        &#x2F;&#x2F; 如果使用一个变量而非队列来储存回调,那么即使多次p1.then()也只会执行一次回调</span><br><span class="line">        while(this._resolveQueue.length) &#123;</span><br><span class="line">          const callback &#x3D; this._resolveQueue.shift()</span><br><span class="line">          callback(val)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      setTimeout(run)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 实现同resolve</span><br><span class="line">    let _reject &#x3D; (val) &#x3D;&gt; &#123;</span><br><span class="line">      const run &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        if(this._status !&#x3D;&#x3D; PENDING) return   &#x2F;&#x2F; 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span><br><span class="line">        this._status &#x3D; REJECTED               &#x2F;&#x2F; 变更状态</span><br><span class="line">        this._value &#x3D; val                     &#x2F;&#x2F; 储存当前value</span><br><span class="line">        while(this._rejectQueue.length) &#123;</span><br><span class="line">          const callback &#x3D; this._rejectQueue.shift()</span><br><span class="line">          callback(val)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      setTimeout(run)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; new Promise()时立即执行executor,并传入resolve和reject</span><br><span class="line">    executor(_resolve, _reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; then方法,接收一个成功的回调和一个失败的回调</span><br><span class="line">  then(resolveFn, rejectFn) &#123;</span><br><span class="line">    &#x2F;&#x2F; 根据规范，如果then的参数不是function，则我们需要忽略它, 让链式调用继续往下执行</span><br><span class="line">    typeof resolveFn !&#x3D;&#x3D; &#39;function&#39; ? resolveFn &#x3D; value &#x3D;&gt; value : null</span><br><span class="line">    typeof rejectFn !&#x3D;&#x3D; &#39;function&#39; ? rejectFn &#x3D; reason &#x3D;&gt; &#123;</span><br><span class="line">      throw new Error(reason instanceof Error? reason.message:reason);</span><br><span class="line">    &#125; : null</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; return一个新的promise</span><br><span class="line">    return new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span><br><span class="line">      const fulfilledFn &#x3D; value &#x3D;&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          &#x2F;&#x2F; 执行第一个(当前的)Promise的成功回调,并获取返回值</span><br><span class="line">          let x &#x3D; resolveFn(value)</span><br><span class="line">          &#x2F;&#x2F; 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span><br><span class="line">          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; reject同理</span><br><span class="line">      const rejectedFn  &#x3D; error &#x3D;&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          let x &#x3D; rejectFn(error)</span><br><span class="line">          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      switch (this._status) &#123;</span><br><span class="line">        &#x2F;&#x2F; 当状态为pending时,把then回调push进resolve&#x2F;reject执行队列,等待执行</span><br><span class="line">        case PENDING:</span><br><span class="line">          this._resolveQueue.push(fulfilledFn)</span><br><span class="line">          this._rejectQueue.push(rejectedFn)</span><br><span class="line">          break;</span><br><span class="line">        &#x2F;&#x2F; 当状态已经变为resolve&#x2F;reject时,直接执行then回调</span><br><span class="line">        case FULFILLED:</span><br><span class="line">          fulfilledFn(this._value)    &#x2F;&#x2F; this._value是上一个then回调return的值(见完整版代码)</span><br><span class="line">          break;</span><br><span class="line">        case REJECTED:</span><br><span class="line">          rejectedFn(this._value)</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;catch方法其实就是执行一下then的第二个回调</span><br><span class="line">  catch(rejectFn) &#123;</span><br><span class="line">    return this.then(undefined, rejectFn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;finally方法</span><br><span class="line">  finally(callback) &#123;</span><br><span class="line">    return this.then(</span><br><span class="line">      value &#x3D;&gt; MyPromise.resolve(callback()).then(() &#x3D;&gt; value),             &#x2F;&#x2F;执行回调,并returnvalue传递给后面的then</span><br><span class="line">      reason &#x3D;&gt; MyPromise.resolve(callback()).then(() &#x3D;&gt; &#123; throw reason &#125;)  &#x2F;&#x2F;reject同理</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;静态的resolve方法</span><br><span class="line">  static resolve(value) &#123;</span><br><span class="line">    if(value instanceof MyPromise) return value &#x2F;&#x2F;根据规范, 如果参数是Promise实例, 直接return这个实例</span><br><span class="line">    return new MyPromise(resolve &#x3D;&gt; resolve(value))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;静态的reject方法</span><br><span class="line">  static reject(reason) &#123;</span><br><span class="line">    return new MyPromise((resolve, reject) &#x3D;&gt; reject(reason))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;静态的all方法</span><br><span class="line">  static all(promiseArr) &#123;</span><br><span class="line">    let index &#x3D; 0</span><br><span class="line">    let result &#x3D; []</span><br><span class="line">    return new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      promiseArr.forEach((p, i) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F;Promise.resolve(p)用于处理传入值不为Promise的情况</span><br><span class="line">        MyPromise.resolve(p).then(</span><br><span class="line">          val &#x3D;&gt; &#123;</span><br><span class="line">            index++</span><br><span class="line">            result[i] &#x3D; val</span><br><span class="line">            if(index &#x3D;&#x3D;&#x3D; promiseArr.length) &#123;</span><br><span class="line">              resolve(result)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          err &#x3D;&gt; &#123;</span><br><span class="line">            reject(err)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;静态的race方法</span><br><span class="line">  static race(promiseArr) &#123;</span><br><span class="line">    return new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F;同时执行Promise,如果有一个Promise的状态发生改变,就变更新MyPromise的状态</span><br><span class="line">      for (let p of promiseArr) &#123;</span><br><span class="line">        MyPromise.resolve(p).then(  &#x2F;&#x2F;Promise.resolve(p)用于处理传入值不为Promise的情况</span><br><span class="line">          value &#x3D;&gt; &#123;</span><br><span class="line">            resolve(value)        &#x2F;&#x2F;注意这个resolve是上边new MyPromise的</span><br><span class="line">          &#125;,</span><br><span class="line">          err &#x3D;&gt; &#123;</span><br><span class="line">            reject(err)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>洋洋洒洒 150 多行的代码，到这里，我们终于可以给 Promise 的实现做一个结尾了。我们从一个最简单的 Promise 使用实例开始，通过对调用流程的分析，根据观察者模式实现了 Promise 的大致骨架，然后依据 Promise/A+规范填充代码，重点实现了 then 的链式调用，最后完成了 Promise 的静态/实例方法。其实 Promise 实现在整体上并没有太复杂的思想，但我们日常使用的时候往往忽略了很多 Promise 细节，因而很难写出一个符合规范的 Promise 实现，源码的实现过程，其实也是对 Promise 使用细节重新学习的过程。</p>
<h1 id="async-await-实现"><a href="#async-await-实现" class="headerlink" title="async/await 实现"></a>async/await 实现</h1><p>虽然前边花了这么多篇幅讲 Promise 的实现，不过探索<code>async/await</code>暂停执行的机制才是我们的初衷，下面我们就来进入这一块的内容。同样地，开头我们点一下 async/await 的使用意义。 在多个回调依赖的场景中，尽管 Promise 通过链式调用取代了回调嵌套，但过多的链式调用可读性仍然不佳，流程控制也不方便，ES7 提出的 async 函数，终于让 JS 对于异步操作有了终极解决方案，简洁优美地解决了以上两个问题。</p>
<blockquote>
<p>设想一个这样的场景，异步任务 a-&gt;b-&gt;c 之间存在依赖关系，如果我们通过 then 链式调用来处理这些关系，可读性并不是很好，如果我们想控制其中某个过程，比如在某些条件下，b 不往下执行到 c，那么也不是很方便控制</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(a)</span><br><span class="line">  .then(b &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(c &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是如果通过 async/await 来实现这个场景，可读性和流程控制都会方便不少。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async () &#x3D;&gt; &#123;</span><br><span class="line">  const a &#x3D; await Promise.resolve(a);</span><br><span class="line">  const b &#x3D; await Promise.resolve(b);</span><br><span class="line">  const c &#x3D; await Promise.resolve(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们要如何实现一个 async/await 呢，首先我们要知道，<strong>async/await 实际上是对 Generator（生成器）的封装</strong>，是一个语法糖。由于 Generator 出现不久就被 async/await 取代了，很多同学对 Generator 比较陌生，因此我们先来看看 Generator 的用法：</p>
<blockquote>
<p>ES6 新引入了 Generator 函数，可以通过 yield 关键字，把函数的执行流挂起，通过 next()方法可以切换到下一个状态，为改变执行流程提供了可能，从而为异步编程提供解决方案。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function* myGenerator() &#123;</span><br><span class="line">  yield &#39;1&#39;</span><br><span class="line">  yield &#39;2&#39;</span><br><span class="line">  return &#39;3&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const gen &#x3D; myGenerator();  &#x2F;&#x2F; 获取迭代器</span><br><span class="line">gen.next()  &#x2F;&#x2F;&#123;value: &quot;1&quot;, done: false&#125;</span><br><span class="line">gen.next()  &#x2F;&#x2F;&#123;value: &quot;2&quot;, done: false&#125;</span><br><span class="line">gen.next()  &#x2F;&#x2F;&#123;value: &quot;3&quot;, done: true&#125;</span><br></pre></td></tr></table></figure>

<p>也可以通过给<code>next()</code>传参, 让 yield 具有返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function* myGenerator() &#123;</span><br><span class="line">  console.log(yield &#39;1&#39;)  &#x2F;&#x2F;test1</span><br><span class="line">  console.log(yield &#39;2&#39;)  &#x2F;&#x2F;test2</span><br><span class="line">  console.log(yield &#39;3&#39;)  &#x2F;&#x2F;test3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取迭代器</span><br><span class="line">const gen &#x3D; myGenerator();</span><br><span class="line"></span><br><span class="line">gen.next()</span><br><span class="line">gen.next(&#39;test1&#39;)</span><br><span class="line">gen.next(&#39;test2&#39;)</span><br><span class="line">gen.next(&#39;test3&#39;)</span><br></pre></td></tr></table></figure>

<p>我们看到 Generator 的用法，应该️会感到很熟悉，<code>*/yield</code>和<code>async/await</code>看起来其实已经很相似了，它们都提供了暂停执行的功能，但二者又有三点不同：</p>
<ul>
<li><code>async/await</code>自带执行器，不需要手动调用 next()就能自动执行下一步</li>
<li><code>async</code>函数返回值是 Promise 对象，而 Generator 返回的是生成器对象</li>
<li><code>await</code>能够返回 Promise 的 resolve/reject 的值</li>
</ul>
<p><strong>我们对 async/await 的实现，其实也就是对应以上三点封装 Generator</strong></p>
<h2 id="1-自动执行"><a href="#1-自动执行" class="headerlink" title="1.自动执行"></a>1.自动执行</h2><p>我们先来看一下，对于这样一个 Generator，手动执行是怎样一个流程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function* myGenerator() &#123;</span><br><span class="line">  yield Promise.resolve(1);</span><br><span class="line">  yield Promise.resolve(2);</span><br><span class="line">  yield Promise.resolve(3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 手动执行迭代器</span><br><span class="line">const gen &#x3D; myGenerator()</span><br><span class="line">gen.next().value.then(val &#x3D;&gt; &#123;</span><br><span class="line">  console.log(val)</span><br><span class="line">  gen.next().value.then(val &#x3D;&gt; &#123;</span><br><span class="line">    console.log(val)</span><br><span class="line">    gen.next().value.then(val &#x3D;&gt; &#123;</span><br><span class="line">      console.log(val)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出1 2 3</span><br></pre></td></tr></table></figure>

<p>我们也可以通过给<code>gen.next()</code>传值的方式，让 yield 能返回 resolve 的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function* myGenerator() &#123;</span><br><span class="line">  console.log(yield Promise.resolve(1))   &#x2F;&#x2F;1</span><br><span class="line">  console.log(yield Promise.resolve(2))   &#x2F;&#x2F;2</span><br><span class="line">  console.log(yield Promise.resolve(3))   &#x2F;&#x2F;3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 手动执行迭代器</span><br><span class="line">const gen &#x3D; myGenerator()</span><br><span class="line">gen.next().value.then(val &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; console.log(val)</span><br><span class="line">  gen.next(val).value.then(val &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; console.log(val)</span><br><span class="line">    gen.next(val).value.then(val &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; console.log(val)</span><br><span class="line">      gen.next(val)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>显然，手动执行的写法看起来既笨拙又丑陋，我们希望生成器函数能自动往下执行，且 yield 能返回 resolve 的值，基于这两个需求，我们进行一个基本的封装，这里<code>async/await</code>是关键字，不能重写，我们用函数来模拟：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function run(gen) &#123;</span><br><span class="line">  var g &#x3D; gen()                     &#x2F;&#x2F;由于每次gen()获取到的都是最新的迭代器,因此获取迭代器操作要放在_next()之前,否则会进入死循环</span><br><span class="line"></span><br><span class="line">  function _next(val) &#123;             &#x2F;&#x2F;封装一个方法, 递归执行g.next()</span><br><span class="line">    var res &#x3D; g.next(val)           &#x2F;&#x2F;获取迭代器对象，并返回resolve的值</span><br><span class="line">    if(res.done) return res.value   &#x2F;&#x2F;递归终止条件</span><br><span class="line">    res.value.then(val &#x3D;&gt; &#123;         &#x2F;&#x2F;Promise的then方法是实现自动迭代的前提</span><br><span class="line">      _next(val)                    &#x2F;&#x2F;等待Promise完成就自动执行下一个next，并传入resolve的值</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  _next()  &#x2F;&#x2F;第一次执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于我们之前的例子，我们就能这样执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function* myGenerator() &#123;</span><br><span class="line">  console.log(yield Promise.resolve(1))   &#x2F;&#x2F;1</span><br><span class="line">  console.log(yield Promise.resolve(2))   &#x2F;&#x2F;2</span><br><span class="line">  console.log(yield Promise.resolve(3))   &#x2F;&#x2F;3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(myGenerator)</span><br></pre></td></tr></table></figure>

<p>这样我们就初步实现了一个<code>async/await</code>。上边的代码只有五六行，但并不是一下就能看明白的，我们之前用了四个例子来做铺垫，也是为了让读者更好地理解这段代码。 简单来说，我们封装了一个 run 方法，run 方法里我们把执行下一步的操作封装成<code>_next()</code>，每次 Promise.then()的时候都去执行<code>_next()</code>，实现自动迭代的效果。在迭代的过程中，我们还把 resolve 的值传入<code>gen.next()</code>，使得 yield 得以返回 Promise 的 resolve 的值</p>
<blockquote>
<p>这里插一句，是不是只有<code>.then方法</code>这样的形式才能完成我们自动执行的功能呢？答案是否定的，yield 后边除了接 Promise，还可以接<code>thunk函数</code>，thunk 函数不是一个新东西，所谓 thunk 函数，就是<strong>单参的只接受回调的函数</strong>，详细介绍可以看<a target="_blank" rel="noopener" href="https://user-gold-cdn.xitu.io/2020/3/15/170dc5e88df6c208">阮一峰 Thunk 函数的含义和用法</a>，无论是 Promise 还是 thunk 函数，其核心都是通过<strong>传入回调</strong>的方式来实现 Generator 的自动执行。thunk 函数只作为一个拓展知识，理解有困难的同学也可以跳过这里，并不影响后续理解。</p>
</blockquote>
<h2 id="2-返回-Promise-amp-异常处理"><a href="#2-返回-Promise-amp-异常处理" class="headerlink" title="2.返回 Promise &amp; 异常处理"></a>2.返回 Promise &amp; 异常处理</h2><p>虽然我们实现了 Generator 的自动执行以及让 yield 返回 resolve 的值，但上边的代码还存在着几点问题：</p>
<ol>
<li><strong>需要兼容基本类型</strong>：这段代码能自动执行的前提是<code>yield</code>后面跟 Promise，为了兼容后面跟着基本类型值的情况，我们需要把 yield 跟的内容(<code>gen().next.value</code>)都用<code>Promise.resolve()</code>转化一遍</li>
<li><strong>缺少错误处理</strong>：上边代码里的 Promise 如果执行失败，就会导致后续执行直接中断，我们需要通过调用<code>Generator.prototype.throw()</code>，把错误抛出来，才能被外层的 try-catch 捕获到</li>
<li><strong>返回值是 Promise</strong>：<code>async/await</code>的返回值是一个 Promise，我们这里也需要保持一致，给返回值包一个 Promise</li>
</ol>
<p>我们改造一下 run 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function run(gen) &#123;</span><br><span class="line">  &#x2F;&#x2F;把返回值包装成promise</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    var g &#x3D; gen()</span><br><span class="line"></span><br><span class="line">    function _next(val) &#123;</span><br><span class="line">      &#x2F;&#x2F;错误处理</span><br><span class="line">      try &#123;</span><br><span class="line">        var res &#x3D; g.next(val)</span><br><span class="line">      &#125; catch(err) &#123;</span><br><span class="line">        return reject(err);</span><br><span class="line">      &#125;</span><br><span class="line">      if(res.done) &#123;</span><br><span class="line">        return resolve(res.value);</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F;res.value包装为promise，以兼容yield后面跟基本类型的情况</span><br><span class="line">      Promise.resolve(res.value).then(</span><br><span class="line">        val &#x3D;&gt; &#123;</span><br><span class="line">          _next(val);</span><br><span class="line">        &#125;,</span><br><span class="line">        err &#x3D;&gt; &#123;</span><br><span class="line">          &#x2F;&#x2F;抛出错误</span><br><span class="line">          g.throw(err)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    _next();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们可以测试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function* myGenerator() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    console.log(yield Promise.resolve(1))</span><br><span class="line">    console.log(yield 2)   &#x2F;&#x2F;2</span><br><span class="line">    console.log(yield Promise.reject(&#39;error&#39;))</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    console.log(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const result &#x3D; run(myGenerator)     &#x2F;&#x2F;result是一个Promise</span><br><span class="line">&#x2F;&#x2F;输出 1 2 error</span><br></pre></td></tr></table></figure>

<p>到这里，一个<code>async/await</code>的实现基本完成了。最后我们可以看一下 babel 对 async/await 的转换结果，其实整体的思路是一样的，但是写法稍有不同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;相当于我们的run()</span><br><span class="line">function _asyncToGenerator(fn) &#123;</span><br><span class="line">  &#x2F;&#x2F; return一个function，和async保持一致。我们的run直接执行了Generator，其实是不太规范的</span><br><span class="line">  return function() &#123;</span><br><span class="line">    var self &#x3D; this</span><br><span class="line">    var args &#x3D; arguments</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">      var gen &#x3D; fn.apply(self, args);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;相当于我们的_next()</span><br><span class="line">      function _next(value) &#123;</span><br><span class="line">        asyncGeneratorStep(gen, resolve, reject, _next, _throw, &#39;next&#39;, value);</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F;处理异常</span><br><span class="line">      function _throw(err) &#123;</span><br><span class="line">        asyncGeneratorStep(gen, resolve, reject, _next, _throw, &#39;throw&#39;, err);</span><br><span class="line">      &#125;</span><br><span class="line">      _next(undefined);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    var info &#x3D; gen[key](arg);</span><br><span class="line">    var value &#x3D; info.value;</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  if (info.done) &#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    Promise.resolve(value).then(_next, _throw);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const foo &#x3D; _asyncToGenerator(function* () &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    console.log(yield Promise.resolve(1))   &#x2F;&#x2F;1</span><br><span class="line">    console.log(yield 2)                    &#x2F;&#x2F;2</span><br><span class="line">    return &#39;3&#39;</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    console.log(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">foo().then(res &#x3D;&gt; &#123;</span><br><span class="line">  console.log(res)                          &#x2F;&#x2F;3</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>有关<code>async/await</code>的实现，到这里就告一段落了。但是直到结尾，我们也不知道 await 到底是如何暂停执行的，有关 await 暂停执行的秘密，我们还要到 Generator 的实现中去寻找答案</p>
<h1 id="Generator-实现"><a href="#Generator-实现" class="headerlink" title="Generator 实现"></a>Generator 实现</h1><p>我们从一个简单的 Generator 使用实例开始，一步步探究 Generator 的实现原理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function* foo() &#123;</span><br><span class="line">  yield &#39;result1&#39;</span><br><span class="line">  yield &#39;result2&#39;</span><br><span class="line">  yield &#39;result3&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const gen &#x3D; foo()</span><br><span class="line">console.log(gen.next().value)</span><br><span class="line">console.log(gen.next().value)</span><br><span class="line">console.log(gen.next().value)</span><br></pre></td></tr></table></figure>

<p>我们可以在<a target="_blank" rel="noopener" href="https://babeljs.io/repl/#?browsers=&build=&builtIns=false&spec=false&loose=false&code_lz=GYVwdgxgLglg9mAVAAmHOAKAlMg3gKGWQE8YBTAGwBNkByAJzIGcQKoBGWwk86uxlmwBMXIqUo0GzVlADMXAL7d8EBEyjIA5mTDIAvKnTYVauBTIA6CnE0ZtYC2DIAPKNgsA3AIYUQZLCZgTGaW1rb2ji5uWJ4-fgGqQSFWNnY6ka7u3r7-QA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=false&fileSize=false&timeTravel=false&sourceType=module&lineWrap=true&presets=es2015%2Creact%2Cstage-2&prettier=false&targets=&version=7.5.5&externalPlugins=">babel 官网</a>上在线转化这段代码，看看 ES5 环境下是如何实现 Generator 的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">var _marked &#x3D;</span><br><span class="line">&#x2F;*#__PURE__*&#x2F;</span><br><span class="line">regeneratorRuntime.mark(foo);</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">  return regeneratorRuntime.wrap(function foo$(_context) &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">      switch (_context.prev &#x3D; _context.next) &#123;</span><br><span class="line">        case 0:</span><br><span class="line">          _context.next &#x3D; 2;</span><br><span class="line">          return &#39;result1&#39;;</span><br><span class="line"></span><br><span class="line">        case 2:</span><br><span class="line">          _context.next &#x3D; 4;</span><br><span class="line">          return &#39;result2&#39;;</span><br><span class="line"></span><br><span class="line">        case 4:</span><br><span class="line">          _context.next &#x3D; 6;</span><br><span class="line">          return &#39;result3&#39;;</span><br><span class="line"></span><br><span class="line">        case 6:</span><br><span class="line">        case &quot;end&quot;:</span><br><span class="line">          return _context.stop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, _marked);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var gen &#x3D; foo();</span><br><span class="line">console.log(gen.next().value);</span><br><span class="line">console.log(gen.next().value);</span><br><span class="line">console.log(gen.next().value);</span><br></pre></td></tr></table></figure>

<p>代码咋一看不长，但如果仔细观察会发现有两个不认识的东西 —— <code>regeneratorRuntime.mark</code>和<code>regeneratorRuntime.wrap</code>，这两者其实是 regenerator-runtime 模块里的两个方法，regenerator-runtime 模块来自 facebook 的 regenerator 模块，完整代码在<a target="_blank" rel="noopener" href="https://github.com/facebook/regenerator/blob/master/packages/regenerator-runtime/runtime.js">runtime.js</a>，这个 runtime 有 700 多行…-_-||，因此我们不能全讲，不太重要的部分我们就简单地过一下，重点讲解暂停执行相关部分代码</p>
<blockquote>
<p>个人觉得啃源码的效果不是很好，建议读者拉到末尾先看结论和简略版实现，源码作为一个补充理解</p>
</blockquote>
<h2 id="regeneratorRuntime-mark"><a href="#regeneratorRuntime-mark" class="headerlink" title="regeneratorRuntime.mark()"></a>regeneratorRuntime.mark()</h2><p><code>regeneratorRuntime.mark(foo)</code>这个方法在第一行被调用，我们先看一下 runtime 里 mark()方法的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;runtime.js里的定义稍有不同，多了一些判断，以下是编译后的代码</span><br><span class="line">runtime.mark &#x3D; function(genFun) &#123;</span><br><span class="line">  genFun.__proto__ &#x3D; GeneratorFunctionPrototype;</span><br><span class="line">  genFun.prototype &#x3D; Object.create(Gp);</span><br><span class="line">  return genFun;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里边<code>GeneratorFunctionPrototype</code>和<code>Gp</code>我们都不认识，他们被定义在 runtime 里，不过没关系，我们只要知道<code>mark()方法</code>为生成器函数（foo）绑定了一系列原型就可以了，这里就简单地过了</p>
<h2 id="regeneratorRuntime-wrap"><a href="#regeneratorRuntime-wrap" class="headerlink" title="regeneratorRuntime.wrap()"></a>regeneratorRuntime.wrap()</h2><p>从上面 babel 转化的代码我们能看到，执行<code>foo()</code>，其实就是执行<code>wrap()</code>，那么这个方法起到什么作用呢，他想包装一个什么东西呢，我们先来看看 wrap 方法的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;runtime.js里的定义稍有不同，多了一些判断，以下是编译后的代码</span><br><span class="line">function wrap(innerFn, outerFn, self) &#123;</span><br><span class="line">  var generator &#x3D; Object.create(outerFn.prototype);</span><br><span class="line">  var context &#x3D; new Context([]);</span><br><span class="line">  generator._invoke &#x3D; makeInvokeMethod(innerFn, self, context);</span><br><span class="line"></span><br><span class="line">  return generator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>wrap 方法先是创建了一个 generator，并继承<code>outerFn.prototype</code>；然后 new 了一个<code>context对象</code>；<code>makeInvokeMethod方法</code>接收<code>innerFn(对应foo$)</code>、<code>context</code>和<code>this</code>，并把返回值挂到<code>generator._invoke</code>上；最后 return 了 generator。<strong>其实 wrap()相当于是给 generator 增加了一个_invoke 方法</strong></p>
<p>这段代码肯定让人产生很多疑问，outerFn.prototype 是什么，Context 又是什么，makeInvokeMethod 又做了哪些操作。下面我们就来一一解答：</p>
<blockquote>
<p><code>outerFn.prototype</code>其实就是<code>genFun.prototype</code>，</p>
</blockquote>
<p>这个我们结合一下上面的代码就能知道</p>
<blockquote>
<p><code>context</code>可以直接理解为这样一个全局对象，用于储存各种状态和上下文：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var ContinueSentinel &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">var context &#x3D; &#123;</span><br><span class="line">  done: false,</span><br><span class="line">  method: &quot;next&quot;,</span><br><span class="line">  next: 0,</span><br><span class="line">  prev: 0,</span><br><span class="line">  abrupt: function(type, arg) &#123;</span><br><span class="line">    var record &#x3D; &#123;&#125;;</span><br><span class="line">    record.type &#x3D; type;</span><br><span class="line">    record.arg &#x3D; arg;</span><br><span class="line"></span><br><span class="line">    return this.complete(record);</span><br><span class="line">  &#125;,</span><br><span class="line">  complete: function(record, afterLoc) &#123;</span><br><span class="line">    if (record.type &#x3D;&#x3D;&#x3D; &quot;return&quot;) &#123;</span><br><span class="line">      this.rval &#x3D; this.arg &#x3D; record.arg;</span><br><span class="line">      this.method &#x3D; &quot;return&quot;;</span><br><span class="line">      this.next &#x3D; &quot;end&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ContinueSentinel;</span><br><span class="line">  &#125;,</span><br><span class="line">  stop: function() &#123;</span><br><span class="line">    this.done &#x3D; true;</span><br><span class="line">    return this.rval;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>makeInvokeMethod</code>的定义如下，它 return 了一个<code>invoke方法</code>，invoke 用于判断当前状态和执行下一步，其实就是我们调用的<code>next()</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;以下是编译后的代码</span><br><span class="line">function makeInvokeMethod(innerFn, context) &#123;</span><br><span class="line">  &#x2F;&#x2F; 将状态置为start</span><br><span class="line">  var state &#x3D; &quot;start&quot;;</span><br><span class="line"></span><br><span class="line">  return function invoke(method, arg) &#123;</span><br><span class="line">    &#x2F;&#x2F; 已完成</span><br><span class="line">    if (state &#x3D;&#x3D;&#x3D; &quot;completed&quot;) &#123;</span><br><span class="line">      return &#123; value: undefined, done: true &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    context.method &#x3D; method;</span><br><span class="line">    context.arg &#x3D; arg;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 执行中</span><br><span class="line">    while (true) &#123;</span><br><span class="line">      state &#x3D; &quot;executing&quot;;</span><br><span class="line"></span><br><span class="line">      var record &#x3D; &#123;</span><br><span class="line">        type: &quot;normal&quot;,</span><br><span class="line">        arg: innerFn.call(self, context)    &#x2F;&#x2F; 执行下一步,并获取状态(其实就是switch里边return的值)</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      if (record.type &#x3D;&#x3D;&#x3D; &quot;normal&quot;) &#123;</span><br><span class="line">        &#x2F;&#x2F; 判断是否已经执行完成</span><br><span class="line">        state &#x3D; context.done ? &quot;completed&quot; : &quot;yield&quot;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; ContinueSentinel其实是一个空对象,record.arg &#x3D;&#x3D;&#x3D; &#123;&#125;则跳过return进入下一个循环</span><br><span class="line">        &#x2F;&#x2F; 什么时候record.arg会为空对象呢, 答案是没有后续yield语句或已经return的时候,也就是switch返回了空值的情况(跟着上面的switch走一下就知道了)</span><br><span class="line">        if (record.arg &#x3D;&#x3D;&#x3D; ContinueSentinel) &#123;</span><br><span class="line">          continue;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; next()的返回值</span><br><span class="line">        return &#123;</span><br><span class="line">          value: record.arg,</span><br><span class="line">          done: context.done</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么<code>generator._invoke</code>实际上就是<code>gen.next</code>呢，因为在 runtime 对于 next()的定义中，next()其实就 return 了_invoke 方法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Helper for defining the .next, .throw, and .return methods of the</span><br><span class="line">&#x2F;&#x2F; Iterator interface in terms of a single ._invoke method.</span><br><span class="line">function defineIteratorMethods(prototype) &#123;</span><br><span class="line">    [&quot;next&quot;, &quot;throw&quot;, &quot;return&quot;].forEach(function(method) &#123;</span><br><span class="line">      prototype[method] &#x3D; function(arg) &#123;</span><br><span class="line">        return this._invoke(method, arg);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defineIteratorMethods(Gp);</span><br></pre></td></tr></table></figure>

<h2 id="低配实现-amp-调用流程分析"><a href="#低配实现-amp-调用流程分析" class="headerlink" title="低配实现 &amp; 调用流程分析"></a>低配实现 &amp; 调用流程分析</h2><p>这么一遍源码下来，估计很多读者还是懵逼的，毕竟源码中纠集了很多概念和封装，一时半会不好完全理解，让我们跳出源码，实现一个简单的 Generator，然后再回过头看源码，会得到更清晰的认识</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 生成器函数根据yield语句将代码分割为switch-case块，后续通过切换_context.prev和_context.next来分别执行各个case</span><br><span class="line">function gen$(_context) &#123;</span><br><span class="line">  while (1) &#123;</span><br><span class="line">    switch (_context.prev &#x3D; _context.next) &#123;</span><br><span class="line">      case 0:</span><br><span class="line">        _context.next &#x3D; 2;</span><br><span class="line">        return &#39;result1&#39;;</span><br><span class="line"></span><br><span class="line">      case 2:</span><br><span class="line">        _context.next &#x3D; 4;</span><br><span class="line">        return &#39;result2&#39;;</span><br><span class="line"></span><br><span class="line">      case 4:</span><br><span class="line">        _context.next &#x3D; 6;</span><br><span class="line">        return &#39;result3&#39;;</span><br><span class="line"></span><br><span class="line">      case 6:</span><br><span class="line">      case &quot;end&quot;:</span><br><span class="line">        return _context.stop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 低配版context</span><br><span class="line">var context &#x3D; &#123;</span><br><span class="line">  next:0,</span><br><span class="line">  prev: 0,</span><br><span class="line">  done: false,</span><br><span class="line">  stop: function stop () &#123;</span><br><span class="line">    this.done &#x3D; true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 低配版invoke</span><br><span class="line">let gen &#x3D; function() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    next: function() &#123;</span><br><span class="line">      value &#x3D; context.done ? undefined: gen$(context)</span><br><span class="line">      done &#x3D; context.done</span><br><span class="line">      return &#123;</span><br><span class="line">        value,</span><br><span class="line">        done</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 测试使用</span><br><span class="line">var g &#x3D; gen()</span><br><span class="line">g.next()  &#x2F;&#x2F; &#123;value: &quot;result1&quot;, done: false&#125;</span><br><span class="line">g.next()  &#x2F;&#x2F; &#123;value: &quot;result2&quot;, done: false&#125;</span><br><span class="line">g.next()  &#x2F;&#x2F; &#123;value: &quot;result3&quot;, done: false&#125;</span><br><span class="line">g.next()  &#x2F;&#x2F; &#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码并不难理解，我们分析一下调用流程：</p>
<ol>
<li><p>我们定义的<code>function*</code>生成器函数被转化为以上代码</p>
</li>
<li><p>转化后的代码分为三大块：</p>
<ul>
<li><code>gen$(_context)</code>由 yield 分割生成器函数代码而来</li>
<li><code>context对象</code>用于储存函数执行上下文</li>
<li><code>invoke()方法</code>定义 next()，用于执行 gen$(_context)来跳到下一步</li>
</ul>
</li>
<li><p>当我们调用<code>g.next()</code>，就相当于调用<code>invoke()方法</code>，执行<code>gen$(_context)</code>，进入 switch 语句，switch 根据 context 的标识，执行对应的 case 块，return 对应结果</p>
</li>
<li><p>当生成器函数运行到末尾（没有下一个 yield 或已经 return），switch 匹配不到对应代码块，就会 return 空值，这时<code>g.next()</code>返回<code>&#123;value: undefined, done: true&#125;</code></p>
</li>
</ol>
<p>从中我们可以看出，<strong>Generator 实现的核心在于</strong><code>**上下文的保存**</code><strong>，函数并没有真的被挂起，每一次 yield，其实都执行了一遍传入的生成器函数，只是在这个过程中间用了一个 context 对象储存上下文，使得每次执行生成器函数的时候，都可以从上一个执行结果开始执行，看起来就像函数被挂起了一样</strong></p>
<h1 id="总结-amp-致谢"><a href="#总结-amp-致谢" class="headerlink" title="总结 &amp; 致谢"></a>总结 &amp; 致谢</h1><p>有关 Promise、async/await、Generator 的原理就实现到这里了，感谢大家能够跟我一起走完全程，不知不觉，我们花了近 9 千字来讲述有关异步编程的故事，异步编程的世界环环相扣，一开始，笔者只是出于对 await 挂起机制的好奇，后来，从一个 “await 是如何实现暂停执行” 的小问题，引出了对异步编程的一系列思考和实现原理。三者的实现，其实也是前端异步编程一步步演化推进的过程。</p>
<p>成文过程中得到很多大佬的帮助，这四篇参考文章都是我阅读了很多相关文章后精选的四篇，建议大家结合阅读，大佬们写的比我好很多，另外感谢冴羽大佬在 Generator 机制上给予的解惑~</p>
<blockquote>
<p>前端技匠：<a target="_blank" rel="noopener" href="https://juejin.im/post/6844903989083897870">各种源码实现，你想要的这里都有</a></p>
</blockquote>
<p>神三元：<a target="_blank" rel="noopener" href="https://juejin.im/post/6844903702457925640">我如何实现 Promise</a></p>
<p>winty：<a target="_blank" rel="noopener" href="https://juejin.im/post/6844903988584775693#heading-0">async/await 原理及执行顺序分析</a></p>
<p>冴羽：<a target="_blank" rel="noopener" href="https://juejin.im/post/6844903701908291592">ES6 系列之 Babel 将 Generator 编译成了什么样子</a></p>
<p><strong>最后卑微求个赞 Thanks♪(･ω･)ﾉ</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619261369471-9f4febb6-72fb-41b7-a3bb-60cfeb077c95.jpeg#clientId=u0787e3d2-71b0-4&from=drop&id=u5e819ff0&margin=%5Bobject%20Object%5D&name=2.jpg&originHeight=380&originWidth=714&originalType=binary&size=85453&status=done&style=none&taskId=ua85c3f64-ca03-48e4-bfca-25b503824f6" alt="2.jpg"></p>
<blockquote>
<p>往期文章</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/6844904036013965325">10 行代码看尽 redux 实现 —— 全面剖析 redux &amp; react-redux &amp; redux 中间件设计实现 | 8k 字</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/6844904006175686669">红黑树上红黑果，红黑树下你和我 —— 红黑树入门 | 6k 字</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/6844904000387563533">SSR 从入门到放弃 —— 深入 React 服务端渲染原理 | 1W 字</a>？</li>
</ol>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/23/yuque/%E5%8A%A8%E7%94%BB%E6%80%A7%E8%83%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/23/yuque/%E5%8A%A8%E7%94%BB%E6%80%A7%E8%83%BD/" class="post-title-link" itemprop="url">动画性能</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-23 13:33:32" itemprop="dateCreated datePublished" datetime="2021-04-23T13:33:32+08:00">2021-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-24 18:51:14" itemprop="dateModified" datetime="2021-04-24T18:51:14+08:00">2021-04-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>先总结几个要点<br><strong>精简 DOM，合理布局</strong><br><strong>使用 transform 代替 left、top 减少使用引起页面重排的属性</strong><br><strong>开启硬件加速</strong><br><strong>尽量避免浏览器创建不必要的图形层</strong><br><strong>尽量减少 js 动画，如需要，使用对性能友好的 requestAnimationFrame</strong><br><strong>使用 chrome performance 工具调试动画性能</strong></p>
<p>我们知道网页动画的每一帧都是一次重新渲染，每秒低于 24 镇的动画，人眼就能感受到停顿，每秒 30-60 帧才能比较流畅 浏览器会按照大多数显示器的刷新频率 60Hz 来刷新动画， 如果想达到 60FPS,就意味着每一帧的任务耗时不能高于 16 毫秒。</p>
<p>通过下图我们可以了解浏览器渲染每一帧的过程<br><img src="https://cdn.nlark.com/yuque/0/2021/webp/21377586/1619156045002-3bd51fc7-149d-4148-8cdb-8f69404dc3db.webp#clientId=u31f05833-5d5b-4&from=paste&height=343&id=u16107b32&margin=%5Bobject%20Object%5D&originHeight=343&originWidth=720&originalType=url&status=done&style=none&taskId=u333ca95c-b807-450e-8286-cfd761dd888&width=720"></p>
<ul>
<li>1.JavaScript。一般来说，我们会使用 JavaScript 来实现一些视觉变化的效果。比如用 jQuery 的 animate 函数做一个动画、对一个数据集进行排序或者往页面里添加一些 DOM 元素等。当然，除了 JavaScript，还有其他一些常用方法也可以实现视觉变化效果，比如：CSS Animations、Transitions 和 Web Animation API。</li>
<li>2.样式计算。此过程是根据匹配选择器（例如 .headline 或 .nav &gt; .nav__item）计算出哪些元素应用哪些 CSS 3. 规则的过程。从中知道规则之后，将应用规则并计算每个元素的最终样式。</li>
<li>3.布局。在知道对一个元素应用哪些规则之后，浏览器即可开始计算它要占据的空间大小及其在屏幕的位置。网页的布局模式意味着一个元素可能影响其他元素，例如 元素的宽度一般会影响其子元素的宽度以及树中各处的节点，因此对于浏览器来说，布局过程是经常发生的。</li>
<li>4.绘制。绘制是填充像素的过程。它涉及绘出文本、颜色、图像、边框和阴影，基本上包括元素的每个可视部分。绘制一般是在多个表面（通常称为层）上完成的。</li>
<li>5.合成。由于页面的各部分可能被绘制到多层，由此它们需要按正确顺序绘制到屏幕上，以便正确渲染页面。对于与另一元素重叠的元素来说，这点特别重要，因为一个错误可能使一个元素错误地出现在另一个元素的上层。</li>
<li>“生成布局”（flow）和”绘制”（paint）这两步，合称为”渲染”（render）。重新渲染就是需要重新生成布局和重新绘制。 有上述的渲染流水线我们可以得知重绘不一定需要重排，重排必然导致重绘</li>
<li>重排和重绘会不断触发，这是不可避免的。但是，它们非常耗费资源，是导致网页性能低下的根本原因。 提高网页性能，就是要降低”重排”和”重绘”的频率和成本，尽量少触发重新渲染。</li>
<li>重排还重绘会消耗大量的 CPU 和 GPU 资源，前端新能优化最主要的优化点就是尽量减少重绘和重排。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/21377586/1619156083886-901015cf-1400-451a-ba59-92d020065dcb.webp#clientId=u31f05833-5d5b-4&from=paste&height=343&id=u1605db33&margin=%5Bobject%20Object%5D&originHeight=343&originWidth=720&originalType=url&status=done&style=none&taskId=udccd0b91-b739-46c6-9380-cb2ecd9cfc4&width=720"></p>
<h1 id="影响网页渲染的因素"><a href="#影响网页渲染的因素" class="headerlink" title="影响网页渲染的因素"></a>影响网页渲染的因素</h1><p>其中最简单的，样式表越简单，重绘和重排越快，重绘和重排的 DOM 元素层级越高，成本就越高，所以我们在开发前端页面时就需要精简 DOM 元素，合理布局。<br>另外 Table 元素的重排和重绘成本要高于 div，所以我们提倡使用 div+css 布局，尽量避免使用 table 布局。<br>还有其他对渲染性能有影响的操作，比如：</p>
<ul>
<li>DOM 元素读写分离</li>
<li>让进行大量动画的元素脱离文档流，减少重排开销</li>
<li>通过改变元素的 class 或 csstext 一次性的更改样式</li>
<li>缓存 DOM 元素的位置信息，避免不必要的属性读取</li>
<li>尽量使用离线 DOM</li>
<li>使用 css3 transform 优化动画性能</li>
</ul>
<h1 id="使用-css3-transform"><a href="#使用-css3-transform" class="headerlink" title="使用 css3 transform"></a>使用 css3 transform</h1><p>该 CSS 属性可以旋转，缩放，倾斜，或者上传给定的元素。这是通过修改 CSS 可视格式模型的坐标空间来实现的。<br>如果该属性的值不是 none，则会创建一个堆叠上下文。在这种情况下，该对象将充当 position: fixed 的包含块（所以 position: fixed 的元素将会被他覆盖）。</p>
<p><strong>css3 transform 的执行效率</strong><br>我们通过一个例子来解释为什么 transform 的动画执行效果更佳。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 对应图<span class="number">1</span>-- &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">transition</span>: height <span class="number">1s</span> linear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 对应图<span class="number">2</span> -- &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">transition</span>: transform <span class="number">1s</span> linear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个从 height: 100px 到 height: 200px 的 动画按照下面的流程图来执行各种操作 橙色方框的操作比较耗时，绿色方框的操作比较快速<br><img src="https://cdn.nlark.com/yuque/0/2021/webp/21377586/1619156167485-d5405de1-1137-43f6-a0fb-4f771e179840.webp#clientId=u31f05833-5d5b-4&from=paste&height=1025&id=uc382e09a&margin=%5Bobject%20Object%5D&originHeight=1025&originWidth=455&originalType=url&status=done&style=none&taskId=u1c0285ca-7c7f-4067-8a14-431f977d49d&width=455"><br><img src="https://cdn.nlark.com/yuque/0/2021/webp/21377586/1619156180032-59cfbfa7-4237-41ed-8435-2d49044fabfe.webp#clientId=u31f05833-5d5b-4&from=paste&height=844&id=udfd3f826&margin=%5Bobject%20Object%5D&originHeight=844&originWidth=510&originalType=url&status=done&style=none&taskId=u9a529281-896c-46be-9a13-9eaeec7a309&width=510"><br>因为每一帧的变化浏览器都在进行布局、绘制、把新的位图交给 GPU 内存，但是在将位图加载到 GPU 内存中的操作是个相对耗时的操作。<br>GPU 在如下方面很快：</p>
<ul>
<li>绘制位图到屏幕上</li>
<li>可不断的绘制相同的位图</li>
<li>将同一位图进行位移、旋转、缩放</li>
</ul>
<p>我们看使用了 transform 属性的动画执行过程（图二），这个无疑是效率最优的执行方式。</p>
<h1 id="层的引入（参考-无线性能优化：Composite）"><a href="#层的引入（参考-无线性能优化：Composite）" class="headerlink" title="层的引入（参考-无线性能优化：Composite）"></a>层的引入（<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://taobaofed.org/blog/2016/04/25/performance-composite/">参考-无线性能优化：Composite</a>）</h1><p>页面一旦在装入并解析完成后，就会表示为许多 Web 开发者所熟悉的结构：DOM。然而，在页面的渲染过程中，浏览器还具有一系列并不直接暴露给开发者的页面中间表示方式。这些表示方式中最重要的结构就是层。<br>在 Chrome 中实际上有几种不同类型的层：掌管 DOM 子树的渲染层（RenderLayer）以及掌管渲染层子树的图形层（GraphicsLayer），某些特殊的渲染层会被认为是合成层（Compositing Layers，合成层拥有单独的 GraphicsLayer。<br>拥有单独 GraphicsLayer 的层，都会将位图存储在共享内存中，作为纹理上传到 GPU 中，最后由 GPU 将多个位图进行合成，然后 draw 到屏幕上。<br>什么渲染层会提升为合成层？Chrome 在这方面采用的规则仍在随着时间推移逐渐发展变化，但在目前下面这些因素都会引起 Chrome 创建层：</p>
<ul>
<li>进行 3D 或者透视变换的 CSS 属性</li>
<li>使用硬件加速视频解码的<video>元素</li>
<li>具有 3D（WebGL）上下文或者硬件加速的 2D 上下文的<canvas>元素</li>
<li>组合型插件（即 Flash）</li>
<li>具有有 CSS 透明度动画或者使用动画式 Webkit 变换的元素</li>
<li>具有硬件加速的 CSS 滤镜的元素</li>
<li>子元素中存在具有组合层的元素的元素（换句话说，就是存在具有自己的层的子元素的元素）</li>
<li>同级元素中有 Z 索引比其小的元素，而且该 Z 索引比较小的元素具有组合层（换句话说就是在组合层之上进行渲染的元素）</li>
</ul>
<p>提升为合成层简单说来有以下几点好处</p>
<ul>
<li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快</li>
<li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</li>
<li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li>
</ul>
<p>合成层的好处是不会影响到其他元素的绘制，因此，为了减少动画元素对其他元素的影响，从而减少 paint，我们需要把动画效果中的元素提升为合成层。<br>提升合成层的最好方式是使用 CSS 的 will-change 属性。从上一节合成层产生原因中，可以知道 will-change 设置为 opacity、transform、top、left、bottom、right 可以将元素提升为合成层。<br>对于那些目前还不支持 will-change 属性的浏览器，目前常用的是使用一个 3D transform 属性来强制提升为合成层：transofrm: translateZ(0)<br>通常情况下开启硬件加速会提高动画的流畅性，但是过多的合成层也会造成性能瓶颈，过多的合成层会占用大量的内存空间，<br>对于合成层占用内存的问题，这里有两个 demo 进行了验证。<br><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://taobaofed.github.io/demo/performance-composite-demo/memory/multi-layers-expect.html">demo 1</a> 和 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://taobaofed.github.io/demo/performance-composite-demo/memory/multi-layers.html">demo 2</a> 中，会创建 2000 个同样的 div 元素，不同的是 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://taobaofed.github.io/demo/performance-composite-demo/memory/multi-layers.html">demo 2</a> 中的元素通过 will-change 都提升为了合成层，而两个 demo 页面的内存消耗却有很明显的差别。<br><img src="https://cdn.nlark.com/yuque/0/2021/webp/21377586/1619156221113-60d5de53-69da-44b1-8baa-f44ed8ba14a2.webp#clientId=u31f05833-5d5b-4&from=paste&height=436&id=u51e4f365&margin=%5Bobject%20Object%5D&originHeight=485&originWidth=947&originalType=url&status=done&style=none&taskId=u740ae6c5-5d30-4705-a621-dd62062dcc7&width=851.5"></p>
<h1 id="网页动画的渲染"><a href="#网页动画的渲染" class="headerlink" title="网页动画的渲染"></a>网页动画的渲染</h1><p>有一些 JavaScript 方法可以调节重新渲染，大幅提高网页性能。<br>其中最重要的，就是 window.requestAnimationFrame() 方法。它可以将某些代码放到下一次重新渲染时执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.requestAnimationFrame(fn);</span><br></pre></td></tr></table></figure>

<p>****window.requestIdleCallback()****也可以用来调节重新渲染。它指定只有当一帧的末尾有空闲时间，才会执行回调函数。只有当前帧的运行时间小于 16.66ms 时，函数 fn 才会执行。否则，就推迟到下一帧，如果下一帧也没有空闲时间，就推迟到下下一帧，以此类推</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestIdleCallback(fn);</span><br></pre></td></tr></table></figure>

<p>它还可以接受第二个参数，表示指定的毫秒数。如果在指定 的这段时间之内，每一帧都没有空闲时间，那么函数 fn 将会强制执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestIdleCallback(fn, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure>

<h1 id="Chrome-Devtool-Performance"><a href="#Chrome-Devtool-Performance" class="headerlink" title="Chrome Devtool Performance"></a>Chrome Devtool Performance</h1><p>怎么去分析页面运行时的性能表现，Chrome Devtool Performance 是一个很好的选择。这里请大家参考这篇文章<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://zhuanlan.zhihu.com/p/29879682">全新 Chrome Devtool Performance 使用指南</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/23/yuque/%E5%A4%A7%E9%87%8F%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/23/yuque/%E5%A4%A7%E9%87%8F%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">大量图片加载优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-23 12:51:07" itemprop="dateCreated datePublished" datetime="2021-04-23T12:51:07+08:00">2021-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-24 18:51:14" itemprop="dateModified" datetime="2021-04-24T18:51:14+08:00">2021-04-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>饿了么 App 中新零售项目主要是以图片展示为主，引导用户点击轮播广告栏或者店铺列表进入指定的商品页面，因此页面中包含了大量图片，如搜索框下面的轮播广告栏、中部的促销栏以及底部的店铺列表，这些区域中都有大量的展示图片。因此图片的加载速率直接影响页面的加载速度。下面将从图片加载存在的问题和原因、解决方案两个方面来阐述如何优化新零售图片的加载。<br>本文所有数据及图片都是通过<strong>Charles</strong>模拟 256 kbps ISDN/DSL 网络环境获取到的。在本案例中只考虑位图，因此文本中提及的图片都是指位图而非矢量图。</p>
<h2 id="图片加载存在的问题和原因"><a href="#图片加载存在的问题和原因" class="headerlink" title="图片加载存在的问题和原因"></a><strong>图片加载存在的问题和原因</strong></h2><p><strong>问题一</strong>：启动页面时加载过多图片<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619153486011-145891ec-7533-447d-b37b-6f016bcf2b43.jpeg#clientId=uc716cf97-bcfe-4&from=paste&height=629&id=ub4ea3c13&margin=%5Bobject%20Object%5D&originHeight=629&originWidth=720&originalType=url&status=done&style=none&taskId=ud5c99b57-f1f0-4c88-add8-1a4d8e4cc19&width=720"><br><strong>图 1</strong>： 新零售图片请求瀑布图<br><strong>问题原因分析：</strong>如上图所示，页面启动时加载了大约 49 张图片（具体图片数量会根据后端返回数据而变化），而这些图片请求几乎是并发的，在 Chrome 浏览器，对于同一个域名，最多支持 6 个请求的并发，其他的请求将会推入到队列中等待或者停滞不前，直到六个请求之一完成后，队列中新的请求才会发出。上面的瀑布图中，在绿色的标记框中，我们看到不同长度的白色横柱，这些都是请求的图片资源排队等待时间。</p>
<p><strong>问题二</strong>：部分图片体积过大<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619153789647-3253d48a-a3bc-4500-b720-6d185883da54.jpeg#clientId=uc716cf97-bcfe-4&from=paste&height=397&id=ufd4c09a4&margin=%5Bobject%20Object%5D&originHeight=498&originWidth=1050&originalType=url&status=done&style=none&taskId=u2e8adb8b-92bb-4682-85af-359c994c07d&width=836"><br><strong>图 2.<strong>顶部轮播图中的一张图片加载图<br><strong>问题原因分析：</strong>如图 1，红框中是搜索框下部的轮播广告中的一张图片，通过图 2 可以看到，该图片主要耗时在 Conent Download 阶段。在下载阶段耗时 13.50s。而该请求的总共时间也就 13.78s。产生该问题的原因从图 1 也能看出一些端倪，该图片体积 76.2KB，</strong>图片体积过大</strong>，直接导致了下载图片时间过长。</p>
<h2 id="前端解决方案"><a href="#前端解决方案" class="headerlink" title="前端解决方案"></a><strong>前端解决方案</strong></h2><p><strong>针对问题一的解决方案</strong><br>由于新零售首页展示展示大量图片，其实在这大约 49 张图片中，大部分图片都不是首屏所需的，因此可以延迟首屏不需要的图片加载，而优先加载首屏所需图片。这儿<strong>首屏</strong>的含义是指打开新零售首页首先进入屏幕视窗内的区域范围。<br>判断图片是否是首屏内图片，首先想到的肯定是通过 getBoundingClientRect 方法，获取到图片的位置信息，判断其是否在 viewport 内部。可能的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inViewport = <span class="function">(<span class="params">el</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> rect = el.getBoundingClientRect();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    rect.top &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">    rect.bottom &lt; <span class="built_in">window</span>.innerHeight &amp;&amp;</span><br><span class="line">    rect.left &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">    rect.right &lt; <span class="built_in">window</span>.innerWidth</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是在项目中，我们并没有采用该方案来判断是否在首屏，其原因在于，只有当 DOM 元素插入到 DOM 树中，并且页面进行重排和重绘后，我们才能够知道该元素是否在首屏中。在项目中我们使用了<a href="https://link.zhihu.com/?target=https://github.com/ElemeFE/vue-img">v-img</a>指令（新零售项目使用该指令对图片进行加载、并且将 hash 转换成 Url。项目已开源，在符合需求前提下欢迎使用），在 Vue 指令中包含两个钩子函数 bind 和 inserted。官网对这两个钩子函数进行如下解释：</p>
<ul>
<li>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</li>
<li>inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</li>
</ul>
<p>由上面解释可知，我们只能够在 inserted 钩子函数中才能够获取到元素的位置，并且判断其是否在首屏中。在新零售项目中，经过笔者测试，这两个钩子函数的触发时差大约是 200ms，因此如果在 inserted 钩子函数内再去加载图片就会比在 bind 钩子函数中加载晚大约 200ms，在 4G 网络环境下，200ms 对于很多图片来说已经足够用来加载了，因此我们最终放弃了在 inserted 钩子函数中加载首屏图片的方案。</p>
<p><strong>如果元素没有插入到 DOM 树中并渲染，怎么能够判断其是否在首屏中呢？</strong></p>
<blockquote>
<img v-img="{ hash: 'xxx', defer: true }">
</blockquote>
<p>项目中使用了一种比较笨的方式来判断哪些是首屏图片，新零售页面布局是确定的，轮播广告栏下面是促销栏、再下面是店铺列表，这些组件的高度也都相对固定，因此这些组件是否在首屏中其实我们是事先知道的。因此在实际使用<a href="https://link.zhihu.com/?target=https://github.com/ElemeFE/vue-img">v-img</a>指令的时候，通过传 defer 配置项来告诉 v-img 哪些图片需要提前加载，哪些图片等待提前加载的图片加载完毕后再加载。这样我们就能够在 bind 钩子函数中加载优先加载的图片了。比如说，轮播组件图片、促销组件图片、前两个店铺中的展示图片需要先加载，除此以外的其他图片，需等待首屏图片完全加载后再进行请求加载。实际实现代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = []; <span class="comment">// 用来存储优先加载的图片</span></span><br><span class="line">Vue.directive(<span class="string">&quot;img&quot;</span>, &#123;</span><br><span class="line">  <span class="function"><span class="title">bind</span>(<span class="params">el, binding, vnode</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> &#123; defer &#125; = binding.value;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (!defer) &#123;</span><br><span class="line">      promises.push(update(el, binding, vnode));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">inserted</span>(<span class="params">el, binding, vnode</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; defer &#125; = binding.value;</span><br><span class="line">    <span class="keyword">if</span> (!defer) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (inViewport(el)) &#123;</span><br><span class="line">      promises.push(update(el, binding, vnode));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Vue.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">Promise</span>.all(promises)</span><br><span class="line">          .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            promises.length = <span class="number">0</span>;</span><br><span class="line">            update(el, binding, vnode);</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>首先通过声明一个数组 promises 用于存储优先加载的图片，在 bind 钩子函数内部，如果 defer 配置项为 false，说明不延时加载，那么就在 bind 钩子函数内部加载该图片，且将返回的 promise 推入到 promises 数组中。在 inserted 钩子函数内，对于延迟加载的图片（defer 为 true），但是其又在首屏内，那么也有优先加载权，在 inseted 钩子函数调用时就对其加载。而对于非首屏且延迟加载的图片等待 promises 数组内部所有的图片都加载完成后才加载。当然在实际代码中还会考虑容错机制，比如上面某张图片加载失败、或者加载时间太长等。因此我们可以配置一个最大等待时间。<br>优化后的图片加载瀑布图如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619154236444-47386cf6-0b09-40ee-b395-4b4d4584cba4.jpeg#clientId=uc716cf97-bcfe-4&from=paste&height=732&id=ue2cc6cb2&margin=%5Bobject%20Object%5D&originHeight=732&originWidth=720&originalType=url&status=done&style=none&taskId=u778a9e8a-2981-4ffa-9a6c-4dc6e9d9663&width=720"><br><strong>图 3</strong>. 图片按需加载的瀑布图<br>如上图所示，下面红框的图片不是首屏图片，因此进行了延迟加载。可以看出，其是在上面所有图片（包括上面的红框中耗时最长的那张图）加载完成之后进行加载的。这样减少了首屏加载时的网络消耗，提升了图片下载速度。<br><strong>优化前后对比</strong><br>通过上面的优化方案，在预设的网络环境下（参见文末注），分别对优化前和优化后进行了 5 次平行清空缓存加载，平均数据如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619154254755-bcd04db3-16bf-4846-8819-9e80588679bf.jpeg#clientId=uc716cf97-bcfe-4&from=paste&height=130&id=u00930861&margin=%5Bobject%20Object%5D&originHeight=130&originWidth=720&originalType=url&status=done&style=none&taskId=uac8e2e49-a999-4b0e-9e3c-e6b7b96b23c&width=720"><br>通过上面表格可以看出，DOMContentLoaded 和 Loaded 并没有多大参考价值，首屏的完整展现所需要的时间依然由加载最慢（一般都是体积最大那张图片）的图片决定，也就是上表的 Max_size_image 决定，上表可以看出，优化后比优化前最大体积图片的加载时间缩短了<strong>5.74s</strong>。提速了整整**41.41%**。加载最慢的图片加载速度的变化也很好的反应了首屏时间的变化。<br>当然上面的数据也不能够完全反应线上场景，毕竟测试的时间点及后端数据都有所不同。我们也不能够在同一时间点、同一网络环境下对优化前、优化后进行同时数据采集。<br><strong>针对问题一还有些后续的解决方案：</strong></p>
<ul>
<li>在 HTTP/1.0 和 HTTP/1.1 协议下，由于 Chrome 只支持同域同时发送 6 个并发请求，可以进行域名切分，来提升并发的请求数量，或者使用 HTTP/2 协议。</li>
</ul>
<p><strong>针对问题二的解决方案</strong><br><strong>图片体积过大，导致下载时间过长。</strong>在保证清晰度的前提下尽量使用体积较小的图片。而一张图片的体积由两个因素决定，该图片总的像素数目和编码单位像素所需的字节数。因此一张图片的文件大小就等于图片总像素数目乘以编码单位像素所需字节数，也就是如下等式：<br>FileSize = Total Number Pixels _ Bytes of Encode single Pixels<br>举个例子：<br>一张 100px _ 100px 像素的图片，其包含该 100 _ 100 = 10000 个像素点，而每个像素点通过 RGBA 颜色值进行存储，R\G\B\A 每个色道都有 0~255 个取值，也就是 2^8 = 256。正好是 8 位 1byte。而每个像素点有四个色道，每个像素点需要 4bytes。因此该图片体积为：10000 _ 4bytes = 40000bytes = 39KB。<br>有了上面的背景知识后，我们就知道怎么去优化一张图片了，无非就两个方向：</p>
<ul>
<li>一方面是减少单位像素所需的字节数</li>
<li>另一方面是减少一张图片总的像素个数</li>
</ul>
<p><strong>单位像素优化</strong>：单位像素的优化也有两个方向，一个方向是「有损」的删除一些像素数据，另一个方面是做一些「无损」的图片像素压缩。正如上面例子所说，RGBA 颜色值可以表示 256^4 种颜色，这是一个很大的数字，往往我们不需要这么多颜色值，因此我们是否可以减少色板中的颜色种类呢？这样表示单位像素的字节数就减少了。而「无损」压缩是通过一些算法，存储像素数据不变的前提下，尽量减少图片存储体积。比如一张图片中的某一个像素点和其周围的像素点很接近，比如一张蓝天的图片，因此我们可以存储两个像素点颜色值的差值（当然实际算法中可能不止考虑两个像素点也许更多），这样既保证了像素数据的「无损」，同时也减少了存储体积。不过也增加了图片解压缩的开销。<br>针对单位像素的优化，衍生出了不同的图片格式，jpeg、png、gif、webp。不同的图片格式都有自己的减少单位像素体积的算法。同时也有各自的优势和劣势，比如 jpeg 和 png 不支持动画效果，jpeg 图片体积小但是不支持透明度等。因此项目在选择图片格式上的策略就是，在满足自己需求的前提下选择体积最小的图片格式，新零售项目中已经统一使用的 WebP 格式，和 jpeg 格式相比，其体积更减少 30%，同时还支持动画和透明度。<br><strong>图片像素总数优化</strong>：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619154330747-73f2544a-2ed5-4ff1-9ee2-ed1ad86eb358.png#clientId=uc716cf97-bcfe-4&from=paste&height=116&id=ude860fbe&margin=%5Bobject%20Object%5D&originHeight=116&originWidth=331&originalType=url&status=done&style=none&taskId=u4ee0138b-0e4d-4eef-9734-d1d71cddb27&width=331"><br><strong>图 4</strong>：图片加载尺寸和实际渲染尺寸对比<br>上图是新零售类目页在 Chrome 浏览器中的 iPhone 6 模拟器加载后的轮播展示的图片之一，展示的图片是 750 _ 188 像素，但是图片的实际尺寸为 1440 _ 360 像素，也就是说我们根本不需要这么大的图片，大图片不仅造成了图片加载的时长增加（后面会有数据说明），同时由于图片尺寸需要缩小增加 CPU 的负担。<br>上文中已经提及，项目中我们使用的 v-img 指令来加载项目中的所需图片，如果我们能够根据设备的尺寸来加载不同尺寸（像素总数不同）的图片，也就是说在保证图片清晰度的前提下，尽量使用体积小的图片，问题就迎刃而解了。项目中我们使用的是七牛的图片服务，<a href="https://link.zhihu.com/?target=https://developer.qiniu.com/dora/manual/1270/the-advanced-treatment-of-images-imagemogr2">七牛图片服务</a>提供了图片格式转换、按尺寸裁剪等图片处理功能。只需要对 v-img 指令添加图片宽、高的配置，那么我们是不是可以对不同的设备加载不同尺寸的图片呢？<br>项目中我们使用的<a href="https://link.zhihu.com/?target=https://github.com/amfe/lib-flexible">lib-flexible</a>来对不同的移动端设备进行适配，lib-flexible 库在我们页面的 html 元素添加了两个属性，data-dpr 和 style。这儿我们主要会用到 style 中的 font-size 值，在一定的设备范围内其正好是 html 元素宽度的十分之一（具体原理参见：<a href="https://link.zhihu.com/?target=http://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html">使用 Flexible 实现手淘 H5 页面的终端适配</a>），也就是说我们可以通过 style 属性大概获取到设备的宽度。同时设计稿又是以 iPhone6 为基础进行设计的，也就是设计稿是宽度为 750px 的设计图，这样在设计图中的图片大小我们也就能够转换成其他设备中所需的图片大小了。<br>举个例子：<br>设计稿中一张宽 200px 的图片，其对应的 iPhone 6 设备的宽度为 750px。我们通过 html 元素的 style 属性计算出 iPhone6 plus 的宽度为 1242px。这样也就能够计算中 iPhone6 plus 所需图片尺寸。计算如下：<br>200 * 1242 / 750 = 331.2px<br>实现代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resize = <span class="function">(<span class="params">size</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> viewWidth;</span><br><span class="line">  <span class="keyword">const</span> dpr = <span class="built_in">window</span>.devicePixelRatio;</span><br><span class="line">  <span class="keyword">const</span> html = <span class="built_in">document</span>.documentElement;</span><br><span class="line">  <span class="keyword">const</span> dataDpr = html.getAttribute(<span class="string">&quot;data-dpr&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> ratio = dataDpr ? dpr / dataDpr : dpr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    viewWidth = +(html.getAttribute(<span class="string">&quot;style&quot;</span>).match(<span class="regexp">/(\d+)/</span>) || [])[<span class="number">1</span>];</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">const</span> w = html.offsetWidth;</span><br><span class="line">    <span class="keyword">if</span> (w / dpr &gt; <span class="number">540</span>) &#123;</span><br><span class="line">      viewWidth = (<span class="number">540</span> * dpr) / <span class="number">10</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      viewWidth = w / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  viewWidth = viewWidth * ratio;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Number</span>(viewWidth) &gt;= <span class="number">0</span> &amp;&amp; <span class="keyword">typeof</span> viewWidth === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (size * viewWidth) / <span class="number">75</span>; <span class="comment">// 75 is the 1/10 iphone6 deivce width pixel</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面 resize 方法用于将配置的宽、高值转换为实际所需的图片尺寸，也就是说，size 参数是 iphone 6 设计稿中的尺寸，resize 的返回值就是当前设备所需的尺寸，再把该尺寸配置到图片服务器的传参中，这样我们就能够获取到按设备裁剪后的图片了。<br><strong>优化前后效果对比</strong>，有了上面的基础，我们在 Chrome 中的不同的移动端模拟器上进行了实验，我们对新零售类目页中的一张体积最大的广告图片在不同设备中的加载进行了数据统计（平行三次清空缓存加载），为什么选择体积最大的图片，上文也已经说过，其决定了首屏展现所需的时间。<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619154382774-f516ce8a-aed1-4a7f-9653-22d2d2a9df0f.jpeg#clientId=uc716cf97-bcfe-4&from=paste&height=285&id=u71f6c189&margin=%5Bobject%20Object%5D&originHeight=285&originWidth=720&originalType=url&status=done&style=none&taskId=ud752b764-d81b-44c4-8e9b-89083237490&width=720"><br>上表格中，除去最后一行是未优化的加载数据，从上到下，设备屏幕尺寸逐渐变大，加载的图片尺寸也从 23.2kb 增加到 65.5kb。而加载时间和下载时长也跟随着图片体积的加大而增加，下面的折线图更能够反应图片尺寸、加载时长、下载时长之间的正相关关系。TTFB（从发送请求到接收到第一个字节所需时长）却和图片大小没有明显的正相关关系，可能对于图片服务器在裁剪上述不同尺寸的图片所需时长差异不大。<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619154382719-89420942-d084-4bd2-b8ea-ea9fb2fc338c.jpeg#clientId=uc716cf97-bcfe-4&from=paste&height=300&id=ufa56ddca&margin=%5Bobject%20Object%5D&originHeight=300&originWidth=720&originalType=url&status=done&style=none&taskId=u92216d5c-ddd9-4719-87ef-028fcbc54d1&width=720"><br><strong>图 5</strong>：不同设备中对同一张图片进行加载，文件大小、加载和下载时长的折线变化<br>由上折线图我们还能看到，对于小屏幕设备的效果尤为明显，在不优化下，iPhone5 中图片的加载需要 14.85s，而优化后，加载时长缩短到了 3.90s。加载时长整整缩短了**73.73%<strong>。而对于大屏幕的 iPhone6 plus 也有</strong>26.00%<strong>时长优化。<br>当然上面的数据是建立在 256 kbps ISDN/DSL 的网络环境下的，该低速网络环境下，图片的加载时间主要是由于下载时间决定的，因此通过优化图片体积能够达到很好的效果。在 4G（Charles 模拟）环境下，iPhone5 中的优化效果就会有些折扣，加载时长缩短</strong>69.15%**。其实也很容易想到，在高速的网络环境下，TTFB 对加载时长的影响会比低速网络环境下影响要大一些。</p>
<h2 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a><strong>最后总结</strong></h2><p>通过上面的研究及数据结果表明，新零售图片加载缓慢的优化策略：</p>
<ul>
<li>首屏图片优先加载，等首屏图片加载完全后再去加载非首屏图片。</li>
<li>对大部分图片，特别是轮播广告中的图片进行按设备尺寸裁剪，减少图片体积，减少网络开销，加快下载速率。</li>
</ul>
<p>本文中没有过多的讨论代码实现细节，而是把重点放在了图片加载缓慢的原因分析，以及优化前后效果对比的数据分析上，如果想看更多代码细节，请移步<a href="https://link.zhihu.com/?target=https://github.com/ElemeFE/vue-img">vue-img</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/23/yuque/%E7%99%BD%E5%B1%8F%E6%97%B6%E9%97%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/23/yuque/%E7%99%BD%E5%B1%8F%E6%97%B6%E9%97%B4/" class="post-title-link" itemprop="url">白屏时间</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-23 12:22:29" itemprop="dateCreated datePublished" datetime="2021-04-23T12:22:29+08:00">2021-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-24 18:51:14" itemprop="dateModified" datetime="2021-04-24T18:51:14+08:00">2021-04-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该篇文章会为您分享在前端性能优化中非常重要的一环-白屏时间，将从白屏时间的概念、重要性以及白屏的过程一一进行阐述，同时提供性能优化的策略与实践。</p>
<h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p>白屏时间：即用户点击一个链接或打开浏览器输入 URL 地址后，从屏幕空白到显示第一个画面的时间。<br>白屏时间的长短将直接影响用户对该网站的第一印象。</p>
<h2 id="二、白屏时间的重要性"><a href="#二、白屏时间的重要性" class="headerlink" title="二、白屏时间的重要性"></a>二、白屏时间的重要性</h2><p>当用户点开一个链接或者是直接在浏览器中输入 URL 开始进行访问时，就开始等待页面的展示。页面渲染的时间越短，用户等待的时间就越短，用户感知到页面的速度就越快。这样可以极大的提升用户的体验，减少用户的跳出，提升页面的留存率。<br>打开一个页面就像你的女票召唤你一样，你出现的越迅速，女票肯定会愈加欣喜！反之，你千呼万唤始出来，那么你的女票很可能又要抛弃你了(为什么要对你说又呢? …)</p>
<h2 id="三、白屏是一个怎样的过程呢？"><a href="#三、白屏是一个怎样的过程呢？" class="headerlink" title="三、白屏是一个怎样的过程呢？"></a>三、白屏是一个怎样的过程呢？</h2><p>让我们一起来揭秘：从打开一个页面，到页面的画面展示经历了怎样的过程！</p>
<h3 id="1-DNS-Lookup"><a href="#1-DNS-Lookup" class="headerlink" title="1. DNS Lookup"></a>1. DNS Lookup</h3><p>DNS Lookup 即浏览器从 DNS 服务器中进行域名查询。<br>浏览器会先对页面进行<a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/cns?from=10680">域名解析</a>，获取到服务器的 IP 地址后，进而和服务器进行通信。<br>Tips: 通常在整个加载页面的过程中，浏览器会多次进行 DNS Lookup，包括页面本身的域名查询以及在解析 HTML 页面时加载的 JS、CSS、Image、Video 等资源产生的域名查询。</p>
<h3 id="2-建立-TCP-请求连接"><a href="#2-建立-TCP-请求连接" class="headerlink" title="2. 建立 TCP 请求连接"></a>2. 建立 TCP 请求连接</h3><p>浏览器和服务端 TCP 请求建立的过程，是基于 TCP/IP，该协议由网络层的 IP 和传输层的 TCP 组成。IP 是每一台互联网设备在互联网中的唯一地址。<br>TCP 通过三次握手建立连接，并提供可靠的数据传输服务。</p>
<h3 id="3-服务端请求处理响应"><a href="#3-服务端请求处理响应" class="headerlink" title="3. 服务端请求处理响应"></a>3. 服务端请求处理响应</h3><p>在 TCP 连接建立后，Web 服务器接受请求，开始进行处理，同时浏览器端开始等待服务器的处理响应。<br>Web 服务器根据请求类型的不同，进行相应的处理。静态资源如图片、CSS 文件、静态 HTML 直接进行响应；如其他注册的请求转发给相应的应用服务器，进行如数据处理、缓存中取数据，将数据按照约定好的格式响应给浏览器。<br>在大型应用中，通常为分布式服务架构，应用服务器的处理有可能经过很多个系统的中间件，最终获取到需要的数据</p>
<h3 id="4-客户端下载、解析、渲染显示页面"><a href="#4-客户端下载、解析、渲染显示页面" class="headerlink" title="4. 客户端下载、解析、渲染显示页面"></a>4. 客户端下载、解析、渲染显示页面</h3><p>在服务器返回数据后，客户端浏览器接收数据，进行 HTML 下载、解析、渲染显示。</p>
<ul>
<li>a. 如果是 Gzip 包，则先解压为 HTML</li>
<li>b. 解析 HTML 的头部代码，下载头部代码中的样式资源文件或脚本资源文件</li>
<li>c. 解析 HTML 代码和样式文件代码，构建 HTML 的 DOM 树以及与 CSS 相关的 CSSOM 树</li>
<li>d. 通过遍历 DOM 树和 CSSOM 树，浏览器依次计算每个节点的大小、坐标、颜色等样式，构造渲染树</li>
<li>e. 根据渲染树完成绘制过程</li>
</ul>
<p>浏览器下载 HTML 后，首先解析头部代码，进行样式表下载，然后继续向下解析 HTML 代码，构建 DOM 树，同时进行样式下载。当 DOM 树构建完成后，立即开始构造 CSSOM 树。理想情况下，样式表下载速度够快，DOM 树和 CSSOM 树进入一个并行的过程，当两棵树构建完毕，构建渲染树，然后进行绘制。<br>Tips:浏览器安全解析策略对解析 HTML 造成的影响：</p>
<ul>
<li>当解析 HTML 时遇到内联 JS 代码，会阻塞 DOM 树的构建</li>
<li>特别悲惨的情况： 当 CSS 样式文件没有下载完成时，浏览器解析 HTML 遇到了内联 JS 代码，此时！！！根据浏览器的安全解析策略，浏览器暂停 JS 脚本执行，暂停 HTML 解析。直到 CSS 文件下载完成，完成 CSSOM 树构建，重新恢复原来的解析。<br>一定要合理放置 JS 代码！！！</li>
</ul>
<h2 id="四、白屏-性能优化"><a href="#四、白屏-性能优化" class="headerlink" title="四、白屏-性能优化"></a>四、白屏-性能优化</h2><p>至此，我们已经了解了从浏览器在打开一个链接开始，到屏幕展示的过程-白屏时间的历程，那这对每个环节中发生的事情，我们可以有针对性的进行相关的优化。</p>
<h3 id="1-DNS-解析优化"><a href="#1-DNS-解析优化" class="headerlink" title="1. DNS 解析优化"></a>1. DNS 解析优化</h3><p>针对 DNS Lookup 环节，我们可以针对性的进行 DNS 解析优化。</p>
<ul>
<li>DNS 缓存优化</li>
<li>DNS 预加载策略</li>
<li>稳定可靠的 DNS 服务器</li>
</ul>
<h3 id="2-TCP-网络链路优化"><a href="#2-TCP-网络链路优化" class="headerlink" title="2. TCP 网络链路优化"></a>2. TCP 网络链路优化</h3><p>针对网络链路的优化，好像除了花钱没有什么更好的方式！</p>
<h3 id="3-服务端处理优化"><a href="#3-服务端处理优化" class="headerlink" title="3. 服务端处理优化"></a>3. 服务端处理优化</h3><p>服务端的处理优化，是一个非常庞大的话题，会涉及到如<a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/crs?from=10680">Redis</a>缓存、数据库存储优化或是系统内的各种中间件以及 Gzip 压缩等…</p>
<h3 id="4-浏览器下载、解析、渲染页面优化"><a href="#4-浏览器下载、解析、渲染页面优化" class="headerlink" title="4. 浏览器下载、解析、渲染页面优化"></a>4. 浏览器下载、解析、渲染页面优化</h3><p>根据浏览器对页面的下载、解析、渲染过程，可以考虑一下的优化处理：</p>
<ul>
<li>尽可能的精简 HTML 的代码和结构</li>
<li>尽可能的优化 CSS 文件和结构</li>
<li>一定要合理的放置 JS 代码，尽量不要使用内联的 JS 代码</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/23/yuque/%E9%87%8D%E6%8E%92%E5%92%8C%E9%87%8D%E7%BB%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/23/yuque/%E9%87%8D%E6%8E%92%E5%92%8C%E9%87%8D%E7%BB%98/" class="post-title-link" itemprop="url">重排和重绘</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-23 12:12:22" itemprop="dateCreated datePublished" datetime="2021-04-23T12:12:22+08:00">2021-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-24 18:51:14" itemprop="dateModified" datetime="2021-04-24T18:51:14+08:00">2021-04-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>本文首发于我的个人网站：<a target="_blank" rel="noopener" href="https://litgod.net/">litgod.net</a></p>
</blockquote>
<p>之前面试的大佬问我关于重排重绘的原理和具体操作，一下子把我问蒙了。回家便默默地把问题记下来，仔细总结……在阅读了一些文章后，自己也有了一定的理解，所以分享给大家。希望大家也能耐心把这篇文章看完，认真思考，彻底掌握这个知识点！</p>
<h2 id="页面生成的过程："><a href="#页面生成的过程：" class="headerlink" title="页面生成的过程："></a>页面生成的过程：</h2><p>1.HTML 被 HTML 解析器解析成 DOM 树；</p>
<p>2.CSS 被 CSS 解析器解析成 CSSOM 树；</p>
<p>3.结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment；</p>
<p>4.生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点；</p>
<p>5.将布局绘制(paint)在屏幕上，显示出整个页面。</p>
<p>第四步和第五步是最耗时的部分，这两步合起来，就是我们通常所说的渲染。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619151461786-9b1a1f67-2d18-41da-a534-6348a8210d4c.png#clientId=u94e07666-41db-4&from=drop&id=udd3e394b&margin=%5Bobject%20Object%5D&name=1.png&originHeight=313&originWidth=800&originalType=binary&size=42085&status=done&style=none&taskId=u4de619f6-97ac-4982-99da-91a5b369896" alt="1.png"></p>
<h2 id="渲染："><a href="#渲染：" class="headerlink" title="渲染："></a>渲染：</h2><p>在页面的生命周期中，**网页生成的时候，至少会渲染一次。在用户访问的过程中，还会不断触发重排(reflow)和重绘(repaint)**，不管页面发生了重绘还是重排，都会影响性能，最可怕的是重排，会使我们付出高额的性能代价，所以我们应尽量避免。</p>
<h2 id="重排比重绘大："><a href="#重排比重绘大：" class="headerlink" title="重排比重绘大："></a>重排比重绘大：</h2><p>大，在这个语境里的意思是：谁能影响谁？</p>
<ul>
<li>重绘：某些元素的外观被改变，例如：元素的填充颜色</li>
<li>重排：重新生成布局，重新排列元素。</li>
</ul>
<p>就如上面的概念一样，单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分。比如改变元素高度，这个元素乃至周边 dom 都需要重新绘制。</p>
<p>也就是说：<strong>重绘不一定导致重排，但重排一定会导致重绘</strong>。</p>
<h2 id="重排-reflow-："><a href="#重排-reflow-：" class="headerlink" title="重排(reflow)："></a>重排(reflow)：</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>当 DOM 的变化影响了元素的几何信息(元素的的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。</p>
<p>重排也叫回流，简单的说就是重新生成布局，重新排列元素。</p>
<h3 id="下面情况会发生重排："><a href="#下面情况会发生重排：" class="headerlink" title="下面情况会发生重排："></a>下面情况会发生重排：</h3><ul>
<li>页面初始渲染，这是开销最大的一次重排</li>
<li>添加/删除可见的 DOM 元素</li>
<li>改变元素位置</li>
<li>改变元素尺寸，比如边距、填充、边框、宽度和高度等</li>
<li>改变元素内容，比如文字数量，图片大小等</li>
<li>改变元素字体大小</li>
<li>改变浏览器窗口尺寸，比如 resize 事件发生时</li>
<li>激活 CSS 伪类（例如：<code>:hover</code>）</li>
<li>设置 style 属性的值，因为通过设置 style 属性改变结点样式的话，每一次设置都会触发一次 reflow</li>
<li>查询某些属性或调用某些计算方法：offsetWidth、offsetHeight 等，除此之外，当我们调用 <code>getComputedStyle</code>方法，或者 IE 里的 <code>currentStyle</code> 时，也会触发重排，原理是一样的，都为求一个“即时性”和“准确性”。<table>
<thead>
<tr>
<th>常见引起重排属性和方法</th>
<th>–</th>
<th>–</th>
<th>–</th>
</tr>
</thead>
<tbody><tr>
<td>width</td>
<td>height</td>
<td>margin</td>
<td>padding</td>
</tr>
<tr>
<td>display</td>
<td>border-width</td>
<td>border</td>
<td>position</td>
</tr>
<tr>
<td>overflow</td>
<td>font-size</td>
<td>vertical-align</td>
<td>min-height</td>
</tr>
<tr>
<td>clientWidth</td>
<td>clientHeight</td>
<td>clientTop</td>
<td>clientLeft</td>
</tr>
<tr>
<td>offsetWudth</td>
<td>offsetHeight</td>
<td>offsetTop</td>
<td>offsetLeft</td>
</tr>
<tr>
<td>scrollWidth</td>
<td>scrollHeight</td>
<td>scrollTop</td>
<td>scrollLeft</td>
</tr>
<tr>
<td>scrollIntoView()</td>
<td>scrollTo()</td>
<td>getComputedStyle()</td>
<td></td>
</tr>
<tr>
<td>getBoundingClientRect()</td>
<td>scrollIntoViewIfNeeded()</td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="重排影响的范围："><a href="#重排影响的范围：" class="headerlink" title="重排影响的范围："></a>重排影响的范围：</h3><p>由于浏览器渲染界面是基于流失布局模型的，所以触发重排时会对周围 DOM 重新排列，影响的范围有两种：</p>
<ul>
<li>全局范围：从根节点 html 开始对整个渲染树进行重新布局。</li>
<li>局部范围：对渲染树的某部分或某一个渲染对象进行重新布局</li>
</ul>
<p><strong>全局范围重排：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;hello&quot;&gt;</span><br><span class="line">    &lt;h4&gt;hello&lt;&#x2F;h4&gt;</span><br><span class="line">    &lt;p&gt;&lt;strong&gt;Name:&lt;&#x2F;strong&gt;BDing&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;h5&gt;male&lt;&#x2F;h5&gt;</span><br><span class="line">    &lt;ol&gt;</span><br><span class="line">      &lt;li&gt;coding&lt;&#x2F;li&gt;</span><br><span class="line">      &lt;li&gt;loving&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ol&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<p>当 p 节点上发生 reflow 时，hello 和 body 也会重新渲染，甚至 h5 和 ol 都会收到影响。</p>
<p><strong>局部范围重排：</strong></p>
<p>用局部布局来解释这种现象：把一个 dom 的宽高之类的几何信息定死，然后在 dom 内部触发重排，就只会重新渲染该 dom 内部的元素，而不会影响到外界。</p>
<h2 id="重绘-Repaints"><a href="#重绘-Repaints" class="headerlink" title="重绘(Repaints):"></a>重绘(Repaints):</h2><h3 id="概念：-1"><a href="#概念：-1" class="headerlink" title="概念："></a>概念：</h3><p>当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。</p>
<h3 id="常见的引起重绘的属性："><a href="#常见的引起重绘的属性：" class="headerlink" title="常见的引起重绘的属性："></a>常见的引起重绘的属性：</h3><table>
<thead>
<tr>
<th>属性：</th>
<th>–</th>
<th>–</th>
<th>–</th>
</tr>
</thead>
<tbody><tr>
<td>color</td>
<td>border-style</td>
<td>visibility</td>
<td>background</td>
</tr>
<tr>
<td>text-decoration</td>
<td>background-image</td>
<td>background-position</td>
<td>background-repeat</td>
</tr>
<tr>
<td>outline-color</td>
<td>outline</td>
<td>outline-style</td>
<td>border-radius</td>
</tr>
<tr>
<td>outline-width</td>
<td>box-shadow</td>
<td>background-size</td>
<td></td>
</tr>
</tbody></table>
<h2 id="重排优化建议："><a href="#重排优化建议：" class="headerlink" title="重排优化建议："></a>重排优化建议：</h2><p>重排的代价是高昂的，会破坏用户体验，并且让 UI 展示非常迟缓。通过减少重排的负面影响来提高用户体验的最简单方式就是尽可能的减少重排次数，重排范围。下面是一些行之有效的建议，大家可以用来参考。</p>
<h3 id="减少重排范围"><a href="#减少重排范围" class="headerlink" title="减少重排范围"></a>减少重排范围</h3><p>我们应该尽量以局部布局的形式组织 html 结构，尽可能小的影响重排的范围。</p>
<ul>
<li>尽可能在低层级的 DOM 节点上，而不是像上述全局范围的示例代码一样，如果你要改变 p 的样式，class 就不要加在 div 上，通过父元素去影响子元素不好。</li>
<li>不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局。那么在不得已使用 table 的场合，可以设置 table-layout:auto;或者是 table-layout:fixed 这样可以让 table 一行一行的渲染，这种做法也是为了限制 reflow 的影响范围。</li>
</ul>
<h3 id="减少重排次数"><a href="#减少重排次数" class="headerlink" title="减少重排次数"></a>减少重排次数</h3><h4 id="1-样式集中改变"><a href="#1-样式集中改变" class="headerlink" title="1.样式集中改变"></a>1.样式集中改变</h4><p>不要频繁的操作样式，对于一个静态页面来说，明智且可维护的做法是更改类名而不是修改样式，对于动态改变的样式来说，相较每次微小修改都直接触及元素，更好的办法是统一在 <code>cssText</code> 变量中编辑。虽然现在大部分现代浏览器都会有 <code>Flush</code> 队列进行渲染队列优化，但是有些老版本的浏览器比如 IE6 的效率依然低下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; bad</span><br><span class="line">var left &#x3D; 10;</span><br><span class="line">var top &#x3D; 10;</span><br><span class="line">el.style.left &#x3D; left + &quot;px&quot;;</span><br><span class="line">el.style.top &#x3D; top + &quot;px&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当top和left的值是动态计算而成时...</span><br><span class="line">&#x2F;&#x2F; better</span><br><span class="line">el.style.cssText +&#x3D; &quot;; left: &quot; + left + &quot;px; top: &quot; + top + &quot;px;&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; better</span><br><span class="line">el.className +&#x3D; &quot; className&quot;;</span><br></pre></td></tr></table></figure>

<h4 id="2-分离读写操作"><a href="#2-分离读写操作" class="headerlink" title="2.分离读写操作"></a>2.分离读写操作</h4><p>DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; bad 强制刷新 触发四次重排+重绘</span><br><span class="line">div.style.left &#x3D; div.offsetLeft + 1 + &#39;px&#39;;</span><br><span class="line">div.style.top &#x3D; div.offsetTop + 1 + &#39;px&#39;;</span><br><span class="line">div.style.right &#x3D; div.offsetRight + 1 + &#39;px&#39;;</span><br><span class="line">div.style.bottom &#x3D; div.offsetBottom + 1 + &#39;px&#39;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; good 缓存布局信息 相当于读写分离 触发一次重排+重绘</span><br><span class="line">var curLeft &#x3D; div.offsetLeft;</span><br><span class="line">var curTop &#x3D; div.offsetTop;</span><br><span class="line">var curRight &#x3D; div.offsetRight;</span><br><span class="line">var curBottom &#x3D; div.offsetBottom;</span><br><span class="line"></span><br><span class="line">div.style.left &#x3D; curLeft + 1 + &#39;px&#39;;</span><br><span class="line">div.style.top &#x3D; curTop + 1 + &#39;px&#39;;</span><br><span class="line">div.style.right &#x3D; curRight + 1 + &#39;px&#39;;</span><br><span class="line">div.style.bottom &#x3D; curBottom + 1 + &#39;px&#39;;</span><br></pre></td></tr></table></figure>

<p>原来的操作会导致四次重排，读写分离之后实际上只触发了一次重排，这都得益于浏览器的渲染队列机制：</p>
<blockquote>
<p>当我们修改了元素的几何属性，导致浏览器触发重排或重绘时。它会把该操作放进渲染队列，等到队列中的操作到了一定的数量或者到了一定的时间间隔时，浏览器就会批量执行这些操作。</p>
</blockquote>
<h4 id="3-将-DOM-离线"><a href="#3-将-DOM-离线" class="headerlink" title="3.将 DOM 离线"></a>3.将 DOM 离线</h4><p>“离线”意味着不在当前的 DOM 树中做修改，我们可以这样做：</p>
<ul>
<li>使用 display:none</li>
</ul>
<p>一旦我们给元素设置 <code>display:none</code> 时（只有一次重排重绘），元素便不会再存在在渲染树中，相当于将其从页面上“拿掉”，我们之后的操作将不会触发重排和重绘，添加足够多的变更后，通过 <code>display</code>属性显示（另一次重排重绘）。通过这种方式即使大量变更也只触发两次重排。另外，<code>visibility : hidden</code> 的元素只对重绘有影响，不影响重排。</p>
<ul>
<li>通过 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment">documentFragment</a> 创建一个 <code>dom</code> 碎片,在它上面批量操作 <code>dom</code>，操作完成之后，再添加到文档中，这样只会触发一次重排。</li>
<li>复制节点，在副本上工作，然后替换它！</li>
</ul>
<h4 id="4-使用-absolute-或-fixed-脱离文档流"><a href="#4-使用-absolute-或-fixed-脱离文档流" class="headerlink" title="4.使用 absolute 或 fixed 脱离文档流"></a>4.使用 absolute 或 fixed 脱离文档流</h4><p>使用绝对定位会使的该元素单独成为渲染树中 <code>body</code> 的一个子元素，重排开销比较小，不会对其它节点造成太多影响。当你在这些节点上放置这个元素时，一些其它在这个区域内的节点可能需要重绘，但是不需要重排。</p>
<h4 id="5-优化动画"><a href="#5-优化动画" class="headerlink" title="5.优化动画"></a>5.优化动画</h4><ul>
<li><p>可以把动画效果应用到 <code>position</code>属性为 <code>absolute</code> 或 <code>fixed</code> 的元素上，这样对其他元素影响较小。<br>动画效果还应牺牲一些平滑，来换取速度，这中间的度自己衡量： 比如实现一个动画，以 1 个像素为单位移动这样最平滑，但是 Layout 就会过于频繁，大量消耗 CPU 资源，如果以 3 个像素为单位移动则会好很多</p>
</li>
<li><p>启用 GPU 加速 <code>GPU</code> 硬件加速是指应用 <code>GPU</code> 的图形性能对浏览器中的一些图形操作交给 <code>GPU</code> 来完成，因为 <code>GPU</code> 是专门为处理图形而设计，所以它在速度和能耗上更有效率。<br><code>GPU</code> 加速通常包括以下几个部分：Canvas2D，布局合成, CSS3 转换（transitions），CSS3 3D 变换（transforms），WebGL 和视频(video)。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">* 根据上面的结论</span><br><span class="line">* 将 2d transform 换成 3d</span><br><span class="line">* 就可以强制开启 GPU 加速</span><br><span class="line">* 提高动画性能</span><br><span class="line">*&#x2F;</span><br><span class="line">div &#123;</span><br><span class="line">  transform: translate3d(10px, 10px, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何在浏览器中查看页面渲染时间"><a href="#如何在浏览器中查看页面渲染时间" class="headerlink" title="如何在浏览器中查看页面渲染时间"></a>如何在浏览器中查看页面渲染时间</h2><p>1.打开开发者工具：点击 Performance 左侧有个小圆点 点击刷新页面会录制整个页面加载出来 时间的分配情况。如下图</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619151494645-c4bd51a8-0e69-4887-a6bf-c7f909c9bb6f.png#clientId=u94e07666-41db-4&from=drop&id=u03928006&margin=%5Bobject%20Object%5D&name=2.png&originHeight=829&originWidth=680&originalType=binary&size=147234&status=done&style=none&taskId=u0b1eddf4-9c59-4f4c-a2a6-80a7f6195e0" alt="2.png"></p>
<ul>
<li>蓝色: 网络通信和 HTML 解析</li>
<li>黄色: JavaScript 执行</li>
<li>紫色: 样式计算和布局，即重排</li>
<li>绿色: 重绘</li>
</ul>
<p>哪种色块比较多，就说明性能耗费在那里。色块越长，问题越大。</p>
<p>2.点击 Event Log：单独勾选 Loading 项会显示 html 和 css 加载时间。如下图：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619151540816-61f9df67-3054-4b8e-a2e7-da929d01eb77.png#clientId=u94e07666-41db-4&from=drop&id=u59c3d491&margin=%5Bobject%20Object%5D&name=3.png&originHeight=621&originWidth=675&originalType=binary&size=118065&status=done&style=none&taskId=u6ead564e-4a04-47ed-b5da-5ff10cdf20d" alt="3.png"></p>
<p>3.解析完 DOM+CSSOM 之后会生成一个渲染树 Render Tree，就是 DOM 和 CSSOM 的一一对应关系。</p>
<p>4.通过渲染树中在屏幕上“画”出的所有节点，称为渲染。</p>
<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><ul>
<li>渲染的三个阶段 Layout，Paint，Composite Layers。 Layout：重排，又叫回流。 Paint:重绘，重排重绘这些步骤都是在 CPU 中发生的。 Compostite Layers：CPU 把生成的 BitMap（位图）传输到 GPU，渲染到屏幕。</li>
<li>CSS3 就是在 GPU 发生的：Transform Opacity。在 GPU 发生的属性比较高效。所以 CSS3 性能比较高。</li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>非常感谢你看完了这篇很长的文章，也希望大家能重视重排的这些问题，在我们平时的开发中，也需要有意识的规避这些问题，才能让我们写出来的代码更规范！</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000017491520">掌握浏览器重绘(repaint)重排(reflow))-前端进阶</a></p>
<p><a target="_blank" rel="noopener" href="https://csstriggers.com/">csstriggers</a></p>
<p><a target="_blank" rel="noopener" href="https://efe.baidu.com/blog/hardware-accelerated-css-the-nice-vs-the-naughty/">CSS 硬件加速的好与坏</a></p>
<p>欢迎大家关注我的公众号，一起研究前端技术，期待与你共同进步。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619151550276-0ea0bf43-ec4c-4ce2-880a-8c726fd04a0b.jpeg#clientId=u94e07666-41db-4&from=drop&id=u5ca8fd73&margin=%5Bobject%20Object%5D&name=4.jpg&originHeight=649&originWidth=1500&originalType=binary&size=306289&status=done&style=none&taskId=u8098271c-bb28-4ba5-9b04-4c5316ef2bf" alt="4.jpg"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/23/yuque/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/23/yuque/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5/" class="post-title-link" itemprop="url">性能优化手段</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-23 12:09:55" itemprop="dateCreated datePublished" datetime="2021-04-23T12:09:55+08:00">2021-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-24 18:51:14" itemprop="dateModified" datetime="2021-04-24T18:51:14+08:00">2021-04-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619151042204-47a6c0b4-9803-47d8-8c30-4250196c6c45.png#clientId=u36fa501e-dc3b-4&from=paste&height=2948&id=u21574d4d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=2948&originWidth=1063&originalType=binary&size=251688&status=done&style=none&taskId=uc2d5a027-1c85-4cf1-b38e-b8a955834e2&width=1063" alt="image.png"><br><a target="_blank" rel="noopener" href="https://alienzhou.com/projects/fe-performance-journey/#%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9F">性能优化网站</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/23/yuque/RAIL%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/23/yuque/RAIL%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">RAIL模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-23 12:03:14" itemprop="dateCreated datePublished" datetime="2021-04-23T12:03:14+08:00">2021-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-24 18:51:14" itemprop="dateModified" datetime="2021-04-24T18:51:14+08:00">2021-04-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>RAIL 是一个以用户为中心的性能模型，它把用户的体验拆分成几个关键点（例如，tap，scroll，load），并且帮你定义好了每一个的性能指标。</p>
<p>有以下四个方面：</p>
<ul>
<li>Response</li>
<li>Animation</li>
<li>Idle</li>
<li>Load</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619150771872-117600c0-b2a9-43ed-a90b-b8247570bdff.png#clientId=ub5665ef9-7048-4&from=drop&id=u486a7804&margin=%5Bobject%20Object%5D&name=1.png&originHeight=504&originWidth=1390&originalType=binary&size=53426&status=done&style=none&taskId=u9d743441-e052-4807-8e12-3db9d757539" alt="1.png"></p>
<h2 id="聚焦用户"><a href="#聚焦用户" class="headerlink" title="聚焦用户"></a>聚焦用户</h2><p>以下是用户对性能延迟的感知：</p>
<table>
<thead>
<tr>
<th>延迟时间</th>
<th>用户感知</th>
</tr>
</thead>
<tbody><tr>
<td>0-16ms</td>
<td>很流畅</td>
</tr>
<tr>
<td>0-100ms</td>
<td>基本流畅</td>
</tr>
<tr>
<td>100-1000ms</td>
<td>感觉到网站上有一些加载任务</td>
</tr>
<tr>
<td>1000ms or more</td>
<td>失去耐心了</td>
</tr>
<tr>
<td>10000ms or more</td>
<td>直接离开，不会再访问了</td>
</tr>
</tbody></table>
<h2 id="Response-事件处理最好在-50ms-内完成"><a href="#Response-事件处理最好在-50ms-内完成" class="headerlink" title="Response: 事件处理最好在 50ms 内完成"></a>Response: 事件处理最好在 50ms 内完成</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul>
<li>用户的输入到响应的时间不超过 100ms，给用户的感受是瞬间就完成了。</li>
</ul>
<h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><ul>
<li>事件处理函数在 50ms 内完成，考虑到 idle task 的情况，事件会排队，等待时间大概在 50ms。适用于 click，toggle，starting animations 等，不适用于 drag 和 scroll。</li>
<li>复杂的 js 计算尽可能放在后台，如 web worker，避免对用户输入造成阻塞</li>
<li>超过 50ms 的响应，一定要提供反馈，比如倒计时，进度百分比等。</li>
</ul>
<blockquote>
<p>idle task：除了要处理输入事件，浏览器还有其它任务要做，这些任务会占用部分时间，一般情况会花费 50ms 的时间，输入事件的响应则排在其后。</p>
</blockquote>
<p>下图是 idle task 对 input response 的影响：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619150777984-c9507c61-f117-4ce2-923a-8ee977344b57.png#clientId=ub5665ef9-7048-4&from=drop&id=u97430f32&margin=%5Bobject%20Object%5D&name=2.png&originHeight=1200&originWidth=2400&originalType=binary&size=235602&status=done&style=none&taskId=u4b853e52-ee45-4c14-8c7f-bdb6320bad2" alt="2.png"></p>
<h2 id="Animation-在-10ms-内产生一帧"><a href="#Animation-在-10ms-内产生一帧" class="headerlink" title="Animation: 在 10ms 内产生一帧"></a>Animation: 在 10ms 内产生一帧</h2><h3 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h3><ul>
<li>产生每一帧的时间不要超过 10ms，为了保证浏览器 60 帧，每一帧的时间在 16ms 左右，但浏览器需要用 6ms 来渲染每一帧。</li>
<li>旨在视觉上的平滑。用户对帧率变化感知很敏感。</li>
</ul>
<h3 id="优化方案-1"><a href="#优化方案-1" class="headerlink" title="优化方案"></a>优化方案</h3><ul>
<li>在一些高压点上，比如动画，不要去挑战 cpu，尽可能地少做事，如：取 offset，设置 style 等操作。尽可能地保证 60 帧的体验。</li>
<li>在渲染性能上，针对不同的动画做一些特定优化</li>
</ul>
<blockquote>
<p>动画不只是 UI 的视觉效果，以下行为都属于</p>
</blockquote>
<blockquote>
<ul>
<li>视觉动画，如渐隐渐显，tweens，loading 等</li>
<li>滚动，包含弹性滚动，松开手指后，滚动会持续一段距离</li>
<li>拖拽，缩放，经常伴随着用户行为</li>
</ul>
</blockquote>
<h2 id="Idle-最大化空闲时间"><a href="#Idle-最大化空闲时间" class="headerlink" title="Idle: 最大化空闲时间"></a>Idle: 最大化空闲时间</h2><h3 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h3><ul>
<li>最大化空闲时间，以增大 50ms 内响应用户输入的几率</li>
</ul>
<h3 id="优化方案-2"><a href="#优化方案-2" class="headerlink" title="优化方案"></a>优化方案</h3><ul>
<li>用空闲时间来完成一些延后的工作，如先加载页面可见的部分，然后利用空闲时间加载剩余部分，此处可以使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback">requestIdleCallback API</a></li>
<li>在空闲时间内执行的任务尽量控制在 50ms 以内，如果更长的话，会影响 input handle 的 pending 时间</li>
<li>如果用户在空闲时间任务进行时进行交互，必须以此为最高优先级，并暂停空闲时间的任务</li>
</ul>
<h2 id="Load-传输内容到页面可交互的时间不超过-5-秒"><a href="#Load-传输内容到页面可交互的时间不超过-5-秒" class="headerlink" title="Load: 传输内容到页面可交互的时间不超过 5 秒"></a>Load: 传输内容到页面可交互的时间不超过 5 秒</h2><p>如果页面加载比较慢，用户的交点可能会离开。加载很快的页面，用户平均停留时间会变长，跳出率会更低，也就有更高的广告查看率</p>
<h3 id="目标-3"><a href="#目标-3" class="headerlink" title="目标"></a>目标</h3><ul>
<li>优化加载速度，可以根据设备、网络等条件。目前，比较好的一个方式是，让你的页面在一个中配的 3G 网络手机上打开时间不超过 5 秒</li>
<li>对于第二次打开，尽量不超过 2 秒</li>
</ul>
<h3 id="优化方案-3"><a href="#优化方案-3" class="headerlink" title="优化方案"></a>优化方案</h3><ul>
<li>在手机设备上测试加载性能，选用中配的 3G 网络（400kb/s，400ms RTT），可以使用 <a target="_blank" rel="noopener" href="https://www.webpagetest.org/easy">WebPageTest</a> 来测试</li>
<li>要注意的是，即使用户的网络是 4G，但因为丢包或者网络波动，可能会比预期的更慢</li>
<li><a target="_blank" rel="noopener" href="https://web.dev/render-blocking-resources/">禁用渲染阻塞的资源，延后加载</a></li>
<li>可以采用 <a target="_blank" rel="noopener" href="https://web.dev/native-lazy-loading/">lazy load</a>，<a target="_blank" rel="noopener" href="https://web.dev/reduce-javascript-payloads-with-code-splitting/">code-splitting</a> 等 <a target="_blank" rel="noopener" href="https://web.dev/fast/">其他优化</a> 手段，让第一次加载的资源更少</li>
</ul>
<h2 id="分析-RAIL-用的工具"><a href="#分析-RAIL-用的工具" class="headerlink" title="分析 RAIL 用的工具"></a>分析 RAIL 用的工具</h2><ul>
<li><a target="_blank" rel="noopener" href="https://developers.google.com/web/tools/chrome-devtools">Chrome DevTools</a></li>
<li><a target="_blank" rel="noopener" href="https://web.dev/measure/">Lighthouse</a></li>
<li><a target="_blank" rel="noopener" href="https://webpagetest.org/easy">WebPageTest</a></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>RAIL 是一个旅程，为了提升用户在网站的交互体验而不断探索。你需要去理解用户如何感知你的站点，这样才能设置最佳的性能目标</p>
<ul>
<li>聚焦用户</li>
<li>100ms 内响应用户的输入</li>
<li>10ms 内产生 1 帧，在滚动或者动画执行时</li>
<li>最大化主线程的空闲时间</li>
<li>5s 内让网页变得可交互</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://web.dev/rail/">https://web.dev/rail/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/23/yuque/this%E6%8C%87%E5%90%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/23/yuque/this%E6%8C%87%E5%90%91/" class="post-title-link" itemprop="url">this指向</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-23 11:13:15" itemprop="dateCreated datePublished" datetime="2021-04-23T11:13:15+08:00">2021-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-24 18:51:14" itemprop="dateModified" datetime="2021-04-24T18:51:14+08:00">2021-04-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>其实 JS 中的 this 是一个非常简单的东西，只需要理解它的执行规则就 OK。<br>在这里不想像其他博客一样展示太多的代码例子弄得天花乱坠， 反而不易理解。<br>call/apply/bind 可以显示绑定, 这里就不说了。<br>主要这些场隐式绑定的场景讨论:</p>
<ol>
<li>全局上下文</li>
<li>直接调用函数</li>
<li>对象.方法的形式调用</li>
<li>DOM 事件绑定(特殊)</li>
<li>new 构造函数绑定</li>
<li>箭头函数</li>
</ol>
<h2 id="1-全局上下文"><a href="#1-全局上下文" class="headerlink" title="1. 全局上下文"></a>1. 全局上下文</h2><p>全局上下文默认 this 指向 window, 严格模式下指向 undefined。</p>
<h2 id="2-直接调用函数"><a href="#2-直接调用函数" class="headerlink" title="2. 直接调用函数"></a>2. 直接调用函数</h2><p>比如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> func = obj.a;</span><br><span class="line">func();</span><br></pre></td></tr></table></figure>

<p>这种情况是直接调用。this 相当于全局上下文的情况。</p>
<h2 id="3-对象-方法的形式调用"><a href="#3-对象-方法的形式调用" class="headerlink" title="3. 对象.方法的形式调用"></a>3. 对象.方法的形式调用</h2><p>还是刚刚的例子，我如果这样写:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.a();</span><br></pre></td></tr></table></figure>

<p>这就是对象.方法的情况，this 指向这个对象</p>
<h2 id="4-DOM-事件绑定"><a href="#4-DOM-事件绑定" class="headerlink" title="4. DOM 事件绑定"></a>4. DOM 事件绑定</h2><p>onclick 和 addEventerListener 中 this 默认指向绑定事件的元素。<br>IE 比较奇异，使用 attachEvent，里面的 this 默认指向 window。</p>
<h2 id="5-new-构造函数"><a href="#5-new-构造函数" class="headerlink" title="5. new+构造函数"></a>5. new+构造函数</h2><p>此时构造函数中的 this 指向实例对象。</p>
<h2 id="6-箭头函数？"><a href="#6-箭头函数？" class="headerlink" title="6. 箭头函数？"></a>6. 箭头函数？</h2><p>箭头函数没有 this, 因此也不能绑定。里面的 this 会指向当前最近的非箭头函数的 this，找不到就是 window(严格模式是 undefined)。比如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">do</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.a(); <span class="comment">// 找到最近的非箭头函数a，a现在绑定着obj, 因此箭头函数中的this是obj</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>优先级: new &gt; call、apply、bind &gt; 对象.方法 &gt; 直接调用。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/23/yuque/%E6%B5%AE%E5%8A%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/23/yuque/%E6%B5%AE%E5%8A%A8/" class="post-title-link" itemprop="url">浮动</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-23 11:01:11" itemprop="dateCreated datePublished" datetime="2021-04-23T11:01:11+08:00">2021-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-24 18:51:15" itemprop="dateModified" datetime="2021-04-24T18:51:15+08:00">2021-04-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>页面布局是 CSS 的一个重点应用，例如：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619146953214-6eed72b4-4298-495c-a102-898368d09ad4.png#clientId=u3dd556fe-de2a-4&from=paste&height=352&id=u855d221f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=352&originWidth=403&originalType=binary&size=18863&status=done&style=none&taskId=u9200601b-2bf4-48f6-9483-45483faad6f&width=403" alt="image.png"><br>而实现页面布局主要应用到两种方法，一种是<strong>CSS 浮动</strong>，一种是<strong>Flexbox</strong>（IE9 以上），本文主要讲的是 CSS 浮动，下一篇文章将阐述 Flexbox。</p>
<h2 id="浮动元素"><a href="#浮动元素" class="headerlink" title="浮动元素"></a>浮动元素</h2><p><strong>什么是浮动元素：</strong>浮动元素同时处于常规流内和流外的元素。其中块级元素认为浮动元素不存在，而浮动元素会影响行内元素的布局，浮动元素会通过影响行内元素间接影响了包含块的布局。<br><strong>常规流：</strong>页面上从左往右，从上往下排列的元素流，就是常规流<strong>脱离常规流：</strong>绝对定位，fixed 定位的元素有自己固定的位置，脱离了常规流<strong>包含块：</strong>一个元素离它最近的块级元素是它的包含块<br>下面详细描述以上的内容，举个?：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Bin<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    .border &#123;</span><br><span class="line"><span class="css">      <span class="attribute">border</span>: <span class="number">2px</span> solid;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .common-div &#123;</span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">160px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: red;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .float-red &#123;</span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: <span class="number">#fcc</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">float</span>: left;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .float-blue &#123;</span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: <span class="number">#09c</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">float</span>: left;</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;border&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;float-red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;common-div&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;float-blue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod</span><br><span class="line">      tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim</span><br><span class="line">      veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea</span><br><span class="line">      commodo consequat. Duis aute irure dolor in reprehenderit in voluptate</span><br><span class="line">      velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat</span><br><span class="line">      cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id</span><br><span class="line">      est laborum.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面这段代码显示的样子如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619147229902-4673d52d-70f9-478e-adea-7b20d3d8950e.png#clientId=u3dd556fe-de2a-4&from=paste&height=195&id=uc054066a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=195&originWidth=732&originalType=binary&size=83482&status=done&style=none&taskId=udf3b458b-8f49-4e66-89a6-76fa62b2260&width=732" alt="image.png"></p>
<ul>
<li>块级元素认为浮动元素不存在：红色的块级元素没有受到粉色浮动元素的影响，还展示在左上角的位置，但是被粉色元素盖住了左边的部分</li>
<li>浮动元素会影响行内元素：文字部分被蓝色浮动元素影响，空出了蓝色浮动元素的部分</li>
<li>浮动元素会间接影响了包含块的布局：浮动元素影响了文字部分吗，使之多出了一行，文字部分撑高了最外面的 border 框，所以间接影响了包含块的布局。</li>
</ul>
<p>其中，<strong>浮动元素的摆放</strong>会遵循如下的规则：</p>
<ul>
<li>尽量靠上</li>
<li>尽量靠左</li>
<li>尽量一个挨着一个</li>
<li>不能超出包含块，除非元素比包含块更宽</li>
<li>不能超过所在行的最高点</li>
<li>不能超过它前面浮动元素的最高点</li>
<li>行内元素绕着浮动元素摆放：左浮动元素的右边和右浮动元素的左边会出浮动元素</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>浮动元素并不能撑起包含块，这和我们的预期并不相符。通过以下的办法可以将包含块撑开，称之为<strong>闭合浮动</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619147337086-bbbe8792-e580-421d-9bb2-ec0b637fa630.png#clientId=u3dd556fe-de2a-4&from=paste&height=227&id=u37fc5218&margin=%5Bobject%20Object%5D&name=image.png&originHeight=227&originWidth=732&originalType=binary&size=4433&status=done&style=none&taskId=u99d50c93-721b-4ea8-8032-35592e09c65&width=732" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619147351522-7de19830-7fd5-46ca-8c78-4deb7fad9719.png#clientId=u3dd556fe-de2a-4&from=paste&height=226&id=ud232f1d9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=226&originWidth=732&originalType=binary&size=5293&status=done&style=none&taskId=ubee4f117-405f-4bea-bf75-279079dc0ab&width=732" alt="image.png"></p>
<h3 id="闭合浮动的方法："><a href="#闭合浮动的方法：" class="headerlink" title="闭合浮动的方法："></a>闭合浮动的方法：</h3><ul>
<li>**BFC:**1) 包含块设置 overflow:hidden 或者 2)包含块设置 display:table-cell/table/flex…</li>
</ul>
<blockquote>
<p><strong>BFC：块级格式化上下文。它是一个独立的渲染区域，只有 Block-level box 参与， 它规定了内部的块级元素如何布局，并且与这个区域外部毫不相干。</strong>只要<strong>符合以下的条件就是 BFC:</strong></p>
<ol>
<li>根元素</li>
<li>float 属性不为 none</li>
<li>position 为 absolute 或 fixed</li>
<li>display 为 inline-block, table-cell, table-caption, flex, inline-flex</li>
<li>overflow 不为 visible</li>
</ol>
</blockquote>
<p>相应的背景文档可以参阅：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html">《BFC 的神奇原理》</a></p>
<ul>
<li><strong>伪元素</strong>：</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>clear:both;意味着块级元素的左边和右边都不能有浮动元素。在包含块的末尾建立了一个内容为空的伪元素，并设置 clear:both，使这个元素位于所有的浮动元素之后，从而撑开了包含块的高。</p>
</blockquote>
<ul>
<li><strong>包含块自己也浮动</strong></li>
</ul>
<p>这个方法也是 w3c 使用的方法。不过，下一个元素会受到这个浮动元素的影响。为了解决这个问题，有些人选择对布局中的所有东西进行浮动，然后使用适当的有意义的元素（常常是站点的页脚）对这些浮动进行清理。这有助于减少或消除不必要的标记。<br>相应的背景文档：<a target="_blank" rel="noopener" href="http://www.w3school.com.cn/css/css_positioning_floating.asp">《W3C CSS 浮动》</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Adam Blog</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Adam Blog</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
