<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Adam">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Adam">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Adam Blog">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Adam</title>
  <meta name="referrer" content="no-referrer" />
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Adam</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/20/yuque/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F%EF%BC%9Ahash%E6%A8%A1%E5%BC%8F%E5%92%8C%20history%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/20/yuque/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F%EF%BC%9Ahash%E6%A8%A1%E5%BC%8F%E5%92%8C%20history%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">前端路由的两种模式：hash模式和 history模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-20 12:51:15" itemprop="dateCreated datePublished" datetime="2021-04-20T12:51:15+08:00">2021-04-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-22 14:41:28" itemprop="dateModified" datetime="2021-04-22T14:41:28+08:00">2021-04-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>为什么要使用路由<br>现在的网络应用程序越来越多的使用 AJAX 异步请求完成页面的无缝刷新，导致浏览器的 URL 不会发生任何变化而完成了请求，从而破换了用户浏览体验。同时本次浏览的页面内容在用户下次使用 URL 访问时将无法重新呈现，使用路由可以很好地解决这个问题。</p>
<p>单页面应用利用了 JavaScript 动态变换网页内容，避免了页面重载；路由则提供了浏览器地址变化，网页内容也跟随变化，两者结合起来则为我们提供了体验良好的单页面 web 应用。</p>
<h2 id="前端路由实现方式"><a href="#前端路由实现方式" class="headerlink" title="前端路由实现方式"></a>前端路由实现方式</h2><p>路由需要实现三个功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当浏览器地址变化时，切换页面；</span><br><span class="line">点击浏览器【后退】、【前进】按钮，网页内容跟随变化；</span><br><span class="line">刷新浏览器，网页加载当前路由对应内容；</span><br></pre></td></tr></table></figure>

<p>在单页面 web 网页中, 单纯的浏览器地址改变, 网页不会重载，如单纯的 hash 网址改变网页不会变化，因此我们的路由主要是通过监听事件，并利用 js 实现动态改变网页内容，有两种实现方式：</p>
<ul>
<li>hash 模式：监听浏览器地址 hash 值变化，执行相应的 js 切换网页；</li>
<li>history 模式：利用 history API 实现 url 地址改变，网页内容改变；</li>
</ul>
<p>它们的区别最明显的就是 hash 会在浏览器地址后面增加#号，而 history 可以自定义地址。</p>
<h2 id="hash-模式"><a href="#hash-模式" class="headerlink" title="hash 模式"></a>hash 模式</h2><p>使用 window.location.hash 属性及窗口的 onhashchange 事件，可以实现监听浏览器地址 hash 值变化，执行相应的 js 切换网页。下面具体介绍几个使用过程中必须理解的要点：</p>
<ul>
<li>hash 指的是地址中#号以及后面的字符，也称为散列值。hash 也称作锚点，本身是用来做页面跳转定位的。如<a target="_blank" rel="noopener" href="http://localhost/index.html#abc">http://localhost/index.html#abc</a>，这里的#abc 就是 hash；</li>
<li>散列值是不会随请求发送到服务器端的，所以改变 hash，不会重新加载页面；</li>
<li>监听 window 的 hashchange 事件，当散列值改变时，可以通过 location.hash 来获取和设置 hash 值；</li>
<li>location.hash 值的变化会直接反应到浏览器地址栏；</li>
</ul>
<h2 id="触发-hashchange-事件的几种情况："><a href="#触发-hashchange-事件的几种情况：" class="headerlink" title="触发 hashchange 事件的几种情况："></a>触发 hashchange 事件的几种情况：</h2><ul>
<li>浏览器地址栏散列值的变化（包括浏览器的前进、后退）会触发 window.location.hash 值的变化，从而触发 onhashchange 事件；</li>
<li>当浏览器地址栏中 URL 包含哈希如 <a target="_blank" rel="noopener" href="http://www.baidu.com/#home">http://www.baidu.com/#home</a>，这时按下输入，浏览器发送<a target="_blank" rel="noopener" href="http://www.baidu.com/">http://www.baidu.com/</a>请求至服务器，请求完毕之后设置散列值为#home，进而触发 onhashchange 事件；</li>
<li>当只改变浏览器地址栏 URL 的哈希部分，这时按下回车，浏览器不会发送任何请求至服务器，这时发生的只是设置散列值新修改的哈希值，并触发 onhashchange 事件；</li>
<li>html 中<a>标签的属性 href 可以设置为页面的元素 ID 如 #top，当点击该链接时页面跳转至该 id 元素所在区域，同时浏览器自动设置 window.location.hash 属性，地址栏中的哈希值也会发生改变，并触发 onhashchange 事件；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置 url 的 hash，会在当前url后加上&#x27;#abc&#x27;</span></span><br><span class="line"><span class="built_in">window</span>.location.hash = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> hash = <span class="built_in">window</span>.location.hash; <span class="comment">//&#x27;#abc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;hashchange&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//监听hash变化，点击浏览器的前进后退会触发</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="history-模式"><a href="#history-模式" class="headerlink" title="history 模式"></a>history 模式</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>window.history 属性指向 History 对象，它表示当前窗口的浏览历史。当发生改变时，只会改变页面的路径，不会刷新页面。</li>
<li>History 对象保存了当前窗口访问过的所有页面网址。通过 history.length 可以得出当前窗口一共访问过几个网址。</li>
<li>由于安全原因，浏览器不允许脚本读取这些地址，但是允许在地址之间导航。</li>
<li>浏览器工具栏的“前进”和“后退”按钮，其实就是对 History 对象进行操作。</li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>History 对象主要有两个属性。</p>
<ul>
<li>History.length：当前窗口访问过的网址数量（包括当前网页）</li>
<li>History.state：History 堆栈最上层的状态值（详见下文）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前窗口访问过多少个网页</span></span><br><span class="line">history.length; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// History 对象的当前状态</span></span><br><span class="line"><span class="comment">// 通常是 undefined，即未设置</span></span><br><span class="line">history.state; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><strong>History.back()、History.forward()、History.go()</strong><br>这三个方法用于在历史之中移动。</p>
<ul>
<li>**History.back()**：移动到上一个网址，等同于点击浏览器的后退键。对于第一个访问的网址，该方法无效果。</li>
<li>**History.forward()**：移动到下一个网址，等同于点击浏览器的前进键。对于最后一个访问的网址，该方法无效果。</li>
<li>**History.go()**：接受一个整数作为参数，以当前网址为基准，移动到参数指定的网址。如果参数超过实际存在的网址范围，该方法无效果；如果不指定参数，默认参数为 0，相当于刷新当前页面。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">history.back();</span><br><span class="line">history.forward();</span><br><span class="line">history.go(<span class="number">1</span>); <span class="comment">//相当于history.forward()</span></span><br><span class="line">history.go(-<span class="number">1</span>); <span class="comment">//相当于history.back()</span></span><br><span class="line">history.go(<span class="number">0</span>); <span class="comment">// 刷新当前页面</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：移动到以前访问过的页面时，页面通常是从浏览器缓存之中加载，而不是重新要求服务器发送新的网页。</p>
<p><strong>History.pushState()</strong><br>该方法用于在历史中添加一条记录。pushState()方法不会触发页面刷新，只是导致 History 对象发生变化，地址栏会有变化。</p>
<p>语法：history.pushState(object, title, url)</p>
<p>该方法接受三个参数，依次为：</p>
<ul>
<li>object：是一个对象，通过 pushState 方法可以将该对象内容传递到新页面中。如果不需要这个对象，此处可以填 null。</li>
<li>title：指标题，几乎没有浏览器支持该参数，传一个空字符串比较安全。</li>
<li>url：新的网址，必须与当前页面处在同一个域。不指定的话则为当前的路径，如果设置了一个跨域网址，则会报错。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">foo</span>: <span class="string">&quot;bar&quot;</span> &#125;;</span><br><span class="line">history.pushState(data, <span class="string">&quot;&quot;</span>, <span class="string">&quot;2.html&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(history.state); <span class="comment">// &#123;foo: &quot;bar&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：如果 pushState 的 URL 参数设置了一个新的锚点值（即 hash），并不会触发 hashchange 事件。反过来，如果 URL 的锚点值变了，则会在 History 对象创建一条浏览记录。</p>
<p>如果 pushState() 方法设置了一个跨域网址，则会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="comment">// 当前网址为 http://example.com</span></span><br><span class="line">history.pushState(<span class="literal">null</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;https://twitter.com/hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，pushState 想要插入一个跨域的网址，导致报错。这样设计的目的是，防止恶意代码让用户以为他们是在另一个网站上，因为这个方法不会导致页面跳转。</p>
<p><strong>History.replaceState()</strong><br>该方法用来修改 History 对象的当前记录，用法与 pushState() 方法一样。<br>假定当前网页是 example.com/example.html。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">history.pushState(&#123; <span class="attr">page</span>: <span class="number">1</span> &#125;, <span class="string">&quot;&quot;</span>, <span class="string">&quot;?page=1&quot;</span>);</span><br><span class="line"><span class="comment">// URL 显示为 http://example.com/example.html?page=1</span></span><br><span class="line"></span><br><span class="line">history.pushState(&#123; <span class="attr">page</span>: <span class="number">2</span> &#125;, <span class="string">&quot;&quot;</span>, <span class="string">&quot;?page=2&quot;</span>);</span><br><span class="line"><span class="comment">// URL 显示为 http://example.com/example.html?page=2</span></span><br><span class="line"></span><br><span class="line">history.replaceState(&#123; <span class="attr">page</span>: <span class="number">3</span> &#125;, <span class="string">&quot;&quot;</span>, <span class="string">&quot;?page=3&quot;</span>);</span><br><span class="line"><span class="comment">// URL 显示为 http://example.com/example.html?page=3</span></span><br><span class="line"></span><br><span class="line">history.back();</span><br><span class="line"><span class="comment">// URL 显示为 http://example.com/example.html?page=1</span></span><br><span class="line"></span><br><span class="line">history.back();</span><br><span class="line"><span class="comment">// URL 显示为 http://example.com/example.html</span></span><br><span class="line"></span><br><span class="line">history.go(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// URL 显示为 http://example.com/example.html?page=3</span></span><br></pre></td></tr></table></figure>

<p><strong>popstate 事件</strong><br>每当 history 对象出现变化时，就会触发 popstate 事件。<br>注意：</p>
<ul>
<li>仅仅调用 pushState()方法或 replaceState()方法 ，并不会触发该事件;</li>
<li>只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用 History.back()、History.forward()、History.go()方法时才会触发。</li>
<li>另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。</li>
<li>页面第一次加载的时候，浏览器不会触发 popstate 事件。</li>
</ul>
<p>使用的时候，可以为 popstate 事件指定回调函数，回调函数的参数是一个 event 事件对象，它的 state 属性指向当前的 state 对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;popstate&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//e.state 相当于 history.state</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;state: &quot;</span> + <span class="built_in">JSON</span>.stringify(e.state));</span><br><span class="line">  <span class="built_in">console</span>.log(history.state);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Charissa2017/article/details/103841476">点击查看</a><br>通过 history.pushState 实现页面 tab 切换的功能。<br>history 致命的缺点就是当改变页面地址后，强制刷新浏览器时，（如果后端没有做准备的话）会报错，因为刷新是拿当前地址去请求服务器的，如果服务器中没有相应的响应，会出现 404 页面。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/19/yuque/%E8%B7%A8%E9%A1%B5%E9%9D%A2%E9%80%9A%E4%BF%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/19/yuque/%E8%B7%A8%E9%A1%B5%E9%9D%A2%E9%80%9A%E4%BF%A1/" class="post-title-link" itemprop="url">跨页面通信</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-19 20:50:53" itemprop="dateCreated datePublished" datetime="2021-04-19T20:50:53+08:00">2021-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-22 14:41:28" itemprop="dateModified" datetime="2021-04-22T14:41:28+08:00">2021-04-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在浏览器中，我们可以同时打开多个 Tab 页，每个 Tab 页可以粗略理解为一个“独立”的运行环境，即使是全局对象也不会在多个 Tab 间共享。然而有些时候，我们希望能在这些“独立”的 Tab 页面之间同步页面的数据、信息或状态。</p>
<p>正如下面这个例子：我在列表页点击“收藏”后，对应的详情页按钮会自动更新为“已收藏”状态；类似的，在详情页点击“收藏”后，列表页中按钮也会更新。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/gif/21377586/1618909289351-36a24fd7-e6f6-41d8-9682-c09e9b6c384c.gif#clientId=u61de38f8-254c-4&from=paste&height=438&id=u88553d57&margin=%5Bobject%20Object%5D&originHeight=876&originWidth=1364&originalType=url&status=done&style=none&taskId=u3edd39f2-51e8-4eb9-9e3b-cac496758d4&width=682"></p>
<p>这就是我们所说的前端跨页面通信。</p>
<p>你知道哪些跨页面通信的方式呢？如果不清楚，下面我就带大家来看看七种跨页面通信的方式。</p>
<p>–</p>
<h2 id="一、同源页面间的跨页面通信"><a href="#一、同源页面间的跨页面通信" class="headerlink" title="一、同源页面间的跨页面通信"></a>一、同源页面间的跨页面通信</h2><blockquote>
<p>以下各种方式的 <a target="_blank" rel="noopener" href="https://alienzhou.github.io/cross-tab-communication/">在线 Demo 可以戳这里 &gt;&gt;</a></p>
</blockquote>
<p>浏览器的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Same-origin_policy">同源策略</a>在下述的一些跨页面通信方法中依然存在限制。因此，我们先来看看，在满足同源策略的情况下，都有哪些技术可以用来实现跨页面通信。</p>
<h3 id="1-BroadCast-Channel"><a href="#1-BroadCast-Channel" class="headerlink" title="1. BroadCast Channel"></a>1. BroadCast Channel</h3><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel">BroadCast Channel</a> 可以帮我们创建一个用于广播的通信频道。当所有页面都监听同一频道的消息时，其中某一个页面通过它发送的消息就会被其他所有页面收到。它的 API 和用法都非常简单。</p>
<p>下面的方式就可以创建一个标识为<code>AlienZHOU</code>的频道：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const bc &#x3D; new BroadcastChannel(&#39;AlienZHOU&#39;);</span><br></pre></td></tr></table></figure>

<p>各个页面可以通过<code>onmessage</code>来监听被广播的消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bc.onmessage &#x3D; function (e) &#123;</span><br><span class="line">    const data &#x3D; e.data;</span><br><span class="line">    const text &#x3D; &#39;[receive] &#39; + data.msg + &#39; —— tab &#39; + data.from;</span><br><span class="line">    console.log(&#39;[BroadcastChannel] receive message:&#39;, text);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>要发送消息时只需要调用实例上的<code>postMessage</code>方法即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bc.postMessage(mydata);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Broadcast Channel 的具体的使用方式可以看这篇<a target="_blank" rel="noopener" href="https://juejin.im/post/6844903811228663815">《【3 分钟速览】前端广播式通信：Broadcast Channel》</a>。</p>
</blockquote>
<h3 id="2-Service-Worker"><a href="#2-Service-Worker" class="headerlink" title="2. Service Worker"></a>2. Service Worker</h3><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API">Service Worker</a> 是一个可以长期运行在后台的 Worker，能够实现与页面的双向通信。多页面共享间的 Service Worker 可以共享，将 Service Worker 作为消息的处理中心（中央站）即可实现广播效果。</p>
<blockquote>
<p>Service Worker 也是 PWA 中的核心技术之一，由于本文重点不在 PWA ，因此如果想进一步了解 Service Worker，可以阅读我之前的文章<a target="_blank" rel="noopener" href="https://juejin.im/post/6844903588691443725">【PWA 学习与实践】(3) 让你的 WebApp 离线可用</a>。</p>
</blockquote>
<p>首先，需要在页面注册 Service Worker：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 页面逻辑 *&#x2F;</span><br><span class="line">navigator.serviceWorker.register(&#39;..&#x2F;util.sw.js&#39;).then(function () &#123;</span><br><span class="line">    console.log(&#39;Service Worker 注册成功&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>其中<code>../util.sw.js</code>是对应的 Service Worker 脚本。Service Worker 本身并不自动具备“广播通信”的功能，需要我们添加些代码，将其改造成消息中转站：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* ..&#x2F;util.sw.js Service Worker 逻辑 *&#x2F;</span><br><span class="line">self.addEventListener(&#39;message&#39;, function (e) &#123;</span><br><span class="line">    console.log(&#39;service worker receive message&#39;, e.data);</span><br><span class="line">    e.waitUntil(</span><br><span class="line">        self.clients.matchAll().then(function (clients) &#123;</span><br><span class="line">            if (!clients || clients.length &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            clients.forEach(function (client) &#123;</span><br><span class="line">                client.postMessage(e.data);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们在 Service Worker 中监听了<code>message</code>事件，获取页面（从 Service Worker 的角度叫 client）发送的信息。然后通过<code>self.clients.matchAll()</code>获取当前注册了该 Service Worker 的所有页面，通过调用每个 client（即页面）的<code>postMessage</code>方法，向页面发送消息。这样就把从一处（某个 Tab 页面）收到的消息通知给了其他页面。</p>
<p>处理完 Service Worker，我们需要在页面监听 Service Worker 发送来的消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 页面逻辑 *&#x2F;</span><br><span class="line">navigator.serviceWorker.addEventListener(&#39;message&#39;, function (e) &#123;</span><br><span class="line">    const data &#x3D; e.data;</span><br><span class="line">    const text &#x3D; &#39;[receive] &#39; + data.msg + &#39; —— tab &#39; + data.from;</span><br><span class="line">    console.log(&#39;[Service Worker] receive message:&#39;, text);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>最后，当需要同步消息时，可以调用 Service Worker 的<code>postMessage</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 页面逻辑 *&#x2F;</span><br><span class="line">navigator.serviceWorker.controller.postMessage(mydata);</span><br></pre></td></tr></table></figure>

<h3 id="3-LocalStorage"><a href="#3-LocalStorage" class="headerlink" title="3. LocalStorage"></a>3. LocalStorage</h3><p>LocalStorage 作为前端最常用的本地存储，大家应该已经非常熟悉了；但<code>StorageEvent</code>这个与它相关的事件有些同学可能会比较陌生。</p>
<p>当 LocalStorage 变化时，会触发<code>storage</code>事件。利用这个特性，我们可以在发送消息时，把消息写入到某个 LocalStorage 中；然后在各个页面内，通过监听<code>storage</code>事件即可收到通知。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#39;storage&#39;, function (e) &#123;</span><br><span class="line">    if (e.key &#x3D;&#x3D;&#x3D; &#39;ctc-msg&#39;) &#123;</span><br><span class="line">        const data &#x3D; JSON.parse(e.newValue);</span><br><span class="line">        const text &#x3D; &#39;[receive] &#39; + data.msg + &#39; —— tab &#39; + data.from;</span><br><span class="line">        console.log(&#39;[Storage I] receive message:&#39;, text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在各个页面添加如上的代码，即可监听到 LocalStorage 的变化。当某个页面需要发送消息时，只需要使用我们熟悉的<code>setItem</code>方法即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mydata.st &#x3D; +(new Date);</span><br><span class="line">window.localStorage.setItem(&#39;ctc-msg&#39;, JSON.stringify(mydata));</span><br></pre></td></tr></table></figure>

<p>注意，这里有一个细节：我们在 mydata 上添加了一个取当前毫秒时间戳的<code>.st</code>属性。这是因为，<code>storage</code>事件只有在值真正改变时才会触发。举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.localStorage.setItem(&#39;test&#39;, &#39;123&#39;);</span><br><span class="line">window.localStorage.setItem(&#39;test&#39;, &#39;123&#39;);</span><br></pre></td></tr></table></figure>

<p>由于第二次的值<code>&#39;123&#39;</code>与第一次的值相同，所以以上的代码只会在第一次<code>setItem</code>时触发<code>storage</code>事件。因此我们通过设置<code>st</code>来保证每次调用时一定会触发<code>storage</code>事件。</p>
<h3 id="小憩一下"><a href="#小憩一下" class="headerlink" title="小憩一下"></a>小憩一下</h3><p>上面我们看到了三种实现跨页面通信的方式，不论是建立广播频道的 Broadcast Channel，还是使用 Service Worker 的消息中转站，抑或是些 tricky 的<code>storage</code>事件，其都是“广播模式”：一个页面将消息通知给一个“中央站”，再由“中央站”通知给各个页面。</p>
<blockquote>
<p>在上面的例子中，这个“中央站”可以是一个 BroadCast Channel 实例、一个 Service Worker 或是 LocalStorage。</p>
</blockquote>
<p>下面我们会看到另外两种跨页面通信方式，我把它称为“共享存储+轮询模式”。</p>
<p>–</p>
<h3 id="4-Shared-Worker"><a href="#4-Shared-Worker" class="headerlink" title="4. Shared Worker"></a>4. Shared Worker</h3><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker">Shared Worker</a> 是 Worker 家族的另一个成员。普通的 Worker 之间是独立运行、数据互不相通；而多个 Tab 注册的 Shared Worker 则可以实现数据共享。</p>
<p>Shared Worker 在实现跨页面通信时的问题在于，它无法主动通知所有页面，因此，我们会使用轮询的方式，来拉取最新的数据。思路如下：</p>
<p>让 Shared Worker 支持两种消息。一种是 post，Shared Worker 收到后会将该数据保存下来；另一种是 get，Shared Worker 收到该消息后会将保存的数据通过<code>postMessage</code>传给注册它的页面。也就是让页面通过 get 来主动获取（同步）最新消息。具体实现如下：</p>
<p>首先，我们会在页面中启动一个 Shared Worker，启动方式非常简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 构造函数的第二个参数是 Shared Worker 名称，也可以留空</span><br><span class="line">const sharedWorker &#x3D; new SharedWorker(&#39;..&#x2F;util.shared.js&#39;, &#39;ctc&#39;);</span><br></pre></td></tr></table></figure>

<p>然后，在该 Shared Worker 中支持 get 与 post 形式的消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* ..&#x2F;util.shared.js: Shared Worker 代码 *&#x2F;</span><br><span class="line">let data &#x3D; null;</span><br><span class="line">self.addEventListener(&#39;connect&#39;, function (e) &#123;</span><br><span class="line">    const port &#x3D; e.ports[0];</span><br><span class="line">    port.addEventListener(&#39;message&#39;, function (event) &#123;</span><br><span class="line">        &#x2F;&#x2F; get 指令则返回存储的消息数据</span><br><span class="line">        if (event.data.get) &#123;</span><br><span class="line">            data &amp;&amp; port.postMessage(data);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 非 get 指令则存储该消息数据</span><br><span class="line">        else &#123;</span><br><span class="line">            data &#x3D; event.data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    port.start();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>之后，页面定时发送 get 指令的消息给 Shared Worker，轮询最新的消息数据，并在页面监听返回信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定时轮询，发送 get 指令的消息</span><br><span class="line">setInterval(function () &#123;</span><br><span class="line">    sharedWorker.port.postMessage(&#123;get: true&#125;);</span><br><span class="line">&#125;, 1000);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 监听 get 消息的返回数据</span><br><span class="line">sharedWorker.port.addEventListener(&#39;message&#39;, (e) &#x3D;&gt; &#123;</span><br><span class="line">    const data &#x3D; e.data;</span><br><span class="line">    const text &#x3D; &#39;[receive] &#39; + data.msg + &#39; —— tab &#39; + data.from;</span><br><span class="line">    console.log(&#39;[Shared Worker] receive message:&#39;, text);</span><br><span class="line">&#125;, false);</span><br><span class="line">sharedWorker.port.start();</span><br></pre></td></tr></table></figure>

<p>最后，当要跨页面通信时，只需给 Shared Worker <code>postMessage</code>即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sharedWorker.port.postMessage(mydata);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，如果使用<code>addEventListener</code>来添加 Shared Worker 的消息监听，需要显式调用<code>MessagePort.start</code>方法，即上文中的<code>sharedWorker.port.start()</code>；如果使用<code>onmessage</code>绑定监听则不需要。</p>
</blockquote>
<h3 id="5-IndexedDB"><a href="#5-IndexedDB" class="headerlink" title="5. IndexedDB"></a>5. IndexedDB</h3><p>除了可以利用 Shared Worker 来共享存储数据，还可以使用其他一些“全局性”（支持跨页面）的存储方案。例如 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API">IndexedDB</a> 或 cookie。</p>
<blockquote>
<p>鉴于大家对 cookie 已经很熟悉，加之作为“互联网最早期的存储方案之一”，cookie 已经在实际应用中承受了远多于其设计之初的责任，我们下面会使用 IndexedDB 来实现。</p>
</blockquote>
<p>其思路很简单：与 Shared Worker 方案类似，消息发送方将消息存至 IndexedDB 中；接收方（例如所有页面）则通过轮询去获取最新的信息。在这之前，我们先简单封装几个 IndexedDB 的工具方法。</p>
<ul>
<li>打开数据库连接：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function openStore() &#123;</span><br><span class="line">    const storeName &#x3D; &#39;ctc_aleinzhou&#39;;</span><br><span class="line">    return new Promise(function (resolve, reject) &#123;</span><br><span class="line">        if (!(&#39;indexedDB&#39; in window)) &#123;</span><br><span class="line">            return reject(&#39;don\&#39;t support indexedDB&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">        const request &#x3D; indexedDB.open(&#39;CTC_DB&#39;, 1);</span><br><span class="line">        request.onerror &#x3D; reject;</span><br><span class="line">        request.onsuccess &#x3D;  e &#x3D;&gt; resolve(e.target.result);</span><br><span class="line">        request.onupgradeneeded &#x3D; function (e) &#123;</span><br><span class="line">            const db &#x3D; e.srcElement.result;</span><br><span class="line">            if (e.oldVersion &#x3D;&#x3D;&#x3D; 0 &amp;&amp; !db.objectStoreNames.contains(storeName)) &#123;</span><br><span class="line">                const store &#x3D; db.createObjectStore(storeName, &#123;keyPath: &#39;tag&#39;&#125;);</span><br><span class="line">                store.createIndex(storeName + &#39;Index&#39;, &#39;tag&#39;, &#123;unique: false&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>存储数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function saveData(db, data) &#123;</span><br><span class="line">    return new Promise(function (resolve, reject) &#123;</span><br><span class="line">        const STORE_NAME &#x3D; &#39;ctc_aleinzhou&#39;;</span><br><span class="line">        const tx &#x3D; db.transaction(STORE_NAME, &#39;readwrite&#39;);</span><br><span class="line">        const store &#x3D; tx.objectStore(STORE_NAME);</span><br><span class="line">        const request &#x3D; store.put(&#123;tag: &#39;ctc_data&#39;, data&#125;);</span><br><span class="line">        request.onsuccess &#x3D; () &#x3D;&gt; resolve(db);</span><br><span class="line">        request.onerror &#x3D; reject;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>查询/读取数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function query(db) &#123;</span><br><span class="line">    const STORE_NAME &#x3D; &#39;ctc_aleinzhou&#39;;</span><br><span class="line">    return new Promise(function (resolve, reject) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            const tx &#x3D; db.transaction(STORE_NAME, &#39;readonly&#39;);</span><br><span class="line">            const store &#x3D; tx.objectStore(STORE_NAME);</span><br><span class="line">            const dbRequest &#x3D; store.get(&#39;ctc_data&#39;);</span><br><span class="line">            dbRequest.onsuccess &#x3D; e &#x3D;&gt; resolve(e.target.result);</span><br><span class="line">            dbRequest.onerror &#x3D; reject;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (err) &#123;</span><br><span class="line">            reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>剩下的工作就非常简单了。首先打开数据连接，并初始化数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openStore().then(db &#x3D;&gt; saveData(db, null))</span><br></pre></td></tr></table></figure>

<p>对于消息读取，可以在连接与初始化后轮询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">openStore().then(db &#x3D;&gt; saveData(db, null)).then(function (db) &#123;</span><br><span class="line">    setInterval(function () &#123;</span><br><span class="line">        query(db).then(function (res) &#123;</span><br><span class="line">            if (!res || !res.data) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            const data &#x3D; res.data;</span><br><span class="line">            const text &#x3D; &#39;[receive] &#39; + data.msg + &#39; —— tab &#39; + data.from;</span><br><span class="line">            console.log(&#39;[Storage I] receive message:&#39;, text);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>最后，要发送消息时，只需向 IndexedDB 存储数据即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">openStore().then(db &#x3D;&gt; saveData(db, null)).then(function (db) &#123;</span><br><span class="line">    &#x2F;&#x2F; …… 省略上面的轮询代码</span><br><span class="line">    &#x2F;&#x2F; 触发 saveData 的方法可以放在用户操作的事件监听内</span><br><span class="line">    saveData(db, mydata);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="小憩一下-1"><a href="#小憩一下-1" class="headerlink" title="小憩一下"></a>小憩一下</h3><p>在“广播模式”外，我们又了解了“共享存储+长轮询”这种模式。也许你会认为长轮询没有监听模式优雅，但实际上，有些时候使用“共享存储”的形式时，不一定要搭配长轮询。</p>
<p>例如，在多 Tab 场景下，我们可能会离开 Tab A 到另一个 Tab B 中操作；过了一会我们从 Tab B 切换回 Tab A 时，希望将之前在 Tab B 中的操作的信息同步回来。这时候，其实只用在 Tab A 中监听<code>visibilitychange</code>这样的事件，来做一次信息同步即可。</p>
<p>下面，我会再介绍一种通信方式，我把它称为“口口相传”模式。</p>
<p>–</p>
<h3 id="6-window-open-window-opener"><a href="#6-window-open-window-opener" class="headerlink" title="6. window.open + window.opener"></a>6. window.open + window.opener</h3><p>当我们使用<code>window.open</code>打开页面时，方法会返回一个被打开页面<code>window</code>的引用。而在未显示指定<code>noopener</code>时，被打开的页面可以通过<code>window.opener</code>获取到打开它的页面的引用 —— 通过这种方式我们就将这些页面建立起了联系（一种树形结构）。</p>
<p>首先，我们把<code>window.open</code>打开的页面的<code>window</code>对象收集起来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let childWins &#x3D; [];</span><br><span class="line">document.getElementById(&#39;btn&#39;).addEventListener(&#39;click&#39;, function () &#123;</span><br><span class="line">    const win &#x3D; window.open(&#39;.&#x2F;some&#x2F;sample&#39;);</span><br><span class="line">    childWins.push(win);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>然后，当我们需要发送消息的时候，作为消息的发起方，一个页面需要同时通知它打开的页面与打开它的页面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 过滤掉已经关闭的窗口</span><br><span class="line">childWins &#x3D; childWins.filter(w &#x3D;&gt; !w.closed);</span><br><span class="line">if (childWins.length &gt; 0) &#123;</span><br><span class="line">    mydata.fromOpenner &#x3D; false;</span><br><span class="line">    childWins.forEach(w &#x3D;&gt; w.postMessage(mydata));</span><br><span class="line">&#125;</span><br><span class="line">if (window.opener &amp;&amp; !window.opener.closed) &#123;</span><br><span class="line">    mydata.fromOpenner &#x3D; true;</span><br><span class="line">    window.opener.postMessage(mydata);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，我这里先用<code>.closed</code>属性过滤掉已经被关闭的 Tab 窗口。这样，作为消息发送方的任务就完成了。下面看看，作为消息接收方，它需要做什么。</p>
<p>此时，一个收到消息的页面就不能那么自私了，除了展示收到的消息，它还需要将消息再传递给它所“知道的人”（打开与被它打开的页面）:</p>
<blockquote>
<p>需要注意的是，我这里通过判断消息来源，避免将消息回传给发送方，防止消息在两者间死循环的传递。（该方案会有些其他小问题，实际中可以进一步优化）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#39;message&#39;, function (e) &#123;</span><br><span class="line">    const data &#x3D; e.data;</span><br><span class="line">    const text &#x3D; &#39;[receive] &#39; + data.msg + &#39; —— tab &#39; + data.from;</span><br><span class="line">    console.log(&#39;[Cross-document Messaging] receive message:&#39;, text);</span><br><span class="line">    &#x2F;&#x2F; 避免消息回传</span><br><span class="line">    if (window.opener &amp;&amp; !window.opener.closed &amp;&amp; data.fromOpenner) &#123;</span><br><span class="line">        window.opener.postMessage(data);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 过滤掉已经关闭的窗口</span><br><span class="line">    childWins &#x3D; childWins.filter(w &#x3D;&gt; !w.closed);</span><br><span class="line">    &#x2F;&#x2F; 避免消息回传</span><br><span class="line">    if (childWins &amp;&amp; !data.fromOpenner) &#123;</span><br><span class="line">        childWins.forEach(w &#x3D;&gt; w.postMessage(data));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这样，每个节点（页面）都肩负起了传递消息的责任，也就是我说的“口口相传”，而消息就在这个树状结构中流转了起来。</p>
<h3 id="小憩一下-2"><a href="#小憩一下-2" class="headerlink" title="小憩一下"></a>小憩一下</h3><p>显然，“口口相传”的模式存在一个问题：如果页面不是通过在另一个页面内的<code>window.open</code>打开的（例如直接在地址栏输入，或从其他网站链接过来），这个联系就被打破了。</p>
<p>除了上面这六个常见方法，其实还有一种（第七种）做法是通过 WebSocket 这类的“服务器推”技术来进行同步。这好比将我们的“中央站”从前端移到了后端。</p>
<p>关于 WebSocket 与其他“服务器推”技术，不了解的同学可以阅读这篇<a target="_blank" rel="noopener" href="https://juejin.im/post/6844903618043183111">《各类“服务器推”技术原理与实例（Polling/COMET/SSE/WebSocket）》</a></p>
<p>此外，我还针对以上各种方式写了一个 <a target="_blank" rel="noopener" href="https://alienzhou.github.io/cross-tab-communication/">在线演示的 Demo &gt;&gt;</a></p>
<p><img src="2.gif#id=Meuzf&originalType=binary&status=done&style=none"></p>
<h2 id="二、非同源页面之间的通信"><a href="#二、非同源页面之间的通信" class="headerlink" title="二、非同源页面之间的通信"></a>二、非同源页面之间的通信</h2><p>上面我们介绍了七种前端跨页面通信的方法，但它们大都受到同源策略的限制。然而有时候，我们有两个不同域名的产品线，也希望它们下面的所有页面之间能无障碍地通信。那该怎么办呢？</p>
<p>要实现该功能，可以使用一个用户不可见的 iframe 作为“桥”。由于 iframe 与父页面间可以通过指定<code>origin</code>来忽略同源限制，因此可以在每个页面中嵌入一个 iframe （例如：<code>http://sample.com/bridge.html</code>），而这些 iframe 由于使用的是一个 url，因此属于同源页面，其通信方式可以复用上面第一部分提到的各种方式。</p>
<p>页面与 iframe 通信非常简单，首先需要在页面中监听 iframe 发来的消息，做相应的业务处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 业务页面代码 *&#x2F;</span><br><span class="line">window.addEventListener(&#39;message&#39;, function (e) &#123;</span><br><span class="line">    &#x2F;&#x2F; …… do something</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>然后，当页面要与其他的同源或非同源页面通信时，会先给 iframe 发送消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 业务页面代码 *&#x2F;</span><br><span class="line">window.frames[0].window.postMessage(mydata, &#39;*&#39;);</span><br></pre></td></tr></table></figure>

<p>其中为了简便此处将<code>postMessage</code>的第二个参数设为了<code>&#39;*&#39;</code>，你也可以设为 iframe 的 URL。iframe 收到消息后，会使用某种跨页面消息通信技术在所有 iframe 间同步消息，例如下面使用的 Broadcast Channel：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* iframe 内代码 *&#x2F;</span><br><span class="line">const bc &#x3D; new BroadcastChannel(&#39;AlienZHOU&#39;);</span><br><span class="line">&#x2F;&#x2F; 收到来自页面的消息后，在 iframe 间进行广播</span><br><span class="line">window.addEventListener(&#39;message&#39;, function (e) &#123;</span><br><span class="line">    bc.postMessage(e.data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>其他 iframe 收到通知后，则会将该消息同步给所属的页面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* iframe 内代码 *&#x2F;</span><br><span class="line">&#x2F;&#x2F; 对于收到的（iframe）广播消息，通知给所属的业务页面</span><br><span class="line">bc.onmessage &#x3D; function (e) &#123;</span><br><span class="line">    window.parent.postMessage(e.data, &#39;*&#39;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下图就是使用 iframe 作为“桥”的非同源页面间通信模式图。</p>
<p><img src="3.png#id=K3AvO&originalType=binary&status=done&style=none"></p>
<p>其中“同源跨域通信方案”可以使用文章第一部分提到的某种技术。</p>
<p>–</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天和大家分享了一下跨页面通信的各种方式。</p>
<p>对于同源页面，常见的方式包括：</p>
<ul>
<li>广播模式：Broadcast Channe / Service Worker / LocalStorage + StorageEvent</li>
<li>共享存储模式：Shared Worker / IndexedDB / cookie</li>
<li>口口相传模式：window.open + window.opener</li>
<li>基于服务端：Websocket / Comet / SSE 等</li>
</ul>
<p>而对于非同源页面，则可以通过嵌入同源 iframe 作为“桥”，将非同源页面通信转换为同源页面通信。</p>
<blockquote>
<p>对文章感兴趣的同学欢迎关注 <a target="_blank" rel="noopener" href="https://github.com/alienzhou/blog">我的博客 &gt;&gt; https://github.com/alienzhou/blog</a></p>
</blockquote>
<p>本文在分享的同时，也是为了抛转引玉。如果你有什么其他想法，欢迎一起讨论，提出你的见解和想法~</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/19/yuque/%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%EF%BC%8C%E5%9D%97%E7%8A%B6%E5%85%83%E7%B4%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/19/yuque/%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%EF%BC%8C%E5%9D%97%E7%8A%B6%E5%85%83%E7%B4%A0/" class="post-title-link" itemprop="url">行内元素，块状元素</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-19 20:31:03" itemprop="dateCreated datePublished" datetime="2021-04-19T20:31:03+08:00">2021-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-22 14:41:28" itemprop="dateModified" datetime="2021-04-22T14:41:28+08:00">2021-04-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>什么叫行内元素？<br>常见的 span、a、lable、strong、b 等 html 标签都是行内元素<br>什么叫块级元素？<br>常见的 div、p、li、h1、h2、h3、h4 等 html 标签都是块级元素</p>
<h3 id="略知一二："><a href="#略知一二：" class="headerlink" title="略知一二："></a>略知一二：</h3><p>行内元素有：a, span, label, strong, em, br, img, input, select, textarea, cite,块级元素：div, h1~h6, p, form, ul, li, ol, dl, address, hr, menu, table, fieldset</p>
<h3 id="粗通皮毛："><a href="#粗通皮毛：" class="headerlink" title="粗通皮毛："></a>粗通皮毛：</h3><h4 id="（行内元素）内联元素-inline-element"><a href="#（行内元素）内联元素-inline-element" class="headerlink" title="（行内元素）内联元素(inline element)"></a>（行内元素）内联元素(inline element)</h4><ul>
<li>a - 锚点</li>
<li>abbr - 缩写</li>
<li>acronym - 首字</li>
<li>b - 粗体(不推荐)</li>
<li>bdo - bidi override</li>
<li>big - 大字体</li>
<li>br - 换行</li>
<li>cite - 引用</li>
<li>code - 计算机代码(在引用源码的时候需要)</li>
<li>dfn - 定义字段</li>
<li>em - 强调</li>
<li>font - 字体设定(不推荐)</li>
<li>i - 斜体</li>
<li>img - 图片</li>
<li>input - 输入框</li>
<li>kbd - 定义键盘文本</li>
<li>label - 表格标签</li>
<li>q - 短引用</li>
<li>s - 中划线(不推荐)</li>
<li>samp - 定义范例计算机代码</li>
<li>select - 项目选择</li>
<li>small - 小字体文本</li>
<li>span - 常用内联容器，定义文本内区块</li>
<li>strike - 中划线</li>
<li>strong - 粗体强调</li>
<li>sub - 下标</li>
<li>sup - 上标</li>
<li>textarea - 多行文本输入框</li>
<li>tt - 电传文本</li>
<li>u - 下划线</li>
<li>var - 定义变量</li>
</ul>
<h4 id="块元素-block-element"><a href="#块元素-block-element" class="headerlink" title="块元素(block element)"></a>块元素(block element)</h4><ul>
<li>address - 地址</li>
<li>blockquote - 块引用</li>
<li>center - 举中对齐块</li>
<li>dir - 目录列表</li>
<li>div - 常用块级容易，也是 css layout 的主要标签</li>
<li>dl - 定义列表</li>
<li>fieldset - form 控制组</li>
<li>form - 交互表单</li>
<li>h1 - 大标题</li>
<li>h2 - 副标题</li>
<li>h3 - 3 级标题</li>
<li>h4 - 4 级标题</li>
<li>h5 - 5 级标题</li>
<li>h6 - 6 级标题</li>
<li>hr - 水平分隔线</li>
<li>isindex - input prompt</li>
<li>menu - 菜单列表</li>
<li>noframes - frames 可选内容，（对于不支持 frame 的浏览器显示此区块内容</li>
<li>noscript - ）可选脚本内容（对于不支持 script 的浏览器显示此内容）</li>
<li>ol - 排序表单</li>
<li>p - 段落</li>
<li>pre - 格式化文本</li>
<li>table - 表格</li>
<li>ul - 非排序列表</li>
</ul>
<h4 id="可变元素"><a href="#可变元素" class="headerlink" title="可变元素"></a>可变元素</h4><p>可变元素为根据上下文语境决定该元素为块元素或者行内元素。</p>
<ul>
<li>applet - java applet</li>
<li>button - 按钮</li>
<li>del - 删除文本</li>
<li>iframe - inline frame</li>
<li>ins - 插入的文本</li>
<li>map - 图片区块(map)</li>
<li>object - object 对象</li>
<li>script - 客户端脚本</li>
</ul>
<h3 id="驾轻就熟："><a href="#驾轻就熟：" class="headerlink" title="驾轻就熟："></a>驾轻就熟：</h3><h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><ol>
<li>块级元素会独占一行，其宽度自动填满其父元素宽度行内元素不会独占一行，相邻的行内元素会排列在同一行里，知道一行排不下，才会换行，其宽度随元素的内容而变化</li>
<li>块级元素可以设置 width, height 属性，【注意：块级元素即使设置了宽度，仍然是独占一行的】行内元素设置 width, height 无效;</li>
<li>块级元素可以设置 margin 和 padding.行内元素的水平方向的 padding-left,padding-right,margin-left,margin-right 都产生边距效果，但是竖直方向的 padding-top,padding-bottom,margin-top,margin-bottom 都不会产生边距效果。（水平方向有效，竖直方向无效）</li>
</ol>
<h3 id="青出於蓝"><a href="#青出於蓝" class="headerlink" title="青出於蓝:"></a>青出於蓝:</h3><ul>
<li><p>行内元素与块级元素直观上的区别行内元素会在一条直线上排列，都是同一行的，水平方向排列块级元素各占据一行，垂直方向排列。块级元素从新行开始结束接着一个断行。</p>
</li>
<li><p>块级元素可以包含行内元素和块级元素。行内元素不能包含块级元素。</p>
</li>
<li><p>行内元素与块级元素属性的不同，主要是盒模型属性上行内元素设置 width 无效，height 无效(可以设置 line-height)，margin 上下无效，padding 上下无效</p>
<p>display：inline 行内元素/内联元素<br>display:block 块级元素<br>display:inline-block 设置成行内块级元素。</p>
</li>
</ul>
<p>行内块级元素:和其他元素同一行（行内元素特点），可以设置元素的宽高等（块级元素特点）；这样的元素有 img input；它们为行内元素，但可以改变宽和高；但我在我印象中，貌似没有默认样式是 inline-block 的元素。</p>
<h3 id="融会贯通："><a href="#融会贯通：" class="headerlink" title="融会贯通："></a>融会贯通：</h3><ul>
<li>行内元素属性<ol>
<li> 行内元素属性标签它和其它标签处在同一行内</li>
<li> 行内元素属性标签无法设置宽度，高度 行高 距顶部距离 距底部距离</li>
<li> 行内元素属性标签的宽度是直接由内部的文字或者图片等内容撑开的</li>
<li> 行内元素属性标签内部不能嵌套行属性标签（a 链接内不能嵌套其他链接）</li>
</ol>
</li>
<li>块级元素属性<ol>
<li> 每一个块级元素属性标签都是从新的一行开始，而且之后的元素也都会从新的一行开始（因为每一个块属性标签都会直接占据一整行的内容，导致下面的内容也只能从新的一行开始）</li>
<li> 块级元素属性标签都是可以设置宽度、高度，行高，距顶部距离，距底部距离</li>
<li> 块级元素属性标签的宽度假如不做设置，会直接默认为父元素宽度的 100%</li>
<li> 块级元素属性标签是可以直接嵌套的</li>
<li> p 标签中不能嵌套 div 标签</li>
</ol>
</li>
</ul>
<h3 id="出类拔萃："><a href="#出类拔萃：" class="headerlink" title="出类拔萃："></a>出类拔萃：</h3><ul>
<li><p>CSS 设置行内元素的</p>
<ul>
<li><p>水平居中 div{text-align:center} /<em>DIV 内的行内元素均会水平居中</em>/</p>
</li>
<li><p>垂直居中 div{height:30px; line-height:30px} /<em>DIV 内的行内元素均会垂直居中</em>/</p>
</li>
</ul>
</li>
<li><p>CSS 设置块级元素的</p>
<ul>
<li><p>水平居中</p>
<ul>
<li>div p{margin:0 auto; width:500px} /<em>块级元素 p 一定要设置宽度， 才能相当于 DIV 父容器水平居中</em>/-</li>
</ul>
</li>
<li><p>垂直居中 div{width:500px} /*DIV 父容器设置宽度</p>
<ul>
<li>*/ div p{margin:0 aut0; height:30px; line-height:30px} /*块级元素 p 也可以加个宽度， 以达到相对于 DIV 父容器的水平居中效果*/</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>在以后的实际项目中，块级元素的垂直居中布局方式可能会碰到比这个更复杂, 会尝试用 inline-block 去解决问题，希望后续多多关注；另外推荐各位一本书肖志华《CSS 核心技术详解》</p>
<h3 id="返璞归真："><a href="#返璞归真：" class="headerlink" title="返璞归真："></a>返璞归真：</h3><p>在标准文档流里面，块级元素具有以下特点：<br>① 总是在新行上开始，占据一整行；<br>② 高度，行高以及外边距和内边距都可控制；<br>③ 宽带始终是与浏览器宽度一样，与内容无关；<br>④ 它可以容纳内联元素和其他块元素。</p>
<p>行内元素的特点：<br>① 和其他元素都在一行上；<br>② 高，行高及外边距和内边距部分可改变；<br>③ 宽度只与内容有关；<br>④ 行内元素只能容纳文本或者其他行内元素。<br>不可以设置宽高，其宽度随着内容增加，高度随字体大小而改变，内联元素可以设置外边界，但是外边界不对上下起作用，只能对左右起作用，也可以设置内边界，但是内边界在 ie6 中不对上下起作用，只能对左右起作用</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/19/yuque/%E9%97%AD%E5%8C%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/19/yuque/%E9%97%AD%E5%8C%85/" class="post-title-link" itemprop="url">闭包</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-19 15:41:01" itemprop="dateCreated datePublished" datetime="2021-04-19T15:41:01+08:00">2021-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-22 14:41:28" itemprop="dateModified" datetime="2021-04-22T14:41:28+08:00">2021-04-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h1><p>闭包函数：声明在一个函数中的函数，叫做闭包函数。</p>
<p>闭包：内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。</p>
<h2 id="2、特点"><a href="#2、特点" class="headerlink" title="2、特点"></a>2、特点</h2><p>让外部访问函数内部变量成为可能；<br>  局部变量会常驻在内存中；<br>  可以避免使用全局变量，防止全局变量污染；<br>  会造成内存泄漏（有一块内存空间被长期占用，而不被释放）</p>
<h3 id="3、闭包的创建：­­­"><a href="#3、闭包的创建：­­­" class="headerlink" title="3、闭包的创建：­­­"></a>3、闭包的创建：­­­</h3><p>闭包就是可以创建一个独立的环境，每个闭包里面的环境都是独立的，互不干扰。闭包会发生内存泄漏，每次外部函数执行的时 候，外部函数的引用地址不同，都会重新创建一个新的地址。但凡是当前活动对象中有被内部子集引用的数据，那么这个时候，这个数据不删除，保留一根指针给内部活动对象。<br>闭包内存泄漏为： key = value，key 被删除了 value 常驻内存中; 局部变量闭包升级版（中间引用的变量） =&gt; 自由变量；</p>
<h1 id="4、闭包的应用场景"><a href="#4、闭包的应用场景" class="headerlink" title="4、闭包的应用场景"></a>4、闭包的应用场景</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>; <span class="comment">// funA的活动对象之中;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//匿名函数的活动对象;</span></span><br><span class="line">    alert(a);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = funA();</span><br><span class="line">b(); <span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">innerFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> innerFn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> inner = outerFn(); <span class="comment">//每次外部函数执行的时候,都会开辟一块内存空间,外部函数的地址不同，都会重新创建一个新的地址</span></span><br><span class="line">inner();</span><br><span class="line">inner();</span><br><span class="line">inner();</span><br><span class="line"><span class="keyword">var</span> inner2 = outerFn();</span><br><span class="line">inner2();</span><br><span class="line">inner2();</span><br><span class="line">inner2(); <span class="comment">//1 2 3 1 2 3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">innnerFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> innnerFn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> inner1 = outerFn();</span><br><span class="line"><span class="keyword">var</span> inner2 = outerFn();</span><br><span class="line">inner1();</span><br><span class="line">inner2();</span><br><span class="line">inner1();</span><br><span class="line">inner2(); <span class="comment">//1 2 3 4</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++a;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">alert(fn()()); <span class="comment">//4</span></span><br><span class="line">alert(fn()()); <span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">innnerFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> innnerFn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> inner1 = outerFn();</span><br><span class="line"><span class="keyword">var</span> inner2 = outerFn();</span><br><span class="line">inner1();</span><br><span class="line">inner2();</span><br><span class="line">inner1();</span><br><span class="line">inner2(); <span class="comment">//1 1 2 2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> m = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getM</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">seta</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    m = val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">window</span>.g = getM;</span><br><span class="line">  <span class="built_in">window</span>.f = seta;</span><br><span class="line">&#125;)();</span><br><span class="line">f(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.info(g()); <span class="comment">//100  闭包找到的是同一地址中父级函数中对应变量最终的值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(++i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = a();</span><br><span class="line">c(); <span class="comment">//1</span></span><br><span class="line">c(); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">console</span>.info(count);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> t1 = f();</span><br><span class="line">t1(); <span class="comment">//1</span></span><br><span class="line">t1(); <span class="comment">//2</span></span><br><span class="line">t1(); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> tmp = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    sum = sum + x;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;;</span><br><span class="line">  tmp.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;;</span><br><span class="line">alert(add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">//6</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lis = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;li&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lis.length; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">    lis[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(i); <span class="comment">//事件处理函数中闭包的写法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(++x);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m1()(); <span class="comment">//2</span></span><br><span class="line">m1()(); <span class="comment">//2</span></span><br><span class="line">m1()(); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m2 = m1();</span><br><span class="line">m2(); <span class="comment">//2</span></span><br><span class="line">m2(); <span class="comment">//3</span></span><br><span class="line">m2(); <span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">10</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(++i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn;</span><br><span class="line">&#125;)();</span><br><span class="line">fn(); <span class="comment">//11</span></span><br><span class="line">fn(); <span class="comment">//12</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">love1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">223</span>;</span><br><span class="line">  <span class="keyword">var</span> me1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">  &#125;;</span><br><span class="line">  num++;</span><br><span class="line">  <span class="keyword">return</span> me1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> loveme1 = love1();</span><br><span class="line">loveme1(); <span class="comment">//输出224</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">n, o</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(o);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    fun: <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fun(m, n);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = fun(<span class="number">0</span>); <span class="comment">//undefined</span></span><br><span class="line">a.fun(<span class="number">1</span>); <span class="comment">//0</span></span><br><span class="line">a.fun(<span class="number">2</span>); <span class="comment">//0</span></span><br><span class="line">a.fun(<span class="number">3</span>); <span class="comment">//0</span></span><br><span class="line"><span class="keyword">var</span> b = fun(<span class="number">0</span>).fun(<span class="number">1</span>).fun(<span class="number">2</span>).fun(<span class="number">3</span>); <span class="comment">//undefined  0  1  2</span></span><br><span class="line"><span class="keyword">var</span> c = fun(<span class="number">0</span>).fun(<span class="number">1</span>);</span><br><span class="line">c.fun(<span class="number">2</span>);</span><br><span class="line">c.fun(<span class="number">3</span>); <span class="comment">//undefined  0  1  1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    arr[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> list = fn();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(list[i]());</span><br><span class="line">&#125; <span class="comment">//5 5 5 5 5</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    arr[i] = (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;)(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> list = fn();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(list[i]());</span><br><span class="line">&#125; <span class="comment">//0 1 2 3 4</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/18/yuque/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/18/yuque/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">数据类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-18 00:19:29" itemprop="dateCreated datePublished" datetime="2021-04-18T00:19:29+08:00">2021-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-22 14:41:28" itemprop="dateModified" datetime="2021-04-22T14:41:28+08:00">2021-04-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1618676788048-988699b0-72f7-4748-9064-1bc417d8ba39.png#clientId=u0f756751-46c8-4&from=paste&height=555&id=ued534341&margin=%5Bobject%20Object%5D&originHeight=788&originWidth=1021&originalType=binary&size=126478&status=done&style=none&taskId=u0d11ffd4-876a-4c72-8173-b5871de923e&width=719.5"></p>
<h2 id="原始值-primitive-values"><a href="#原始值-primitive-values" class="headerlink" title="原始值( primitive values )"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E5%8E%9F%E5%A7%8B%E5%80%BC_primitive_values">原始值( primitive values )</a></h2><p>除 Object 以外的所有类型都是不可变的（值本身无法被改变）。例如，与 C 语言不同，JavaScript 中字符串是不可变的（译注：如，JavaScript 中对字符串的操作一定返回了一个新字符串，原始字符串并没有被改变）。我们称这些类型的值为“原始值”。</p>
<h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B">布尔类型</a></h3><p>布尔表示一个逻辑实体，可以有两个值：true 和 false。</p>
<h3 id="Null-类型"><a href="#Null-类型" class="headerlink" title="Null 类型"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#null_%E7%B1%BB%E5%9E%8B">Null 类型</a></h3><p>Null 类型只有一个值：null，更多详情可查看<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null">null</a>和<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Glossary/Null">Null</a>。</p>
<h3 id="Undefined-类型"><a href="#Undefined-类型" class="headerlink" title="Undefined 类型"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#undefined_%E7%B1%BB%E5%9E%8B">Undefined 类型</a></h3><p>一个没有被赋值的变量会有个默认值 undefined，更多详情可查看<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined">undefined</a>和<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Glossary/undefined">Undefined</a>。</p>
<h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B">数字类型</a></h3><p>根据 ECMAScript 标准，JavaScript 中只有一种数字类型：基于 IEEE 754 标准的双精度 64 位二进制格式的值（-(253-1) 到 253-1）。<strong>它并没有为整数给出一种特定的类型</strong>。除了能够表示浮点数外，还有一些带符号的值：+Infinity，-Infinity 和 NaN(非数值，Not-a-Number)。<br>要检查值是否大于或小于+/-Infinity，你可以使用常量<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_VALUE">Number.MAX_VALUE</a>和<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/MIN_VALUE">Number.MIN_VALUE</a>。另外在 ECMAScript 6 中，你也可以通过<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger">Number.isSafeInteger()</a>方法还有<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER">Number.MAX_SAFE_INTEGER</a>和<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/MIN_SAFE_INTEGER">Number.MIN_SAFE_INTEGER</a>来检查值是否在双精度浮点数的取值范围内。 超出这个范围，JavaScript 中的数字不再安全了，也就是只有 second mathematical interger 可以在 JavaScript 数字类型中正确表现。<br>数字类型中只有一个整数有两种表示方法： 0 可表示为 -0 和 +0（”0” 是 +0 的简写）。 在实践中，这也几乎没有影响。 例如+0 === -0 为真。 但是，你可能要注意除以 0 的时候：<br>42 / +0; // Infinity<br>42 / -0; // -Infinity</p>
<p>尽管一个数字常常仅代表它本身的值，但 JavaScript 提供了一些<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators">位运算符</a>。 这些位运算符和一个单一数字通过位操作可以用来表现一些布尔值。然而自从 JavaScript 提供其他的方式来表示一组布尔值（如一个布尔值数组或一个布尔值分配给命名属性的对象）后，这种方式通常被认为是不好的。位操作也容易使代码难以阅读，理解和维护， 在一些非常受限的情况下，可能需要用到这些技术，比如试图应付本地存储的存储限制。 位操作只应该是用来优化尺寸的最后选择。</p>
<h3 id="BigInt-类型"><a href="#BigInt-类型" class="headerlink" title="BigInt 类型"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#bigint_%E7%B1%BB%E5%9E%8B">BigInt 类型</a></h3><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt">BigInt</a>类型是 JavaScript 中的一个基础的数值类型，可以用任意精度表示整数。使用 BigInt，您可以安全地存储和操作大整数，甚至可以超过数字的安全整数限制。BigInt 是通过在整数末尾附加  n  或调用构造函数来创建的。<br>通过使用常量<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER">Number.MAX_SAFE_INTEGER</a>，您可以获得可以用数字递增的最安全的值。通过引入 BigInt，您可以操作超过<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER">Number.MAX_SAFE_INTEGER</a>的数字。您可以在下面的示例中观察到这一点，其中递增<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER">Number.MAX_SAFE_INTEGER</a>会返回预期的结果:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">const</span> x = <span class="number">2n</span> ** <span class="number">53n</span>;</span><br><span class="line"><span class="number">9007199254740992n</span></span><br><span class="line">&gt; <span class="keyword">const</span> y = x + <span class="number">1n</span>;</span><br><span class="line"><span class="number">9007199254740993n</span></span><br></pre></td></tr></table></figure>

<p>可以对 BigInt 使用运算符+、*、-、**和%，就像对数字一样。BigInt 严格来说并不等于一个数字，但它是松散的。<br>在将 BigInt 转换为 Boolean 时，它的行为类似于一个数字：if、||、&amp;&amp;、Boolean  和!。<br>BigInt 不能与数字互换操作。否则，将抛出<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError">TypeError</a>。</p>
<h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B">字符串类型</a></h3><p>JavaScript 的字符串类型用于表示文本数据。它是一组 16 位的无符号整数值的“元素”。在字符串中的每个元素占据了字符串的位置。第一个元素的索引为 0，下一个是索引 1，依此类推。字符串的长度是它的元素的数量。<br>不同于类 C 语言，JavaScript 字符串是不可更改的。这意味着字符串一旦被创建，就不能被修改。但是，可以基于对原始字符串的操作来创建新的字符串。例如：</p>
<ul>
<li>获取一个字符串的子串可通过选择个别字母或者使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/substr">String.substr()</a>.</li>
<li>两个字符串的连接使用连接操作符 (+) 或者<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/concat">String.concat()</a>.</li>
</ul>
<h4 id="注意代码中的“字符串类型”！"><a href="#注意代码中的“字符串类型”！" class="headerlink" title="注意代码中的“字符串类型”！"></a>注意代码中的“字符串类型”！</h4><p>可以使用字符串来表达复杂的数据。以下是一些很好的性质：</p>
<ul>
<li>容易连接构造复杂的字串符</li>
<li>字符串容易被调试(你看到的往往在字符串里)</li>
<li>字符串通常是许多 APIs 的常见标准 (<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/DOM/HTMLInputElement">input fields</a>,<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/Storage">local storage</a>values,<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a>当使用 responseText 等的时候回应) 而且他只能与字符串一同使用。</li>
</ul>
<p>使用约定，字符串一般可以用来表达任何数据结构。这不是一个好主意。例如，使用一个分隔符，可以模拟一个列表（而 JavaScript 数组可能更适合）。不幸的是，当分隔符用于列表中的元素时，列表就会被破坏。 可以选择转义字符，等等。所有这些都需要约定，并造成不必要的维护负担。<br>表达文本数据和符号数据时候推荐使用字符串。当表达复杂的数据时，使用字符串解析和适当的缩写。</p>
<h3 id="符号类型"><a href="#符号类型" class="headerlink" title="符号类型"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B">符号类型</a></h3><p>符号(Symbols)是 ECMAScript 第 6 版新定义的。符号类型是唯一的并且是不可修改的, 并且也可以用来作为 Object 的 key 的值(如下).  在某些语言当中也有类似的原子类型(Atoms). 你也可以认为为它们是 C 里面的枚举类型.  更多细节请看<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Glossary/Symbol">Symbol</a>和  <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol">Symbol</a>。</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E5%AF%B9%E8%B1%A1">对象</a></h2><p>在计算机科学中, 对象是指内存中的可以被  <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Glossary/Identifier">标识符</a>引用的一块区域.</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E5%B1%9E%E6%80%A7">属性</a></h3><p>在 Javascript 里，对象可以被看作是一组属性的集合。用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/JavaScript/Guide/Values,_variables,_and_literals#object_literals">对象字面量语法</a>来定义一个对象时，会自动初始化一组属性。（也就是说，你定义一个 var a = “Hello”，那么 a 本身就会有 a.substring 这个方法，以及 a.length 这个属性，以及其它；如果你定义了一个对象，var a = {}，那么 a 就会自动有 a.hasOwnProperty 及 a.constructor 等属性和方法。）而后，这些属性还可以被增减。属性的值可以是任意类型，包括具有复杂数据结构的对象。属性使用键来标识，它的键值可以是一个字符串或者符号值（Symbol）。<br>ECMAScript 定义的对象中有两种属性：数据属性和访问器属性。</p>
<h4 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h4><p>数据属性是键值对，并且每个数据属性拥有下列特性:<br><strong>数据属性的特性(Attributes of a data property)</strong><br>| 特性 | 数据类型 | 描述 | 默认值 |<br>| — | — | — | — |<br>| [[Value]] | 任何 Javascript 类型 | 包含这个属性的数据值。 | undefined |<br>| [[Writable]] | Boolean | 如果该值为  false，则该属性的 [[Value]] 特性 不能被改变。 | false |<br>| [[Enumerable]] | Boolean | 如果该值为  true，则该属性可以用  <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in">for…in</a>循环来枚举。 | false |<br>| [[Configurable]] | Boolean | 如果该值为  false，则该属性不能被删除，并且 除了 [[Value]] 和 [[Writable]] 以外的特性都不能被改变。 | false |</p>
<h4 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h4><p>访问器属性有一个或两个访问器函数  (get 和 set) 来存取数值，并且有以下特性:<br>| 特性 | 类型 | 描述 | 默认值 |<br>| — | — | — | — |<br>| [[Get]] | 函数对象或者 undefined | 该函数使用一个空的参数列表，能够在有权访问的情况下读取属性值。另见  <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/get">get</a>。 | undefined |<br>| [[Set]] | 函数对象或者 undefined | 该函数有一个参数，用来写入属性值，另见  <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/set">set</a>。 | undefined |<br>| [[Enumerable]] | Boolean | 如果该值为  true，则该属性可以用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in">for…in</a>  循环来枚举。 | false |<br>| [[Configurable]] | Boolean | 如果该值为  false，则该属性不能被删除，并且不能被转变成一个数据属性。 | false |</p>
<h3 id="“标准的”-对象-和函数"><a href="#“标准的”-对象-和函数" class="headerlink" title="“标准的” 对象, 和函数"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E6%A0%87%E5%87%86%E7%9A%84_%E5%AF%B9%E8%B1%A1_%E5%92%8C%E5%87%BD%E6%95%B0">“标准的” 对象, 和函数</a></h3><p>一个 Javascript 对象就是键和值之间的映射.。键是一个字符串（或者<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol">Symbol</a>） ，值可以是任意类型的值。  这使得对象非常符合  <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Hash_table">哈希表</a>。<br>函数是一个附带可被调用功能的常规对象。</p>
<h3 id="日期"><a href="#日期" class="headerlink" title="日期"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E6%97%A5%E6%9C%9F">日期</a></h3><p>当你想要显示日期时，毋庸置疑，使用内建的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/JavaScript/Reference/Global_Objects/Date">Date</a>对象。</p>
<h3 id="有序集-数组和类型数组"><a href="#有序集-数组和类型数组" class="headerlink" title="有序集: 数组和类型数组"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E6%9C%89%E5%BA%8F%E9%9B%86_%E6%95%B0%E7%BB%84%E5%92%8C%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84">有序集: 数组和类型数组</a></h3><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array">数组</a>是一种使用整数作为键(integer-key-ed)属性和长度(length)属性之间关联的常规对象。此外，数组对象还继承了 Array.prototype 的一些操作数组的便捷方法。例如, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf">indexOf</a> (搜索数组中的一个值) or <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/push">push</a> (向数组中添加一个元素)，等等。  这使得数组是表示列表或集合的最优选择。<br><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays">类型数组(Typed Arrays)</a>是 ECMAScript Edition 6 中新定义的 JavaScript 内建对象，提供了一个基本的二进制数据缓冲区的类数组视图。下面的表格能帮助你找到对等的 C 语言数据类型：</p>
<h4 id="TypedArray-objects"><a href="#TypedArray-objects" class="headerlink" title="TypedArray objects"></a>TypedArray objects</h4><table>
<thead>
<tr>
<th>Type</th>
<th>Value Range</th>
<th>Size in bytes</th>
<th>Description</th>
<th>Web IDL type</th>
<th>Equivalent C type</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array">Int8Array</a></td>
<td>-128to127</td>
<td>1</td>
<td>8-bit two’s complement signed integer</td>
<td>byte</td>
<td>int8_t</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array">Uint8Array</a></td>
<td>0to255</td>
<td>1</td>
<td>8-bit unsigned integer</td>
<td>octet</td>
<td>uint8_t</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray">Uint8ClampedArray</a></td>
<td>0to255</td>
<td>1</td>
<td>8-bit unsigned integer (clamped)</td>
<td>octet</td>
<td>uint8_t</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array">Int16Array</a></td>
<td>-32768to32767</td>
<td>2</td>
<td>16-bit two’s complement signed integer</td>
<td>short</td>
<td>int16_t</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array">Uint16Array</a></td>
<td>0to65535</td>
<td>2</td>
<td>16-bit unsigned integer</td>
<td>unsigned short</td>
<td>uint16_t</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array">Int32Array</a></td>
<td>-2147483648to2147483647</td>
<td>4</td>
<td>32-bit two’s complement signed integer</td>
<td>long</td>
<td>int32_t</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array">Uint32Array</a></td>
<td>0to4294967295</td>
<td>4</td>
<td>32-bit unsigned integer</td>
<td>unsigned long</td>
<td>uint32_t</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array">Float32Array</a></td>
<td>1.2×10-38to3.4×1038</td>
<td>4</td>
<td>32-bit IEEE floating point number (7 significant digits e.g.,1.234567)</td>
<td>unrestricted float</td>
<td>float</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array">Float64Array</a></td>
<td>5.0×10-324to1.8×10308</td>
<td>8</td>
<td>64-bit IEEE floating point number (16 significant digits e.g.,1.23456789012345)</td>
<td>unrestricted double</td>
<td>double</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt64Array">BigInt64Array</a></td>
<td>-263to263-1</td>
<td>8</td>
<td>64-bit two’s complement signed integer</td>
<td>bigint</td>
<td>int64_t (signed long long)</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigUint64Array">BigUint64Array</a></td>
<td>0to264-1</td>
<td>8</td>
<td>64-bit unsigned integer</td>
<td>bigint</td>
<td>uint64_t (unsigned long long)</td>
</tr>
</tbody></table>
<h3 id="键控集-Maps-Sets-WeakMaps-WeakSets"><a href="#键控集-Maps-Sets-WeakMaps-WeakSets" class="headerlink" title="键控集: Maps, Sets, WeakMaps, WeakSets"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E9%94%AE%E6%8E%A7%E9%9B%86_maps_sets_weakmaps_weaksets">键控集: Maps, Sets, WeakMaps, WeakSets</a></h3><p>这些数据结构把对象的引用当作键，其在 ECMAScript 第 6 版中有介绍。当<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map">Map</a>和<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap">WeakMap</a>把一个值和对象关联起来的时候，<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set">Set</a>和<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakSet">WeakSet</a>表示一组对象。 Map 和 WeakMaps 之间的差别在于，在前者中，对象键是可枚举的。这允许垃圾收集器优化后面的枚举(This allows garbage collection optimizations in the latter case)。<br>在纯 ECMAScript 5 下可以实现 Maps 和 Sets。然而，因为对象并不能进行比较（就对象“小于”示例来讲），所以查询必定是线性的。他们本地实现（包括 WeakMaps）查询所花费的时间可能是对数增长。<br>通常，可以通过直接在对象上设置属性或着使用 data-*属性，来绑定数据到 DOM 节点。然而缺陷是在任何的脚本里，数据都运行在同样的上下文中。Maps 和 WeakMaps 方便将数据私密的绑定到一个对象。</p>
<h3 id="结构化数据-JSON"><a href="#结构化数据-JSON" class="headerlink" title="结构化数据: JSON"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE_json">结构化数据: JSON</a></h3><p>JSON (JavaScript Object Notation) 是一种轻量级的数据交换格式，来源于 JavaScript 同时也被多种语言所使用。 JSON 用于构建通用的数据结构。参见<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Glossary/JSON">JSON</a>以及<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON">JSON</a>了解更多。</p>
<h3 id="标准库中更多的对象"><a href="#标准库中更多的对象" class="headerlink" title="标准库中更多的对象"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%AF%B9%E8%B1%A1">标准库中更多的对象</a></h3><p>JavaScript 有一个内置对象的标准库。请查看<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects">参考</a>来了解更多对象。</p>
<h2 id="使用-typeof-操作符判断对象类型"><a href="#使用-typeof-操作符判断对象类型" class="headerlink" title="使用 typeof 操作符判断对象类型"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E4%BD%BF%E7%94%A8_typeof_%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B">使用 typeof 操作符判断对象类型</a></h2><p>typeof 运算符可以帮助你查询变量的类型。要了解更多细节和注意事项请阅读<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof">参考页</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/18/yuque/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/18/yuque/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" class="post-title-link" itemprop="url">类型转换</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-18 00:11:00" itemprop="dateCreated datePublished" datetime="2021-04-18T00:11:00+08:00">2021-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-22 14:41:28" itemprop="dateModified" datetime="2021-04-22T14:41:28+08:00">2021-04-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="原始值到原始值的转换"><a href="#原始值到原始值的转换" class="headerlink" title="原始值到原始值的转换"></a>原始值到原始值的转换</h2><p>原始值转化为布尔值</p>
<p>所有的假值(undefined、null、0、-0、NaN、””)会被转化为 false，其他都会被转为 true</p>
<p>原始值转化为字符串 都相当于 原始值 + “”</p>
<p>原始值转为数字</p>
<ul>
<li>布尔转数字：true -&gt; 1, false -&gt; 0</li>
<li>字符串转数字：以数字表示的字符串可以直接会转为字符串，如果字符串头尾有空格会忽略，但是空格在中间，转换结果就是 NaN。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+&quot; 66&quot; &#x2F;&#x2F; 66</span><br><span class="line">+&quot; 6 7 &quot; &#x2F;&#x2F; NaN</span><br></pre></td></tr></table></figure>

<h2 id="原始值到对象的转换"><a href="#原始值到对象的转换" class="headerlink" title="原始值到对象的转换"></a>原始值到对象的转换</h2><ul>
<li>null 和 undefined 转对象直接抛异常</li>
<li>原始值通过调用 String()、Number()、Boolean()构造函数，转换为他们各自的包装对象</li>
<li><img src="http://47.98.159.95/my_blog/015/type.jpg#alt=project"></li>
</ul>
<h2 id="对象到原始值的转换"><a href="#对象到原始值的转换" class="headerlink" title="对象到原始值的转换"></a>对象到原始值的转换</h2><p>对象转为布尔都为 true</p>
<p>对象到字符串</p>
<ul>
<li>如果对象有 toString() 方法，就调用 toString() 方法。如果该方法返回原始值，就讲这个值转化为字符串。</li>
<li>如果对象没有 toString() 方法或者 该方法返回的不是原始值，就会调用该对象的 valueOf() 方法。如果存在就调用这个方法，如果返回值是原始值，就转化为字符串。</li>
<li>否则就报错</li>
</ul>
<p>对象到数字</p>
<ul>
<li>对象转化为数字做了跟对象转化为字符串做了想同的事儿，不同的是后者是先调用 valueOf 方法，如果调用失败或者返回不是原始值，就调用 toString 方法。</li>
</ul>
<p>补充。一些常用内置对象 toString 方法和 valueOf 的转换规则</p>
<ul>
<li>toString 相关</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/7/165124228d44d25a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1#alt="></p>
<ul>
<li>valueOf 相关</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/7/165124228d85b808?imageView2/0/w/1280/h/960/format/webp/ignore-error/1#alt=img"></p>
<h2 id="运算符如何进行类型转换"><a href="#运算符如何进行类型转换" class="headerlink" title="== 运算符如何进行类型转换"></a>== 运算符如何进行类型转换</h2><ol>
<li>如果一个值是 null，另一个值是 undefined，则相等</li>
<li>如果一个是字符串，另一个值是数字，则把字符串转换成数字，进行比较</li>
<li>如果任意值是 true，则把 true 转换成 1 再进行比较；如果任意值是 false，则把 false 转换成 0 再进行比较</li>
<li>如果一个是对象，另一个是数值或字符串，把对象转换成基础类型的值再比较。对象转换成基础类型，利用它的 toString 或者 valueOf 方法。 <strong>js 核心内置类，会尝试 valueOf 先于 toString（可以理解为对象优先转换成数字</strong>）；例外的是 Date，Date 利用的是 toString 转换。非 js 核心的对象，通过自己的实现中定义的方法转换成原始值。</li>
<li><img src="https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-043719.png#alt=img"></li>
</ol>
<h2 id="运算符如何进行类型转化"><a href="#运算符如何进行类型转化" class="headerlink" title="+ 运算符如何进行类型转化"></a>+ 运算符如何进行类型转化</h2><p>如果作为一元运算符就是转化为数字，常常用来将字符串转化为数字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+&quot;2&quot; &#x2F;&#x2F;  2</span><br><span class="line">2+false &#x2F;&#x2F; 0</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如果作为二元运算符就有两种转换方式</p>
<ul>
<li>两边如果有字符串，另一边一会转化为字符串进行相加</li>
<li>如果没有字符串，两边都会转化为数字进行相加，对象也根据前面的方法转化为原始值数字。</li>
<li>如果其中的一个操作数是对象,则将对象转换成原始值，日期对象会通过 toString() 方法进行转换，其他对象通过 valueOf（）方法进行转换，但是大多数方法都是不具备可用的 valueOf() 方法，所以还是会通过 toString() 方法执行转换。</li>
</ul>
<p>流程图如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/7/165124228d0924e7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1#alt=img"></p>
<h1 id="、-、-、-amp-amp"><a href="#、-、-、-amp-amp" class="headerlink" title="+、==、||、&amp;&amp;"></a><strong>+、==、||、&amp;&amp;</strong></h1><h3 id="重点"><a href="#重点" class="headerlink" title="+ (重点)"></a>+ (重点)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">1 + &quot;1&quot; &#x2F;&#x2F; &#39;11&#39;</span><br><span class="line">1 + &quot;string&quot; &#x2F;&#x2F; &quot;1tring&quot; （加非数字字符串）</span><br><span class="line">1 + true &#x2F;&#x2F; 2</span><br><span class="line">1 + false &#x2F;&#x2F;1</span><br><span class="line">1 + [] &#x2F;&#x2F; &quot;1&quot;</span><br><span class="line">1 + [1,2,3] &#x2F;&#x2F; &quot;11,2,3&quot;</span><br><span class="line">1 + &#123;&#125;  &#x2F;&#x2F; &quot;1[object Object]&quot;</span><br><span class="line">1 + null &#x2F;&#x2F; 1</span><br><span class="line">1 + undefined &#x2F;&#x2F; 1</span><br><span class="line">null + undefined &#x2F;&#x2F; NaN</span><br><span class="line"></span><br><span class="line">true + 1 &#x2F;&#x2F; 2</span><br><span class="line">true + &quot;1&quot; &#x2F;&#x2F; &quot;true1&quot;</span><br><span class="line">true + &quot;true&quot; &#x2F;&#x2F; &quot;truetrue&quot; （加非数字字符串）</span><br><span class="line">true + true &#x2F;&#x2F; 2</span><br><span class="line">true + false &#x2F;&#x2F; 1</span><br><span class="line">true + [] &#x2F;&#x2F; &quot;true&quot;</span><br><span class="line">true + [1,2,3] &#x2F;&#x2F; &quot;true1,2,3&quot;</span><br><span class="line">true + &quot;true[object Object]&quot; &#x2F;&#x2F; NaN</span><br><span class="line">true + null &#x2F;&#x2F; 1</span><br><span class="line">true + undefined &#x2F;&#x2F; NaN</span><br><span class="line"></span><br><span class="line">false + 1 &#x2F;&#x2F; 1</span><br><span class="line">false + &quot;1&quot; &#x2F;&#x2F; &quot;false1&quot;</span><br><span class="line">false + &quot;string&quot; &#x2F;&#x2F; &quot;falsestring&quot; （加非数字字符串）</span><br><span class="line">false + false &#x2F;&#x2F; 0</span><br><span class="line">false + true &#x2F;&#x2F; 1</span><br><span class="line">false + [] &#x2F;&#x2F; &quot;false&quot;</span><br><span class="line">false + &#123;&#125;  &#x2F;&#x2F; &quot;false[object Object]&quot;</span><br><span class="line"></span><br><span class="line">[] + 1 &#x2F;&#x2F; &quot;1&quot;</span><br><span class="line">[] + &quot;1&quot; &#x2F;&#x2F; &quot;1&quot;</span><br><span class="line">[] + &quot;string&quot; &#x2F;&#x2F; &quot;string&quot; （加非数字字符串）</span><br><span class="line">[] + true  &#x2F;&#x2F; &quot;true&quot;</span><br><span class="line">[] + false &#x2F;&#x2F; &quot;false&quot;</span><br><span class="line">[] + [] &#x2F;&#x2F; &quot;&quot;</span><br><span class="line">[1] + [1] &#x2F;&#x2F; &quot;11&quot;</span><br><span class="line">[] + &#123;&#125; &#x2F;&#x2F; &quot;[object Object]&quot; （注意！！！）</span><br><span class="line">[] + null &#x2F;&#x2F; &quot;null&quot;</span><br><span class="line">[] + undefined &#x2F;&#x2F; &quot;undefined&quot;</span><br><span class="line"></span><br><span class="line">&#123;&#125; + 1 &#x2F;&#x2F; 1</span><br><span class="line">&#123;&#125; + &quot;1&quot; &#x2F;&#x2F; 1</span><br><span class="line">&#123;&#125; + &quot;string&quot; &#x2F;&#x2F; NaN</span><br><span class="line">&#123;&#125; + true &#x2F;&#x2F; 1</span><br><span class="line">&#123;&#125; + false &#x2F;&#x2F; 0</span><br><span class="line">&#123;&#125; + [] &#x2F;&#x2F; 0 （注意！！！）</span><br><span class="line">&#123; a:1 &#125; + [] &#x2F;&#x2F; 0（注意！！！）</span><br><span class="line">&#123;&#125; + [1] &#x2F;&#x2F; 1 （注意！！！）</span><br><span class="line">&#123;&#125; + [1,2,3] &#x2F;&#x2F; NaN （注意！！！）</span><br><span class="line">&#123;&#125; + &#123;&#125; &#x2F;&#x2F; &quot;[object Object][object Object]&quot;</span><br><span class="line">&#123;&#125; + null &#x2F;&#x2F; 0</span><br><span class="line">&#123;&#125; + undefined &#x2F;&#x2F; NaN</span><br><span class="line"></span><br><span class="line">-Infinity + Infinity &#x2F;&#x2F; NaN</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li>如果某个操作数是字符串或者能够转换为字符串的话， + 将进行拼接操作。可见在 + 操作中字符串的拼接<strong>「优先级」</strong>高于数字的 +。</li>
<li>如果一个操作数是对象（包括数组），则首先对其调用<code>ToPrimitive</code>操作，该抽象操作再调用<code>[[DefalutValue]]</code>，以数字作为上下文，保证了优先调用<code>valueOf()</code>方法，可见在 + 操作时，引用类型内部调用<code>valueOf()</code>方法的<strong>「优先级」</strong>高于<code>toString()</code>。</li>
<li>数组或者对象在调用<code>valueOf()</code>方法如果无法获取到基本类型值（数字），会转而调用<code>toString()</code>。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 这里提供valueOf()方法，</span><br><span class="line">var daRui &#x3D; &#123;</span><br><span class="line">    valueOf: function() &#123;</span><br><span class="line">        return 18</span><br><span class="line">    &#125;,</span><br><span class="line">    toString: function() &#123;</span><br><span class="line">        return &quot;daRUI&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">daRui + 7 &#x2F;&#x2F; 25</span><br><span class="line">daRui + &quot;7&quot; &#x2F;&#x2F; &quot;187&quot;</span><br><span class="line">daRui + &quot;hello&quot; &#x2F;&#x2F; &quot;18hello&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里仅提供toString()方法，</span><br><span class="line">var daRui &#x3D; &#123;</span><br><span class="line">    toString: function() &#123;</span><br><span class="line">        return &quot;daRUI&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">daRui + 7 &#x2F;&#x2F; &quot;daRUI7&quot;</span><br><span class="line">daRui + &quot; hello&quot; &#x2F;&#x2F; &quot;daRUI hello&quot;</span><br></pre></td></tr></table></figure>

<p>特别说明:</p>
<ol>
<li><p>数组中的<code>toString()</code>方法是经过改写的，故<code>[1,2,3]</code>会转为”1,2,3”，<code>[]</code> 会转为””。</p>
</li>
<li><p>对象的<code>toString()</code>方法会返回 “[object Class]”，<code>Object.prototype.toString.call([])</code> 返回 “[object Array]”。</p>
</li>
<li><p><code>[] + &#123;&#125;</code>得到”[object Object]“，而<code>&#123;&#125; + []</code> 得到 0。这是因为 <code>&#123;&#125;</code> (花括号)在 JS 中有两种含义：</p>
<ol>
<li>当 <code>&#123;&#125;</code> 在 + 后面时，表示对象<code>&#123;&#125;</code></li>
<li>当 <code>&#123;&#125;</code> 位于 + 前面时，<code>&#123;&#125;</code> 表示一个独立的<strong>「空代码块」</strong>，所以<code>&#123;&#125; + []</code> 操作相当于进行的是 <code>+[]</code>(一元操作符转换操作) 将 <code>[]</code> 转为 0</li>
</ol>
</li>
</ol>
<h2 id="（重点）"><a href="#（重点）" class="headerlink" title="==（重点）"></a>==（重点）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">1 &#x3D;&#x3D; &#39;1&#39; &#x2F;&#x2F; true</span><br><span class="line">1 &#x3D;&#x3D; true &#x2F;&#x2F; true</span><br><span class="line">1 &#x3D;&#x3D; [] &#x2F;&#x2F; false</span><br><span class="line">1 &#x3D;&#x3D; [1] &#x2F;&#x2F; true</span><br><span class="line">1 &#x3D;&#x3D; &#123;&#125;  &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">true &#x3D;&#x3D; &quot;1&quot; &#x2F;&#x2F; true</span><br><span class="line">true &#x3D;&#x3D; &quot;true&quot; &#x2F;&#x2F; false</span><br><span class="line">true &#x3D;&#x3D; [] &#x2F;&#x2F; true</span><br><span class="line">true &#x3D;&#x3D; [1]  &#x2F;&#x2F; true</span><br><span class="line">true &#x3D;&#x3D; &#123;&#125; &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">[] &#x3D;&#x3D; &quot;1&quot;&#x2F;&#x2F; false</span><br><span class="line">[] &#x3D;&#x3D; true  &#x2F;&#x2F; false</span><br><span class="line">[] &#x3D;&#x3D; false &#x2F;&#x2F; true</span><br><span class="line">[] &#x3D;&#x3D; []  &#x2F;&#x2F; false (注意！！！)</span><br><span class="line">[] &#x3D;&#x3D; &#123;&#125; &#x2F;&#x2F; false</span><br><span class="line">[] &#x3D;&#x3D; ![] &#x2F;&#x2F; true (注意！！！)</span><br><span class="line"></span><br><span class="line">&#123;&#125; &#x3D;&#x3D; 1 &#x2F;&#x2F; Unexpected token &#39;&#x3D;&#x3D;&#39;</span><br><span class="line">&#123;&#125; &#x3D;&#x3D; &quot;1&quot; &#x2F;&#x2F; Unexpected token &#39;&#x3D;&#x3D;&#39;</span><br><span class="line">&#123;&#125; &#x3D;&#x3D; true &#x2F;&#x2F; Unexpected token &#39;&#x3D;&#x3D;&#39;</span><br><span class="line">&#123;&#125; &#x3D;&#x3D; false &#x2F;&#x2F; Unexpected token &#39;&#x3D;&#x3D;&#39;</span><br><span class="line">&#123;&#125; &#x3D;&#x3D; [] &#x2F;&#x2F; Unexpected token &#39;&#x3D;&#x3D;&#39;</span><br><span class="line">&#123;&#125; &#x3D;&#x3D; &#123;&#125; &#x2F;&#x2F; false (注意！！！)</span><br><span class="line"></span><br><span class="line">&quot;0&quot; &#x3D;&#x3D; null &#x2F;&#x2F; false</span><br><span class="line">&quot;0&quot; &#x3D;&#x3D; undefined &#x2F;&#x2F; false</span><br><span class="line">&quot;0&quot; &#x3D;&#x3D; false &#x2F;&#x2F; true (注意！！！)</span><br><span class="line">&quot;0&quot; &#x3D;&#x3D; NaN &#x2F;&#x2F; false</span><br><span class="line">&quot;0&quot; &#x3D;&#x3D; 0 &#x2F;&#x2F; true</span><br><span class="line">&quot;0&quot; &#x3D;&#x3D; &quot;&quot; &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">false &#x3D;&#x3D; null &#x2F;&#x2F; false (注意！！！)</span><br><span class="line">false &#x3D;&#x3D; undefined &#x2F;&#x2F; false (注意！！！)</span><br><span class="line">false &#x3D;&#x3D; NaN &#x2F;&#x2F; false</span><br><span class="line">false &#x3D;&#x3D; 0 &#x2F;&#x2F; true (注意！！！)</span><br><span class="line">false &#x3D;&#x3D; &quot;&quot; &#x2F;&#x2F; true (注意！！！)</span><br><span class="line">false &#x3D;&#x3D; [] &#x2F;&#x2F; true (注意！！！)</span><br><span class="line">false &#x3D;&#x3D; &#123;&#125; &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">&quot;&quot; &#x3D;&#x3D; null &#x2F;&#x2F; false</span><br><span class="line">&quot;&quot; &#x3D;&#x3D; undefined &#x2F;&#x2F;false</span><br><span class="line">&quot;&quot; &#x3D;&#x3D; NaN &#x2F;&#x2F; false</span><br><span class="line">&quot;&quot; &#x3D;&#x3D; 0 &#x2F;&#x2F;true (注意！！！)</span><br><span class="line">&quot;&quot; &#x3D;&#x3D; [] &#x2F;&#x2F; true (注意！！！)</span><br><span class="line">&quot;&quot; &#x3D;&#x3D; &#123;&#125; &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">0 &#x3D;&#x3D; null &#x2F;&#x2F; false</span><br><span class="line">0 &#x3D;&#x3D; undefined &#x2F;&#x2F; false</span><br><span class="line">0 &#x3D;&#x3D; NaN &#x2F;&#x2F; false</span><br><span class="line">0 &#x3D;&#x3D; [] &#x2F;&#x2F; true  (注意！！！)</span><br><span class="line">0 &#x3D;&#x3D; &#123;&#125; &#x2F;&#x2F; false</span><br><span class="line">+0 &#x3D;&#x3D; -0 &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">null &#x3D;&#x3D; null &#x2F;&#x2F; true</span><br><span class="line">null &#x3D;&#x3D; undefined &#x2F;&#x2F; true</span><br><span class="line">null &#x3D;&#x3D; &quot;&quot; &#x2F;&#x2F; false</span><br><span class="line">null &#x3D;&#x3D; 0 &#x2F;&#x2F; false</span><br><span class="line">undefined &#x3D;&#x3D; &quot;&quot; &#x2F;&#x2F; false</span><br><span class="line">undefined &#x3D;&#x3D; 0 &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">NaN &#x3D;&#x3D; NaN &#x2F;&#x2F; false  可以使用isNaN() 判断是不是NaN</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>== 操作，最重要的时在两个操作数的转换过程！关于 == 操作<a target="_blank" rel="noopener" href="http://www.ecma-international.org/ecma-262/5.1/index.html#sec-11.9.3">ES5 规范 11.9.3</a>给出了明确规范：</p>
<ol>
<li><p>字符串和数字之间的相等比较：</p>
<ol>
<li> 如果 Type(x)是数字，Type(y)是字符串，则返回 <code>x == ToNumber(y)</code>的结果。</li>
<li> 如果 Type(x)是字符串，Type(y)是数字，则返回<code>ToNumber(x) == y</code>的结果。</li>
</ol>
</li>
<li><p>其他类型值和布尔类型之间的相等比较：</p>
<ol>
<li> 如果 Type(x)是布尔类型，这返回<code>ToNumber(x) == y</code>的结果</li>
<li> 如果 Type(y)是布尔类型，则返回<code>x == ToNumber(y)</code> 的结果</li>
</ol>
</li>
<li><p>null 和 undefined 之间的相等比较</p>
<ol>
<li> 如果 x 为 null，y 为 undefined，则结果为 true</li>
<li> 如果 x 为 undefined，y 为 null，则结果为 true</li>
</ol>
</li>
<li><p>对象和非对象之间的相等比较：</p>
<ol>
<li> 如果 Type(x)是字符串或者数字，Type(y)是对象，则返回<code>x == ToPrimitive(y)</code>的结果</li>
<li> 如果 Type(x)是对象，Type(y)是字符串或者数字，则返回<code>toPrimitive(x) == y</code>的结果</li>
</ol>
</li>
<li><p>对象和对象之间比较:</p>
<ol>
<li> 在<code>Javascript</code>中对象属于引用类型，对象之间的比较，本质比较的是内存地址。所以都为 false。</li>
</ol>
</li>
</ol>
<p>（感谢掘友：<code>Bug开发工程师同志</code> 的指正）</p>
<blockquote>
<p>❝</p>
</blockquote>
<blockquote>
<p>== 相等操作中，如果两边的操作数不同的话，都会进行类型转换，而且优先转为数字，再进行比较，如果转换后还不同则再次转换，直到相同为止。这里以 <code>字符串类型 == 布尔类型</code>做介绍：</p>
</blockquote>
<blockquote>
<ol>
<li>首先字符串类型转为 Number 类型，这时比较的是 <code>数字类型 == 布尔类型</code></li>
<li>再将布尔类型转为 Number 类型，这时比较的是<code>数字类型 == 数字类型</code></li>
</ol>
</blockquote>
<blockquote>
<p>这也就不难解释为什么<code>&quot;0&quot; == false</code>了</p>
</blockquote>
<blockquote>
<p>如果连个操作数中有引用类型，这会先将引用类型转换为基本类型，在进行上面的操作，进行比较。</p>
</blockquote>
<blockquote>
<p>再说<code>[] == ![] // true</code>:</p>
</blockquote>
<blockquote>
<ol>
<li>这里!操作的优先级是高于 == 的，![] 首先转换为 false</li>
<li>此时比较双方是 [] == false，这里会将 [] 再次转换为 0</li>
<li>此时比较双方是 0 == false，接下来就不难理解了</li>
</ol>
</blockquote>
<h2 id=""><a href="#" class="headerlink" title="!!"></a>!!</h2><p>将值转为布尔值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 除将下面的转为false其余全部为true</span></span><br><span class="line">!!<span class="string">&quot;&quot;</span>;</span><br><span class="line">!!<span class="number">0</span>;</span><br><span class="line">!!-<span class="number">0</span>;</span><br><span class="line">!!+<span class="number">0</span>;</span><br><span class="line">!!<span class="literal">null</span>;</span><br><span class="line">!!<span class="literal">undefined</span>;</span><br><span class="line">!!<span class="literal">NaN</span>;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/17/yuque/Promise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/17/yuque/Promise/" class="post-title-link" itemprop="url">Promise</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-17 21:15:01" itemprop="dateCreated datePublished" datetime="2021-04-17T21:15:01+08:00">2021-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-22 14:41:28" itemprop="dateModified" datetime="2021-04-22T14:41:28+08:00">2021-04-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RESOLVE = <span class="string">&quot;resolved&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> REJECT = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handlePromise = <span class="function">(<span class="params">result, newPromise, resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (result === newPromise) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;can&#x27;t not return oneself&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    (<span class="keyword">typeof</span> result === <span class="string">&quot;object&quot;</span> &amp;&amp; <span class="keyword">typeof</span> result !== <span class="literal">null</span>) ||</span><br><span class="line">    <span class="keyword">typeof</span> result === <span class="string">&quot;function&quot;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">let</span> lock = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> then = result.then;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        then.call(</span><br><span class="line">          result,</span><br><span class="line">          (r) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (lock) <span class="keyword">return</span>;</span><br><span class="line">            handlePromise(r, newPromise, resolve, reject);</span><br><span class="line">            lock = <span class="literal">true</span>;</span><br><span class="line">          &#125;,</span><br><span class="line">          (e) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (lock) <span class="keyword">return</span>;</span><br><span class="line">            reject(e);</span><br><span class="line">            lock = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resolve(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JJPromise</span> </span>&#123;</span><br><span class="line">  status = PENDING;</span><br><span class="line">  result = <span class="literal">undefined</span>;</span><br><span class="line">  reason = <span class="literal">undefined</span>;</span><br><span class="line">  onResolveArr = [];</span><br><span class="line">  onRejectArr = [];</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">excution</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> resolve = <span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="built_in">this</span>.result = result;</span><br><span class="line">        <span class="built_in">this</span>.status = RESOLVE;</span><br><span class="line">        <span class="built_in">this</span>.onResolveArr.map(<span class="function">(<span class="params">fn</span>) =&gt;</span> fn());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="built_in">this</span>.reason = reason;</span><br><span class="line">        <span class="built_in">this</span>.status = REJECT;</span><br><span class="line">        <span class="built_in">this</span>.onRejectArr.map(<span class="function">(<span class="params">fn</span>) =&gt;</span> fn());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      excution(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">onResolved, onRejected</span>)</span> &#123;</span><br><span class="line">    onResolved = <span class="keyword">typeof</span> onResolved === <span class="string">&quot;function&quot;</span> ? onResolved : <span class="function">(<span class="params">data</span>) =&gt;</span> data;</span><br><span class="line">    onRejected =</span><br><span class="line">      <span class="keyword">typeof</span> onRejected === <span class="string">&quot;function&quot;</span></span><br><span class="line">        ? onRejected</span><br><span class="line">        : <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(err);</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> newPromise = <span class="keyword">new</span> JJPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === RESOLVE) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> result = onResolved(<span class="built_in">this</span>.result);</span><br><span class="line">            handlePromise(result, newPromise, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            reject(error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === REJECT) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> result = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">            handlePromise(result, newPromise, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            reject(error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="built_in">this</span>.onResolveArr.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> result = onResolved(<span class="built_in">this</span>.result);</span><br><span class="line">            handlePromise(result, newPromise, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            reject(error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">this</span>.onRejectArr.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> result = onRejected(<span class="built_in">this</span>.result);</span><br><span class="line">            handlePromise(result, newPromise, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            reject(error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> newPromise;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, onRejected);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> JJPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">test.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/17/yuque/Promise%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/17/yuque/Promise%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Promise原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-17 00:22:27" itemprop="dateCreated datePublished" datetime="2021-04-17T00:22:27+08:00">2021-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-22 14:41:28" itemprop="dateModified" datetime="2021-04-22T14:41:28+08:00">2021-04-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Promise 必须为以下三种状态之一：等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected）。一旦 Promise 被 resolve 或 reject，不能再迁移至其他任何状态（即状态 immutable）。</p>
<p>基本过程：</p>
<ol>
<li>初始化 Promise 状态（pending）</li>
<li>立即执行 Promise 中传入的 fn 函数，将 Promise 内部 resolve、reject 函数作为参数传递给 fn ，按事件机制时机处理</li>
<li>执行 then(..) 注册回调处理数组（then 方法可被同一个 promise 调用多次）</li>
<li>Promise 里的关键是要保证，then 方法传入的参数 onFulfilled 和 onRejected，必须在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。</li>
</ol>
<p><strong>真正的链式 Promise 是指在当前 promise 达到 fulfilled 状态后，即开始进行下一个 promise.</strong></p>
<h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p>先从 Promise 执行结果看一下，有如下一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        resolve(&#123; test: 1 &#125;)</span><br><span class="line">        resolve(&#123; test: 2 &#125;)</span><br><span class="line">        reject(&#123; test: 2 &#125;)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;result1&#39;, data)</span><br><span class="line">&#125;,(data1)&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&#39;result2&#39;,data1)</span><br><span class="line">&#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;result3&#39;, data)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;result1 &#123; test: 1 &#125;</span><br><span class="line">&#x2F;&#x2F;result3 undefined</span><br></pre></td></tr></table></figure>

<p>显然这里输出了不同的 data。由此可以看出几点：</p>
<ol>
<li>可进行链式调用，且每次 then 返回了新的 Promise(2 次打印结果不一致，如果是同一个实例，打印结果应该一致。</li>
<li>只输出第一次 resolve 的内容，reject 的内容没有输出，即 Promise 是有状态且状态只可以由 pending -&gt; fulfilled 或 pending-&gt; rejected,是不可逆的。</li>
<li>then 中返回了新的 Promise,但是 then 中注册的回调仍然是属于上一个 Promise 的。</li>
</ol>
<p>基于以上几点，我们先写个基于 <a target="_blank" rel="noopener" href="https://promisesaplus.com/">PromiseA+</a> 规范的只含 resolve 方法的 Promise 模型:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn)&#123;</span><br><span class="line">    let state &#x3D; &#39;pending&#39;;</span><br><span class="line">    let value &#x3D; null;</span><br><span class="line">    const callbacks &#x3D; [];</span><br><span class="line"></span><br><span class="line">    this.then &#x3D; function (onFulfilled)&#123;</span><br><span class="line">        return new Promise((resolve, reject)&#x3D;&gt;&#123;</span><br><span class="line">            handle(&#123; &#x2F;&#x2F;桥梁，将新 Promise 的 resolve 方法，放到前一个 promise 的回调对象中</span><br><span class="line">                onFulfilled,</span><br><span class="line">                resolve</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function handle(callback)&#123;</span><br><span class="line">        if(state &#x3D;&#x3D;&#x3D; &#39;pending&#39;)&#123;</span><br><span class="line">            callbacks.push(callback)</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39;)&#123;</span><br><span class="line">            if(!callback.onFulfilled)&#123;</span><br><span class="line">                callback.resolve(value)</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            const ret &#x3D; callback.onFulfilled(value) &#x2F;&#x2F;处理回调</span><br><span class="line">            callback.resolve(ret) &#x2F;&#x2F;处理下一个 promise 的resolve</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function resolve(newValue)&#123;</span><br><span class="line">        const fn &#x3D; ()&#x3D;&gt;&#123;</span><br><span class="line">            if(state !&#x3D;&#x3D; &#39;pending&#39;)return</span><br><span class="line"></span><br><span class="line">            state &#x3D; &#39;fulfilled&#39;;</span><br><span class="line">            value &#x3D; newValue</span><br><span class="line">            handelCb()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setTimeout(fn,0) &#x2F;&#x2F;基于 PromiseA+ 规范</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function handelCb()&#123;</span><br><span class="line">        while(callbacks.length) &#123;</span><br><span class="line">            const fulfiledFn &#x3D; callbacks.shift();</span><br><span class="line">            handle(fulfiledFn);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn(resolve)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这个模型简单易懂，这里最关键的点就是在 then 中新创建的 Promise，它的状态变为 fulfilled 的节点是在上一个 Promise 的回调执行完毕的时候。也就是说当一个 Promise 的状态被 fulfilled 之后，会执行其回调函数，而回调函数返回的结果会被当作 value，返回给下一个 Promise(也就是 then 中产生的 Promise)，同时下一个 Promise 的状态也会被改变(执行 resolve 或 reject)，然后再去执行其回调,以此类推下去…链式调用的效应就出来了。</strong></p>
<p>但是如果仅仅是例子中的情况，我们可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        resolve(&#123; test: 1 &#125;)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;result1&#39;, data)</span><br><span class="line">    &#x2F;&#x2F;dosomething</span><br><span class="line">    console.log(&#39;result3&#39;)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;result1 &#123; test: 1 &#125;</span><br><span class="line">&#x2F;&#x2F;result3</span><br></pre></td></tr></table></figure>

<p>实际上，我们常用的链式调用，是用在异步回调中，以解决”回调地狱”的问题。如下例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    resolve(&#123; test: 1 &#125;)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;result1&#39;, data)</span><br><span class="line">  &#x2F;&#x2F;dosomething</span><br><span class="line">  return test()</span><br><span class="line">&#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;result2&#39;, data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function test(id) &#123;</span><br><span class="line">  return new Promise(((resolve) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      resolve(&#123; test: 2 &#125;)</span><br><span class="line">    &#125;, 5000)</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;基于第一个 Promise 模型，执行后的输出</span><br><span class="line">&#x2F;&#x2F;result1 &#123; test: 1 &#125;</span><br><span class="line">&#x2F;&#x2F;result2 Promise &#123;then: ƒ&#125;</span><br></pre></td></tr></table></figure>

<p>用上面的 Promise 模型，得到的结果显然不是我们想要的。认真看上面的模型，执行 callback.resolve 时，传入的参数是 callback.onFulfilled 执行完成的返回，显然这个测试例子返回的就是一个 Promise，而我们的 Promise 模型中的 resolve 方法并没有特殊处理。那么我们将 resolve 改一下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn)&#123;</span><br><span class="line">    ...</span><br><span class="line">    function resolve(newValue)&#123;</span><br><span class="line">        const fn &#x3D; ()&#x3D;&gt;&#123;</span><br><span class="line">            if(state !&#x3D;&#x3D; &#39;pending&#39;)return</span><br><span class="line"></span><br><span class="line">            if(newValue &amp;&amp; (typeof newValue &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof newValue &#x3D;&#x3D;&#x3D; &#39;function&#39;))&#123;</span><br><span class="line">                const &#123;then&#125; &#x3D; newValue</span><br><span class="line">                if(typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;)&#123;</span><br><span class="line">                    &#x2F;&#x2F; newValue 为新产生的 Promise,此时resolve为上个 promise 的resolve</span><br><span class="line">                    &#x2F;&#x2F;相当于调用了新产生 Promise 的then方法，注入了上个 promise 的resolve 为其回调</span><br><span class="line">                    then.call(newValue,resolve)</span><br><span class="line">                    return</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            state &#x3D; &#39;fulfilled&#39;;</span><br><span class="line">            value &#x3D; newValue</span><br><span class="line">            handelCb()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setTimeout(fn,0)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用这个模型，再测试我们的例子，就得到了正确的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        resolve(&#123; test: 1 &#125;)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;result1&#39;, data)</span><br><span class="line">    &#x2F;&#x2F;dosomething</span><br><span class="line">    return test()</span><br><span class="line">&#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;result2&#39;, data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function test(id) &#123;</span><br><span class="line">    return new Promise(((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        resolve(&#123; test: 2 &#125;)</span><br><span class="line">        &#125;, 5000)</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;result1 &#123; test: 1 &#125;</span><br><span class="line">&#x2F;&#x2F;result2 &#123; test: 2 &#125;</span><br></pre></td></tr></table></figure>

<p>显然，新增的逻辑就是针对 resolve 入参为 Promise 的时候的处理。我们观察一下 test 里面创建的 Promise，它是没有调用 then 方法的。从上面的分析我们已经知道 Promise 的回调函数就是通过调用其 then 方法注册的，因此 test 里面创建的 Promise 其回调函数为空。</p>
<p>显然如果没有回调函数，执行 resolve 的时候，是没办法链式下去的。因此，我们需要主动为其注入回调函数。</p>
<p>我们只要把第一个 then 中产生的 Promise 的 resolve 函数的执行，延迟到 test 里面的 Promise 的状态为 onFulfilled 的时候再执行，那么链式就可以继续了。所以，当 resolve 入参为 Promise 的时候，调用其 then 方法为其注入回调函数，而注入的是前一个 Promise 的 resolve 方法，所以要用 call 来绑定 this 的指向。</p>
<p>基于新的 Promise 模型，上面的执行过程产生的 Promise 实例及其回调函数，可以用看下表：<br>| Promise | callback |<br>| — | — |<br>| P1 | [{onFulfilled:c1(第一个 then 中的 fn),resolve:p2resolve}] |<br>| P2 (P1 调用 then 时产生) | [{onFulfilled:c2(第二个 then 中的 fn),resolve:p3resolve}] |<br>| P3 (P2 调用 then 时产生) | [] |<br>| P4 (执行 c1 中产生[调用 test ]) | [{onFulfilled:p2resolve,resolve:p5resolve}] |<br>| P5 (调用 p2resolve 时，进入 then.call 逻辑中产生) | [] |</p>
<p>有了这个表格，我们就可以清晰知道各个实例中 callback 执行的顺序是：</p>
<p>c1 -&gt; p2resolve -&gt; c2 -&gt; p3resolve -&gt; [] -&gt; p5resolve -&gt; []</p>
<p>以上就是链式调用的原理了。</p>
<h3 id="reject"><a href="#reject" class="headerlink" title="reject"></a>reject</h3><p>下面我们再来补全 reject 的逻辑。只需要在注册回调、状态改变时加上 reject 的逻辑即可。</p>
<p>完整代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn)&#123;</span><br><span class="line">    let state &#x3D; &#39;pending&#39;;</span><br><span class="line">    let value &#x3D; null;</span><br><span class="line">    const callbacks &#x3D; [];</span><br><span class="line"></span><br><span class="line">    this.then &#x3D; function (onFulfilled,onRejected)&#123;</span><br><span class="line">        return new Promise((resolve, reject)&#x3D;&gt;&#123;</span><br><span class="line">            handle(&#123;</span><br><span class="line">                onFulfilled,</span><br><span class="line">                onRejected,</span><br><span class="line">                resolve,</span><br><span class="line">                reject</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function handle(callback)&#123;</span><br><span class="line">        if(state &#x3D;&#x3D;&#x3D; &#39;pending&#39;)&#123;</span><br><span class="line">            callbacks.push(callback)</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        const cb &#x3D; state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39; ? callback.onFulfilled:callback.onRejected;</span><br><span class="line">        const next &#x3D; state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39;? callback.resolve:callback.reject;</span><br><span class="line"></span><br><span class="line">        if(!cb)&#123;</span><br><span class="line">            next(value)</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        const ret &#x3D; cb(value)</span><br><span class="line">        next(ret)</span><br><span class="line">    &#125;</span><br><span class="line">    function resolve(newValue)&#123;</span><br><span class="line">        const fn &#x3D; ()&#x3D;&gt;&#123;</span><br><span class="line">            if(state !&#x3D;&#x3D; &#39;pending&#39;)return</span><br><span class="line"></span><br><span class="line">            if(newValue &amp;&amp; (typeof newValue &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof newValue &#x3D;&#x3D;&#x3D; &#39;function&#39;))&#123;</span><br><span class="line">                const &#123;then&#125; &#x3D; newValue</span><br><span class="line">                if(typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;)&#123;</span><br><span class="line">                    &#x2F;&#x2F; newValue 为新产生的 Promise,此时resolve为上个 promise 的resolve</span><br><span class="line">                    &#x2F;&#x2F;相当于调用了新产生 Promise 的then方法，注入了上个 promise 的resolve 为其回调</span><br><span class="line">                    then.call(newValue,resolve, reject)</span><br><span class="line">                    return</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            state &#x3D; &#39;fulfilled&#39;;</span><br><span class="line">            value &#x3D; newValue</span><br><span class="line">            handelCb()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setTimeout(fn,0)</span><br><span class="line">    &#125;</span><br><span class="line">    function reject(error)&#123;</span><br><span class="line"></span><br><span class="line">        const fn &#x3D; ()&#x3D;&gt;&#123;</span><br><span class="line">            if(state !&#x3D;&#x3D; &#39;pending&#39;)return</span><br><span class="line"></span><br><span class="line">            if(error &amp;&amp; (typeof error &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof error &#x3D;&#x3D;&#x3D; &#39;function&#39;))&#123;</span><br><span class="line">                const &#123;then&#125; &#x3D; error</span><br><span class="line">                if(typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;)&#123;</span><br><span class="line">                    then.call(error,resolve, reject)</span><br><span class="line">                    return</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            state &#x3D; &#39;rejected&#39;;</span><br><span class="line">            value &#x3D; error</span><br><span class="line">            handelCb()</span><br><span class="line">        &#125;</span><br><span class="line">        setTimeout(fn,0)</span><br><span class="line">    &#125;</span><br><span class="line">    function handelCb()&#123;</span><br><span class="line">        while(callbacks.length) &#123;</span><br><span class="line">            const fn &#x3D; callbacks.shift();</span><br><span class="line">            handle(fn);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    fn(resolve, reject)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>异常通常是指在执行成功/失败回调时代码出错产生的错误，对于这类异常，我们使用 try-catch 来捕获错误，并将 Promise 设为 rejected 状态即可。</p>
<p>handle 代码改造如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function handle(callback)&#123;</span><br><span class="line">    if(state &#x3D;&#x3D;&#x3D; &#39;pending&#39;)&#123;</span><br><span class="line">        callbacks.push(callback)</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const cb &#x3D; state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39; ? callback.onFulfilled:callback.onRejected;</span><br><span class="line">    const next &#x3D; state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39;? callback.resolve:callback.reject;</span><br><span class="line"></span><br><span class="line">    if(!cb)&#123;</span><br><span class="line">        next(value)</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        const ret &#x3D; cb(value)</span><br><span class="line">        next(ret)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">        callback.reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们实际使用时，常习惯注册 catch 方法来处理错误，例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        resolve(&#123; test: 1 &#125;)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;).then((data) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;result1&#39;, data)</span><br><span class="line">    &#x2F;&#x2F;dosomething</span><br><span class="line">    return test()</span><br><span class="line">&#125;).catch((ex) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;error&#39;, ex)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>实际上，错误也好，异常也罢，最终都是通过 reject 实现的。也就是说可以通过 then 中的错误回调来处理。所以我们可以增加这样的一个 catch 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn)&#123;</span><br><span class="line">    ...</span><br><span class="line">    this.then &#x3D; function (onFulfilled,onRejected)&#123;</span><br><span class="line">        return new Promise((resolve, reject)&#x3D;&gt;&#123;</span><br><span class="line">            handle(&#123;</span><br><span class="line">                onFulfilled,</span><br><span class="line">                onRejected,</span><br><span class="line">                resolve,</span><br><span class="line">                reject</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    this.catch &#x3D; function (onError)&#123;</span><br><span class="line">        this.then(null,onError)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Finally-方法"><a href="#Finally-方法" class="headerlink" title="Finally 方法"></a>Finally 方法</h3><p>在实际应用的时候，我们很容易会碰到这样的场景，不管 Promise 最后的状态如何，都要执行一些最后的操作。我们把这些操作放到 finally 中，也就是说 finally 注册的函数是与 Promise 的状态无关的，不依赖 Promise 的执行结果。所以我们可以这样写 finally 的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn)&#123;</span><br><span class="line">    ...</span><br><span class="line">    this.catch &#x3D; function (onError)&#123;</span><br><span class="line">        this.then(null,onError)</span><br><span class="line">    &#125;</span><br><span class="line">    this.finally &#x3D; function (onDone)&#123;</span><br><span class="line">        this.then(onDone,onDone)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="resolve-方法和-reject-方法"><a href="#resolve-方法和-reject-方法" class="headerlink" title="resolve 方法和 reject 方法"></a>resolve 方法和 reject 方法</h3><p>实际应用中，我们可以使用 Promise.resolve 和 Promise.reject 方法，用于将于将非 Promise 实例包装为 Promise 实例。如下例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(&#123;name:&#39;winty&#39;&#125;)</span><br><span class="line">Promise.reject(&#123;name:&#39;winty&#39;&#125;)</span><br><span class="line">&#x2F;&#x2F; 等价于</span><br><span class="line">new Promise(resolve &#x3D;&gt; resolve(&#123;name:&#39;winty&#39;&#125;))</span><br><span class="line">new Promise((resolve,reject) &#x3D;&gt; reject(&#123;name:&#39;winty&#39;&#125;))</span><br></pre></td></tr></table></figure>

<p>这些情况下，Promise.resolve 的入参可能有以下几种情况：</p>
<ul>
<li>无参数 [直接返回一个 resolved 状态的 Promise 对象]</li>
<li>普通数据对象 [直接返回一个 resolved 状态的 Promise 对象]</li>
<li>一个 Promise 实例 [直接返回当前实例]</li>
<li>一个 thenable 对象(thenable 对象指的是具有 then 方法的对象) [转为 Promise 对象，并立即执行 thenable 对象的 then 方法。]</li>
</ul>
<p>基于以上几点，我们可以实现一个 Promise.resolve 方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn)&#123;</span><br><span class="line">    ...</span><br><span class="line">    this.resolve &#x3D; function (value)&#123;</span><br><span class="line">        if (value &amp;&amp; value instanceof Promise) &#123;</span><br><span class="line">            return value;</span><br><span class="line">        &#125; else if (value &amp;&amp; typeof value &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; typeof value.then &#x3D;&#x3D;&#x3D; &#39;function&#39;)&#123;</span><br><span class="line">            let then &#x3D; value.then;</span><br><span class="line">            return new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">                then(resolve);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; else if (value) &#123;</span><br><span class="line">            return new Promise(resolve &#x3D;&gt; resolve(value));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return new Promise(resolve &#x3D;&gt; resolve());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Promise.reject 与 Promise.resolve 类似，区别在于 Promise.reject 始终返回一个状态的 rejected 的 Promise 实例，而 Promise.resolve 的参数如果是一个 Promise 实例的话，返回的是参数对应的 Promise 实例，所以状态不一 定。 因此，reject 的实现就简单多了，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> function Promise(fn)&#123;</span><br><span class="line">     ...</span><br><span class="line">     this.reject &#x3D; function (value)&#123;</span><br><span class="line">         return new Promise(function(resolve, reject) &#123;</span><br><span class="line">	reject(value);</span><br><span class="line">&#125;);</span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>入参是一个 Promise 的实例数组，然后注册一个 then 方法，然后是数组中的 Promise 实例的状态都转为 fulfilled 之后则执行 then 方法。这里主要就是一个计数逻辑，每当一个 Promise 的状态变为 fulfilled 之后就保存该实例返回的数据，然后将计数减一，当计数器变为 0 时，代表数组中所有 Promise 实例都执行完毕。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn)&#123;</span><br><span class="line">    ...</span><br><span class="line">    this.all &#x3D; function (arr)&#123;</span><br><span class="line">        var args &#x3D; Array.prototype.slice.call(arr);</span><br><span class="line">        return new Promise(function(resolve, reject) &#123;</span><br><span class="line">            if(args.length &#x3D;&#x3D;&#x3D; 0) return resolve([]);</span><br><span class="line">            var remaining &#x3D; args.length;</span><br><span class="line"></span><br><span class="line">            function res(i, val) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if(val &amp;&amp; (typeof val &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof val &#x3D;&#x3D;&#x3D; &#39;function&#39;)) &#123;</span><br><span class="line">                        var then &#x3D; val.then;</span><br><span class="line">                        if(typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">                            then.call(val, function(val) &#123;</span><br><span class="line">                                res(i, val);</span><br><span class="line">                            &#125;, reject);</span><br><span class="line">                            return;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    args[i] &#x3D; val;</span><br><span class="line">                    if(--remaining &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">                        resolve(args);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch(ex) &#123;</span><br><span class="line">                    reject(ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for(var i &#x3D; 0; i &lt; args.length; i++) &#123;</span><br><span class="line">                res(i, args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>有了 Promise.all 的理解，Promise.race 理解起来就更容易了。它的入参也是一个 Promise 实例数组，然后其 then 注册的回调方法是数组中的某一个 Promise 的状态变为 fulfilled 的时候就执行。因为 Promise 的状态只能改变一次，那么我们只需要把 Promise.race 中产生的 Promise 对象的 resolve 方法，注入到数组中的每一个 Promise 实例中的回调函数中即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn)&#123;</span><br><span class="line">    ...</span><br><span class="line">    this.race &#x3D; function(values) &#123;</span><br><span class="line">        return new Promise(function(resolve, reject) &#123;</span><br><span class="line">            for(var i &#x3D; 0, len &#x3D; values.length; i &lt; len; i++) &#123;</span><br><span class="line">                values[i].then(resolve, reject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Promise 源码不过几百行，我们可以从执行结果出发，分析每一步的执行过程，然后思考其作用即可。其中最关键的点就是要理解 then 函数是负责注册回调的，真正的执行是在 Promise 的状态被改变之后。而当 resolve 的入参是一个 Promise 时，要想链式调用起来，就必须调用其 then 方法(then.call),将上一个 Promise 的 resolve 方法注入其回调数组中。</p>
<h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><p>虽然 then 普遍认为是微任务。但是浏览器没办法模拟微任务，目前要么用 setImmediate ，这个也是宏任务，且不兼容的情况下还是用 setTimeout 打底的。还有，promise 的 polyfill (es6-promise) 里用的也是 setTimeout。因此这里就直接用 setTimeout,以宏任务来代替微任务了。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a target="_blank" rel="noopener" href="https://promisesaplus.com/">PromiseA+规范</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/58428287">Promise 实现原理精解</a></li>
<li><a target="_blank" rel="noopener" href="https://mengera88.github.io/2017/05/18/Promise%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">30 分钟，让你彻底明白 Promise 原理</a></li>
</ul>
<h3 id="完整-Promise-模型"><a href="#完整-Promise-模型" class="headerlink" title="完整 Promise 模型"></a>完整 Promise 模型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">function Promise(fn) &#123;</span><br><span class="line">  let state &#x3D; &#39;pending&#39;</span><br><span class="line">  let value &#x3D; null</span><br><span class="line">  const callbacks &#x3D; []</span><br><span class="line"></span><br><span class="line">  this.then &#x3D; function (onFulfilled, onRejected) &#123;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      handle(&#123;</span><br><span class="line">        onFulfilled,</span><br><span class="line">        onRejected,</span><br><span class="line">        resolve,</span><br><span class="line">        reject,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.catch &#x3D; function (onError) &#123;</span><br><span class="line">    return this.then(null, onError)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.finally &#x3D; function (onDone) &#123;</span><br><span class="line">    this.then(onDone, onError)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.resolve &#x3D; function (value) &#123;</span><br><span class="line">    if (value &amp;&amp; value instanceof Promise) &#123;</span><br><span class="line">      return value</span><br><span class="line">    &#125; if (value &amp;&amp; typeof value &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; typeof value.then &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">      const &#123; then &#125; &#x3D; value</span><br><span class="line">      return new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">        then(resolve)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; if (value) &#123;</span><br><span class="line">      return new Promise(resolve &#x3D;&gt; resolve(value))</span><br><span class="line">    &#125;</span><br><span class="line">    return new Promise(resolve &#x3D;&gt; resolve())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.reject &#x3D; function (value) &#123;</span><br><span class="line">    return new Promise(((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      reject(value)</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.all &#x3D; function (arr) &#123;</span><br><span class="line">    const args &#x3D; Array.prototype.slice.call(arr)</span><br><span class="line">    return new Promise(((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      if (args.length &#x3D;&#x3D;&#x3D; 0) return resolve([])</span><br><span class="line">      let remaining &#x3D; args.length</span><br><span class="line"></span><br><span class="line">      function res(i, val) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          if (val &amp;&amp; (typeof val &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof val &#x3D;&#x3D;&#x3D; &#39;function&#39;)) &#123;</span><br><span class="line">            const &#123; then &#125; &#x3D; val</span><br><span class="line">            if (typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">              then.call(val, (val) &#x3D;&gt; &#123;</span><br><span class="line">                res(i, val)</span><br><span class="line">              &#125;, reject)</span><br><span class="line">              return</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          args[i] &#x3D; val</span><br><span class="line">          if (--remaining &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">            resolve(args)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; catch (ex) &#123;</span><br><span class="line">          reject(ex)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      for (let i &#x3D; 0; i &lt; args.length; i++) &#123;</span><br><span class="line">        res(i, args[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.race &#x3D; function (values) &#123;</span><br><span class="line">    return new Promise(((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      for (let i &#x3D; 0, len &#x3D; values.length; i &lt; len; i++) &#123;</span><br><span class="line">        values[i].then(resolve, reject)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function handle(callback) &#123;</span><br><span class="line">    if (state &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">      callbacks.push(callback)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const cb &#x3D; state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39; ? callback.onFulfilled : callback.onRejected</span><br><span class="line">    const next &#x3D; state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39; ? callback.resolve : callback.reject</span><br><span class="line"></span><br><span class="line">    if (!cb) &#123;</span><br><span class="line">      next(value)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    let ret;</span><br><span class="line">    try &#123;</span><br><span class="line">     ret &#x3D; cb(value)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      callback.reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">	callback.resolve(ret);</span><br><span class="line">  &#125;</span><br><span class="line">  function resolve(newValue) &#123;</span><br><span class="line">    const fn &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">      if (state !&#x3D;&#x3D; &#39;pending&#39;) return</span><br><span class="line"></span><br><span class="line">      if (newValue &amp;&amp; (typeof newValue &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof newValue &#x3D;&#x3D;&#x3D; &#39;function&#39;)) &#123;</span><br><span class="line">        const &#123; then &#125; &#x3D; newValue</span><br><span class="line">        if (typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">          &#x2F;&#x2F; newValue 为新产生的 Promise,此时resolve为上个 promise 的resolve</span><br><span class="line">          &#x2F;&#x2F; 相当于调用了新产生 Promise 的then方法，注入了上个 promise 的resolve 为其回调</span><br><span class="line">          then.call(newValue, resolve, reject)</span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      state &#x3D; &#39;fulfilled&#39;</span><br><span class="line">      value &#x3D; newValue</span><br><span class="line">      handelCb()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setTimeout(fn, 0)</span><br><span class="line">  &#125;</span><br><span class="line">  function reject(error) &#123;</span><br><span class="line">    const fn &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">      if (state !&#x3D;&#x3D; &#39;pending&#39;) return</span><br><span class="line"></span><br><span class="line">      if (error &amp;&amp; (typeof error &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof error &#x3D;&#x3D;&#x3D; &#39;function&#39;)) &#123;</span><br><span class="line">        const &#123; then &#125; &#x3D; error</span><br><span class="line">        if (typeof then &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">          then.call(error, resolve, reject)</span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      state &#x3D; &#39;rejected&#39;</span><br><span class="line">      value &#x3D; error</span><br><span class="line">      handelCb()</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(fn, 0)</span><br><span class="line">  &#125;</span><br><span class="line">  function handelCb() &#123;</span><br><span class="line">    while (callbacks.length) &#123;</span><br><span class="line">      const fn &#x3D; callbacks.shift()</span><br><span class="line">      handle(fn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  try &#123;</span><br><span class="line">  fn(resolve, reject)</span><br><span class="line">  &#125; catch(ex) &#123;</span><br><span class="line">	reject(ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>觉得内容有帮助可以关注下我的公众号 「前端 Q」，一起学习成长～～</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1618590479863-45b3793c-1dfa-4e0f-b837-edc1d348729a.png#clientId=u6208012a-0391-4&from=drop&id=u4b2d7e71&margin=%5Bobject%20Object%5D&originHeight=800&originWidth=2800&originalType=binary&size=174941&status=done&style=none&taskId=u0db2a6a1-badf-4755-8f94-e4b9e18befe"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/16/yuque/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/16/yuque/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">事件循环机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-16 19:47:37" itemprop="dateCreated datePublished" datetime="2021-04-16T19:47:37+08:00">2021-04-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-22 14:41:29" itemprop="dateModified" datetime="2021-04-22T14:41:29+08:00">2021-04-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="答题大纲"><a href="#答题大纲" class="headerlink" title="答题大纲"></a>答题大纲</h3><ol>
<li>先说基本知识点，宏任务、微任务有哪些</li>
<li>说事件循环机制过程，边说边画图出来</li>
<li>说 async/await 执行顺序注意，可以把 chrome 的优化，做法其实是违法了规范的，V8 团队的 PR 这些自信点说出来，显得你很好学，理解得很详细，很透彻。</li>
<li>把 node 的事件循环也说一下，重复 1、2、3 点，node 中的第 3 点要说的是 node11 前后的事件循环变动点。</li>
</ol>
<p>下面就跟着这个大纲走，每个点来说一下吧～</p>
<h3 id="浏览器中的事件循环"><a href="#浏览器中的事件循环" class="headerlink" title="浏览器中的事件循环"></a>浏览器中的事件循环</h3><p>JavaScript 代码的执行过程中，除了依靠函数调用栈来搞定函数的执行顺序外，还依靠任务队列(task queue)来搞定另外一些代码的执行。整个执行过程，我们称为事件循环过程。一个线程中，事件循环是唯一的，但是任务队列可以拥有多个。任务队列又分为 macro-task（宏任务）与 micro-task（微任务），在最新标准中，它们被分别称为 task 与 jobs。</p>
<p>macro-task 大概包括：</p>
<ul>
<li>script(整体代码)</li>
<li>setTimeout</li>
<li>setInterval</li>
<li>setImmediate</li>
<li>I/O</li>
<li>UI render</li>
</ul>
<p>micro-task 大概包括:</p>
<ul>
<li>process.nextTick</li>
<li>Promise</li>
<li>Async/Await(实际就是 promise)</li>
<li>MutationObserver(html5 新特性)</li>
</ul>
<p>整体执行，我画了一个流程图：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1618573781952-7782507e-dfda-41bf-8417-0435c4b684c9.png#clientId=u0fbb7ad9-f0df-4&from=drop&id=u25578fe7&margin=%5Bobject%20Object%5D&originHeight=818&originWidth=1678&originalType=binary&size=59057&status=done&style=none&taskId=u73daa851-8b7c-42da-8bec-df55426c906"></p>
<p>总的结论就是，执行宏任务，然后执行该宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行微任务，微任务执行完毕后，再回到宏任务中进行下一轮循环。举个例子：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1618573787405-8a3aca03-1875-4117-b918-81ae19c99e11.jpeg#clientId=u0fbb7ad9-f0df-4&from=drop&id=ubfc6d14f&margin=%5Bobject%20Object%5D&originHeight=488&originWidth=1000&originalType=binary&size=80503&status=done&style=none&taskId=ufac4233a-7981-4bb7-8d51-1bbbd5e63f6"></p>
<p>结合流程图理解，答案输出为：async2 end =&gt; Promise =&gt; async1 end =&gt; promise1 =&gt; promise2 =&gt; setTimeout</p>
<p>但是，对于 async/await ，我们有个细节还要处理一下。如下：</p>
<h3 id="async-await-执行顺序"><a href="#async-await-执行顺序" class="headerlink" title="async/await 执行顺序"></a>async/await 执行顺序</h3><p>我们知道<code>async</code>隐式返回 Promise 作为结果的函数,那么可以简单理解为，await 后面的函数执行完毕时，await 会产生一个微任务(Promise.then 是微任务)。但是我们要注意这个微任务产生的时机，它是执行完 await 之后，直接跳出 async 函数，执行其他代码(此处就是协程的运作，A 暂停执行，控制权交给 B)。其他代码执行完毕后，再回到 async 函数去执行剩下的代码，然后把 await 后面的代码注册到微任务队列当中。我们来看个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1 end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async2 end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Promise&quot;</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script end&quot;</span>);</span><br><span class="line"><span class="comment">// 旧版输出如下，但是请继续看完本文下面的注意那里，新版有改动</span></span><br><span class="line"><span class="comment">// script start =&gt; async2 end =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; async1 end =&gt; setTimeout</span></span><br></pre></td></tr></table></figure>

<p>分析这段代码：</p>
<ul>
<li>执行代码，输出<code>script start</code>。</li>
<li>执行 async1(),会调用 async2(),然后输出<code>async2 end</code>,此时将会保留 async1 函数的上下文，然后跳出 async1 函数。</li>
<li>遇到 setTimeout，产生一个宏任务</li>
<li>执行 Promise，输出<code>Promise</code>。遇到 then，产生第一个微任务</li>
<li>继续执行代码，输出<code>script end</code></li>
<li>代码逻辑执行完毕(当前宏任务执行完毕)，开始执行当前宏任务产生的微任务队列，输出<code>promise1</code>，该微任务遇到 then，产生一个新的微任务</li>
<li>执行产生的微任务，输出<code>promise2</code>,当前微任务队列执行完毕。执行权回到 async1</li>
<li>执行 await,实际上会产生一个 promise 返回，即</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise_ = <span class="keyword">new</span> <span class="built_in">Promise</span>((resolve,reject)&#123; resolve(<span class="literal">undefined</span>)&#125;)</span><br></pre></td></tr></table></figure>

<p>执行完成，执行 await 后面的语句，输出<code>async1 end</code></p>
<ul>
<li>最后，执行下一个宏任务，即执行 setTimeout，输出<code>setTimeout</code></li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>新版的 chrome 浏览器中不是如上打印的，因为 chrome 优化了,await 变得更快了,输出为:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// script start =&gt; async2 end =&gt; Promise =&gt; script end =&gt; async1 end =&gt; promise1 =&gt; promise2 =&gt; setTimeout</span></span><br></pre></td></tr></table></figure>

<p>但是这种做法其实是违法了规范的，当然规范也是可以更改的，这是 V8 团队的一个 <a target="_blank" rel="noopener" href="https://github.com/tc39/ecma262/pull/1250#issue-197979338">PR</a> ，目前新版打印已经修改。</p>
<p>知乎上也有相关讨论,可以看看 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/268007969">https://www.zhihu.com/question/268007969</a></p>
<p>我们可以分 2 种情况来理解：</p>
<ol>
<li> 如果 await 后面直接跟的为一个变量，比如：await 1；这种情况的话相当于直接把 await 后面的代码注册为一个微任务，可以简单理解为 promise.then(await 下面的代码)。然后跳出 async1 函数，执行其他代码，当遇到 promise 函数的时候，会注册 promise.then()函数到微任务队列，注意此时微任务队列里面已经存在 await 后面的微任务。所以这种情况会先执行 await 后面的代码（async1 end），再执行 async1 函数后面注册的微任务代码(promise1,promise2)。</li>
<li> 如果 await 后面跟的是一个异步函数的调用，比如上面的代码，将代码改成这样：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1 end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async2 end&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;async2 end1&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Promise&quot;</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script end&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// script start =&gt; async2 end =&gt; Promise =&gt; script end =&gt; async2 end1 =&gt; promise1 =&gt; promise2 =&gt; async1 end =&gt; setTimeout</span></span><br></pre></td></tr></table></figure>

<p>此时执行完 awit 并不先把 await 后面的代码注册到微任务队列中去，而是执行完 await 之后，直接跳出 async1 函数，执行其他代码。然后遇到 promise 的时候，把 promise.then 注册为微任务。其他代码执行完毕后，需要回到 async1 函数去执行剩下的代码，然后把 await 后面的代码注册到微任务队列当中，注意此时微任务队列中是有之前注册的微任务的。所以这种情况会先执行 async1 函数之外的微任务(promise1,promise2)，然后才执行 async1 内注册的微任务(async1 end).</p>
<p>可以理解为，这种情况下，await 后面的代码会在本轮循环的最后被执行.</p>
<p>浏览器中有事件循环，node 中也有，事件循环是 node 处理非阻塞 I/O 操作的机制，node 中事件循环的实现是依靠的 libuv 引擎。由于 node 11 之后，事件循环的一些原理发生了变化，这里就以新的标准去讲，最后再列上变化点让大家了解前因后果。</p>
<h3 id="node-中的事件循环"><a href="#node-中的事件循环" class="headerlink" title="node 中的事件循环"></a>node 中的事件循环</h3><p>浏览器中有事件循环，node 中也有，事件循环是 node 处理非阻塞 I/O 操作的机制，node 中事件循环的实现是依靠的 libuv 引擎。由于 node 11 之后，事件循环的一些原理发生了变化，这里就以新的标准去讲，最后再列上变化点让大家了解前因后果。</p>
<h4 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h4><p>node 中也有宏任务和微任务，与浏览器中的事件循环类似，其中，</p>
<p>macro-task 大概包括：</p>
<ul>
<li>setTimeout</li>
<li>setInterval</li>
<li>setImmediate</li>
<li>script（整体代码)</li>
<li>I/O 操作等。</li>
</ul>
<p>micro-task 大概包括：</p>
<ul>
<li>process.nextTick(与普通微任务有区别，在微任务队列执行之前执行)</li>
<li>new Promise().then(回调)等。</li>
</ul>
<h4 id="node-事件循环整体理解"><a href="#node-事件循环整体理解" class="headerlink" title="node 事件循环整体理解"></a>node 事件循环整体理解</h4><p>先看一张官网的 node 事件循环简化图：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1618573805467-2e96e30d-3f85-40c5-9215-78a7795fa76c.png#clientId=u0fbb7ad9-f0df-4&from=drop&id=u24642caa&margin=%5Bobject%20Object%5D&originHeight=451&originWidth=751&originalType=binary&size=25564&status=done&style=none&taskId=ud4bb323f-7d66-49c8-919b-bb1d659d487"></p>
<p>图中的每个框被称为事件循环机制的一个阶段，每个阶段都有一个 FIFO 队列来执行回调。虽然每个阶段都是特殊的，但通常情况下，当事件循环进入给定的阶段时，它将执行特定于该阶段的任何操作，然后执行该阶段队列中的回调，直到队列用尽或最大回调数已执行。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段。</p>
<p>因此，从上面这个简化图中，我们可以分析出 node 的事件循环的阶段顺序为：</p>
<p>输入数据阶段(incoming data)-&gt;轮询阶段(poll)-&gt;检查阶段(check)-&gt;关闭事件回调阶段(close callback)-&gt;定时器检测阶段(timers)-&gt;I/O 事件回调阶段(I/O callbacks)-&gt;闲置阶段(idle, prepare)-&gt;轮询阶段…</p>
<h4 id="阶段概述"><a href="#阶段概述" class="headerlink" title="阶段概述"></a>阶段概述</h4><ul>
<li>定时器检测阶段(timers)：本阶段执行 timer 的回调，即 setTimeout、setInterval 里面的回调函数。</li>
<li>I/O 事件回调阶段(I/O callbacks)：执行延迟到下一个循环迭代的 I/O 回调，即上一轮循环中未被执行的一些 I/O 回调。</li>
<li>闲置阶段(idle, prepare)：仅系统内部使用。</li>
<li>轮询阶段(poll)：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞。</li>
<li>检查阶段(check)：setImmediate() 回调函数在这里执行</li>
<li>关闭事件回调阶段(close callback)：一些关闭的回调函数，如：socket.on(‘close’, …)。</li>
</ul>
<h4 id="三大重点阶段"><a href="#三大重点阶段" class="headerlink" title="三大重点阶段"></a>三大重点阶段</h4><p>日常开发中的绝大部分异步任务都是在 poll、check、timers 这 3 个阶段处理的,所以我们来重点看看。</p>
<h5 id="timers"><a href="#timers" class="headerlink" title="timers"></a>timers</h5><p>timers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。 同样，在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行。</p>
<h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h5><p>poll 是一个至关重要的阶段，poll 阶段的执行逻辑流程图如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1618573818346-738f855a-9297-4b19-9e7e-4350d4e3e7d1.jpeg#clientId=u0fbb7ad9-f0df-4&from=drop&id=ubb22cbe6&margin=%5Bobject%20Object%5D&originHeight=594&originWidth=625&originalType=binary&size=38789&status=done&style=none&taskId=u17631d17-a0d2-4dfb-acf9-0827e261e10"></p>
<p>如果当前已经存在定时器，而且有定时器到时间了，拿出来执行，eventLoop 将回到 timers 阶段。</p>
<p>如果没有定时器, 会去看回调函数队列。</p>
<ul>
<li>如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制</li>
<li>如果 poll 队列为空时，会有两件事发生<ul>
<li>如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调</li>
<li>如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去,一段时间后自动进入 check 阶段。</li>
</ul>
</li>
</ul>
<h5 id="check"><a href="#check" class="headerlink" title="check"></a>check</h5><p>check 阶段。这是一个比较简单的阶段，直接执行 setImmdiate 的回调。</p>
<h4 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick"></a>process.nextTick</h4><p>process.nextTick 是一个独立于 eventLoop 的任务队列。</p>
<p>在每一个 eventLoop 阶段完成后会去检查 nextTick 队列，如果里面有任务，会让这部分任务优先于微任务执行。</p>
<p>看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;timeout1&quot;</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;promise resolve&quot;</span>));</span><br><span class="line">  process.nextTick(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;next tick1&quot;</span>));</span><br><span class="line">&#125;);</span><br><span class="line">setImmediate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;timeout2&quot;</span>);</span><br><span class="line">  process.nextTick(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;next tick2&quot;</span>));</span><br><span class="line">&#125;);</span><br><span class="line">setImmediate(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;timeout3&quot;</span>));</span><br><span class="line">setImmediate(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;timeout4&quot;</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>在 node11 之前，因为每一个 eventLoop 阶段完成后会去检查 nextTick 队列，如果里面有任务，会让这部分任务优先于微任务执行，因此上述代码是先进入 check 阶段，执行所有 setImmediate，完成之后执行 nextTick 队列，最后执行微任务队列，因此输出为<code>timeout1=&gt;timeout2=&gt;timeout3=&gt;timeout4=&gt;next tick1=&gt;next tick2=&gt;promise resolve</code></li>
<li>在 node11 之后，process.nextTick 是微任务的一种,因此上述代码是先进入 check 阶段，执行一个 setImmediate 宏任务，然后执行其微任务队列，再执行下一个宏任务及其微任务,因此输出为<code>timeout1=&gt;next tick1=&gt;promise resolve=&gt;timeout2=&gt;next tick2=&gt;timeout3=&gt;timeout4</code></li>
</ul>
<h3 id="node-版本差异说明"><a href="#node-版本差异说明" class="headerlink" title="node 版本差异说明"></a>node 版本差异说明</h3><p>这里主要说明的是 node11 前后的差异，因为 node11 之后一些特性已经向浏览器看齐了，总的变化一句话来说就是，如果是 node11 版本一旦执行一个阶段里的一个宏任务(setTimeout,setInterval 和 setImmediate)就立刻执行对应的微任务队列，一起来看看吧～</p>
<h4 id="timers-阶段的执行时机变化"><a href="#timers-阶段的执行时机变化" class="headerlink" title="timers 阶段的执行时机变化"></a>timers 阶段的执行时机变化</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;timer1&quot;</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;timer2&quot;</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>如果是 node11 版本一旦执行一个阶段里的一个宏任务(setTimeout,setInterval 和 setImmediate)就立刻执行微任务队列，这就跟浏览器端运行一致，最后的结果为<code>timer1=&gt;promise1=&gt;timer2=&gt;promise2</code></li>
<li>如果是 node10 及其之前版本要看第一个定时器执行完，第二个定时器是否在完成队列中.<ul>
<li>如果是第二个定时器还未在完成队列中，最后的结果为<code>timer1=&gt;promise1=&gt;timer2=&gt;promise2</code></li>
<li>如果是第二个定时器已经在完成队列中，则最后的结果为<code>timer1=&gt;timer2=&gt;promise1=&gt;promise2</code></li>
</ul>
</li>
</ul>
<h4 id="check-阶段的执行时机变化"><a href="#check-阶段的执行时机变化" class="headerlink" title="check 阶段的执行时机变化"></a>check 阶段的执行时机变化</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;immediate1&quot;</span>));</span><br><span class="line">setImmediate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;immediate2&quot;</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;promise resolve&quot;</span>));</span><br><span class="line">&#125;);</span><br><span class="line">setImmediate(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;immediate3&quot;</span>));</span><br><span class="line">setImmediate(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;immediate4&quot;</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>如果是 node11 后的版本，会输出<code>immediate1=&gt;immediate2=&gt;promise resolve=&gt;immediate3=&gt;immediate4</code></li>
<li>如果是 node11 前的版本，会输出<code>immediate1=&gt;immediate2=&gt;immediate3=&gt;immediate4=&gt;promise resolve</code></li>
</ul>
<h4 id="nextTick-队列的执行时机变化"><a href="#nextTick-队列的执行时机变化" class="headerlink" title="nextTick 队列的执行时机变化"></a>nextTick 队列的执行时机变化</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;timeout1&quot;</span>));</span><br><span class="line">setImmediate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;timeout2&quot;</span>);</span><br><span class="line">  process.nextTick(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;next tick&quot;</span>));</span><br><span class="line">&#125;);</span><br><span class="line">setImmediate(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;timeout3&quot;</span>));</span><br><span class="line">setImmediate(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;timeout4&quot;</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>如果是 node11 后的版本，会输出<code>timeout1=&gt;timeout2=&gt;next tick=&gt;timeout3=&gt;timeout4</code></li>
<li>如果是 node11 前的版本，会输出<code>timeout1=&gt;timeout2=&gt;timeout3=&gt;timeout4=&gt;next tick</code></li>
</ul>
<p>以上几个例子，你应该就能清晰感受到它的变化了，反正记着一个结论，如果是 node11 版本一旦执行一个阶段里的一个宏任务(setTimeout,setInterval 和 setImmediate)就立刻执行对应的微任务队列。</p>
<h3 id="node-和-浏览器-eventLoop-的主要区别"><a href="#node-和-浏览器-eventLoop-的主要区别" class="headerlink" title="node 和 浏览器 eventLoop 的主要区别"></a>node 和 浏览器 eventLoop 的主要区别</h3><p>两者最主要的区别在于浏览器中的微任务是在每个相应的宏任务中执行的，而 nodejs 中的微任务是在不同阶段之间执行的。</p>
<h3 id="更多理解资料"><a href="#更多理解资料" class="headerlink" title="更多理解资料"></a>更多理解资料</h3><ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI0MzIyMDM5Ng==%E2%88%A3=2649826490&idx=1&sn=5e38c673dfa45dabc1a348597cdd6e82&chksm=f175ee79c602676fc885e145fbaef28e6e88678f852c62fb00b8229cfedcf9ac422bcf20b2e4&scene=21#wechat_redirect">【语音解题系列】说说 JS 的事件循环机制 (含满分答题技巧)</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/qEmR-N6cANSkKuJt2QO_eg">【语音解题系列】说说 JS 的事件循环机制 (含满分答题技巧)</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LuckyWinty/fe-weekly-questions/issues">自测题目</a></li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/book/6844733763675488269/section/6844733763763568654#heading-4">前端面试之道</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903858129338375">一道面试题引发的 node 事件循环深入思考</a></li>
<li><a target="_blank" rel="noopener" href="https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/">Node.js 事件循环，定时器和 process.nextTick()</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/33058983">详解 JavaScript 中的 Event Loop（事件循环）机制</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.insiderattack.net/new-changes-to-timers-and-microtasks-from-node-v11-0-0-and-above-68d112743eb3">New Changes to the Timers and Microtasks in Node v11.0.0 ( and above)</a></li>
</ul>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><ul>
<li>欢迎加我微信(winty230)，拉你进技术群，长期交流学习…</li>
<li>欢迎关注「前端 Q」,认真学前端，做个有专业的技术人…</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1618573825825-d88156eb-e92a-4394-95c6-642ec5c602cd.png#clientId=u0fbb7ad9-f0df-4&from=drop&id=ua550051a&margin=%5Bobject%20Object%5D&originHeight=480&originWidth=480&originalType=binary&size=207122&status=done&style=none&taskId=u875f592c-0be4-4d8f-ac64-3ffb5c9bdb7"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/16/yuque/%E4%BD%9C%E7%94%A8%E5%9F%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/16/yuque/%E4%BD%9C%E7%94%A8%E5%9F%9F/" class="post-title-link" itemprop="url">作用域</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-16 18:18:01" itemprop="dateCreated datePublished" datetime="2021-04-16T18:18:01+08:00">2021-04-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-22 14:41:29" itemprop="dateModified" datetime="2021-04-22T14:41:29+08:00">2021-04-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JavaScript 中有一个被称为作用域(Scope)的特性。虽然对于许多新手开发者来说，作用域的概念并不是很容易理解，本文我会尽我所能用最简单的方式来解释作用域和作用域链，希望大家有所收获！</p>
<p><strong>想阅读更多优质文章请猛戳</strong><a target="_blank" rel="noopener" href="https://github.com/ljianshu/Blog"><strong>GitHub 博客</strong></a></p>
<h2 id="作用域-Scope"><a href="#作用域-Scope" class="headerlink" title="作用域(Scope)"></a>作用域(Scope)</h2><h3 id="1-什么是作用域"><a href="#1-什么是作用域" class="headerlink" title="1.什么是作用域"></a>1.什么是作用域</h3><p>作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。换句话说，作用域决定了代码区块中变量和其他资源的可见性。可能这两句话并不好理解，我们先来看个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function outFun2() &#123;</span><br><span class="line">    var inVariable &#x3D; &quot;内层变量2&quot;;</span><br><span class="line">&#125;</span><br><span class="line">outFun2();&#x2F;&#x2F;要先执行这个函数，否则根本不知道里面是啥</span><br><span class="line">console.log(inVariable); &#x2F;&#x2F; Uncaught ReferenceError: inVariable is not defined</span><br></pre></td></tr></table></figure>

<p>从上面的例子可以体会到作用域的概念，变量 inVariable 在全局作用域没有声明，所以在全局作用域下取值会报错。我们可以这样理解：<strong>作用域就是一个独立的地盘，让变量不会外泄、暴露出去</strong>。也就是说<strong>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</strong></p>
<p><strong>ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域</strong>。ES6 的到来，为我们提供了‘块级作用域’,可通过新增命令 let 和 const 来体现。</p>
<h3 id="2-全局作用域和函数作用域"><a href="#2-全局作用域和函数作用域" class="headerlink" title="2.全局作用域和函数作用域"></a>2.全局作用域和函数作用域</h3><p>在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下几种情形拥有全局作用域：</p>
<ul>
<li>最外层函数 和在最外层函数外面定义的变量拥有全局作用域</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var outVariable &#x3D; &quot;我是最外层变量&quot;; &#x2F;&#x2F;最外层变量</span><br><span class="line">function outFun() &#123; &#x2F;&#x2F;最外层函数</span><br><span class="line">    var inVariable &#x3D; &quot;内层变量&quot;;</span><br><span class="line">    function innerFun() &#123; &#x2F;&#x2F;内层函数</span><br><span class="line">        console.log(inVariable);</span><br><span class="line">    &#125;</span><br><span class="line">    innerFun();</span><br><span class="line">&#125;</span><br><span class="line">console.log(outVariable); &#x2F;&#x2F;我是最外层变量</span><br><span class="line">outFun(); &#x2F;&#x2F;内层变量</span><br><span class="line">console.log(inVariable); &#x2F;&#x2F;inVariable is not defined</span><br><span class="line">innerFun(); &#x2F;&#x2F;innerFun is not defined</span><br></pre></td></tr></table></figure>

<ul>
<li>所有末定义直接赋值的变量自动声明为拥有全局作用域</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function outFun2() &#123;</span><br><span class="line">    variable &#x3D; &quot;未定义直接赋值的变量&quot;;</span><br><span class="line">    var inVariable2 &#x3D; &quot;内层变量2&quot;;</span><br><span class="line">&#125;</span><br><span class="line">outFun2();&#x2F;&#x2F;要先执行这个函数，否则根本不知道里面是啥</span><br><span class="line">console.log(variable); &#x2F;&#x2F;未定义直接赋值的变量</span><br><span class="line">console.log(inVariable2); &#x2F;&#x2F;inVariable2 is not defined</span><br></pre></td></tr></table></figure>

<ul>
<li>所有 window 对象的属性拥有全局作用域</li>
</ul>
<p>一般情况下，window 对象的内置属性都拥有全局作用域，例如 window.name、window.location、window.top 等等。</p>
<p>全局作用域有个弊端：如果我们写了很多行 JS 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中。这样就会 污染全局命名空间, 容易引起命名冲突。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 张三写的代码中</span><br><span class="line">var data &#x3D; &#123;a: 100&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 李四写的代码中</span><br><span class="line">var data &#x3D; &#123;x: true&#125;</span><br></pre></td></tr></table></figure>

<p>这就是为何 jQuery、Zepto 等库的源码，所有的代码都会放在<code>(function()&#123;....&#125;)()</code>中。因为放在里面的所有变量，都不会被外泄和暴露，不会污染到外面，不会对其他的库或者 JS 脚本造成影响。这是函数作用域的一个体现。</p>
<p>函数作用域,是指声明在函数内部的变量，和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function doSomething()&#123;</span><br><span class="line">    var blogName&#x3D;&quot;浪里行舟&quot;;</span><br><span class="line">    function innerSay()&#123;</span><br><span class="line">        alert(blogName);</span><br><span class="line">    &#125;</span><br><span class="line">    innerSay();</span><br><span class="line">&#125;</span><br><span class="line">alert(blogName); &#x2F;&#x2F;脚本错误</span><br><span class="line">innerSay(); &#x2F;&#x2F;脚本错误</span><br></pre></td></tr></table></figure>

<p><strong>作用域是分层的，内层作用域可以访问外层作用域的变量，反之则不行</strong>。我们看个例子，用泡泡来比喻作用域可能好理解一点：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1618568347878-7b1e69f1-82cd-44f5-8577-203aec5debf6.png#clientId=u86861ac7-38dd-4&from=drop&height=294&id=u853b9505&margin=%5Bobject%20Object%5D&originHeight=294&originWidth=461&originalType=binary&size=37264&status=done&style=none&taskId=u1902bc6f-4248-4373-9939-5f737f86482&width=461"></p>
<p>最后输出的结果为 2, 4, 12</p>
<ul>
<li>泡泡 1 是全局作用域，有标识符 foo；</li>
<li>泡泡 2 是作用域 foo，有标识符 a,bar,b；</li>
<li>泡泡 3 是作用域 bar，仅有标识符 c。</li>
</ul>
<p>值得注意的是：<strong>块语句（大括号“｛｝”中间的语句），如 if 和 switch 条件语句或 for 和 while 循环语句，不像函数，它们不会创建一个新的作用域</strong>。在块语句中定义的变量将保留在它们已经存在的作用域中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">    &#x2F;&#x2F; &#39;if&#39; 条件语句块不会创建一个新的作用域</span><br><span class="line">    var name &#x3D; &#39;Hammad&#39;; &#x2F;&#x2F; name 依然在全局作用域中</span><br><span class="line">&#125;</span><br><span class="line">console.log(name); &#x2F;&#x2F; logs &#39;Hammad&#39;</span><br></pre></td></tr></table></figure>

<p>JS 的初学者经常需要花点时间才能习惯变量提升，而如果不理解这种特有行为，就可能导致 bug 。正因为如此， ES6 引入了块级作用域，让变量的生命周期更加可控。</p>
<h3 id="3-块级作用域"><a href="#3-块级作用域" class="headerlink" title="3.块级作用域"></a>3.块级作用域</h3><p>块级作用域可通过新增命令 let 和 const 声明，所声明的变量在指定块的作用域外无法被访问。块级作用域在如下情况被创建：</p>
<ol>
<li>在一个函数内部</li>
<li>在一个代码块（由一对花括号包裹）内部</li>
</ol>
<p>let 声明的语法与 var 的语法一致。你基本上可以用 let 来代替 var 进行变量声明，但会将变量的作用域限制在当前代码块中。块级作用域有以下几个特点：</p>
<ul>
<li>声明变量不会提升到代码块顶部</li>
</ul>
<p>let/const 声明并不会被提升到当前代码块的顶部，因此你需要手动将 let/const 声明放置到顶部，以便让变量在整个代码块内部可用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function getValue(condition) &#123;</span><br><span class="line">if (condition) &#123;</span><br><span class="line">let value &#x3D; &quot;blue&quot;;</span><br><span class="line">return value;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F; value 在此处不可用</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; value 在此处不可用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>禁止重复声明</li>
</ul>
<p>如果一个标识符已经在代码块内部被定义，那么在此代码块内使用同一个标识符进行 let 声明就会导致抛出错误。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var count &#x3D; 30;</span><br><span class="line">let count &#x3D; 40; &#x2F;&#x2F; Uncaught SyntaxError: Identifier &#39;count&#39; has already been declared</span><br></pre></td></tr></table></figure>

<p>在本例中， count 变量被声明了两次：一次使用 var ，另一次使用 let 。因为 let 不能在同一作用域内重复声明一个已有标识符，此处的 let 声明就会抛出错误。但如果在嵌套的作用域内使用 let 声明一个同名的新变量，则不会抛出错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var count &#x3D; 30;</span><br><span class="line">&#x2F;&#x2F; 不会抛出错误</span><br><span class="line">if (condition) &#123;</span><br><span class="line">let count &#x3D; 40;</span><br><span class="line">&#x2F;&#x2F; 其他代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>循环中的绑定块作用域的妙用</li>
</ul>
<p>开发者可能最希望实现 for 循环的块级作用域了，因为可以把声明的计数器变量限制在循环内，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (let i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line">console.log(i);</span><br><span class="line">&#x2F;&#x2F; ReferenceError: i is not defined</span><br></pre></td></tr></table></figure>

<p>上面代码中，计数器 i 只在 for 循环体内有效，在循环体外引用就会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [];</span><br><span class="line">for (var i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">  a[i] &#x3D; function () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[6](); &#x2F;&#x2F; 10</span><br></pre></td></tr></table></figure>

<p>上面代码中，变量 i 是 var 命令声明的，在全局范围内都有效，所以全局只有一个变量 i。每一次循环，变量 i 的值都会发生改变，而循环内被赋给数组 a 的函数内部的 console.log(i)，里面的 i 指向的就是全局的 i。也就是说，所有数组 a 的成员里面的 i，指向的都是同一个 i，导致运行时输出的是最后一轮的 i 的值，也就是 10。</p>
<p>如果使用 let，声明的变量仅在块级作用域内有效，最后输出的是 6。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [];</span><br><span class="line">for (let i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">  a[i] &#x3D; function () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[6](); &#x2F;&#x2F; 6</span><br></pre></td></tr></table></figure>

<p>上面代码中，变量 i 是 let 声明的，当前的 i 只在本轮循环有效，所以每一次循环的 i 其实都是一个新的变量，所以最后输出的是 6。你可能会问，如果每一轮循环的变量 i 都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量 i 时，就在上一轮循环的基础上进行计算。</p>
<p>另外，for 循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (let i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">  let i &#x3D; &#39;abc&#39;;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; abc</span><br><span class="line">&#x2F;&#x2F; abc</span><br><span class="line">&#x2F;&#x2F; abc</span><br></pre></td></tr></table></figure>

<p>上面代码正确运行，输出了 3 次 abc。这表明函数内部的变量 i 与循环变量 i 不在同一个作用域，有各自单独的作用域。</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><h3 id="1-什么是自由变量"><a href="#1-什么是自由变量" class="headerlink" title="1.什么是自由变量"></a>1.什么是自由变量</h3><p>首先认识一下什么叫做 <strong>自由变量</strong> 。如下代码中，<code>console.log(a)</code>要得到 a 变量，但是在当前的作用域中没有定义 a（可对比一下 b）。当前作用域没有定义的变量，这成为 自由变量 。自由变量的值如何得到 —— 向父级作用域寻找（注意：这种说法并不严谨，下文会重点解释）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 100</span><br><span class="line">function fn() &#123;</span><br><span class="line">    var b &#x3D; 200</span><br><span class="line">    console.log(a) &#x2F;&#x2F; 这里的a在这里就是一个自由变量</span><br><span class="line">    console.log(b)</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>

<h3 id="2-什么是作用域链"><a href="#2-什么是作用域链" class="headerlink" title="2.什么是作用域链"></a>2.什么是作用域链</h3><p>如果父级也没呢？再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是 作用域链 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 100</span><br><span class="line">function F1() &#123;</span><br><span class="line">    var b &#x3D; 200</span><br><span class="line">    function F2() &#123;</span><br><span class="line">        var c &#x3D; 300</span><br><span class="line">        console.log(a) &#x2F;&#x2F; 自由变量，顺作用域链向父作用域找</span><br><span class="line">        console.log(b) &#x2F;&#x2F; 自由变量，顺作用域链向父作用域找</span><br><span class="line">        console.log(c) &#x2F;&#x2F; 本作用域的变量</span><br><span class="line">    &#125;</span><br><span class="line">    F2()</span><br><span class="line">&#125;</span><br><span class="line">F1()</span><br></pre></td></tr></table></figure>

<h3 id="3-关于自由变量的取值"><a href="#3-关于自由变量的取值" class="headerlink" title="3.关于自由变量的取值"></a>3.关于自由变量的取值</h3><p>关于自由变量的值，上文提到要到父作用域中取，其实有时候这种解释会产生歧义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; 10</span><br><span class="line">function fn() &#123;</span><br><span class="line">  console.log(x)</span><br><span class="line">&#125;</span><br><span class="line">function show(f) &#123;</span><br><span class="line">  var x &#x3D; 20</span><br><span class="line">  (function() &#123;</span><br><span class="line">    f() &#x2F;&#x2F;10，而不是20</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;</span><br><span class="line">show(fn)</span><br></pre></td></tr></table></figure>

<p>在 fn 函数中，取自由变量 x 的值时，要到哪个作用域中取？——要到创建 fn 函数的那个作用域中取，<strong>无论 fn 函数将在哪里调用</strong>。</p>
<p>所以，不要在用以上说法了。相比而言，用这句话描述会更加贴切:<strong>要到创建这个函数的那个域”。 作用域中取值,这里强调的是“创建”，而不是“调用”</strong>，切记切记——其实这就是所谓的”静态作用域”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 10</span><br><span class="line">function fn() &#123;</span><br><span class="line">  var b &#x3D; 20</span><br><span class="line">  function bar() &#123;</span><br><span class="line">    console.log(a + b) &#x2F;&#x2F;30</span><br><span class="line">  &#125;</span><br><span class="line">  return bar</span><br><span class="line">&#125;</span><br><span class="line">var x &#x3D; fn(),</span><br><span class="line">  b &#x3D; 200</span><br><span class="line">x() &#x2F;&#x2F;bar()</span><br></pre></td></tr></table></figure>

<p>fn()返回的是 bar 函数，赋值给 x。执行 x()，即执行 bar 函数代码。取 b 的值时，直接在 fn 作用域取出。取 a 的值时，试图在 fn 作用域取，但是取不到，只能转向创建 fn 的那个作用域中去查找，结果找到了,所以最后的结果是 30</p>
<h2 id="作用域与执行上下文"><a href="#作用域与执行上下文" class="headerlink" title="作用域与执行上下文"></a>作用域与执行上下文</h2><p>许多开发人员经常混淆作用域和执行上下文的概念，误认为它们是相同的概念，但事实并非如此。</p>
<p>我们知道 JavaScript 属于解释型语言，JavaScript 的执行分为：解释和执行两个阶段,这两个阶段所做的事并不一样：</p>
<h3 id="解释阶段："><a href="#解释阶段：" class="headerlink" title="解释阶段："></a>解释阶段：</h3><ul>
<li>词法分析</li>
<li>语法分析</li>
<li>作用域规则确定</li>
</ul>
<h3 id="执行阶段："><a href="#执行阶段：" class="headerlink" title="执行阶段："></a>执行阶段：</h3><ul>
<li>创建执行上下文</li>
<li>执行函数代码</li>
<li>垃圾回收</li>
</ul>
<p>JavaScript 解释阶段便会确定作用域规则，因此作用域在函数定义时就已经确定了，而不是在函数调用时确定，但是执行上下文是函数执行之前创建的。执行上下文最明显的就是 this 的指向是执行时确定的。而作用域访问的变量是编写代码的结构确定的。</p>
<p>作用域和执行上下文之间最大的区别是： <strong>执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变</strong>。</p>
<p>一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。<strong>同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值</strong>。</p>
<p><strong>给大家推荐一个好用的 BUG 监控工具</strong><a target="_blank" rel="noopener" href="https://www.fundebug.com/?utm_source=liao"><strong>Fundebug</strong></a><strong>，欢迎免费试用！</strong></p>
<p>欢迎关注公众号：<strong>前端工匠</strong>，你的成长我们一起见证！如果你感觉有收获，欢迎给我打赏,以激励我更多输出优质开源内容</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1618568367206-228fd607-a241-405c-9887-aa0d1698b534.png#clientId=u86861ac7-38dd-4&from=drop&id=u57884e8e&margin=%5Bobject%20Object%5D&originHeight=372&originWidth=1179&originalType=binary&size=533174&status=done&style=none&taskId=uf98150e8-7678-4277-9772-679cf28bd81"></p>
<h2 id="参考文章和书籍"><a href="#参考文章和书籍" class="headerlink" title="参考文章和书籍"></a>参考文章和书籍</h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/wangfupeng1988/p/4001284.html">深入理解 javascript 原型和闭包系列</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/book/6844733713780047886/section/6844733713830379533">Web 前端面试指南与高频考题解析</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/creeperyang/blog/issues/16">深入理解 JS 中声明提升、作用域（链）和关键字</a><code>this</code></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/lhb25/archive/2011/09/06/javascript-scope-chain.html">JavaScript 开发进阶：理解 JavaScript 作用域和作用域链</a></li>
<li><a target="_blank" rel="noopener" href="https://gaohaoyang.github.io/2015/05/20/scope/#top">JavaScript 作用域和作用域链</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/27072230/">深入理解 ES6</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Adam Blog</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Adam Blog</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
