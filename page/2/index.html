<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Adam">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Adam">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Adam Blog">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Adam</title>
  <meta name="referrer" content="no-referrer" />
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Adam</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/25/yuque/TCP%20%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%EF%BC%88%E4%B8%8A%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/25/yuque/TCP%20%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%EF%BC%88%E4%B8%8A%EF%BC%89/" class="post-title-link" itemprop="url">TCP 的那些事儿（上）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-25 22:19:58" itemprop="dateCreated datePublished" datetime="2021-04-25T22:19:58+08:00">2021-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 18:36:14" itemprop="dateModified" datetime="2021-04-29T18:36:14+08:00">2021-04-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>TCP 是一个巨复杂的协议，因为他要解决很多问题，而这些问题又带出了很多子问题和阴暗面。所以学习 TCP 本身是个比较痛苦的过程，但对于学习的过程却能让人有很多收获。关于 TCP 这个协议的细节，我还是推荐你去看<a target="_blank" rel="noopener" href="http://www.kohala.com/start/">W.Richard Stevens</a>的《<a target="_blank" rel="noopener" href="http://book.douban.com/subject/1088054/">TCP/IP 详解 卷 1：协议</a>》（当然，你也可以去读一下<a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc793">RFC793</a>以及后面 N 多的 RFC）。另外，本文我会使用英文术语，这样方便你通过这些英文关键词来查找相关的技术文档。<br>之所以想写这篇文章，目的有三个，</p>
<ul>
<li>一个是想锻炼一下自己是否可以用简单的篇幅把这么复杂的 TCP 协议描清楚的能力。</li>
<li>另一个是觉得现在的好多程序员基本上不会认认真真地读本书，喜欢快餐文化，所以，希望这篇快餐文章可以让你对 TCP 这个古典技术有所了解，并能体会到软件设计中的种种难处。并且你可以从中有一些软件设计上的收获。</li>
<li>最重要的希望这些基础知识可以让你搞清很多以前一些似是而非的东西，并且你能意识到基础的重要。</li>
</ul>
<p>所以，本文不会面面俱到，只是对 TCP 协议、算法和原理的科普。<br>我本来只想写一个篇幅的文章的，但是 TCP 真 TMD 的复杂，比 C++复杂多了，这 30 多年来，各种优化变种争论和修改。所以，写着写着就发现只有砍成两篇。</p>
<ul>
<li>上篇中，主要向你介绍 TCP 协议的定义和丢包时的重传机制。</li>
<li>下篇中，重点介绍 TCP 的流迭、拥塞处理。</li>
</ul>
<p>废话少说，首先，我们需要知道 TCP 在网络 OSI 的七层模型中的第四层——Transport 层，IP 在第三层——Network 层，ARP 在第二层——Data Link 层，在第二层上的数据，我们叫 Frame，在第三层上的数据叫 Packet，第四层的数据叫 Segment。<br>首先，我们需要知道，我们程序的数据首先会打到 TCP 的 Segment 中，然后 TCP 的 Segment 会打到 IP 的 Packet 中，然后再打到以太网 Ethernet 的 Frame 中，传到对端后，各个层解析自己的协议，然后把数据交给更高层的协议处理。</p>
<h1 id="TCP-头格式"><a href="#TCP-头格式" class="headerlink" title="TCP 头格式"></a>TCP 头格式</h1><p>接下来，我们来看一下 TCP 头的格式<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619360435712-cb93875c-cbbb-4568-a93c-cd610d064896.jpeg#clientId=ud05b6d37-a831-4&from=paste&height=324&id=u73cb9979&margin=%5Bobject%20Object%5D&originHeight=324&originWidth=800&originalType=url&status=done&style=none&taskId=ub7a2e625-7c99-4e81-a419-5a010e35f15&width=800">TCP 头格式（<a target="_blank" rel="noopener" href="http://nmap.org/book/tcpip-ref.html">图片来源</a>）<br>你需要注意这么几点：</p>
<ul>
<li>TCP 的包是没有 IP 地址的，那是 IP 层上的事。但是有源端口和目标端口。</li>
<li>一个 TCP 连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说 TCP 协议，所以，这里我只说四元组。</li>
<li>注意上图中的四个非常重要的东西：<ul>
<li><strong>Sequence Number</strong>是包的序号，<strong>用来解决网络包乱序（reordering）问题。</strong></li>
<li><strong>Acknowledgement Number</strong>就是 ACK——用于确认收到，<strong>用来解决不丢包的问题</strong>。</li>
<li><strong>Window 又叫 Advertised-Window</strong>，也就是著名的滑动窗口（Sliding Window），<strong>用于解决流控的</strong>。</li>
<li><strong>TCP Flag</strong>，也就是包的类型，<strong>主要是用于操控 TCP 的状态机的</strong>。</li>
</ul>
</li>
</ul>
<p>关于其它的东西，可以参看下面的图示<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619360435612-00cf3a4b-0003-418b-aa31-24ba052fe8c4.jpeg#clientId=ud05b6d37-a831-4&from=paste&height=245&id=u69ac5547&margin=%5Bobject%20Object%5D&originHeight=245&originWidth=800&originalType=url&status=done&style=none&taskId=u86f9dfbe-f310-4599-8fa7-c7a71241924&width=800"><br>（<a target="_blank" rel="noopener" href="http://nmap.org/book/tcpip-ref.html">图片来源</a>）</p>
<h1 id="TCP-的状态机"><a href="#TCP-的状态机" class="headerlink" title="TCP 的状态机"></a>TCP 的状态机</h1><p>其实，<strong>网络上的传输是没有连接的，包括 TCP 也是一样的</strong>。而 TCP 所谓的“连接”，其实只不过是在通讯的双方维护一个“连接状态”，让它看上去好像有连接一样。所以，TCP 的状态变换是非常重要的。<br>下面是：“<strong>TCP 协议的状态机</strong>”（<a target="_blank" rel="noopener" href="http://www.tcpipguide.com/free/t_TCPOperationalOverviewandtheTCPFiniteStateMachineF-2.htm">图片来源</a>） 和 “<strong>TCP 建链接</strong>”、“<strong>TCP 断链接</strong>”、“<strong>传数据</strong>” 的对照图，我把两个图并排放在一起，这样方便在你对照着看。另外，下面这两个图非常非常的重要，你一定要记牢。（吐个槽：看到这样复杂的状态机，就知道这个协议有多复杂，复杂的东西总是有很多坑爹的事情，所以 TCP 协议其实也挺坑爹的）<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619360435478-bdc079d8-59eb-4c14-b331-a1da33d9d01c.png#clientId=ud05b6d37-a831-4&from=paste&height=401&id=u58631bd8&margin=%5Bobject%20Object%5D&originHeight=801&originWidth=562&originalType=url&status=done&style=none&taskId=u2e244c08-3758-4f85-b8af-bea88766a30&width=281"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619360435742-10a18c36-7582-46d0-8722-b1765b434855.jpeg#clientId=ud05b6d37-a831-4&from=paste&height=488&id=u92e9d4bc&margin=%5Bobject%20Object%5D&originHeight=976&originWidth=875&originalType=url&status=done&style=none&taskId=ubbcb5cdf-a996-417b-9dc7-9d94bbdd3c0&width=437.5"><br>很多人会问，为什么建链接要 3 次握手，断链接需要 4 次挥手？</p>
<ul>
<li><strong>对于建链接的 3 次握手，</strong>主要是要初始化 Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的 Sequence Number（缩写为 ISN：Inital Sequence Number）——所以叫 SYN，全称 Synchronize Sequence Numbers。也就上图中的 x 和 y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP 会用这个序号来拼接数据）。</li>
<li><strong>对于 4 次挥手，</strong>其实你仔细看是 2 次，因为 TCP 是全双工的，所以，发送方和接收方都需要 Fin 和 Ack。只不过，有一方是被动的，所以看上去就成了所谓的 4 次挥手。如果两边同时断连接，那就会就进入到 CLOSING 状态，然后到达 TIME_WAIT 状态。下图是双方同时断连接的示意图（你同样可以对照着 TCP 状态机看）：</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619360435653-74f01dce-4151-4153-ae85-ef5f7c8934ef.png#clientId=ud05b6d37-a831-4&from=paste&height=526&id=u9a87d6d5&margin=%5Bobject%20Object%5D&originHeight=526&originWidth=666&originalType=url&status=done&style=none&taskId=u366cc996-5eb3-4b87-b5ff-af4b774637b&width=666"><br>两端同时断连接（<a target="_blank" rel="noopener" href="http://www.tcpipguide.com/free/t_TCPConnectionTermination-4.htm">图片来源</a>）<br>另外，有几个事情需要注意一下：</p>
<ul>
<li><strong>关于建连接时 SYN 超时</strong>。试想一下，如果 server 端接到了 clien 发的 SYN 后回了 SYN-ACK 后 client 掉线了，server 端没有收到 client 回来的 ACK，那么，这个连接处于一个中间状态，即没成功，也没失败。于是，server 端如果在一定时间内没有收到的 TCP 会重发 SYN-ACK。在 Linux 下，默认重试次数为 5 次，重试的间隔时间从 1s 开始每次都翻售，5 次的重试时间间隔为 1s, 2s, 4s, 8s, 16s，总共 31s，第 5 次发出后还要等 32s 都知道第 5 次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 -1 = 63s，TCP 才会把断开这个连接。</li>
<li><strong>关于 SYN Flood 攻击</strong>。一些恶意的人就为此制造了 SYN Flood 攻击——给服务器发了一个 SYN 后，就下线了，于是服务器需要默认等 63s 才会断开连接，这样，攻击者就可以把服务器的 syn 连接的队列耗尽，让正常的连接请求不能处理。于是，Linux 下给了一个叫<strong>tcp_syncookies</strong>的参数来应对这个事——当 SYN 队列满了后，TCP 会通过源地址端口、目标地址端口和时间戳打造出一个特别的 Sequence Number 发回去（又叫 cookie），如果是攻击者则不会有响应，如果是正常连接，则会把这个 SYN Cookie 发回来，然后服务端可以通过 cookie 建连接（即使你不在 SYN 队列中）。请注意，<strong>请先千万别用 tcp_syncookies 来处理正常的大负载的连接的情况</strong>。因为，synccookies 是妥协版的 TCP 协议，并不严谨。对于正常的请求，你应该调整三个 TCP 参数可供你选择，第一个是：tcp_synack_retries 可以用他来减少重试次数；第二个是：tcp_max_syn_backlog，可以增大 SYN 连接数；第三个是：tcp_abort_on_overflow 处理不过来干脆就直接拒绝连接了。</li>
<li><strong>关于 ISN 的初始化</strong>。ISN 是不能 hard code 的，不然会出问题的——比如：如果连接建好后始终用 1 来做 ISN，如果 client 发了 30 个 segment 过去，但是网络断了，于是 client 重连，又用了 1 做 ISN，但是之前连接的那些包到了，于是就被当成了新连接的包，此时，client 的 Sequence Number 可能是 3，而 Server 端认为 client 端的这个号是 30 了。全乱了。<a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc793">RFC793</a>中说，ISN 会和一个假的时钟绑在一起，这个时钟会在每 4 微秒对 ISN 做加一操作，直到超过 2^32，又从 0 开始。这样，一个 ISN 的周期大约是 4.55 个小时。因为，我们假设我们的 TCP Segment 在网络上的存活时间不会超过 Maximum Segment Lifetime（缩写为 MSL – <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Maximum_Segment_Lifetime">Wikipedia 语条</a>），所以，只要 MSL 的值小于 4.55 小时，那么，我们就不会重用到 ISN。</li>
<li><strong>关于 MSL 和  TIME_WAIT</strong>。通过上面的 ISN 的描述，相信你也知道 MSL 是怎么来的了。我们注意到，在 TCP 的状态图中，从 TIME_WAIT 状态到 CLOSED 状态，有一个超时设置，这个超时设置是 2*MSL（<a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc793">RFC793</a>定义了 MSL 为 2 分钟，Linux 设置成了 30s）为什么要这有 TIME_WAIT？为什么不直接给转成 CLOSED 状态呢？主要有两个原因：1）TIME_WAIT 确保有足够的时间让对端收到了 ACK，如果被动关闭的那方没有收到 Ack，就会触发被动端重发 Fin，一来一去正好 2 个 MSL，2）有足够的时间让这个连接不会跟后面的连接混在一起（你要知道，有些自做主张的路由器会缓存 IP 数据包，如果连接被重用了，那么这些延迟收到的包就有可能会跟新连接混在一起）。你可以看看这篇文章《<a target="_blank" rel="noopener" href="http://www.serverframework.com/asynchronousevents/2011/01/time-wait-and-its-design-implications-for-protocols-and-scalable-servers.html">TIME_WAIT and its design implications for protocols and scalable client server systems</a>》</li>
<li><strong>关于 TIME_WAIT 数量太多</strong>。从上面的描述我们可以知道，TIME_WAIT 是个很重要的状态，但是如果在大并发的短链接下，TIME_WAIT 就会太多，这也会消耗很多系统资源。只要搜一下，你就会发现，十有八九的处理方式都是教你设置两个参数，一个叫<strong>tcp_tw_reuse</strong>，另一个叫<strong>tcp_tw_recycle</strong>的参数，这两个参数默认值都是被关闭的，后者 recyle 比前者 resue 更为激进，resue 要温柔一些。另外，如果使用 tcp_tw_reuse，必需设置 tcp_timestamps=1，否则无效。这里，你一定要注意，<strong>打开这两个参数会有比较大的坑——可能会让 TCP 连接出一些诡异的问题</strong>（因为如上述一样，如果不等待超时重用连接的话，新的连接可能会建不上。正如<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt">官方文档</a>上说的一样“<strong>It should not be changed without advice/request of technical experts</strong>”）。<ul>
<li><strong>关于 tcp_tw_reuse</strong>。官方文档上说 tcp_tw_reuse 加上 tcp_timestamps（又叫 PAWS, for Protection Against Wrapped Sequence Numbers）可以保证协议的角度上的安全，但是你需要 tcp_timestamps 在两边都被打开（你可以读一下<a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/ident?i=tcp_twsk_unique">tcp_twsk_unique</a>的源码）。我个人估计还是有一些场景会有问题。</li>
<li><strong>关于 tcp_tw_recycle</strong>。如果是 tcp_tw_recycle 被打开了话，会假设对端开启了 tcp_timestamps，然后会去比较时间戳，如果时间戳变大了，就可以重用。但是，如果对端是一个 NAT 网络的话（如：一个公司只用一个 IP 出公网）或是对端的 IP 被另一台重用了，这个事就复杂了。建链接的 SYN 可能就被直接丢掉了（你可能会看到 connection time out 的错误）（如果你想观摩一下 Linux 的内核代码，请参看源码<a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/ident?i=tcp_timewait_state_process">tcp_timewait_state_process</a>）。</li>
<li><strong>关于 tcp_max_tw_buckets</strong>。这个是控制并发的 TIME_WAIT 的数量，默认值是 180000，如果超限，那么，系统会把多的给 destory 掉，然后在日志里打一个警告（如：time wait bucket table overflow），官网文档说这个参数是用来对抗 DDoS 攻击的。也说的默认值 180000 并不小。这个还是需要根据实际情况考虑。</li>
</ul>
</li>
</ul>
<p><strong>Again，使用 tcp_tw_reuse 和 tcp_tw_recycle 来解决 TIME_WAIT 的问题是非常非常危险的，因为这两个参数违反了 TCP 协议（</strong><a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc1122">RFC 1122</a>**） **<br>其实，TIME_WAIT 表示的是你主动断连接，所以，这就是所谓的“不作死不会死”。试想，如果让对端断连接，那么这个破问题就是对方的了，呵呵。另外，如果你的服务器是于 HTTP 服务器，那么设置一个<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/HTTP_persistent_connection">HTTP 的 KeepAlive</a>有多重要（浏览器会重用一个 TCP 连接来处理多个 HTTP 请求），然后让客户端去断链接（你要小心，浏览器可能会非常贪婪，他们不到万不得已不会主动断连接）。</p>
<h1 id="数据传输中的-Sequence-Number"><a href="#数据传输中的-Sequence-Number" class="headerlink" title="数据传输中的 Sequence Number"></a>数据传输中的 Sequence Number</h1><p>下图是我从 Wireshark 中截了个我在访问 coolshell.cn 时的有数据传输的图给你看一下，SeqNum 是怎么变的。（使用 Wireshark 菜单中的 Statistics -&gt;Flow Graph… ）<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619360436840-9ad57394-22a9-4ea3-b7cb-3e1f3c4b2288.jpeg#clientId=ud05b6d37-a831-4&from=paste&height=181&id=u961b086c&margin=%5Bobject%20Object%5D&originHeight=361&originWidth=381&originalType=url&status=done&style=none&taskId=ufa11b3ce-ee94-4178-ba9a-f7fc169d625&width=190.5"><br>你可以看到，<strong>SeqNum 的增加是和传输的字节数相关的</strong>。上图中，三次握手后，来了两个 Len:1440 的包，而第二个包的 SeqNum 就成了 1441。然后第一个 ACK 回的是 1441，表示第一个 1440 收到了。<br><strong>注意</strong>：如果你用 Wireshark 抓包程序看 3 次握手，你会发现 SeqNum 总是为 0，不是这样的，Wireshark 为了显示更友好，使用了 Relative SeqNum——相对序号，你只要在右键菜单中的 protocol preference 中取消掉就可以看到“Absolute SeqNum”了</p>
<h1 id="TCP-重传机制"><a href="#TCP-重传机制" class="headerlink" title="TCP 重传机制"></a>TCP 重传机制</h1><p>TCP 要保证所有的数据包都可以到达，所以，必需要有重传机制。<br>注意，接收端给发送端的 Ack 确认只会确认最后一个连续的包，比如，发送端发了 1,2,3,4,5 一共五份数据，接收端收到了 1，2，于是回 ack 3，然后收到了 4（注意此时 3 没收到），此时的 TCP 会怎么办？我们要知道，因为正如前面所说的，<strong>SeqNum 和 Ack 是以字节数为单位，所以 ack 的时候，不能跳着确认，只能确认最大的连续收到的包</strong>，不然，发送端就以为之前的都收到了。</p>
<h2 id="超时重传机制"><a href="#超时重传机制" class="headerlink" title="超时重传机制"></a>超时重传机制</h2><p>一种是不回 ack，死等 3，当发送方发现收不到 3 的 ack 超时后，会重传 3。一旦接收方收到 3 后，会 ack 回 4——意味着 3 和 4 都收到了。<br>但是，这种方式会有比较严重的问题，那就是因为要死等 3，所以会导致 4 和 5 即便已经收到了，而发送方也完全不知道发生了什么事，因为没有收到 Ack，所以，发送方可能会悲观地认为也丢了，所以有可能也会导致 4 和 5 的重传。<br>对此有两种选择：</p>
<ul>
<li>一种是仅重传 timeout 的包。也就是第 3 份数据。</li>
<li>另一种是重传 timeout 后所有的数据，也就是第 3，4，5 这三份数据。</li>
</ul>
<p>这两种方式有好也有不好。第一种会节省带宽，但是慢，第二种会快一点，但是会浪费带宽，也可能会有无用功。但总体来说都不好。因为都在等 timeout，timeout 可能会很长（在下篇会说 TCP 是怎么动态地计算出 timeout 的）</p>
<h2 id="快速重传机制"><a href="#快速重传机制" class="headerlink" title="快速重传机制"></a>快速重传机制</h2><p>于是，TCP 引入了一种叫<strong>Fast Retransmit</strong>的算法，<strong>不以时间驱动，而以数据驱动重传</strong>。也就是说，如果，包没有连续到达，就 ack 最后那个可能被丢了的包，如果发送方连续收到 3 次相同的 ack，就重传。Fast Retransmit 的好处是不用等 timeout 了再重传。<br>比如：如果发送方发出了 1，2，3，4，5 份数据，第一份先到送了，于是就 ack 回 2，结果 2 因为某些原因没收到，3 到达了，于是还是 ack 回 2，后面的 4 和 5 都到了，但是还是 ack 回 2，因为 2 还是没有收到，于是发送端收到了三个 ack=2 的确认，知道了 2 还没有到，于是就马上重转 2。然后，接收端收到了 2，此时因为 3，4，5 都收到了，于是 ack 回 6。示意图如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619360436853-3da25777-c070-4722-8c42-e3c5fc36707b.png#clientId=ud05b6d37-a831-4&from=paste&height=291&id=u83d95bef&margin=%5Bobject%20Object%5D&originHeight=291&originWidth=450&originalType=url&status=done&style=none&taskId=u246727c5-356f-42de-8b6a-e79c6b1156f&width=450"><br>Fast Retransmit 只解决了一个问题，就是 timeout 的问题，它依然面临一个艰难的选择，就是，是重传之前的一个还是重传所有的问题。对于上面的示例来说，是重传#2 呢还是重传#2，#3，#4，#5 呢？因为发送端并不清楚这连续的 3 个 ack(2)是谁传回来的？也许发送端发了 20 份数据，是#6，#10，#20 传来的呢。这样，发送端很有可能要重传从 2 到 20 的这堆数据（这就是某些 TCP 的实际的实现）。可见，这是一把双刃剑。</p>
<h2 id="SACK-方法"><a href="#SACK-方法" class="headerlink" title="SACK 方法"></a>SACK 方法</h2><p>另外一种更好的方式叫：<strong>Selective Acknowledgment (SACK)<strong>（参看<a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc2018">RFC 2018</a>），这种方式需要在 TCP 头里加一个 SACK 的东西，ACK 还是 Fast Retransmit 的 ACK，SACK 则是汇报收到的数据碎版。参看下图：<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619360436992-f9514dc3-2ff5-4739-b8b3-abeca5fcf8d9.jpeg#clientId=ud05b6d37-a831-4&from=paste&height=431&id=u3b552a87&margin=%5Bobject%20Object%5D&originHeight=577&originWidth=1024&originalType=url&status=done&style=none&taskId=ud770b3d1-7779-4030-932e-452d804ed7c&width=765"><br>这样，在发送端就可以根据回传的 SACK 来知道哪些数据到了，哪些没有到。于是就优化了 Fast Retransmit 的算法。当然，这个协议需要两边都支持。在 Linux 下，可以通过</strong>tcp_sack</strong>参数打开这个功能（Linux 2.4 后默认打开）。<br>这里还需要注意一个问题——<strong>接收方 Reneging，所谓 Reneging 的意思就是接收方有权把已经报给发送端 SACK 里的数据给丢了</strong>。这样干是不被鼓励的，因为这个事会把问题复杂化了，但是，接收方这么做可能会有些极端情况，比如要把内存给别的更重要的东西。<strong>所以，发送方也不能完全依赖 SACK，还是要依赖 ACK，并维护 Time-Out，如果后续的 ACK 没有增长，那么还是要把 SACK 的东西重传，另外，接收端这边永远不能把 SACK 的包标记为 Ack。</strong><br>注意：SACK 会消费发送方的资源，试想，如果一个攻击者给数据发送方发一堆 SACK 的选项，这会导致发送方开始要重传甚至遍历已经发出的数据，这会消耗很多发送端的资源。详细的东西请参看《<a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/linux/l-tcp-sack/">TCP SACK 的性能权衡</a>》</p>
<h2 id="Duplicate-SACK-–-重复收到数据的问题"><a href="#Duplicate-SACK-–-重复收到数据的问题" class="headerlink" title="Duplicate SACK – 重复收到数据的问题"></a>Duplicate SACK – 重复收到数据的问题</h2><p>Duplicate SACK 又称 D-SACK，<strong>其主要使用了 SACK 来告诉发送方有哪些数据被重复接收了</strong>。<a target="_blank" rel="noopener" href="http://www.ietf.org/rfc/rfc2883.txt">RFC-2883</a>里有详细描述和示例。下面举几个例子（来源于<a target="_blank" rel="noopener" href="http://www.ietf.org/rfc/rfc2883.txt">RFC-2883</a>）<br>D-SACK 使用了 SACK 的第一个段来做标志，</p>
<ul>
<li>如果 SACK 的第一个段的范围被 ACK 所覆盖，那么就是 D-SACK</li>
<li>如果 SACK 的第一个段的范围被 SACK 的第二个段覆盖，那么就是 D-SACK</li>
</ul>
<p><strong>示例一：ACK 丢包</strong><br>下面的示例中，丢了两个 ACK，所以，发送端重传了第一个数据包（3000-3499），于是接收端发现重复收到，于是回了一个 SACK=3000-3500，因为 ACK 都到了 4000 意味着收到了 4000 之前的所有数据，所以这个 SACK 就是 D-SACK——旨在告诉发送端我收到了重复的数据，而且我们的发送端还知道，数据包没有丢，丢的是 ACK 包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Transmitted  Received    ACK Sent</span><br><span class="line">Segment      Segment     (Including SACK Blocks)</span><br><span class="line"></span><br><span class="line">3000-34993000-34993500 (ACK dropped)</span><br><span class="line">3500-39993500-39994000 (ACK dropped)</span><br><span class="line">3000-34993000-34994000, SACK&#x3D;3000-3500</span><br><span class="line">                                        ---------</span><br></pre></td></tr></table></figure>

<p>**  示例二，网络延误**<br>下面的示例中，网络包（1000-1499）被网络给延误了，导致发送方没有收到 ACK，而后面到达的三个包触发了“Fast Retransmit 算法”，所以重传，但重传时，被延误的包又到了，所以，回了一个 SACK=1000-1500，因为 ACK 已到了 3000，所以，这个 SACK 是 D-SACK——标识收到了重复的包。<br>这个案例下，发送端知道之前因为“Fast Retransmit 算法”触发的重传不是因为发出去的包丢了，也不是因为回应的 ACK 包丢了，而是因为网络延时了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Transmitted    Received    ACK Sent</span><br><span class="line">Segment        Segment     (Including SACK Blocks)</span><br><span class="line"></span><br><span class="line">500-999500-9991000</span><br><span class="line">1000-1499      (delayed)</span><br><span class="line">1500-19991500-19991000, SACK&#x3D;1500-2000</span><br><span class="line">2000-24992000-24991000, SACK&#x3D;1500-2500</span><br><span class="line">2500-29992500-29991000, SACK&#x3D;1500-3000</span><br><span class="line">1000-14991000-14993000</span><br><span class="line">1000-14993000, SACK&#x3D;1000-1500</span><br><span class="line">                                          ---------</span><br></pre></td></tr></table></figure>

<p>可见，引入了 D-SACK，有这么几个好处：<br>1）可以让发送方知道，是发出去的包丢了，还是回来的 ACK 包丢了。<br>2）是不是自己的 timeout 太小了，导致重传。<br>3）网络上出现了先发的包后到的情况（又称 reordering）<br>4）网络上是不是把我的数据包给复制了。<br><strong>知道这些东西可以很好得帮助 TCP 了解网络情况，从而可以更好的做网络上的流控</strong>。<br>Linux 下的 tcp_dsack 参数用于开启这个功能（Linux 2.4 后默认打开）<br>好了，上篇就到这里结束了。如果你觉得我写得还比较浅显易懂，那么，欢迎移步看下篇《<a target="_blank" rel="noopener" href="https://coolshell.cn/articles/11609.html">TCP 的那些事（下）</a>》<br><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/11609.html">TCP 的那些事儿（下）&gt;&gt;&gt;</a><br>（上篇完）<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619360437335-05195b27-62c3-44dd-b137-209d4380410b.jpeg#clientId=ud05b6d37-a831-4&from=paste&height=129&id=u0e081c04&margin=%5Bobject%20Object%5D&originHeight=258&originWidth=258&originalType=url&status=done&style=none&taskId=ue1002983-687d-4442-bb7c-9692e8f2dc8&width=129"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619360438065-ea6f45eb-52cd-490e-a2a0-ffdcb1957a54.jpeg#clientId=ud05b6d37-a831-4&from=paste&height=129&id=u6dbf991e&margin=%5Bobject%20Object%5D&originHeight=258&originWidth=258&originalType=url&status=done&style=none&taskId=ufc420364-0496-4029-82f4-e8800284f91&width=129">关注 CoolShell 微信公众账号和微信小程序<br><strong>（转载本站文章请注明作者和出处</strong><a target="_blank" rel="noopener" href="https://coolshell.cn/">酷 壳 – CoolShell</a><strong>，请勿用于任何商业用途）</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/25/yuque/websocket%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%8A%A5%E6%96%87%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/25/yuque/websocket%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%8A%A5%E6%96%87%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">websocket协议详解及报文分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-25 22:01:29" itemprop="dateCreated datePublished" datetime="2021-04-25T22:01:29+08:00">2021-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 18:36:14" itemprop="dateModified" datetime="2021-04-29T18:36:14+08:00">2021-04-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>#websocket 协议详解及报文分析</p>
<h1 id="websocket-协议详解及报文分析"><a href="#websocket-协议详解及报文分析" class="headerlink" title="websocket 协议详解及报文分析"></a>websocket 协议详解及报文分析</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相较于 HTTP 协议，HTTP 协议有一个的缺陷为：通信只能由客户端发起。在一些场景下，这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用轮询：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。</p>
<p>轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。</p>
<h2 id="websocket-协议概述"><a href="#websocket-协议概述" class="headerlink" title="websocket 协议概述"></a>websocket 协议概述</h2><p>Webscoket 是 Web 浏览器和服务器之间的一种全双工通信协议，其中 WebSocket 协议由 IETF 定为标准，WebSocket API 由 W3C 定为标准。一旦 Web 客户端与服务器建立起连接，之后的全部数据通信都通过这个连接进行。通信过程中，可互相发送 JSON、XML、HTML 或图片等任意格式的数据。 WS（WebSocket）与 HTTP 协议相比，</p>
<p><strong>相同点主要有：</strong></p>
<ul>
<li>都是基于 TCP 的应用层协议；- 都使用 Request/Response 模型进行连接的建立；- 在连接的建立过程中对错误的处理方式相同，在这个阶段 WS 可能返回和 HTTP 相同的返回码；- 都可以在网络中传输数据。</li>
</ul>
<p><strong>不同之处在于：</strong></p>
<ul>
<li>WS 使用 HTTP 来建立连接，但是定义了一系列新的 header 域，这些域在 HTTP 中并不会使用；- WS 的连接不能通过中间人来转发，它必须是一个直接连接；- WS 连接建立之后，通信双方都可以在任何时刻向另一方发送数据；- WS 连接建立之后，数据的传输使用帧来传递，不再需要 Request 消息；- WS 的数据帧有序。</li>
</ul>
<h2 id="websocket-通信过程及对应报文分析"><a href="#websocket-通信过程及对应报文分析" class="headerlink" title="websocket 通信过程及对应报文分析"></a>websocket 通信过程及对应报文分析</h2><p>WS 整个通信过程如下图所示： <img src="https://img-blog.csdnimg.cn/20200527233222508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xMODQ1ODc2NDI1,size_16,color_FFFFFF,t_70#alt="> <img src="https://img-blog.csdnimg.cn/20200527233246458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xMODQ1ODc2NDI1,size_16,color_FFFFFF,t_70#alt="></p>
<p>websocket 是基于 TCP 的一个应用协议，与 HTTP 协议的关联之处在于 websocket 的握手数据被 HTTP 服务器当作 HTTP 包来处理，主要通过 Update request HTTP 包建立起连接，之后的通信全部使用 websocket 自己的协议。</p>
<p><strong>请求：</strong>TCP 连接建立后，客户端发送 websocket 的握手请求，请求报文头部如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;uin&#x3D;xxxxxxxx&amp;app&#x3D;xxxxxxxxx&amp;token&#x3D;XXXXXXXXXXXX HTTP&#x2F;1.1</span><br><span class="line">Host: server.example.cn:443</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_2) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;81.0.4044.138 Safari&#x2F;537.36</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9</span><br><span class="line">Cookie: user_id&#x3D;XXXXX</span><br><span class="line">Sec-WebSocket-Key: 1&#x2F;2hTi&#x2F;+eNURiekpNI4k5Q&#x3D;&#x3D;</span><br><span class="line">Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits</span><br><span class="line">Sec-WebSocket-Protocol: binary, base64</span><br></pre></td></tr></table></figure>

<ul>
<li>第一行为为请求的方法，类型必须为 GET，协议版本号必须大于 1.1- Upgrade 字段必须包含，值为 websocket- Connection 字段必须包含，值为 Upgrade- Sec-WebSocket-Key 字段必须包含 ，记录着握手过程中必不可少的键值。- Sec-WebSocket-Protocol 字段必须包含 ，记录着使用的子协议- Origin（请求头）：Origin 用来指明请求的来源，Origin 头部主要用于保护 Websocket 服务器免受非授权的跨域脚本调用 Websocket API 的请求。也就是不想没被授权的跨域访问与服务器建立连接，服务器可以通过这个字段来判断来源的域并有选择的拒绝。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200527233303721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xMODQ1ODc2NDI1,size_16,color_FFFFFF,t_70#alt="></p>
<p><strong>响应：</strong>服务器接收到请求后，返回状态码为 101 Switching Protocols 的响应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Server: WebSockify Python&#x2F;2.6.6</span><br><span class="line">Date: Wed, 27 May 2020 03:03:21 GMT</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: hXXXXXXXXXXXXXXxGmM&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: binary</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200527233326813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xMODQ1ODc2NDI1,size_16,color_FFFFFF,t_70#alt="></p>
<p>Sec-WebSocket-Accept 字段是由握手请求中的 Sec-WebSocket-Key 字段生层的。</p>
<p>握手成功后，通信不再使用 HTTP 协议，而采用 WebSocket 独立的数据帧。如下图所示，为协议帧格式：</p>
<p><img src="https://img-blog.csdnimg.cn/20200527233345809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xMODQ1ODc2NDI1,size_16,color_FFFFFF,t_70#alt="></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FIN，指明Frame是否是一个Message里最后Frame（之前说过一个Message可能又多个Frame组成）；1bit，是否为信息的最后一帧</span><br><span class="line">RSV1-3，默认是0 (必须是0)，除非有扩展定义了非零值的意义。</span><br><span class="line">Opcode，这个比较重要，有如下取值是被协议定义的</span><br><span class="line">				0x00 denotes a continuation frame</span><br><span class="line">				0x01 表示一个text frame</span><br><span class="line">				0x02 表示一个binary frame</span><br><span class="line">				0x03 ~~ 0x07 are reserved for further non-control frames,为将来的非控制消息片段保留测操作码</span><br><span class="line">				0x08 表示连接关闭</span><br><span class="line">				0x09 表示 ping (心跳检测相关)</span><br><span class="line">				0x0a 表示 pong (心跳检测相关)</span><br><span class="line">				0x0b ~~ 0x0f are reserved for further control frames,为将来的控制消息片段保留的操作码</span><br><span class="line">Mask，这个是指明“payload data”是否被计算掩码。这个和后面的Masking-key有关，如果设置为1,掩码键必须放在masking-key区域，客户端发送给服务端的所有消息，此位的值都是1；</span><br><span class="line">Payload len，数据的长度，</span><br><span class="line">Masking-key，0或者4bit，只有当MASK设置为1时才有效。，给一个Websocket中掩码的意义</span><br><span class="line">Payload data，帧真正要发送的数据，可以是任意长度，但尽管理论上帧的大小没有限制，但发送的数据不能太大，否则会导致无法高效利用网络带宽，正如上面所说Websocket提供分片。</span><br><span class="line">Extension data：扩展数据，如果客户端和服务端没有特殊的约定，那么扩展数据长度始终为0</span><br><span class="line">Application data：应用数据，</span><br></pre></td></tr></table></figure>

<p>websocket 报文细节，这里由于 client 和 server 端的 ip 都是 127.0.0.1 ：</p>
<p><img src="https://img-blog.csdnimg.cn/20200527233405188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xMODQ1ODc2NDI1,size_16,color_FFFFFF,t_70#alt="></p>
<h2 id="nginx-支持-websocket-配置"><a href="#nginx-支持-websocket-配置" class="headerlink" title="nginx 支持 websocket 配置"></a>nginx 支持 websocket 配置</h2><p>由于 http 请求 涉及 反向代理 所以就涉及 nginx 配置需要支持 websocket 需要做一些特殊的配置；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 配置Nginx支持webSocket开始</span><br><span class="line">proxy_set_header Host $http_host;</span><br><span class="line">proxy_http_version 1.1;</span><br><span class="line">proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">proxy_set_header Connection &quot;upgrade&quot;;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200527233424850.png#alt="></p>
<p>其他通过代码模拟 websocket 的代码可以查阅其他博客内容，这里就不赘述；</p>
<p><a target="_blank" rel="noopener" href="https://www.tutorialspoint.com/websockets/websockets_send_receive_messages.htm">https://www.tutorialspoint.com/websockets/websockets_send_receive_messages.htm</a></p>
<p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">http://www.ruanyifeng.com/blog/2017/05/websocket.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/25/yuque/HTTP3.0%E5%92%8CQUIC%E5%8D%8F%E8%AE%AE%E9%82%A3%E4%BA%9B%E4%BA%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/25/yuque/HTTP3.0%E5%92%8CQUIC%E5%8D%8F%E8%AE%AE%E9%82%A3%E4%BA%9B%E4%BA%8B/" class="post-title-link" itemprop="url">HTTP3.0和QUIC协议那些事</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-25 17:04:07" itemprop="dateCreated datePublished" datetime="2021-04-25T17:04:07+08:00">2021-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 18:36:14" itemprop="dateModified" datetime="2021-04-29T18:36:14+08:00">2021-04-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>#HTTP3.0 和 QUIC 协议那些事</p>
<h1 id="HTTP3-0-和-QUIC-协议那些事"><a href="#HTTP3-0-和-QUIC-协议那些事" class="headerlink" title="HTTP3.0 和 QUIC 协议那些事"></a>HTTP3.0 和 QUIC 协议那些事</h1><ul>
<li>写在前面<blockquote>
<ul>
<li>如果你的 App，在不需要任何修改的情况下就能提升 15% 以上的访问速度。特别是弱网络的时候能够提升 20% 以上的访问速度。</li>
<li>如果你的 App，在频繁切换 4G 和 WIFI 网络的情况下，不会断线，不需要重连，用户无任何感知。如果你的 App，既需要 TLS 的安全，也想实现 HTTP2 多路复用的强大。</li>
<li>如果你刚刚才听说 HTTP2 是下一代互联网协议，如果你刚刚才关注到 TLS1.3 是一个革命性具有里程碑意义的协议，但是这两个协议却一直在被另一个更新兴的协议所影响和挑战。</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="一、HTTP2-0-和-HTTP3-0"><a href="#一、HTTP2-0-和-HTTP3-0" class="headerlink" title="一、HTTP2.0 和 HTTP3.0"></a>一、HTTP2.0 和 HTTP3.0</h2><blockquote>
<p>科技永不止步 -   我们都知道互联网中业务是不断迭代前进的，像 HTTP 这种重要的网络协议也是如此，新版本是对旧版本的扬弃。</p>
</blockquote>
<h3 id="1-1-HTTP2-0-和-TCP-的爱恨纠葛"><a href="#1-1-HTTP2-0-和-TCP-的爱恨纠葛" class="headerlink" title="1.1 HTTP2.0 和 TCP 的爱恨纠葛"></a>1.1 HTTP2.0 和 TCP 的爱恨纠葛</h3><p><code>**HTTP2.0**</code><strong>是 2015 年推出的，还是比较年轻的，</strong><code>**其重要的二进制分帧协议、多路复用、头部压缩、服务端推送等**</code><strong>重要优化使 HTTP 协议真正上了一个新台阶。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200922123003302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=BHt2w&originHeight=962&originWidth=828&originalType=binary&status=done&style=none"></p>
<blockquote>
<p>像谷歌这种重要的公司并没有满足于此，而且想继续提升 HTTP 的性能，花最少的时间和资源获取极致体验。<br>那么肯定要问 HTTP2.0 虽然性能已经不错了，还有什么不足吗？ <code>建立连接时间长(本质上是TCP的问题) ,队头阻塞问题</code> &gt; <code>移动互联网领域表现不佳(弱网环境</code>) …</p>
</blockquote>
<ul>
<li><strong>熟悉 HTTP2.0 协议的同学应该知道，这些缺点基本都是由于 TCP 协议引起的，水能载舟亦能覆舟，其实 TCP 也很无辜呀！</strong></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200922123253603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=tAooz&originHeight=748&originWidth=1080&originalType=binary&status=done&style=none"></p>
<ul>
<li><code>**在我们眼里，TCP是面向连接、可靠的传输层协议，当前几乎所有重要的协议和应用都是基于TCP来实现的。**</code></li>
<li><strong>网络环境的改变速度很快，但是 TCP 协议相对缓慢，正是这种矛盾促使谷歌做出了一个看似出乎意料的决定-</strong><code>**基于UDP来开发新一代HTTP协议**</code><strong>。</strong></li>
</ul>
<h3 id="1-2-谷歌为什么选择-UDP"><a href="#1-2-谷歌为什么选择-UDP" class="headerlink" title="1.2 谷歌为什么选择 UDP"></a>1.2 谷歌为什么选择 UDP</h3><p>上面提到，谷歌选择 UDP 是看似出乎意料的，仔细想一想其实很有道理。</p>
<p>我们单纯地看看 TCP 协议的不足和 UDP 的一些优点：</p>
<ul>
<li>基于 TCP 开发的设备和协议非常多，兼容困难</li>
<li>TCP 协议栈是 Linux 内部的重要部分，修改和升级成本很大</li>
<li>UDP 本身是无连接的、没有建链和拆链成本</li>
<li>UDP 的数据包无队头阻塞问题</li>
<li>UDP 改造成本小</li>
</ul>
<p>从上面的对比可以知道，<code>谷歌要想从TCP上进行改造升级绝非易事，但是UDP虽然没有TCP为了保证可靠连接而引发的问题，但是UDP本身不可靠，又不能直接用</code></p>
<p><img src="https://img-blog.csdnimg.cn/20200922123855517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=tDBTF&originHeight=378&originWidth=548&originalType=binary&status=done&style=none"></p>
<blockquote>
<p>综合而知，谷歌决定在 UDP 基础上改造一个具备 TCP 协议优点的新协议也就顺理成章了，这个新协议就是 QUIC 协议。</p>
</blockquote>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>1.3 QUIC 协议和 HTTP3.0</p>
<p>QUIC 其实是 Quick UDP Internet Connections 的缩写，直译为快速 UDP 互联网连接。</p>
<p><img src="https://img-blog.csdnimg.cn/20200922124004308.png#pic_center#id=NQ3nM&originHeight=133&originWidth=308&originalType=binary&status=done&style=none"></p>
<p>我们来看看维基百科对于 QUIC 协议的一些介绍：</p>
<blockquote>
<p>QUIC 协议最初由 Google 的 Jim Roskind 设计，实施并于 2012 年部署，在 2013 年随着实验的扩大而公开宣布，并向 IETF 进行了描述。<br>QUIC 提高了当前正在使用 TCP 的面向连接的 Web 应用程序的性能。它在两个端点之间使用用户数据报协议（UDP）建立多个复用连接来实现此目的。<br>QUIC 的次要目标包括减少连接和传输延迟，在每个方向进行带宽估计以避免拥塞。它还将拥塞控制算法移动到用户空间，而不是内核空间，此外使用前向纠错（FEC）进行扩展，以在出现错误时进一步提高性能。</p>
</blockquote>
<ul>
<li><strong>HTTP3.0 又称为 HTTP Over QUIC，其弃用 TCP 协议，改为使用基于 UDP 协议的 QUIC 协议来实现。</strong> <img src="https://img-blog.csdnimg.cn/20200922124129106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#height=306&id=lfjni&originHeight=306&originWidth=357&originalType=binary&status=done&style=none&width=357"></li>
</ul>
<h2 id="二、QUIC-详解"><a href="#二、QUIC-详解" class="headerlink" title="二、QUIC 详解"></a>二、QUIC 详解</h2><p>择其善者而从之，其不善者而改之。</p>
<ul>
<li><code>**HTTP3.0既然选择了QUIC协议，也就意味着HTTP3.0基本继承了HTTP2.0的强大功能，并且进一步解决了HTTP2.0存在的一些问题，同时必然引入了新的问题**</code></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200922124303607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=nq4cr&originHeight=305&originWidth=778&originalType=binary&status=done&style=none"> QUIC 协议必须要实现 HTTP2.0 在 TCP 协议上的重要功能，同时解决遗留问题，我们来看看 QUIC 是如何实现的。</p>
<h3 id="2-1-队头阻塞问题"><a href="#2-1-队头阻塞问题" class="headerlink" title="2.1 队头阻塞问题"></a>2.1 队头阻塞问题</h3><ul>
<li><p><code>**队头阻塞 Head-of-line blocking（缩写为HOL blocking）是计算机网络中是一种性能受限的现象**</code><strong>，通俗来说就是：</strong><code>**一个数据包影响了一堆数据包，它不来大家都走不了**</code><strong>。</strong></p>
</li>
<li><p><code>队头阻塞问题可能存在于HTTP层和TCP层，在HTTP1.x时两个层次都存在该问题</code>。 <img src="https://img-blog.csdnimg.cn/20200922124452630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=oAWYE&originHeight=444&originWidth=812&originalType=binary&status=done&style=none"></p>
</li>
<li><p><code>**HTTP2.0协议的多路复用机制解决了HTTP层的队头阻塞问题，但是在TCP层仍然存在队头阻塞问题。**</code></p>
</li>
<li><p><code>**TCP协议在收到数据包之后，这部分数据可能是乱序到达的，但是TCP必须将所有数据收集排序整合后给上层使用，如果其中某个包丢失了，就必须等待重传，从而出现某个丢包数据阻塞整个连接的数据使用。**</code></p>
</li>
<li><p>多路复用是 HTTP2 最强大的特性 ，能够将多条请求在一条 TCP 连接上同时发出去。但也恶化了 TCP 的一个问题，队头阻塞 ，如下图示： <img src="https://img-blog.csdnimg.cn/20200922135620387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=ptWhT&originHeight=377&originWidth=1011&originalType=binary&status=done&style=none"></p>
</li>
<li><p><strong>HTTP2 在一个 TCP 连接上同时发送 4 个 Stream。其中 Stream1 已经正确到达，并被应用层读取</strong>。</p>
</li>
<li><p><code>但是 Stream2 的第三个 tcp segment 丢失了，TCP 为了保证数据的可靠性，需要发送端重传第 3 个 segment 才能通知应用层读取接下去的数据，虽然这个时候 Stream3 和 Stream4 的全部数据已经到达了接收端，但都被阻塞住了</code>。</p>
</li>
<li><p><code>不仅如此，由于 HTTP2 强制使用 TLS，还存在一个 TLS 协议层面的队头阻塞</code> <img src="https://img-blog.csdnimg.cn/20200922135807354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=B4UBy&originHeight=692&originWidth=1080&originalType=binary&status=done&style=none"></p>
</li>
<li><p><strong>QUIC 的多路复用和 HTTP2 类似。</strong><code>**在一条 QUIC 连接上可以并发发送多个 HTTP 请求 (stream)**</code><strong>。但是 QUIC 的多路复用相比 HTTP2 有一个很大的优势</strong>。</p>
</li>
<li><p><code>**QUIC 一个连接上的多个 stream 之间没有依赖。这样假如 stream2 丢了一个 udp packet，也只会影响 stream2 的处理。不会影响 stream2 之前及之后的 stream 的处理**</code><strong>。</strong> -   这也就在很大程度上缓解甚至消除了队头阻塞的影响。</p>
</li>
<li><p><strong>QUIC 协议是基于 UDP 协议实现的，</strong><code>**在一条链接上可以有多个流，流与流之间是互不影响的，当一个流出现丢包影响范围非常小，从而解决队头阻塞**</code><strong>问题</strong></p>
</li>
</ul>
<h3 id="2-2-0RTT-建链"><a href="#2-2-0RTT-建链" class="headerlink" title="2.2 0RTT 建链"></a>2.2 0RTT 建链</h3><ul>
<li><code>**衡量网络建链的常用指标是RTT Round-Trip Time，也就是数据包一来一回的时间消耗。**</code> <img src="https://img-blog.csdnimg.cn/20200922124623833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=AsS3u&originHeight=226&originWidth=372&originalType=binary&status=done&style=none"></li>
<li><code>**RTT包括三部分：往返传播时延、网络设备内排队时延、应用程序数据处理时延。**</code> <img src="https://img-blog.csdnimg.cn/20200922124649743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=hg0Cd&originHeight=239&originWidth=579&originalType=binary&status=done&style=none"></li>
<li><strong>一般来说 HTTPS 协议要建立完整链接包括:TCP 握手和 TLS 握手，总计需要至少 2-3 个 RTT，普通的 HTTP 协议也需要至少 1 个 RTT 才可以完成握手。</strong></li>
<li><strong>然而，</strong><code>**QUIC协议可以实现在第一个包就可以包含有效的应用数据，从而实现0RTT，但这也是有条件**</code><strong>的。</strong> - 0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势。那什么是 0RTT 建连呢？这里面有两层含义。</li>
<li><code>传输层 0RTT 就能建立连接</code></li>
<li><code>加密层 0RTT 就能建立加密连接</code> <img src="https://img-blog.csdnimg.cn/20200922132748609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=oQp0N&originHeight=530&originWidth=1080&originalType=binary&status=done&style=none"></li>
</ul>
<blockquote>
<ul>
<li>比如上图左边是 HTTPS 的一次完全握手的建连过程，需要 3 个 RTT。就算是 Session Resumption，也需要至少 2 个 RTT。</li>
<li>而 QUIC 呢？由于建立在 UDP 的基础上，同时又实现了 0RTT 的安全握手，所以在大部分情况下，只需要 0 个 RTT 就能实现数据发送，在实现前向加密 的基础上，并且 0RTT 的成功率相比 TLS 的 Sesison Ticket 要高很多。</li>
</ul>
</blockquote>
<ul>
<li>简单来说，<code>基于TCP协议和TLS协议的HTTP2.0在真正发送数据包之前需要花费一些时间来完成握手和加密协商，完成之后才可以真正传输业务数据</code>。</li>
<li><strong>但是 QUIC 则第一个数据包就可以发业务数据，从而在连接延时有很大优势，可以节约数百毫秒的时间。</strong></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200922124817379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=pqC6c&originHeight=530&originWidth=748&originalType=binary&status=done&style=none"></p>
<ul>
<li><strong>QUIC 的 0RTT 也是需要条件的，</strong><code>**对于第一次交互的客户端和服务端0RTT也是做不到的**</code><strong>，毕竟双方完全陌生。</strong>- <strong>因此，QUIC 协议可以分为首次连接和非首次连接，两种情况进行讨论。</strong></li>
</ul>
<h4 id="2-2-1-首次连接和非首次连接"><a href="#2-2-1-首次连接和非首次连接" class="headerlink" title="2.2.1 首次连接和非首次连接"></a>2.2.1 首次连接和非首次连接</h4><ul>
<li><code>**使用QUIC协议的客户端和服务端要使用1RTT进行密钥交换，使用的交换算法是DH(Diffie-Hellman)迪菲-赫尔曼算法。**</code></li>
</ul>
<h4 id="2-2-2-首次连接"><a href="#2-2-2-首次连接" class="headerlink" title="2.2.2 首次连接"></a>2.2.2 首次连接</h4><ul>
<li>简单来说一下，<code>**首次连接时客户端和服务端的密钥协商和数据传输过程**</code>，其中涉及了 DH 算法的基本过程： <img src="https://img-blog.csdnimg.cn/20200922125205577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=Vl5eN&originHeight=1020&originWidth=1356&originalType=binary&status=done&style=none"> <img src="https://img-blog.csdnimg.cn/20200922125320566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=kzbFK&originHeight=1030&originWidth=1080&originalType=binary&status=done&style=none"></li>
</ul>
<h4 id="2-2-3-非首次连接"><a href="#2-2-3-非首次连接" class="headerlink" title="2.2.3 非首次连接"></a>2.2.3 非首次连接</h4><ul>
<li><code>**前面提到客户端和服务端首次连接时服务端传递了config包，里面包含了服务端公钥和两个随机数，客户端会将config存储下来，后续再连接时可以直接使用，从而跳过这个1RTT，实现0RTT的业务数据交互**</code><strong>。</strong>- <code>**客户端保存config是有时间期限的，在config失效之后仍然需要进行首次连接时的密钥交换。**</code></li>
</ul>
<h3 id="2-3-前向安全问题"><a href="#2-3-前向安全问题" class="headerlink" title="2.3 前向安全问题"></a>2.3 前向安全问题</h3><p>前向安全是密码学领域的专业术语，看下百度上的解释：</p>
<blockquote>
<ul>
<li><code>前向安全或前向保密Forward Secrecy是密码学中通讯协议的安全属性，指的是长期使用的主密钥泄漏不会导致过去的会话密钥泄漏</code>。</li>
<li><code>前向安全能够保护过去进行的通讯不受密码或密钥在未来暴露的威胁，如果系统具有前向安全性，就可以保证在主密钥泄露时历史通讯的安全，即使系统遭到主动攻击也是如此</code></li>
</ul>
</blockquote>
<p><strong>通俗来说，</strong><code>**前向安全指的是密钥泄漏也不会让之前加密的数据被泄漏，影响的只有当前，对之前的数据无影响**</code><strong>。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200922125908240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=NuSZa&originHeight=232&originWidth=1224&originalType=binary&status=done&style=none"> <img src="https://img-blog.csdnimg.cn/20200922125953787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=ZYRgn&originHeight=722&originWidth=1080&originalType=binary&status=done&style=none"></p>
<h3 id="2-4-前向纠错"><a href="#2-4-前向纠错" class="headerlink" title="2.4 前向纠错"></a>2.4 前向纠错</h3><p>前向纠错是通信领域的术语，看下百科的解释：</p>
<ul>
<li>前向纠错也叫前向纠错码 Forward Error Correction 简称 FEC;<code>是增加数据通讯可信度的方法，在单向通讯信道中，一旦错误被发现，其接收器将无权再请求传输</code>。- FEC 是利用数据进行传输冗余信息的方法，当传输中出现错误，将允许接收器再建数据。</li>
<li>听这段描述就是做校验的，看看 QUIC 协议是如何实现的：</li>
<li><code>**QUIC每发送一组数据就对这组数据进行异或运算，并将结果作为一个FEC包发送出去，接收方收到这一组数据后根据数据包和FEC包即可进行校验和纠错**</code>。</li>
</ul>
<h3 id="2-5-连接迁移"><a href="#2-5-连接迁移" class="headerlink" title="2.5 连接迁移"></a>2.5 连接迁移</h3><p>网络切换几乎无时无刻不在发生。</p>
<ul>
<li><code>TCP协议使用五元组来表示一条唯一的连接，当我们从4G环境切换到wifi环境时，手机的IP地址就会发生变化，这时必须创建新的TCP连接才能继续传输数据</code>。</li>
<li><strong>QUIC 协议基于 UDP 实现摒弃了五元组的概念，使用 64 位的随机数作为连接的 ID，并使用该 ID 表示连接。</strong></li>
<li><code>基于QUIC协议之下，我们在日常wifi和4G切换时，或者不同基站之间切换都不会重连，从而提高业务层的体验。</code></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200922130333415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=SOMdm&originHeight=723&originWidth=1080&originalType=binary&status=done&style=none"></p>
<h3 id="2-6-改进的拥塞控制"><a href="#2-6-改进的拥塞控制" class="headerlink" title="2.6 改进的拥塞控制"></a>2.6 改进的拥塞控制</h3><ul>
<li><code>**TCP 的拥塞控制实际上包含了四个算法：慢启动，拥塞避免，快速重传，快速恢复**</code> -  QUIC 协议当前默认使用了 TCP 协议的 Cubic 拥塞控制算法 ，同时也支持 CubicBytes, Reno, RenoBytes, BBR, PCC 等拥塞控制算法。</li>
<li><code>从拥塞算法本身来看，QUIC 只是按照 TCP 协议重新实现了一遍</code>，那么 QUIC 协议到底改进在哪些方面呢？主要有如下几点：</li>
</ul>
<h4 id="2-6-1-可插拔"><a href="#2-6-1-可插拔" class="headerlink" title="2.6.1 可插拔"></a>2.6.1 可插拔</h4><p>什么叫可插拔呢？<code>就是能够非常灵活地生效，变更和停止</code>,体现在如下方面：</p>
<ul>
<li><code>**应用程序层面就能实现不同的拥塞控制算法，不需要操作系统，不需要内核支持**</code><strong>。这是一个飞跃，因为</strong><code>**传统的 TCP 拥塞控制，必须要端到端的网络协议栈支持，才能实现控制效果**</code><strong>。而内核和操作系统的部署成本非常高，升级周期很长，这在产品快速迭代，网络爆炸式增长的今天，显然有点满足不了需求。</strong></li>
<li><strong>即使是单个应用程序的不同连接也能支持配置不同的拥塞控制。就算是一台服务器，接入的用户网络环境也千差万别，结合大数据及人工智能处理，我们能为各个用户提供不同的但又更加精准更加有效的拥塞控制。比如 BBR 适合，Cubic 适合。</strong></li>
<li><code>**应用程序不需要停机和升级就能实现拥塞控制的变更**</code><strong>，我们在服务端只需要修改一下配置，reload 一下，</strong><code>**完全不需要停止服务就能实现拥塞控制的切换**</code><strong>。STGW 在配置层面进行了优化，我们可以针对不同业务，不同网络制式，甚至不同的 RTT，使用不同的拥塞控制算法。</strong></li>
</ul>
<h4 id="2-6-2-单调递增的-Packet-Number"><a href="#2-6-2-单调递增的-Packet-Number" class="headerlink" title="2.6.2 单调递增的 Packet Number"></a>2.6.2 单调递增的 Packet Number</h4><ul>
<li><code>**TCP 为了保证可靠性，使用了基于字节序号的 Sequence Number 及 Ack 来确认消息的有序到达。**</code></li>
<li><code>**QUIC**</code>** 同样是一个可靠的协议，它**<code>**使用 Packet Number 代替了 TCP 的 sequence number，并且每个 Packet Number 都严格递增**</code><strong>，也就是说</strong><code>**就算 Packet N 丢失了，重传的 Packet N 的 Packet Number 已经不是 N，而是一个比 N 大的值**</code><strong>。</strong></li>
<li><strong>而 TCP 呢，重传 segment 的 sequence number 和原始的 segment 的 Sequence Number 保持不变，也正是由于这个特性，引入了 Tcp 重传的歧义问题</strong></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200922133727910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=eVtip&originHeight=473&originWidth=1080&originalType=binary&status=done&style=none"></p>
<ul>
<li><strong>如上图所示，超时事件 RTO 发生后，</strong><code>**客户端发起重传**</code><strong>，然后接收到了 Ack 数据。</strong><code>**由于序列号一样，这个 Ack 数据到底是原始请求的响应还是重传请求的响应呢？不好判断**</code><strong>。</strong></li>
<li>如果<code>算成原始请求的响应，但实际上是重传请求的响应（上图左），会导致采样 RTT 变大。如果算成重传请求的响应，但实际上是原始请求的响应，又很容易导致采样 RTT 过小</code>。</li>
<li><code>**由于 Quic 重传的 Packet 和原始 Packet 的 Pakcet Number 是严格递增的，所以很容易就解决了这个问题。**</code></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200922133916874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=UF0FI&originHeight=427&originWidth=1080&originalType=binary&status=done&style=none"></p>
<ul>
<li><code>如上图所示，RTO 发生后，根据重传的 Packet Number 就能确定精确的 RTT 计算。如果 Ack 的 Packet Number 是 N+M，就根据重传请求计算采样 RTT。如果 Ack 的 Pakcet Number 是 N，就根据原始请求的时间计算采样 RTT，没有歧义性</code>。</li>
<li><strong>但是单纯依靠严格递增的 Packet Number 肯定是无法保证数据的顺序性和可靠性。QUIC 又引入了一个 <strong><code>**Stream Offset**</code></strong> 的概念。</strong></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200922134146426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=ZMt3g&originHeight=312&originWidth=1080&originalType=binary&status=done&style=none"></p>
<ul>
<li>即<code>一个 Stream 可以经过多个 Packet 传输，Packet Number 严格递增，没有依赖</code>。<blockquote>
<ul>
<li>Packet 里的 Payload 如果是 Stream 的话，就需要依靠 Stream 的 Offset 来保证应用数据的顺序。</li>
<li>如图所示，发送端先后发送了 Pakcet N 和 Pakcet N+1，Stream 的 Offset 分别是 x 和 x+y。</li>
<li>假设 Packet N 丢失了，发起重传，重传的 Packet Number 是 N+2，但是它的 Stream 的 Offset 依然是 x，这样就算 Packet N + 2 是后到的，依然可以将 Stream x 和 Stream x+y 按照顺序组织起来，交给应用程序处理。</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="2-6-3-不允许-Reneging"><a href="#2-6-3-不允许-Reneging" class="headerlink" title="2.6.3 不允许 Reneging"></a>2.6.3 不允许 Reneging</h4><ul>
<li><code>**什么叫 Reneging 呢？就是接收方丢弃已经接收并且上报给 SACK 选项的内容 。TCP 协议不鼓励这种行为，但是协议层面允许这样的行为。主要是考虑到服务器资源有限，比如 Buffer 溢出，内存不够等情况。**</code></li>
<li><strong>Reneging 对数据重传会产生很大的干扰。因为 Sack 都已经表明接收到了，但是接收端事实上丢弃了该数据</strong>。</li>
<li><code>QUIC 在协议层面禁止 Reneging，一个 Packet 只要被 Ack，就认为它一定被正确接收，减少了这种干扰</code>。</li>
</ul>
<h4 id="2-6-4-更多的-Ack-块"><a href="#2-6-4-更多的-Ack-块" class="headerlink" title="2.6.4 更多的 Ack 块"></a>2.6.4 更多的 Ack 块</h4><ul>
<li><strong>TCP 的 Sack 选项能够告诉发送方已经接收到的连续 Segment 的范围，方便发送方进行选择性重传。</strong> -   <code>由于 TCP 头部最大只有 60 个字节，标准头部占用了 20 字节，所以 Tcp Option 最大长度只有 40 字节，再加上 Tcp Timestamp option 占用了 10 个字节 ，所以留给 Sack 选项的只有 30 个字节</code>。</li>
<li><strong>每一个 Sack Block 的长度是 8 个，加上 Sack Option 头部 2 个字节，也就意味着 Tcp Sack Option 最大只能提供 3 个 Block</strong>。</li>
<li><code>但是 Quic Ack Frame 可以同时提供 256 个 Ack Block，在丢包率比较高的网络下，更多的 Sack Block 可以提升网络的恢复速度，减少重传量</code>。</li>
</ul>
<h4 id="2-6-5-Ack-Delay-时间"><a href="#2-6-5-Ack-Delay-时间" class="headerlink" title="2.6.5 Ack Delay 时间"></a>2.6.5 Ack Delay 时间</h4><ul>
<li><code>**Tcp 的 Timestamp 选项存在一个问题 ，它只是回显了发送方的时间戳，但是没有计算接收端接收到 segment 到发送 Ack 该 segment 的时间。这个时间可以简称为 Ack Delay。**</code></li>
<li>这样就会导致 RTT 计算误差。如下图：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200922134723577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=BEhaw&originHeight=816&originWidth=1080&originalType=binary&status=done&style=none"></p>
<ul>
<li>可以认为 TCP 的 RTT 计算： <img src="https://img-blog.csdnimg.cn/20200922134807851.png#pic_center#id=KPX6u&originHeight=41&originWidth=301&originalType=binary&status=done&style=none"></li>
<li>而 Quic 计算如下： <img src="https://img-blog.csdnimg.cn/20200922134824234.png#pic_center#id=k1B88&originHeight=41&originWidth=367&originalType=binary&status=done&style=none"></li>
</ul>
<blockquote>
<ul>
<li>当然 RTT 的具体计算没有这么简单，需要采样，参考历史数值进行平滑计算，参考如下公式:</li>
</ul>
</blockquote>
<blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200922134848538.png#pic_center#id=JDhGD&originHeight=67&originWidth=301&originalType=binary&status=done&style=none"></p>
</blockquote>
<h4 id="2-6-6-基于-stream-和-connecton-级别的流量控制"><a href="#2-6-6-基于-stream-和-connecton-级别的流量控制" class="headerlink" title="2.6.6 基于 stream 和 connecton 级别的流量控制"></a>2.6.6 基于 stream 和 connecton 级别的流量控制</h4><ul>
<li>QUIC 的流量控制 类似 HTTP2，<code>即在 Connection 和 Stream 级别提供了两种流量控制</code>。为什么需要两类流量控制呢？主要是因为 QUIC 支持多路复用。</li>
<li>Stream 可以认为就是一条 HTTP 请求。</li>
<li>Connection 可以类比一条 TCP 连接。</li>
<li><strong>多路复用意味着在一条 Connetion 上会同时存在多条 Stream。既需要对单个 Stream 进行控制，又需要针对所有 Stream 进行总体控制。</strong></li>
</ul>
<p>QUIC 实现流量控制的原理比较简单：</p>
<ul>
<li><code>通过 window_update 帧告诉对端自己可以接收的字节数，这样发送方就不会发送超过这个数量的数据</code>。- <strong>通过 BlockFrame 告诉对端由于流量控制被阻塞了，无法发送数据</strong>。</li>
<li><code>QUIC 的流量控制和 TCP 有点区别，TCP 为了保证可靠性，窗口左边沿向右滑动时的长度取决于已经确认的字节数。如果中间出现丢包，就算接收到了更大序号的 Segment，窗口也无法超过这个序列号</code>。</li>
<li><strong>但 QUIC 不同，就算此前有些 packet 没有接收到，它的滑动只取决于接收到的最大偏移字节数。</strong></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200922135106709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=Lk09m&originHeight=442&originWidth=1080&originalType=binary&status=done&style=none"></p>
<ul>
<li>针对 Stream：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200922135129300.png#pic_center#id=wNSZL&originHeight=37&originWidth=431&originalType=binary&status=done&style=none"><br>针对 Connection：<br><img src="https://img-blog.csdnimg.cn/20200922135146282.png#pic_center#id=fmXEv&originHeight=37&originWidth=610&originalType=binary&status=done&style=none"><br>同样地，STGW 也在连接和 Stream 级别设置了不同的窗口数。</p>
<p>最重要的是，我们可以在内存不足或者上游处理性能出现问题时，通过流量控制来限制传输速率，保障服务可用性。</p>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>QUIC 协议 存在的意义在于解决 TCP 协议的一些无法解决的痛点</p>
<ul>
<li><code>多次握手</code>：TCP 协议需要三次握手建立连接，而如果需要 TLS 证书的交换，那么则需要更多次的握手才能建立可靠连接，这在如今长肥网络的趋势下是一个巨大的痛点</li>
<li><code>队头阻塞</code>：TCP 协议下，如果出现丢包，则一条连接将一直被阻塞等待该包的重传，即使后来的数据包可以被缓存，但也无法被递交给应用层去处理。</li>
<li><code>无法判断一个 ACK 是重传包的 ACK 还是原本包的 ACK</code>：比如 一个包 seq=1, 超时重传的包同样是 seq=1，这样在收到一个 ack=1 之后，我们无法判断这个 ack 是对之前的包的 ack 还是对重传包的 ack，这会导致我们对 RTT 的估计出现误差，无法提供更准确的拥塞控制</li>
<li><code>无法进行连接迁移</code>：<strong>一条连接由一个四元组标识，在当今移动互联网的时代，如果一台手机从一个 wifi 环境切换到另一个 wifi 环境，ip 发生变化，那么连接必须重新建立，inflight 的包全部丢失。</strong></li>
</ul>
<p>现在我们给出一个 QUIC 协议的 Overview</p>
<ul>
<li><code>更好的连接建立方式</code></li>
<li><code>更好的拥塞控制</code></li>
<li><code>没有队头阻塞的多路复用</code></li>
<li><code>前向纠错</code></li>
<li><code>连接迁移</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/25/yuque/HTTP2.0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/25/yuque/HTTP2.0/" class="post-title-link" itemprop="url">HTTP2.0</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-25 16:48:35" itemprop="dateCreated datePublished" datetime="2021-04-25T16:48:35+08:00">2021-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 18:36:15" itemprop="dateModified" datetime="2021-04-29T18:36:15+08:00">2021-04-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619340543736-a33f0c98-6dbb-4088-95a8-8d42c25df28e.jpeg#clientId=u148c49a8-157a-4&from=drop&id=u449ec38d&margin=%5Bobject%20Object%5D&name=1.jpg&originHeight=145&originWidth=798&originalType=binary&size=16049&status=done&style=none&taskId=uf8ec65be-f7fd-44db-af5d-1208b45fafb" alt="1.jpg"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/gif/21377586/1619340548956-54a67302-7ca7-4ed6-b03e-22497facf880.gif#clientId=u148c49a8-157a-4&from=drop&id=u1cfa2027&margin=%5Bobject%20Object%5D&name=2.gif&originHeight=281&originWidth=1200&originalType=binary&size=2075450&status=done&style=none&taskId=u963af8b6-9efa-4aab-9114-635366bd545" alt="2.gif"></p>
<p>本文字数：<strong>3825 字</strong></p>
<p>预计阅读时间：<strong>20 分钟</strong></p>
<p><strong>导读</strong></p>
<p>http2.0 是一种安全高效的下一代 http 传输协议。安全是因为 http2.0 建立在 https 协议的基础上，高效是因为它是通过二进制分帧来进行数据传输。正因为这些特性，http2.0 协议也在被越来越多的网站支持。据统计，截止至 2018 年 8 月，已经有 27.9%的网站支持 http2.0。</p>
<p>本文将从<strong>概述、原理、实战及检测</strong>等方面来详细介绍 http2.0，希望能够加深你的理解。</p>
<p><strong>什么是 http2.0 协议？</strong></p>
<p>在 http2.0 官网 ① 的描述是：</p>
<p>http/2 is a replacement for how http is expressed “on the wire.” It is not a ground-up rewrite of the protocol; http methods, status codes and semantics are the same, and it should be possible to use the same APIs as http/1.x (possibly with some small additions) to represent the protocol.</p>
<p>The focus of the protocol is on performance; specifically, end-user perceived latency, network and server resource usage. One major goal is to allow the use of a single connection from browsers to a Web site.</p>
<p>The basis of the work was SPDY, but http/2 has evolved to take the community’s input into account, incorporating several improvements in the process.</p>
<p>中文总结一下就是：</p>
<p><strong>● 对 1.x 协议语意的完全兼容</strong></p>
<p>2.0 协议是在 1.x 基础上的升级而不是重写，1.x 协议的方法，状态及 api 在 2.0 协议里是一样的。</p>
<p><strong>● 性能的大幅提升</strong></p>
<p>2.0 协议重点是对终端用户的感知延迟、网络及服务器资源的使用等性能的优化。</p>
<p><strong>http2.0 优化内容</strong></p>
<p><strong>01</strong></p>
<p><strong>二进制分帧（Binary Format）- http2.0 的基石</strong></p>
<p>http2.0 之所以能够突破 http1.X 标准的性能限制，改进传输性能，实现低延迟和高吞吐量，就是因为其新增了二进制分帧层。</p>
<p>帧(frame)包含部分：类型 Type, 长度 Length, 标记 Flags, 流标识 Stream 和 frame payload 有效载荷。</p>
<p>消息(message)：一个完整的请求或者响应，比如请求、响应等，由一个或多个 Frame 组成。</p>
<p>流是连接中的一个虚拟信道，可以承载双向消息传输。每个流有唯一整数标识符。为了防止两端流 ID 冲突，客户端发起的流具有奇数 ID，服务器端发起的流具有偶数 ID。</p>
<p>流标识是描述二进制 frame 的格式，使得每个 frame 能够基于 http2 发送，与流标识联系的是一个流，每个流是一个逻辑联系，一个独立的双向的 frame 存在于客户端和服务器端之间的 http2 连接中。一个 http2 连接上可包含多个并发打开的流，这个并发流的数量能够由客户端设置。</p>
<p>在二进制分帧层上，http2.0 会将所有传输信息分割为更小的消息和帧，并对它们采用二进制格式的编码将其封装，新增的二进制分帧层同时也能够保证 http 的各种动词，方法，首部都不受影响，兼容上一代 http 标准。其中，http1.X 中的首部信息 header 封装到 Headers 帧中，而 request body 将被封装到 Data 帧中。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619340552914-6d85f416-ef90-425c-aadf-5b8012ea6a0e.jpeg#clientId=u148c49a8-157a-4&from=drop&height=328&id=ud9ea1c6a&margin=%5Bobject%20Object%5D&name=3.jpg&originHeight=328&originWidth=624&originalType=binary&size=27637&status=done&style=none&taskId=u5db12245-ba46-48b9-9407-0903347de64&width=624" alt="3.jpg"></p>
<p><strong>02</strong></p>
<p><strong>多路复用 (Multiplexing) / 连接共享</strong></p>
<p>在 http1.1 中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量的限制，超过限制数目的请求会被阻塞。这也是为何一些站点会有多个静态资源 CDN 域名的原因之一。</p>
<p>而 http2.0 中的多路复用优化了这一性能。多路复用允许同时通过单一的 http/2 连接发起多重的请求-响应消息。有了新的分帧机制后，http/2 不再依赖多个 TCP 连接去实现多流并行了。每个数据流都拆分成很多互不依赖的帧，而这些帧可以交错（乱序发送），还可以分优先级，最后再在另一端把它们重新组合起来。</p>
<p>http 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接（每个域名一个连接）即可。http2 连接可以承载数十或数百个流的复用，多路复用意味着来自很多流的数据包能够混合在一起通过同样连接传输。当到达终点时，再根据不同帧首部的流标识符重新连接将不同的数据流进行组装。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619340559408-1ecd3083-c71e-4701-a7eb-5b198b78904c.png#clientId=u148c49a8-157a-4&from=drop&id=uc5a8e1c5&margin=%5Bobject%20Object%5D&name=4.png&originHeight=224&originWidth=830&originalType=binary&size=81541&status=done&style=none&taskId=ufc08a7ca-a9e9-4475-b4c4-8186fe89a0a" alt="4.png"></p>
<p>上图展示了一个连接上的多个传输数据流：客户端向服务端传输数据帧 stream5，同时服务端向客户端乱序发送 stream1 和 stream3。这次连接上有三个响应请求乱序并行交换。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619340563946-a4561bc4-3067-4483-9864-3db695ec5a1f.jpeg#clientId=u148c49a8-157a-4&from=drop&height=618&id=uf7621412&margin=%5Bobject%20Object%5D&name=5.jpg&originHeight=618&originWidth=625&originalType=binary&size=35776&status=done&style=none&taskId=u4632ef5b-fe20-4abb-a08a-81893d10b95&width=625" alt="5.jpg"></p>
<p>上图就是 http1.X 和 http2.0 在传输数据时的区别。以货物运输为例再现 http1.1 与 http2.0 的场景：</p>
<p>http1.1 过程：货轮 1 从 A 地到 B 地去取货物，取到货物后，从 B 地返回，然后货轮 2 在 A 返回并卸下货物后才开始再从 A 地出发取货返回，如此有序往返。</p>
<p>http2.0 过程：货轮 1、2、3、4、5 从 A 地无序全部出发，取货后返回，然后根据货轮号牌卸载对应货物。</p>
<p>显然，第二种方式运输货物多，河道的利用率高。</p>
<p>03</p>
<p><strong>头部压缩（Header Compression）</strong></p>
<p>http1.x 的头带有大量信息，而且每次都要重复发送。http/2 使用 encoder 来减少需要传输的 header 大小，通讯双方各自缓存一份头部字段表，既避免了重复 header 的传输，又减小了需要传输的大小。</p>
<p>对于相同的数据，不再通过每次请求和响应发送，通信期间几乎不会改变通用键-值对(用户代理、可接受的媒体类型，等等)只需发送一次。</p>
<p>事实上,如果请求中不包含首部(例如对同一资源的轮询请求)，那么，首部开销就是零字节，此时所有首部都自动使用之前请求发送的首部。</p>
<p>如果首部发生了变化，则只需将变化的部分加入到 header 帧中，改变的部分会加入到头部字段表中，首部表在 http 2.0 的连接存续期内始终存在，由客户端和服务器共同渐进地更新。</p>
<p>需要注意的是，http 2.0 关注的是首部压缩，而我们常用的 gzip 等是报文内容（body）的压缩，二者不仅不冲突，且能够一起达到更好的压缩效果。</p>
<p>http/2 使用的是专门为首部压缩而设计的 HPACK② 算法。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619340576632-76592f6e-2635-4ef2-bdeb-bbf31c06beb7.jpeg#clientId=u148c49a8-157a-4&from=drop&height=318&id=uda892c3a&margin=%5Bobject%20Object%5D&name=6.jpg&originHeight=318&originWidth=627&originalType=binary&size=34790&status=done&style=none&taskId=u919f26c9-7da5-450e-8bc4-400b98d0fc0&width=627" alt="6.jpg"></p>
<p>从上图可以看到 http1.X 不支持首部压缩，而 http2.0 的压缩算法效果最好，发送和接受的数据量都是最少的。</p>
<p><strong>04</strong></p>
<p><strong>压缩原理</strong></p>
<p>用 header 字段表里的索引代替实际的 header。</p>
<p>http/2 的 HPACK 算法使用一份索引表来定义常用的 http Header，把常用的 http Header 存放在表里，请求的时候便只需要发送在表里的索引位置即可。</p>
<p>例如 :method=GET 使用索引值 2 表示，:path=/index.html 使用索引值 5 表示，如下图：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619340594084-7273a70e-647d-4b4e-b4ae-5524a9083cea.png#clientId=u148c49a8-157a-4&from=drop&height=488&id=ub851fcd8&margin=%5Bobject%20Object%5D&name=7.png&originHeight=488&originWidth=479&originalType=binary&size=25243&status=done&style=none&taskId=u6fa0f53f-f5c2-4e6d-8fde-d9eae036267&width=479" alt="7.png"></p>
<p>完整的列表参考：HPACK Static Table③ 。</p>
<p>只要给服务端发送一个 Frame，该 Frame 的 Payload 部分存储 0x8285，Frame 的 Type 设置为 Header 类型，便可表示这个 Frame 属于 http Header，请求的内容是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1GET &#x2F;index.html</span><br></pre></td></tr></table></figure>

<p>为什么是 0x8285，而不是 0x0205？这是因为高位设置为 1 表示这个字节是一个完全索引值（key 和 value 都在索引中）。</p>
<p>类似的，通过高位的标志位可以区分出这个字节是属于一个完全索引值，还是仅索引了 key，还是 key 和 value 都没有索引(参见：HTTP/2 首部压缩的 OkHttp3 实现 ④)。</p>
<p>因为索引表的大小的是有限的，它仅保存了一些常用的 http Header，同时每次请求还可以在表的末尾动态追加新的 http Header 缓存，动态部分称之为 Dynamic Table。Static Table 和 Dynamic Table 在一起组合成了索引表：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619340602194-476ded49-c784-46c1-b5aa-5311ef73667e.png#clientId=u148c49a8-157a-4&from=drop&id=u3c0d1396&margin=%5Bobject%20Object%5D&name=8.png&originHeight=222&originWidth=768&originalType=binary&size=32088&status=done&style=none&taskId=u982cf32a-aab1-4bfc-a608-e6db4ef4116" alt="8.png"></p>
<p>HPACK 不仅仅通过索引键值对来降低数据量，同时还会将字符串进行霍夫曼编码来压缩字符串大小。</p>
<p>以常用的 User-Agent 为例，它在静态表中的索引值是 58，它的值是不存在表中的，因为它的值是多变的。第一次请求的时候它的 key 用 58 表示，表示这是一个 User-Agent ，它的值部分会进行霍夫曼编码（如果编码后的字符串变更长了，则不采用霍夫曼编码）。</p>
<p>服务端收到请求后，会将这个 User-Agent 添加到 Dynamic Table 缓存起来，分配一个新的索引值。客户端下一次请求时，假设上次请求 User-Agent 的在表中的索引位置是 62， 此时只需要发送 0xBE（同样的，高位置 1），便可以代表：User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.146 Safari/537.36。</p>
<p>其过程如下图所示：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619340620286-e641085e-f964-41dd-bc5b-e481eff873c5.png#clientId=u148c49a8-157a-4&from=drop&height=259&id=u2bad4692&margin=%5Bobject%20Object%5D&name=9.png&originHeight=259&originWidth=792&originalType=binary&size=78576&status=done&style=none&taskId=ufc5c19f5-828f-441e-a4e5-43847fea366&width=792" alt="9.png"></p>
<p>最终，相同的 Header 只需要发送索引值，新的 Header 会重新加入 Dynamic Table。</p>
<p><strong>05</strong></p>
<p><strong>请求优先级（Request Priorities）</strong></p>
<p>把 http 消息分为很多独立帧之后，就可以通过优化这些帧的交错和传输顺序进一步优化性能。每个流都可以带有一个 31 比特的优先值：0 表示最高优先级；2 的 31 次方-1 表示最低优先级。</p>
<p>服务器可以根据流的优先级，控制资源分配（CPU、内存、带宽），而在响应数据准备好之后，优先将最高优先级的帧发送给客户端。高优先级的流都应该优先发送，但又不会绝对的。绝对地准守，可能又会引入首队阻塞的问题：高优先级的请求慢导致阻塞其他资源交付。</p>
<p>分配处理资源和客户端与服务器间的带宽，不同优先级的混合也是必须的。客户端会指定哪个流是最重要的，有一些依赖参数，这样一个流可以依赖另外一个流。优先级别可以在运行时动态改变，当用户滚动页面时，可以告诉浏览器哪个图像是最重要的，你也可以在一组流中进行优先筛选，能够突然抓住重点流。</p>
<p>● 优先级最高：主要的 html</p>
<p>● 优先级高：CSS 文件</p>
<p>● 优先级中：js 文件</p>
<p>● 优先级低：图片</p>
<p><strong>06</strong></p>
<p><strong>服务端推送（Server Push）</strong></p>
<p>服务器可以对一个客户端请求发送多个响应，服务器向客户端推送资源无需客户端明确地请求。并且，服务端推送能把客户端所需要的资源伴随着 index.html 一起发送到客户端，省去了客户端重复请求的步骤。</p>
<p>正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。Server Push 让 http1.x 时代使用内嵌资源的优化手段变得没有意义；如果一个请求是由你的主页发起的，服务器很可能会响应主页内容、logo 以及样式表，因为它知道客户端会用到这些东西，这相当于在一个 HTML 文档内集合了所有的资源。</p>
<p>不过与之相比，服务器推送还有一个很大的优势：可以缓存！也让在遵循同源的情况下，不同页面之间可以共享缓存资源成为可能。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619340635870-3a618bdd-7c58-4bb4-8181-0753af6a5ba4.png#clientId=u148c49a8-157a-4&from=drop&height=210&id=u8ae706c2&margin=%5Bobject%20Object%5D&name=10.png&originHeight=210&originWidth=494&originalType=binary&size=79425&status=done&style=none&taskId=uebee46ce-df66-4b12-a96d-cef0d181957&width=494" alt="10.png"></p>
<p>注意两点：</p>
<p>1、推送遵循同源策略；</p>
<p>2、这种服务端的推送是基于客户端的请求响应来确定的。</p>
<p>当服务端需要主动推送某个资源时，便会发送一个 Frame Type 为 PUSH_PROMISE 的 Frame，里面带了 PUSH 需要新建的 Stream ID。意思是告诉客户端：接下来我要用这个 ID 向你发送东西，客户端准备好接着。客户端解析 Frame 时，发现它是一个 PUSH_PROMISE 类型，便会准备接收服务端要推送的流。</p>
<p><strong>http2.0 性能瓶颈</strong></p>
<p>启用 http2.0 后会给性能带来很大的提升，但同时也会带来新的性能瓶颈。因为现在所有的压力集中在底层一个 TCP 连接之上，TCP 很可能就是下一个性能瓶颈，比如 TCP 分组的队首阻塞问题，单个 TCP packet 丢失导致整个连接阻塞，无法逃避，此时所有消息都会受到影响。未来，服务器端针对 http 2.0 下的 TCP 配置优化至关重要。</p>
<p><strong>01</strong></p>
<p><strong>如何升级 http2.0 协议</strong></p>
<p>nginx 服务器升级 http2.0 协议需要满足如下条件：</p>
<p>1、nginx 版本高于 1.9.5；</p>
<p>2、–with-http_ssl_module 跟 –with-http_v2_module</p>
<p>–with-http_ssl_module 模块是因为 http2.0 协议是一种 https 协议。</p>
<p><strong>02</strong></p>
<p><strong>查看你的 nginx 配置</strong></p>
<p><code>nginx -V</code></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619340645097-a0c876d8-0a96-479b-a34b-aa41bb60d041.png#clientId=u148c49a8-157a-4&from=drop&id=u3466751d&margin=%5Bobject%20Object%5D&name=11.png&originHeight=152&originWidth=1080&originalType=binary&size=76381&status=done&style=none&taskId=u7fe82bb9-f187-4e1c-89c9-fb83ddf4235" alt="11.png"></p>
<p>这个是已经添加了对应模块。没有这两个模块的需要手动编译安装。</p>
<p><strong>03</strong></p>
<p><strong>找到 nginx 文件目录</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619340651193-7aa65a17-275e-4e6f-b4e8-50742b5a2e5b.jpeg#clientId=u148c49a8-157a-4&from=drop&height=299&id=u45311b71&margin=%5Bobject%20Object%5D&name=12.jpg&originHeight=380&originWidth=1080&originalType=binary&size=41158&status=done&style=none&taskId=udd394e18-2eb9-44bb-91d6-9b11cdf3eca&width=849" alt="12.jpg"></p>
<p><strong>04</strong></p>
<p><strong>编译安装 nginx 文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx  --with-http_stub_status_module  --with-http_ssl_module  --with-http_v2_module</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619340659111-a0b4decb-6a0e-423b-b3d6-8f25b86fedc2.jpeg#clientId=u148c49a8-157a-4&from=drop&id=u7c1a3838&margin=%5Bobject%20Object%5D&name=13.jpg&originHeight=354&originWidth=1080&originalType=binary&size=37571&status=done&style=none&taskId=u435617e3-248c-47f3-a67d-dceb948fc21" alt="13.jpg"></p>
<p>然后执行如下命令，进行编译安装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1make2make install</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619340666832-f7a52a22-fc6e-4d92-aa9f-7970338d3ffb.jpeg#clientId=u148c49a8-157a-4&from=drop&id=ubd20aad5&margin=%5Bobject%20Object%5D&name=14.jpg&originHeight=240&originWidth=1080&originalType=binary&size=27416&status=done&style=none&taskId=u8b29a217-21a1-490f-8815-0ff2e825a7e" alt="14.jpg"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619340672605-191b5f93-e594-459e-82d3-5b3ba09005fc.png#clientId=u148c49a8-157a-4&from=drop&id=u90f5039a&margin=%5Bobject%20Object%5D&name=15.png&originHeight=245&originWidth=906&originalType=binary&size=11897&status=done&style=none&taskId=ud9481316-7173-41ce-adcb-cf16257d872" alt="15.png"></p>
<p><strong>05</strong></p>
<p><strong>更改 nginx 配置</strong></p>
<p>安装结束后将 nginx.config 文件中 443 端口添加 http2；</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619340677468-59acc9ca-e4fc-48bb-8a56-cd87a8c6e895.png#clientId=u148c49a8-157a-4&from=drop&id=u97b5ae08&margin=%5Bobject%20Object%5D&name=16.png&originHeight=83&originWidth=1060&originalType=binary&size=16284&status=done&style=none&taskId=u9f3eb4a7-ef20-46f9-a826-28e0559d8db" alt="16.png"></p>
<p><strong>06</strong></p>
<p><strong>启动 nginx</strong></p>
<p>最后一步，重启 nginx nginx restart（注意不要直接   nginx -s reload ）。这时候你的站点就升级为了 http2.0 协议了。</p>
<p><strong>检测</strong></p>
<p>升级完成后，怎么确定自己的站点是 http2.0 协议呢？一般有如下几种方法：</p>
<p><strong>●chrome devtool</strong></p>
<p>打开 chrome 调试工具，在 network 勾选 protocol 项，h2 代表的是 http2.0 协议，可以看到笔者的网站已经都升级好了；</p>
<p><strong>● 网站</strong></p>
<p>SSL lab⑤ 一个 SSL 服务器检测的网站，对网站进行安全评级，并将检测结果自动生成一个详细的评价报告；</p>
<p><strong>● 插件</strong></p>
<p>http/2 and SPDY indicator 这是一款检测 http2.0 和 SPDY 协议（Google 开发的基于 TCP 的会话层协议）的插件。</p>
<p>参考资料：</p>
<p>[1].<a target="_blank" rel="noopener" href="https://http2.github.io/">https://http2.github.io/</a></p>
<p>[2].<a target="_blank" rel="noopener" href="http://http2.github.io/http2-spec/compression.html">http://http2.github.io/http2-spec/compression.html</a></p>
<p>[3].<a target="_blank" rel="noopener" href="http://http2.github.io/http2-spec/compression.html#rfc.section.A">http://http2.github.io/http2-spec/compression.html#rfc.section.A</a></p>
<p>[4].<a target="_blank" rel="noopener" href="https://neyoufan.github.io/2017/01/06/android/OkHttp3%E4%B8%AD%E7%9A%84HTTP2%E9%A6%96%E9%83%A8%E5%8E%8B%E7%BC%A9/">https://neyoufan.github.io/2017/01/06/android/OkHttp3中的HTTP2首部压缩/</a></p>
<p>[5].<a target="_blank" rel="noopener" href="https://www.ssllabs.com/ssltest/analyze.html">https://www.ssllabs.com/ssltest/analyze.html</a></p>
<p><strong>也许你还想看</strong></p>
<p><strong>（▼ 点击文章标题或封面查看）</strong></p>
<p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzU3NTY3MTQzMg==%E2%88%A3=2247483791&idx=1&sn=f6fd2d66e35e93a27e5918b4ee4c5358&chksm=fd1edc68ca69557ef2d79b7b6bf4ea89de6affa6919c1c85e70d888464e007f9b8683f4e949a&scene=21#wechat_redirect">搜狐新闻推荐算法  |  呈现给你的，都是你所关心的</a></p>
<p>2018-08-30</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619340684287-15958bdc-6ca2-4afe-a819-fe13b1f645b5.jpeg#clientId=u148c49a8-157a-4&from=drop&id=u46cdb403&margin=%5Bobject%20Object%5D&name=17.jpg&originHeight=606&originWidth=1080&originalType=binary&size=87862&status=done&style=none&taskId=ub83e9869-c2af-4963-b51e-e76f9279b1f" alt="17.jpg"></p>
<p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzU3NTY3MTQzMg==%E2%88%A3=2247484862&idx=1&sn=9e1723862ce80488dabc4d3535464cae&chksm=fd1ed859ca69514f02c055a5c8d636f8af2eddd6e7deb0d496d36bb1e5fd404aef90e435b50c&scene=21#wechat_redirect">新闻推荐系统的 CTR 预估模型</a></p>
<p>2019-04-18</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619340689130-b51ed7a9-cea1-417c-bdcd-477568886629.jpeg#clientId=u148c49a8-157a-4&from=drop&id=udef0eb41&margin=%5Bobject%20Object%5D&name=18.jpg&originHeight=459&originWidth=817&originalType=binary&size=36981&status=done&style=none&taskId=u72fc9fb7-90ea-4401-8c50-ffa753221b4" alt="18.jpg"></p>
<p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzU3NTY3MTQzMg==%E2%88%A3=2247483690&idx=1&sn=7187cad324ad14821bf88fa8be4eebf0&chksm=fd1edccdca6955db28c8ce1f24c92367f06cbf81793b2125fa0d76c4692d4a7096f013ca695f&scene=21#wechat_redirect">互联网架构演进之路</a></p>
<p>2018-08-16</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619340693785-dfcc5ff2-345f-4222-ba51-9693b7c94ae7.jpeg#clientId=u148c49a8-157a-4&from=drop&id=u397d1b60&margin=%5Bobject%20Object%5D&name=19.jpg&originHeight=606&originWidth=1080&originalType=binary&size=103864&status=done&style=none&taskId=ue67c9e99-6e7b-42b1-a029-9cc99883457" alt="19.jpg"></p>
<p>加入<strong>搜狐技术作者天团</strong></p>
<p><strong>千元稿费等你来！</strong></p>
<p>戳这里！☛</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619340698782-bc08850e-0b94-4196-932a-55386a90067d.jpeg#clientId=u148c49a8-157a-4&from=drop&id=u87eacb17&margin=%5Bobject%20Object%5D&name=20.jpg&originHeight=1698&originWidth=1080&originalType=binary&size=40520&status=done&style=none&taskId=u1262e6fd-a181-4ed2-9a3f-7162a2ef6e4" alt="20.jpg"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/gif/21377586/1619340708379-ccc64cbf-5988-4df4-84c6-55480795171d.gif#clientId=u148c49a8-157a-4&from=drop&id=u314e39f6&margin=%5Bobject%20Object%5D&name=21.gif&originHeight=318&originWidth=640&originalType=binary&size=2278314&status=done&style=none&taskId=u17beafd1-bded-4021-a835-6a15fe50744" alt="21.gif"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/25/yuque/HTTPS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/25/yuque/HTTPS/" class="post-title-link" itemprop="url">HTTPS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-25 16:41:41" itemprop="dateCreated datePublished" datetime="2021-04-25T16:41:41+08:00">2021-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 18:36:15" itemprop="dateModified" datetime="2021-04-29T18:36:15+08:00">2021-04-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>HTTP 是不安全的，我们的页面也被运营商插入过小黄图广告（数据被篡改），对于 HTTP 来说，再简单不过，只需要设定相应的 DNS，做一个中间人攻击，再将修改后的数据返回，这一方面可能泄露用户隐私数据，同时也对我们的品牌形象产生恶劣影响。<br>然而，当我们切换 HTTPS 时候，运营商的这些小九九就施展不开了，服务端认证不通过，浏览器不会展示相应的页面数据；运营商实施搞的这一套东东也就不能在用户不知情的情况下搞起来了，解决办法是去除相应的受污染的 DNS。<br>全球最大的成人网站 PornHub，YouPorn 都要全面切 HTTPS 了,我们还在犹豫什么了？</p>
<h3 id="安全的-HTTP-的需求"><a href="#安全的-HTTP-的需求" class="headerlink" title="安全的 HTTP 的需求"></a>安全的 HTTP 的需求</h3><p>对 HTTP 的安全需求：</p>
<ul>
<li>加密（客户端和服务器的对话是私密的，无须担心被窃听）</li>
<li>服务端认证（客户端知道它们是在与真正的而不是伪造的服务器通信）</li>
<li>客户端认证（服务器知道它们是在与真正的而不是伪造的客户端通信）</li>
<li>完整性（客户端和服务器的数据不会被修改）</li>
<li>效率（一个运行足够快的算法，一遍低端的客户端和服务器使用）</li>
<li>普适性（基本上所有的客户端和服务器都支持这些协议）</li>
<li>管理的可扩展性（在任何地方的任何人都可以立即进行安全通信）</li>
<li>适应性（能够支持当前最知名的安全方法）</li>
<li>在社会上的可行性（满足社会的政治文化需要），要有公众受信能力</li>
</ul>
<p>在这里面最重要的是前面几条</p>
<ul>
<li>数据加密 传输内容进行混淆</li>
<li>身份验证 通信双方验证对方的身份真实性</li>
<li>数据完整性保护 检测传输的内容是否被篡改或伪造</li>
</ul>
<h3 id="安全-HTTP-的实现"><a href="#安全-HTTP-的实现" class="headerlink" title="安全 HTTP 的实现"></a>安全 HTTP 的实现</h3><h4 id="加密方式的选择"><a href="#加密方式的选择" class="headerlink" title="加密方式的选择"></a>加密方式的选择</h4><p>共享密钥加密 对称密钥加密共享密钥加密方式使用相同的密钥进行加密解密，通信双方都需要接收对方的加密密钥进行数据解密，这种方式在通信过程中必须交互共享的密钥，同样无法避免被网络监听泄漏密钥的问题；同时对于众多客户端的服务器来说还需要分配和管理密钥，对于客户端来说也需要管理密钥，增加设计和实现的复杂度，同时也降低了通信的效率；不用看都不靠谱。<br>公开密钥加密公开密钥加密方式使用一对非对称的密钥对（私钥和公钥），不公开的作为私钥，随意分发的作为公钥；公钥和私钥都能进行数据加密和解密，公钥能解密私钥加密的数据，私钥也能解密公钥加密的数据；这样只需要一套密钥就能处理服务端和众多客户端直接的通信被网络监听泄漏密钥的问题，同时没有额外的管理成本；看起来挺合适。<br>没那么简单公开密钥加密安全性高，伴随着加密方式复杂，处理速度慢的问题。如果我们的通信都是用公开密钥的方式加密，那么通信效率会很低。<br>HTTPS 采用共享密钥加密和公开密钥加密混合的加密方式，在交换密钥对环节使用公开密钥加密方式（防止被监听泄漏密钥）加密共享的密钥，在随后的通信过程中使用共享密钥的方式使用共享的密钥进行加解密。</p>
<h4 id="认证方式实现"><a href="#认证方式实现" class="headerlink" title="认证方式实现"></a>认证方式实现</h4><p>数字证书数字签名是附加在报文上的特殊加密校验码，可以证明是作者编写了这条报文，前提是作者才会有私钥，才能算出这些校验码。如果传输的报文被篡改，则校验码不会匹配，因为校验码只有作者保存的私钥才能产生，所以前面可以保证报文的完整性。<br>数字证书认证机构（Certificate Authority CA）是客户端和服务器双方都可信赖的第三方机构。<br>服务器的运营人员向数字证书认证机构提出证书认证申请，数字证书认证机构在判明申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书（也叫数字证书或证书）后绑定在一起。服务器将这份有数字认证机构颁发的公钥证书发总给客户端，以进行公开密钥加密方式通信。<br>EV SSL（Extended Validation SSL Certificate）证书是基于国际标准的认证指导方针办法的证书，通过认证的 Web 网站能获得更高的认可度。持有 EV SSL 证书的 Web 网站的浏览器地址栏的背景色是绿色的，同时在地址栏的左侧显示了 SSL 证书中记录的组织名称及办法证书的认证机构的名称。<br>使用 OpenSSL，每个人都可以构建一套认证机构文件，同时可以用来给自己的证书请求进行签名，这种方式产生的证书称为自签名证书，这种证书通常是 CA 自己的证书，用户开发测试的正式，也可以像 12306 这样的，信不信由你。<br>证书信任的方式</p>
<ul>
<li>操作系统和浏览器内置每个操作系统和大多数浏览器都会内置一个知名证书颁发机构的名单。因此，你也会信任操作系统及浏览器提供商提供和维护的可信任机构。受信认证机构（也有不受信的，比如赛门铁克，沃通，或者像 2011 年被入侵的 DigiNotar 等）的证书一般会被操作系统或者浏览器在发行或者发布时内置。</li>
<li>证书颁发机构 CA（ Certificate Authority，证书颁发机构）是被证书接受者（拥有者）和依赖证书的一方共同信任的第三方。</li>
<li>手动指定证书所有浏览器和操作系统都提供了一种手工导入信任证书的机制。至于如何获得证书和验证完整性则完全由你自己来定。</li>
</ul>
<p>PKI（Public Key Infrastructure），即公开密钥基础设施，是国际上解决开放式互联网络信息安全需求的一套体系。PKI 支持身份认证，信息传输，存储的完整性，消息传输，存储的机密性以及操作的不可否认性。</p>
<h4 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h4><p>数字签名是只有信息发送者才能产生的别人无法伪造的一段文本，这段文本是对信息发送者发送信息真实性的一个有效证明，具有不可抵赖性。<br>报文的发送方从报文文本生成一个 128 位的散列值（或称为报文摘要活哈希值），发送方使用自己的私钥对这个摘要值进行加密来形成发送方的数字签名。然后这个数字签名将作为报文的附件一起发送给报文的接收方。报文的接收方首先从接收到的原始报文中计算出 128 位的散列值，再用发送方的公钥来对报文附加的数字签名进行解密。如果两次得到的结果是一致的那么接收方可以确认该数字签名是发送方的，同时确认信息是真实的 。</p>
<h3 id="HTTPS-数据交互过程"><a href="#HTTPS-数据交互过程" class="headerlink" title="HTTPS 数据交互过程"></a>HTTPS 数据交互过程</h3><p>HTTP 中没有加密机制，可以通过 SSL（Secure Socket Layer 安全套接层）或 TLS（Transport Layer Security 安全层传输协议）的组合使用，加密 HTTP 的通信内容。<br>HTTPS 是 HTTP Secure 或 HTTP over SSL。<br>SSL（Security Socket Layer）是最初由网景公司（NetScape）为了保障网上交易安全而开发的协议，该协议通过加密来保护客户个人资料，通过认证和完整性检查来确保交易安全。网景公司开发过 SSL3.0 之前的版本；目前主导权已转移给 IETF（Internet Engineering Task Force），IETF 以 SSL3.0 为原型，标准化并制定了 TSL1.0，TLS1.1，TLS1.2。但目前主流的还是 SSL3.0 和 TSL1.0。<br>SSL 工作在 OSI 七层模型中的表示层，TCP/IP 四层模型的应用层。<br>SSL 和 TLS 可以作为基础协议的一部分（对应用透明），也可以嵌入在特定的软件包中（比如 Web 服务器中的实现）。<br>SSL 基于 TCP，SSL 不是简单地单个协议，而是两层协议；SSL 记录协议（SSL Record Protocol）为多种高层协议（SSL 握手协议，SSL 修改密码参数协议，SSL 报警协议）提供基本的安全服务。HTTP 是为 Web 客户端/服务器交互提供传输服务的，它可以在 SSL 的顶层运行；SSL 记录协议为 SSL 链接提供两种服务，机密性：握手协议定义了一个共享密钥，用于 SSL 载荷的对称加密。 消息完整性：握手协议还定义了一个共享密钥，它用来产生一个消息认证码（Message Authentication Code，MAC）。</p>
<h4 id="SSL-记录协议操作"><a href="#SSL-记录协议操作" class="headerlink" title="SSL 记录协议操作"></a>SSL 记录协议操作</h4><ul>
<li>分段 将每个上层消息分解成不大于 2^14（16384）位，然后有选择的进行压缩</li>
<li>添加 MAC 在压缩数据的基础上计算 MAC</li>
<li>加密 消息加上 MAC 用对称加密方法加密</li>
<li>添加 SSL 记录头 内容类型（8 位），主版本（8 位），副版本（8 位），压缩长度（16 位）</li>
</ul>
<h4 id="SSL-握手过程"><a href="#SSL-握手过程" class="headerlink" title="SSL 握手过程"></a>SSL 握手过程</h4><ul>
<li>第一阶段 建立安全能力 包括协议版本 会话 Id 密码构件 压缩方法和初始随机数</li>
<li>第二阶段 服务器发送证书 密钥交换数据和证书请求，最后发送请求-相应阶段的结束信号</li>
<li>第三阶段 如果有证书请求客户端发送此证书 之后客户端发送密钥交换数据 也可以发送证书验证消息</li>
<li>第四阶段 变更密码构件和结束握手协议</li>
</ul>
<p>SSL 协议两个重要概念，SSL 会话，SSL 连接；SSL 连接是点到点的连接，而且每个连接都是瞬态的，每一个链接都与一个会话关联。SSL 会话是一个客户端和一个服务器之间的一种关联，会话由握手协议（Handshake Protocol）创建，所有会话都定义了一组密码安全参数，这些安全参数可以在多个连接之间共享，会话可以用来避免每一个链接需要进行的代价高昂的新的安全参数协商过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Client                                               Server</span><br><span class="line"></span><br><span class="line">   ClientHello:HandShake       --------&gt;</span><br><span class="line">                                                   ServerHello:Handshake</span><br><span class="line">                                                  Certificate*:Handshake</span><br><span class="line">                                            ServerKeyExchange*:Handshake</span><br><span class="line">                                           CertificateRequest*:Handshake</span><br><span class="line">                                &lt;--------      ServerHelloDone:Handshake</span><br><span class="line">   Certificate*:Handshake</span><br><span class="line">   ClientKeyExchange:Handshake</span><br><span class="line">   CertificateVerify*:Handshake</span><br><span class="line">   [ChangeCipherSpec]</span><br><span class="line">   Finished:Handshake           --------&gt;</span><br><span class="line">                                                      [ChangeCipherSpec]</span><br><span class="line">                                &lt;--------             Finished:Handshake</span><br><span class="line">   Application Data             &lt;-------&gt;               Application Data</span><br></pre></td></tr></table></figure>

<h3 id="客户端服务器数据交互实战"><a href="#客户端服务器数据交互实战" class="headerlink" title="客户端服务器数据交互实战"></a>客户端服务器数据交互实战</h3><h4 id="使用-openssl-命令"><a href="#使用-openssl-命令" class="headerlink" title="使用 openssl 命令"></a>使用 openssl 命令</h4><blockquote>
<p>openssl s_client -state -connect q.qunarzz.com:443</p>
</blockquote>
<p>该命令可以显示 SSL 握手过程，SSL 证书链，公钥证书以及其他相关的状态和属性信息。</p>
<h4 id="使用-Wireshark-抓取数据包"><a href="#使用-Wireshark-抓取数据包" class="headerlink" title="使用 Wireshark 抓取数据包"></a>使用 Wireshark 抓取数据包</h4><p>相关配置</p>
<ul>
<li><p>配置环境变量，同时保证文件路径存在</p>
<blockquote>
<p>SSLKEYLOG=/path/to/sslkeylog.log</p>
</blockquote>
</li>
<li><p>配置 Wireshark</p>
<blockquote>
<p>Wireshark-&gt;Preference-&gt;Protocols-&gt;SSL-&gt;(Pre)-Master-Secret log filename=&gt;选择上面的路径</p>
</blockquote>
</li>
</ul>
<p>抓包操作</p>
<ul>
<li><p>在命令行中打开 Chrome 或者 Firefox，确保环境变量被读取;如果不行就用 Chrome 或者 Firefox 的开发版。</p>
<blockquote>
<p>open /Applications/Firefox.app<br>open /Applications/Google\ Chrome.app</p>
</blockquote>
</li>
<li><p>确保$SSLKEYLOGFILE 里面有内容了，再往下进行。</p>
</li>
<li><p>选择对应网卡，抓包配置为 host<a href="https://link.zhihu.com/?target=http://q.qunarzz.com">http://q.qunarzz.com</a>，开始抓包</p>
</li>
<li><p>使用刚刚打开的浏览器访问一个对应 host<a href="https://link.zhihu.com/?target=http://q.qunarzz.com">http://q.qunarzz.com</a>下的某个资源，在抓包界面使用 ssl 过滤数据</p>
</li>
<li><p>在抓包界面可以看到对应的 SSL 握手信息，同时还能看到解密后的应用数据。</p>
</li>
</ul>
<h4 id="内容解析（不同的网络资源可能不完全一致，比如需要客户端证书）"><a href="#内容解析（不同的网络资源可能不完全一致，比如需要客户端证书）" class="headerlink" title="内容解析（不同的网络资源可能不完全一致，比如需要客户端证书）"></a>内容解析（不同的网络资源可能不完全一致，比如需要客户端证书）</h4><p>客户端 ⇒ 服务器</p>
<ul>
<li>Client Hello<ul>
<li>最高支持的协议版本 如 TLS 1.0</li>
<li>支持的加密算法列表(Cipher Suites)</li>
<li>支持的压缩算法列表(Compression Methods)</li>
<li>客户端生成的随机数，稍后用于生成会话密钥</li>
</ul>
</li>
</ul>
<p>服务器 ⇒ 客户端</p>
<ul>
<li>Server Hello<ul>
<li>选定的协议版本</li>
<li>选定的加密算法</li>
<li>选定的压缩方法</li>
<li>服务端生成的随机数，稍后用于生成会话密钥</li>
</ul>
</li>
<li>Certificate 证书内容</li>
<li>Server Key Exchange, Server Hello Done<ul>
<li>公钥</li>
<li>数字签名</li>
<li>Server Hello Done</li>
</ul>
</li>
</ul>
<p>客户端 ⇒ 服务器</p>
<ul>
<li>Client Key Exchange, Change Cipher Spec, Finished<ul>
<li>公钥</li>
<li>Change Cipher Spec</li>
<li>Finished</li>
</ul>
</li>
</ul>
<p>客户端 ⇒ 服务器</p>
<ul>
<li>HTTP GET</li>
</ul>
<p>服务端 ⇒ 客户端</p>
<ul>
<li><strong>内容的数据片段信息</strong></li>
<li>HTTP HTTP/1.1 200 OK</li>
</ul>
<p>服务端 ⇒ 客户端</p>
<ul>
<li>Encrypted Alert</li>
<li>Alert (Level Warning, Description: Close Notify)</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li>《Web 性能权威指南》</li>
<li>《RFC 2246》</li>
<li>《图解 HTTP》</li>
<li>《HTTP 权威指南》</li>
<li>《HTTPS 权威指南 在服务器和 Web 应用上部署 SSL/TLS 和 PKI》</li>
<li>《计算机网络系统方法》</li>
<li>《计算机网络自上而下方法》</li>
<li>《计算机安全原理与实践》</li>
<li>《网络安全基础-应用与标准》</li>
<li>《PKI/CA 与数字证书技术大全》</li>
<li>《SSL 与 TLS》</li>
<li>《OpenSSL 官方命令文档》</li>
<li>《OpenSSL 与网络信息安全-基础、结构和指令》</li>
<li>《OpenSSL 攻略》</li>
<li><a href="https://link.zhihu.com/?target=http://SSL%2520-%2520The%2520Wireshark%2520Wiki">Wireshark Doc SSL</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/25/yuque/HTTP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/25/yuque/HTTP/" class="post-title-link" itemprop="url">HTTP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-25 16:39:57" itemprop="dateCreated datePublished" datetime="2021-04-25T16:39:57+08:00">2021-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 18:36:15" itemprop="dateModified" datetime="2021-04-29T18:36:15+08:00">2021-04-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>HTTP (Hypertext transfer protocol) 翻译成中文是超文本传输协议，是互联网上重要的一个协议，由欧洲核子研究委员会 CERN 的英国工程师<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Tim_Berners-Lee">Tim Berners-Lee</a>v 发明的，同时，他也是 WWW 的发明人，最初的主要是用于传递通过 HTML 封装过的数据。在 1991 年发布了 HTTP 0.9 版，在 1996 年发布 1.0 版，1997 年是 1.1 版，1.1 版也是到今天为止传输最广泛的版本（初始<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc2068">RFC 2068</a>在 1997 年发布， 然后在 1999 年被<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc2616">RFC 2616</a>取代，再在 2014 年被<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7230">RFC 7230</a>/<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7231">7231</a>/<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7232">7232</a>/<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7233">7233</a>/<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7234">7234</a>/<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7235">7235</a>取代），2015 年发布了 2.0 版，其极大的优化了 HTTP/1.1 的性能和安全性，而 2018 年发布的 3.0 版，继续优化 HTTP/2，激进地使用 UDP 取代 TCP 协议，目前，HTTP/3 在 2019 年 9 月 26 日 被 Chrome，Firefox，和 Cloudflare 支持，所以我想写下这篇文章，简单地说一下 HTTP 的前世今生，让大家学到一些知识，并希望可以在推动一下 HTTP 标准协议的发展。</p>
<h4 id="HTTP-0-9-1-0"><a href="#HTTP-0-9-1-0" class="headerlink" title="HTTP 0.9 / 1.0"></a>HTTP 0.9 / 1.0</h4><p>0.9 和 1.0 这两个版本，就是最传统的 request – response 的模式了，HTTP 0.9 版本的协议简单到极点，请求时，不支持请求头，只支持 GET 方法，没了。HTTP 1.0 扩展了 0.9 版，其中主要增加了几个变化：</p>
<ul>
<li>在请求中加入了 HTTP 版本号，如：GET /coolshell/index.html HTTP/1.0</li>
<li>HTTP 开始有 header 了，不管是 request 还是 response 都有 header 了。</li>
<li>增加了 HTTP Status Code 标识相关的状态码。</li>
<li>还有 Content-Type 可以传输其它的文件了。</li>
</ul>
<p>我们可以看到，HTTP 1.0 开始让这个协议变得很文明了，一种工程文明。因为：</p>
<ul>
<li>一个协议有没有版本管理，是一个工程化的象征。</li>
<li>header 是协议可以说是把元数据和业务数据解耦，也可以说是控制逻辑和业务逻辑的分离。</li>
<li>Status Code 的出现可以让请求双方以及第三方的监控或管理程序有了统一的认识。最关键是还是控制错误和业务错误的分离。</li>
</ul>
<p>（注：国内很多公司 HTTP 无论对错只返回 200，这种把 HTTP Status Code 全部抹掉完全是一种工程界的倒退）<br>但是，HTTP1.0 性能上有一个很大的问题，那就是每请求一个资源都要新建一个 TCP 链接，而且是串行请求，所以，就算网络变快了，打开网页的速度也还是很慢。所以，HTTP 1.0 应该是一个必需要淘汰的协议了。</p>
<h4 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h4><p>HTTP/1.1 主要解决了 HTTP 1.0 的网络性能的问题，以及增加了一些新的东西：</p>
<ul>
<li>可以设置 keepalive 来让 HTTP 重用 TCP 链接，重用 TCP 链接可以省了每次请求都要在广域网上进行的 TCP 的三次握手的巨大开销。这是所谓的“<strong>HTTP 长链接</strong>” 或是 “<strong>请求响应式的 HTTP 持久链接</strong>”。英文叫 HTTP Persistent connection.</li>
<li>然后支持 pipeline 网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。（注：非幂等的 POST 方法或是有依赖的请求是不能被 pipeline 化的）</li>
<li>支持 Chunked Responses ，也就是说，在 Response 的时候，不必说明 Content-Length 这样，客户端就不能断连接，直到收到服务端的 EOF 标识。这种技术又叫 “<strong>服务端 Push 模型</strong>”，或是 “<strong>服务端 Push 式的 HTTP 持久链接</strong>”</li>
<li>还增加了 cache control 机制。</li>
<li>协议头注增加了 Language, Encoding, Type 等等头，让客户端可以跟服务器端进行更多的协商。</li>
<li>还正式加入了一个很重要的头——<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Host">HOST</a>这样的话，服务器就知道你要请求哪个网站了。因为可以有多个域名解析到同一个 IP 上，要区分用户是请求的哪个域名，就需要在 HTTP 的协议中加入域名的信息，而不是被 DNS 转换过的 IP 信息。</li>
<li>正式加入了 OPTIONS 方法，其主要用于<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">CORS – Cross Origin Resource Sharing</a>应用。</li>
</ul>
<p>HTTP/1.1 应该分成两个时代，一个是 2014 年前，一个是 2014 年后，因为 2014 年 HTTP/1.1 有了一组 RFC（<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7230">7230</a>/<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7231">7231</a>/<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7232">7232</a>/<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7233">7233</a>/<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7234">7234</a>/<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7235">7235</a>），这组 RFC 又叫“HTTP/2 预览版”。其中影响 HTTP 发展的是两个大的需求：</p>
<ul>
<li>一个需要是加大了 HTTP 的安全性，这样就可以让 HTTP 应用得广泛，比如，使用 TLS 协议。</li>
<li>另一个是让 HTTP 可以支持更多的应用，在 HTTP/1.1 下，HTTP 已经支持四种网络协议：<ul>
<li>传统的短链接。</li>
<li>可重用 TCP 的的长链接模型。</li>
<li>服务端 push 的模型。</li>
<li>WebSocket 模型。</li>
</ul>
</li>
</ul>
<p>自从 2005 年以来，整个世界的应用 API 越来多，这些都造就了整个世界在推动 HTTP 的前进，我们可以看到，<strong>自 2014 的 HTTP/1.1 以来，这个世界基本的应用协议的标准基本上都是向 HTTP 看齐了，也许 2014 年前，还有一些专用的 RPC 协议，但是 2014 年以后，HTTP 协议的增强，让我们实在找不出什么理由不向标准靠拢，还要重新发明轮子了。</strong></p>
<h4 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h4><p>虽然 HTTP/1.1 已经开始变成应用层通讯协议的一等公民了，但是还是有性能问题，虽然 HTTP/1.1 可以重用 TCP 链接，但是请求还是一个一个串行发的，需要保证其顺序。然而，大量的网页请求中都是些资源类的东西，这些东西占了整个 HTTP 请求中最多的传输数据量。所以，理论上来说，如果能够并行这些请求，那就会增加更大的网络吞吐和性能。<br>另外，HTTP/1.1 传输数据时，是以文本的方式，借助耗 CPU 的 zip 压缩的方式减少网络带宽，但是耗了前端和后端的 CPU。这也是为什么很多 RPC 协议诟病 HTTP 的一个原因，就是数据传输的成本比较大。<br>其实，在 2010 年时，Google 就在搞一个实验型的协议，这个协议叫<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/SPDY">SPDY</a>，这个协议成为了 HTTP/2 的基础（也可以说成 HTTP/2 就是 SPDY 的复刻）。HTTP/2 基本上解决了之前的这些性能问题，其和 HTTP/1.1 最主要的不同是：</p>
<ul>
<li>HTTP/2 是一个二进制协议，增加了数据传输的效率。</li>
<li>HTTP/2 是可以在一个 TCP 链接中并发请求多个 HTTP 请求，移除了 HTTP/1.1 中的串行请求。</li>
<li>HTTP/2 会压缩头，如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。这就是所谓的 HPACK 算法（参看<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7541">RFC 7541</a>附录 A）</li>
<li>HTTP/2 允许服务端在客户端放 cache，又叫服务端 push，也就是说，你没有请求的东西，我服务端可以先送给你放在你的本地缓存中。比如，你请求 X，我服务端知道 X 依赖于 Y，虽然你没有的请求 Y，但我把把 Y 跟着 X 的请求一起返回客户端。</li>
</ul>
<p>对于这些性能上的改善，在 Medium 上有篇文章你可看一下相关的细节说明和测试“<a target="_blank" rel="noopener" href="https://medium.com/@factoryhr/http-2-the-difference-between-http-1-1-benefits-and-how-to-use-it-38094fa0e95b">HTTP/2: the difference between HTTP/1.1, benefits and how to use it</a>”<br>当然，还需要注意到的是 HTTP/2 的协议复杂度比之前所有的 HTTP 协议的复杂度都上升了许多许多，其内部还有很多看不见的东西，比如其需要维护一个“优先级树”来用于来做一些资源和请求的调度和控制。如此复杂的协议，自然会产生一些不同的声音，或是降低协议的可维护和可扩展性。所以也有一些争议。尽管如此，HTTP/2 还是很快地被世界所采用。<br>HTTP/2 是 2015 年推出的，其发布后，Google 宣布移除对 SPDY 的支持，拥抱标准的 HTTP/2。过了一年后，就有 8.7%的网站开启了 HTTP/2，根据<a target="_blank" rel="noopener" href="https://w3techs.com/technologies/details/ce-http2/all/all">这份报告</a>，截止至本文发布时（2019 年 10 月 1 日 ）， 在全世界范围内已经有 41%的网站开启了 HTTP/2。<br>HTTP/2 的官方组织在 Github 上维护了一份<a target="_blank" rel="noopener" href="https://github.com/http2/http2-spec/wiki/Implementations">各种语言对 HTTP/2 的实现列表</a>，大家可以去看看。<br>我们可以看到，HTTP/2 在性能上对 HTTP 有质的提高，所以，HTTP/2 被采用的也很快，所以，<strong>如果你在你的公司内负责架构的话，HTTP/2 是你一个非常重要的需要推动的一个事，除了因为性能上的问题，推动标准落地也是架构师的主要职责，因为，你企业内部的架构越标准，你可以使用到开源软件，或是开发方式就会越有效率，跟随着工业界的标准的发展，你的企业会非常自然的享受到标准所带来的红利。</strong></p>
<h4 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h4><p>然而，这个世界没有完美的解决方案，HTTP/2 也不例外，其主要的问题是：若干个 HTTP 的请求在复用一个 TCP 的连接，底层的 TCP 协议是不知道上层有多少个 HTTP 的请求的，所以，一旦发生丢包，造成的问题就是所有的 HTTP 请求都必需等待这个丢了的包被重传回来，哪怕丢的那个包不是我这个 HTTP 请求的。因为 TCP 底层是没有这个知识了。<br>这个问题又叫<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Head-of-line_blocking">Head-of-Line Blocking</a>问题，这也是一个比较经典的流量调度的问题。这个问题最早主要的发生的交换机上。下图来自 Wikipedia。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619340016971-6e74058e-b2cd-4cbf-beb0-72395835d6a5.png#clientId=u3004c439-86d6-4&from=paste&height=220&id=uf7bf408b&margin=%5Bobject%20Object%5D&originHeight=220&originWidth=423&originalType=url&status=done&style=none&taskId=ub4eb0e1b-6c53-4176-aae2-4fc02b731ed&width=423"><br>图中，左边的是输入队列，其中的 1，2，3，4 表示四个队列，四个队列中的 1，2，3，4 要去的右边的 output 的端口号。此时，第一个队列和第三个队列都要写右边的第四个端口，然后，一个时刻只能处理一个包，所以，一个队列只能在那等另一个队列写完后。然后，其此时的 3 号或 1 号端口是空闲的，而队列中的要去 1 和 3 号端号的数据，被第四号端口给 block 住了。这就是所谓的 HOL blocking 问题。<br>HTTP/1.1 中的 pipeline 中如果有一个请求 block 了，那么队列后请求也统统被 block 住了；HTTP/2 多请求复用一个 TCP 连接，一旦发生丢包，就会 block 住所有的 HTTP 请求。这样的问题很讨厌。好像基本无解了。<br>是的 TCP 是无解了，但是 UDP 是有解的 ！<strong>于是 HTTP/3 破天荒地把 HTTP 底层的 TCP 协议改成了 UDP！</strong><br>然后又是 Google 家的协议进入了标准 – QUIC （Quick UDP Internet Connections）。接下来是 QUIC 协议的几个重要的特性，为了讲清楚这些特性，我需要带着问题来讲（注：下面的网络知识，如果你看不懂的话，你需要学习一下《<a target="_blank" rel="noopener" href="https://book.douban.com/subject/1088054/">TCP/IP 详解</a>》一书（在我写 blog 的这 15 年里，这本书推荐了无数次了），或是看一下本站的《<a target="_blank" rel="noopener" href="https://coolshell.cn/articles/11564.html">TCP 的那些事</a>》。）：</p>
<ul>
<li>首先是上面的 Head-of-Line blocking 问题，在 UDP 的世界中，这个就没了。这个应该比较好理解，因为 UDP 不管顺序，不管丢包（当然，QUIC 的一个任务是要像 TCP 的一个稳定，所以 QUIC 有自己的丢包重传的机制）</li>
<li>TCP 是一个无私的协议，也就是说，如果网络上出现拥塞，大家都会丢包，于是大家都会进入拥塞控制的算法中，这个算法会让所有人都“冷静”下来，然后进入一个“慢启动”的过程，包括在 TCP 连接建立时，这个慢启动也在，所以导致 TCP 性能迸发地比较慢。QUIC 基于 UDP，使用更为激进的方式。同时，QUIC 有一套自己的丢包重传和拥塞控制的协，一开始 QUIC 是重新实现一 TCP 的 CUBIC 算法，但是随着 BBR 算法的成熟（BBR 也在借鉴 CUBIC 算法的数学模型），QUIC 也可以使用 BBR 算法。这里，多说几句，<strong>从模型来说，以前的 TCP 的拥塞控制算法玩的是数学模型，而新型的 TCP 拥塞控制算法是以 BBR 为代表的测量模型</strong>，理论上来说，后者会更好，但 QUIC 的团队在一开始觉得 BBR 不如 CUBIC 的算法好，所以没有用。现在的 BBR 2.x 借鉴了 CUBIC 数学模型让拥塞控制更公平。这里有文章大家可以一读“<a target="_blank" rel="noopener" href="https://medium.com/google-cloud/tcp-bbr-magic-dust-for-network-performance-57a5f1ccf437">TCP BBR : Magic dust for network performance.</a>”</li>
<li>接下来，现在要建立一个 HTTPS 的连接，先是 TCP 的三次握手，然后是 TLS 的三次握手，要整出六次网络交互，一个链接才建好，虽说 HTTP/1.1 和 HTTP/2 的连接复用解决这个问题，但是基于 UDP 后，UDP 也得要实现这个事。于是 QUIC 直接把 TCP 的和 TLS 的合并成了三次握手（对此，在 HTTP/2 的时候，是否默认开启 TLS 业内是有争议的，反对派说，TLS 在一些情况下是不需要的，比如企业内网的时候，而支持派则说，TLS 的那些开销，什么也不算了）。<table>
<thead>
<tr>
<th><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619340017332-1af02e02-b10f-448e-ac65-185fb884f598.png#clientId=u3004c439-86d6-4&from=paste&height=300&id=u97051975&margin=%5Bobject%20Object%5D&originHeight=300&originWidth=292&originalType=url&status=done&style=none&taskId=u37c6b49e-6a2e-486b-bda5-30b41af6465&width=292"></th>
<th><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619340018661-91c999e2-fa97-45fb-b47e-1f4fb74d8200.png#clientId=u3004c439-86d6-4&from=paste&height=215&id=u7bd4a36d&margin=%5Bobject%20Object%5D&originHeight=215&originWidth=300&originalType=url&status=done&style=none&taskId=uaa7f25e5-dd58-4049-a7bf-793849522ba&width=300"></th>
</tr>
</thead>
</table>
</li>
</ul>
<p>所以，QUIC 是一个在 UDP 之上的伪 TCP +TLS +HTTP/2 的多路复用的协议。<br>但是对于 UDP 还是有一些挑战的，这个挑战主要来自互联网上的各种网络设备，这些设备根本不知道是什么 QUIC，他们看 QUIC 就只能看到的就是 UDP，所以，在一些情况下，UDP 就是有问题的，</p>
<ul>
<li>比如在 NAT 的环境下，如果是 TCP 的话，NAT 路由或是代理服务器，可以通过记录 TCP 的四元组（源地址、源端口，目标地址，目标端口）来做连接映射的，然而，在 UDP 的情况下不行了。于是，QUIC 引入了个叫 connection id 的不透明的 ID 来标识一个链接，用这种业务 ID 很爽的一个事是，如果你从你的 3G/4G 的网络切到 WiFi 网络（或是反过来），你的链接不会断，因为我们用的是 connection id，而不是四元组。</li>
<li>然而就算引用了 connection id，也还是会有问题 ，比如一些不够“聪明”的等价路由交换机，这些交换机会通过四元组来做 hash 把你的请求的 IP 转到后端的实际的服务器上，然而，他们不懂 connection id，只懂四元组，这么导致属于同一个 connection id 但是四元组不同的网络包就转到了不同的服务器上，这就是导致数据不能传到同一台服务器上，数据不完整，链接只能断了。所以，你需要更聪明的算法（可以参看 Facebook 的<a target="_blank" rel="noopener" href="https://github.com/facebookincubator/katran">Katran</a>开源项目 ）</li>
</ul>
<p>好了，就算搞定上面的东西，还有一些业务层的事没解，这个事就是 HTTP/2 的头压缩算法 HPACK，HPACK 需要维护一个动态的字典表来分析请求的头中哪些是重复的，HPACK 的这个数据结构需要在 encoder 和 decoder 端同步这个东西。在 TCP 上，这种同步是透明的，然而在 UDP 上这个事不好干了。所以，这个事也必需要重新设计了，基于 QUIC 的 QPACK 就出来了，利用两个附加的 QUIC steam，一个用来发送这个字典表的更新给对方，另一个用来 ack 对方发过来的 update。<br>目前看下来，HTTP/3 目前看上去没有太多的协议业务逻辑上的东西，更多是 HTTP/2 + QUIC 协议。但，HTTP/3 因为动到了底层协议，所以，在普及方面上可能会比 HTTP/2 要慢的多的多。但是，可以看到 QUIC 协议的强大，细思及恐，QUIC 这个协议真对 TCP 是个威胁，如果 QUIC 成熟了，TCP 是不是会有可能成为历史呢？<br>未来十年，让我们看看 UDP 是否能够逆袭 TCP……</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/24/yuque/URL%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/24/yuque/URL%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2/" class="post-title-link" itemprop="url">URL到浏览器显示页面</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-24 23:46:03" itemprop="dateCreated datePublished" datetime="2021-04-24T23:46:03+08:00">2021-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 18:36:15" itemprop="dateModified" datetime="2021-04-29T18:36:15+08:00">2021-04-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>面试中常被问到的问题，此问题包含 web 开发中从前端到后端到运维的绝大多数知识，主要考察面试者知识的广度。本文会根据作者了解的程度增加不断更新，不足之处欢迎评论区补充。</p>
</blockquote>
<h2 id="浏览器中输入网址。"><a href="#浏览器中输入网址。" class="headerlink" title="浏览器中输入网址。"></a>浏览器中输入网址。</h2><ul>
<li>http 或 https</li>
<li>url 的组成：<a target="_blank" rel="noopener" href="https://blog.csdn.net/ergouge/article/details/8185219">详解 url 的组成</a></li>
</ul>
<h2 id="通过-DNS-解析域名的实际-IP-地址"><a href="#通过-DNS-解析域名的实际-IP-地址" class="headerlink" title="通过 DNS 解析域名的实际 IP 地址"></a>通过 DNS 解析域名的实际 IP 地址</h2><p>发送至 DNS 服务器并获得域名对应的 WEB 服务器的 ip 地址。</p>
<p>DNS 解析首先会从你的浏览器的缓存中去寻找是否有这个网址对应的 IP 地址，如果没有就向 OS 系统的 DNS 缓存中寻找，如果没有就是路由器的 DNS 缓存， 如果没有就是 ISP 的 DNS 缓存中寻找。</p>
<p>所以，缓存的寻找过程就是： 浏览器 -&gt; 系统 -&gt; 路由器 -&gt; ISP。</p>
<p>如果在某一个缓存中找到的话，就直接跳到下一步。</p>
<p>如果都没有找到的话，就会向 ISP 或者公共的域名解析服务发起 DNS 查找请求。这个查找的过程还是一个递归查询的过程。</p>
<h2 id="检查浏览器是否有缓存"><a href="#检查浏览器是否有缓存" class="headerlink" title="检查浏览器是否有缓存"></a>检查浏览器是否有缓存</h2><ol>
<li>通过<code>Cache-Control</code>和<code>Expires</code>来检查是否命中强缓存，命中则直接取本地磁盘的 html（状态码为 200 from disk(or memory)  cache，内存 or 磁盘）；</li>
<li>如果没有命中强缓存，则会向服务器发起请求（先进行下一步的 TCP 连接），服务器通过<code>Etag</code>和<code>Last-Modify</code>来与服务器确认返回的响应是否被更改（协商缓存），若无更改则返回状态码（304 Not Modified）,浏览器取本地缓存；</li>
<li>若强缓存和协商缓存都没有命中则返回请求结果。</li>
</ol>
<h2 id="与-WEB-服务器建立-TCP-连接。"><a href="#与-WEB-服务器建立-TCP-连接。" class="headerlink" title="与 WEB 服务器建立 TCP 连接。"></a>与 WEB 服务器建立 TCP 连接。</h2><p>TCP 协议通过三次握手建立连接。</p>
<ul>
<li>客户端通过 <code>SYN</code> 报文段发送连接请求，确定服务端是否开启端口准备连接。状态设置为 <code>SYN_SEND</code>;</li>
<li>服务器如果有开着的端口并且决定接受连接，就会返回一个 <code>SYN+ACK</code> 报文段给客户端，状态设置为 <code>SYN_RECV</code>；</li>
<li>客户端收到服务器的 <code>SYN+ACK</code> 报文段，向服务器发送 <code>ACK</code> 报文段表示确认。此时客户端和服务器都设置为 <code>ESTABLISHED</code> 状态。连接建立，可以开始数据传输了。</li>
</ul>
<p>翻译成大白话就是：</p>
<ol>
<li><strong>客户端</strong>：你能接收到我的消息吗？</li>
<li><strong>服务端</strong>：可以的，那你能接收到我的回复吗？</li>
<li><strong>客户端</strong>：可以，那我们开始聊正事吧。</li>
</ol>
<p><strong>为什么是 3 次？</strong>：避免历史连接，确认客户端发来的请求是这次通信的人。</p>
<p><strong>为什么不是 4 次？</strong>：3 次够了第四次浪费</p>
<h2 id="若协议是-https-则会做加密"><a href="#若协议是-https-则会做加密" class="headerlink" title="若协议是 https 则会做加密"></a>若协议是 https 则会做加密</h2><blockquote>
<p>HTTPS = HTTP + 加密 + 认证 + 完整性保护</p>
</blockquote>
<ol>
<li><p>要先申请 CA 证书，并安装在服务器上（一个文件，配置 nginx 支持监听 443 端口开启 ssl 并设置证书路径）</p>
</li>
<li><p>浏览器发送请求；</p>
</li>
<li><p>网站从浏览器发过来的加密规则中选一组自身也支持的加密算法和 hash 算法，并向浏览器发送带有公钥的证书，当然证书还包含了很多信息，如网站地址、证书的颁发机构、过期时间等。</p>
</li>
<li><p>浏览器解析证书。</p>
<ul>
<li>验证证书的合法性。如颁发机构是否合法、证书中的网站地址是否与访问的地址一致，若不合法，则浏览器提示证书不受信任，若合法，浏览器会显示一个小锁头。</li>
<li>若合法，或用户接受了不合法的证书，浏览器会生成一串随机数的密码（即密钥），并用证书中提供的公钥加密。</li>
<li>使用约定好的 hash 计算握手消息，并使用生成的随机数（即密钥）对消息进行加密，最后将之前生成的所有消息一并发送给网站服务器。</li>
</ul>
</li>
<li><p>网站服务器解析消息。用已有的私钥将密钥解密出来，然后用密钥解密发过来的握手消息，并验证是否跟浏览器传过来的一致。然后再用密钥加密一段握手消息，发送给浏览器。</p>
</li>
<li><p>浏览器解密并计算握手消息的 HASH，如果与服务端发来的 HASH 一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。这里浏览器与网站互相发送加密的握手消息并验证，目的是为了保证双方都获得了一致的密码，并且可以正常的加密解密数据，为后续真正数据的传输做一次测试。</p>
</li>
</ol>
<p>下图表示 https 加密通信的过程：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619279748279-f31b3afe-7532-46ab-8566-db4421ad1171.png#clientId=u37cc9bb2-9070-4&from=drop&height=481&id=u3acfa706&margin=%5Bobject%20Object%5D&name=1.png&originHeight=1018&originWidth=1688&originalType=binary&size=1094387&status=done&style=none&taskId=u520b97c5-3c75-443e-b18f-29d22756029&width=797" alt="1.png"></p>
<h2 id="浏览器发送请求获取页面-html"><a href="#浏览器发送请求获取页面-html" class="headerlink" title="浏览器发送请求获取页面 html"></a>浏览器发送请求获取页面 html</h2><p>浏览器向 WEB 服务器的 ip 地址发送相应的 http get 请求页面 html。</p>
<p>通常的请求行是: 请求的方式（<code>get</code>或<code>post</code>） + 请求的资源的位置<code>（url） + HTTP/[版本号](HTTP/1.1)</code></p>
<p>发起 http 请求的过程主要是组装 http 报文并将报文发向指定地址的过程。</p>
<p>http 协议的具体信息可以参考：<a target="_blank" rel="noopener" href="https://www.runoob.com/http/http-tutorial.html">HTTP 介绍教程</a></p>
<h2 id="服务器响应-html"><a href="#服务器响应-html" class="headerlink" title="服务器响应 html"></a>服务器响应 html</h2><p>这里的服务器可能是 server 或者是<code>cdn</code></p>
<p>注：cdn - 内容分发网络，可用来加快传输速度，主要用来存储静态文件，例如前端的 html、css、js、图片文件等。具体请参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a64675c6b73b">CDN 概念基本介绍</a></p>
<p>服务器上可能会通过<code>nginx</code>等设置静态资源代理，将 url 对应的 html 等静态资源返回。</p>
<p><code>nginx</code>是常用的反向代理服务器，介绍请见：<a target="_blank" rel="noopener" href="https://www.w3cschool.cn/nginx/">Nginx 入门指南</a></p>
<p>如果网站是博客或者其他需要<code>seo</code>友好的页面，就需要做<code>服务端渲染</code>，这时服务器会根据模版和数据渲染好 html 文件返回给前端。</p>
<p>常见的服务端渲染方案有：<code>ejs</code>、<code>art-template</code>、等模版语法，也有基于 vue、react 等框架的服务端渲染框架<code>nuxt.js</code>及<code>next.js</code>等。</p>
<h2 id="浏览器解析-HTML"><a href="#浏览器解析-HTML" class="headerlink" title="浏览器解析 HTML"></a>浏览器解析 HTML</h2><ul>
<li>浏览器下载 HTML 数据，将 html 文档解析成为一个个<code>标签</code>，这些标签组成了<code>树状结构</code></li>
<li>如果解析到<code>style</code>标签则开始解析 css，如果解析到 link 标签则先异步下载，完成后解析 css。</li>
<li>如果遇到<code>script</code>标签，判断是行内写法则直接解析执行，如果是 src 引入则<code>同步下载</code>脚本文件，下载完成<code>立即执行</code>，注意这里下载过程是<code>阻塞</code>的，其他流程都会等下载完成后执行。</li>
</ul>
<p>浏览器解析 HTML 文档过程内容较多，详情请看:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Alan_1550587588/article/details/80297765">浏览器解析 HTML 文档过程</a></li>
</ul>
<h2 id="浏览器渲染页面"><a href="#浏览器渲染页面" class="headerlink" title="浏览器渲染页面"></a>浏览器渲染页面</h2><p>浏览器渲染页面的过程主要是解析 html 文档组成<code>标签节点树</code>，解析 css 形成<code>样式规则树</code>，标签节点树和样式规则树共同组成<code>渲染树</code>，浏览器最终显示渲染树形成页面。</p>
<ol>
<li>浏览器会将 HTML 解析成一个 DOM 树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。（更具体的解析 HTML 过程看上一篇博客：点击打开链接）</li>
<li>将 CSS 解析成 CSS Rule Tree（css 规则树） 。</li>
<li>解析完成后，浏览器引擎会根据 DOM 树和 CSS 规则树来构造 Render Tree。注意：Render Tree 渲染树并不等同于 DOM 树，因为一些像 Header 或 display:none 的东西就没必要放在渲染树中了。</li>
<li>有了 Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的 CSS 定义以及他们的从属关系。下一步进行 layout，进入布局处理阶段，即计算出每个节点在屏幕中的位置。</li>
<li>再下一步就是绘制，即遍历 RenderTree，并使用用户界面后端层绘制每个节点。根据计算好的信息绘制整个页面。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619279754931-71e1b816-1df9-4270-9cd1-4bca4ac29922.png#clientId=u37cc9bb2-9070-4&from=drop&height=199&id=u9bc63186&margin=%5Bobject%20Object%5D&name=2.png&originHeight=199&originWidth=780&originalType=binary&size=51388&status=done&style=none&taskId=u65fb4878-9097-475e-9b3c-ccd72188738&width=780" alt="2.png"></p>
<p>注意：上述这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p>
<h2 id="浏览器解析执行-js-脚本"><a href="#浏览器解析执行-js-脚本" class="headerlink" title="浏览器解析执行 js 脚本"></a>浏览器解析执行 js 脚本</h2><p>这个过程中可能会有 dom 操作、ajax 发起的 http 网络请求等。</p>
<h2 id="浏览器发起网络请求"><a href="#浏览器发起网络请求" class="headerlink" title="浏览器发起网络请求"></a>浏览器发起网络请求</h2><p>web-socket、ajax 等，这个过程通常是为了获取数据</p>
<h2 id="服务器响应-ajax-请求"><a href="#服务器响应-ajax-请求" class="headerlink" title="服务器响应 ajax 请求"></a>服务器响应 ajax 请求</h2><ul>
<li>ajax 请求在到达真正的 server 之前，可能还会经过网关全线校验、消息队列或 nginx 等负载均衡处理</li>
<li>到达 server 后，后端会解析 http 请求报文，得到 url、请求参数、http 头、cookie 等等信息</li>
<li>登录校验、权限校验（cookie 校验、jwt 权限校验等）</li>
<li>可能会查询数据库，进行常用的 CRUD（增删改查）等操作</li>
<li>返回响应数据</li>
</ul>
<h2 id="浏览器处理事件循环等异步逻辑。"><a href="#浏览器处理事件循环等异步逻辑。" class="headerlink" title="浏览器处理事件循环等异步逻辑。"></a>浏览器处理事件循环等异步逻辑。</h2><p>setTimeout、setInterval、Promise 等宏任务、微任务队列</p>
<h3 id="不足之处，欢迎在评论区补充，作者会不断更新"><a href="#不足之处，欢迎在评论区补充，作者会不断更新" class="headerlink" title="不足之处，欢迎在评论区补充，作者会不断更新"></a>不足之处，欢迎在评论区补充，作者会不断更新</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/24/yuque/7%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/24/yuque/7%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">7层网络模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-24 23:08:25" itemprop="dateCreated datePublished" datetime="2021-04-24T23:08:25+08:00">2021-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 18:36:15" itemprop="dateModified" datetime="2021-04-29T18:36:15+08:00">2021-04-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="OSI-7-层模型"><a href="#OSI-7-层模型" class="headerlink" title="OSI 7 层模型"></a>OSI 7 层模型</h1><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619337764989-c0cc8a7f-0273-4277-9f96-cfc9212a794c.jpeg#clientId=ub0d3f151-ef7c-4&from=paste&height=471&id=u371344af&margin=%5Bobject%20Object%5D&originHeight=471&originWidth=733&originalType=url&status=done&style=none&taskId=u1d68eee8-a446-4557-a294-a07339a35e5&width=733"><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619339722536-9fca8fdc-3080-45a7-ab91-c29cdb0b9fab.jpeg#clientId=ub0d3f151-ef7c-4&from=paste&height=427&id=u55fa8a9d&margin=%5Bobject%20Object%5D&originHeight=427&originWidth=720&originalType=url&status=done&style=none&taskId=ued4cc0b2-afc7-4326-b897-8e392275d5e&width=720"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/24/yuque/promise_async_generator%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/24/yuque/promise_async_generator%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">promise_async_generator原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-24 18:48:01" itemprop="dateCreated datePublished" datetime="2021-04-24T18:48:01+08:00">2021-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 18:36:15" itemprop="dateModified" datetime="2021-04-29T18:36:15+08:00">2021-04-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>笔者刚接触<code>async/await</code>时，就被其暂停执行的特性吸引了，心想在没有原生 API 支持的情况下，await 居然能挂起当前方法，实现暂停执行，我感到十分好奇。好奇心驱使我一层一层剥开有关 JS 异步编程的一切。阅读完本文，读者应该能够了解：</p>
<ol>
<li><code>Promise</code>的实现原理</li>
<li><code>async/await</code>的实现原理</li>
<li><code>Generator</code>的实现原理</li>
</ol>
<h1 id="Promise-实现"><a href="#Promise-实现" class="headerlink" title="Promise 实现"></a>Promise 实现</h1><p>在成文过程中，笔者查阅了很多讲解 Promise 实现的文章，但感觉大多文章都很难称得上条理清晰，有的上来就放大段 Promise 规范翻译，有的在 Promise 基础使用上浪费篇幅，又或者把一个简单的东西长篇大论，过度讲解，我推荐头铁的同学直接拉到本章小结看最终实现，结合着注释直接啃代码也能理解十之八九</p>
<p>回归正题，文章开头我们先点一下 Promise 为我们解决了什么问题：在传统的异步编程中，如果异步之间存在依赖关系，我们就需要通过层层嵌套回调来满足这种依赖，如果嵌套层数过多，可读性和可维护性都变得很差，产生所谓“回调地狱”，而 Promise 将回调嵌套改为链式调用，增加可读性和可维护性。下面我们就来一步步实现一个 Promise：</p>
<h2 id="1-观察者模式"><a href="#1-观察者模式" class="headerlink" title="1. 观察者模式"></a>1. 观察者模式</h2><p>我们先来看一个最简单的 Promise 使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const p1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        resolve(&#39;result&#39;)</span><br><span class="line">    &#125;,</span><br><span class="line">    1000);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(res &#x3D;&gt; console.log(res), err &#x3D;&gt; console.log(err))</span><br></pre></td></tr></table></figure>

<p>观察这个例子，我们分析 Promise 的调用流程：</p>
<ul>
<li><code>Promise</code>的构造方法接收一个<code>executor()</code>，在<code>new Promise()</code>时就立刻执行这个 executor 回调</li>
<li><code>executor()</code>内部的异步任务被放入宏/微任务队列，等待执行</li>
<li><code>then()</code>被执行，收集成功/失败回调，放入成功/失败队列</li>
<li><code>executor()</code>的异步任务被执行，触发<code>resolve/reject</code>，从成功/失败队列中取出回调依次执行</li>
</ul>
<p>其实熟悉设计模式的同学，很容易就能意识到这是个<strong>观察者模式</strong>，这种<code>收集依赖 -&gt; 触发通知 -&gt; 取出依赖执行</code> 的方式，被广泛运用于观察者模式的实现，在 Promise 里，执行顺序是<code>then收集依赖 -&gt; 异步触发resolve -&gt; resolve执行依赖</code>。依此，我们可以勾勒出 Promise 的大致形状：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class MyPromise &#123;</span><br><span class="line">  &#x2F;&#x2F; 构造方法接收一个回调</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    this._resolveQueue &#x3D; []    &#x2F;&#x2F; then收集的执行成功的回调队列</span><br><span class="line">    this._rejectQueue &#x3D; []     &#x2F;&#x2F; then收集的执行失败的回调队列</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 由于resolve&#x2F;reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue</span><br><span class="line">    let _resolve &#x3D; (val) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 从成功队列里取出回调依次执行</span><br><span class="line">      while(this._resolveQueue.length) &#123;</span><br><span class="line">        const callback &#x3D; this._resolveQueue.shift()</span><br><span class="line">        callback(val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 实现同resolve</span><br><span class="line">    let _reject &#x3D; (val) &#x3D;&gt; &#123;</span><br><span class="line">      while(this._rejectQueue.length) &#123;</span><br><span class="line">        const callback &#x3D; this._rejectQueue.shift()</span><br><span class="line">        callback(val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; new Promise()时立即执行executor,并传入resolve和reject</span><br><span class="line">    executor(_resolve, _reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; then方法,接收一个成功的回调和一个失败的回调，并push进对应队列</span><br><span class="line">  then(resolveFn, rejectFn) &#123;</span><br><span class="line">    this._resolveQueue.push(resolveFn)</span><br><span class="line">    this._rejectQueue.push(rejectFn)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写完代码我们可以测试一下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const p1 &#x3D; new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    resolve(&#39;result&#39;)</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(res &#x3D;&gt; console.log(res))</span><br><span class="line">&#x2F;&#x2F;一秒后输出result</span><br></pre></td></tr></table></figure>

<p>我们运用观察者模式简单的实现了一下<code>then</code>和<code>resolve</code>，使我们能够在 then 方法的回调里取得异步操作的返回值，但我们这个 Promise 离最终实现还有很长的距离，下面我们来一步步补充这个 Promise：</p>
<h2 id="2-Promise-A-规范"><a href="#2-Promise-A-规范" class="headerlink" title="2. Promise A+规范"></a>2. Promise A+规范</h2><p>上面我们已经简单地实现了一个超低配版 Promise，但我们会看到很多文章和我们写的不一样，他们的 Promise 实现中还引入了各种状态控制，这是由于 ES6 的 Promise 实现需要遵循<a target="_blank" rel="noopener" href="https://promisesaplus.com/">Promise/A+规范</a>，是规范对 Promise 的状态控制做了要求。Promise/A+的规范比较长，这里只总结两条核心规则：</p>
<blockquote>
</blockquote>
<blockquote>
<ol>
<li>Promise 本质是一个状态机，且状态只能为以下三种：<code>Pending（等待态）</code>、<code>Fulfilled（执行态）</code>、<code>Rejected（拒绝态）</code>，状态的变更是单向的，只能从 Pending -&gt; Fulfilled 或 Pending -&gt; Rejected，状态变更不可逆</li>
<li><code>then方法</code>接收两个可选参数，分别对应状态改变时触发的回调。then 方法返回一个 promise。then 方法可以被同一个 promise 调用多次。</li>
</ol>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/21377586/1619261340785-d4ebe2d3-dbff-4710-96d6-bbc7abc32282.webp#clientId=u0787e3d2-71b0-4&from=drop&height=174&id=u478ca980&margin=%5Bobject%20Object%5D&name=1.webp&originHeight=174&originWidth=318&originalType=binary&size=6028&status=done&style=none&taskId=uf7f1c65c-14e0-4750-8395-a02cb223112&width=318" alt="1.webp"></p>
<p>根据规范，我们补充一下 Promise 的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Promise&#x2F;A+规范的三种状态</span><br><span class="line">const PENDING &#x3D; &#39;pending&#39;</span><br><span class="line">const FULFILLED &#x3D; &#39;fulfilled&#39;</span><br><span class="line">const REJECTED &#x3D; &#39;rejected&#39;</span><br><span class="line"></span><br><span class="line">class MyPromise &#123;</span><br><span class="line">  &#x2F;&#x2F; 构造方法接收一个回调</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    this._status &#x3D; PENDING     &#x2F;&#x2F; Promise状态</span><br><span class="line">    this._resolveQueue &#x3D; []    &#x2F;&#x2F; 成功队列, resolve时触发</span><br><span class="line">    this._rejectQueue &#x3D; []     &#x2F;&#x2F; 失败队列, reject时触发</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 由于resolve&#x2F;reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue</span><br><span class="line">    let _resolve &#x3D; (val) &#x3D;&gt; &#123;</span><br><span class="line">      if(this._status !&#x3D;&#x3D; PENDING) return   &#x2F;&#x2F; 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span><br><span class="line">      this._status &#x3D; FULFILLED              &#x2F;&#x2F; 变更状态</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 这里之所以使用一个队列来储存回调,是为了实现规范要求的 &quot;then 方法可以被同一个 promise 调用多次&quot;</span><br><span class="line">      &#x2F;&#x2F; 如果使用一个变量而非队列来储存回调,那么即使多次p1.then()也只会执行一次回调</span><br><span class="line">      while(this._resolveQueue.length) &#123;</span><br><span class="line">        const callback &#x3D; this._resolveQueue.shift()</span><br><span class="line">        callback(val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 实现同resolve</span><br><span class="line">    let _reject &#x3D; (val) &#x3D;&gt; &#123;</span><br><span class="line">      if(this._status !&#x3D;&#x3D; PENDING) return   &#x2F;&#x2F; 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span><br><span class="line">      this._status &#x3D; REJECTED               &#x2F;&#x2F; 变更状态</span><br><span class="line">      while(this._rejectQueue.length) &#123;</span><br><span class="line">        const callback &#x3D; this._rejectQueue.shift()</span><br><span class="line">        callback(val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; new Promise()时立即执行executor,并传入resolve和reject</span><br><span class="line">    executor(_resolve, _reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; then方法,接收一个成功的回调和一个失败的回调</span><br><span class="line">  then(resolveFn, rejectFn) &#123;</span><br><span class="line">    this._resolveQueue.push(resolveFn)</span><br><span class="line">    this._rejectQueue.push(rejectFn)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-then-的链式调用"><a href="#3-then-的链式调用" class="headerlink" title="3. then 的链式调用"></a>3. then 的链式调用</h2><p>补充完规范，我们接着来实现链式调用，这是 Promise 实现的重点和难点，我们先来看一下 then 是如何链式调用的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const p1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(1)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1</span><br><span class="line">  .then(res &#x3D;&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">    &#x2F;&#x2F;then回调中可以return一个Promise</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        resolve(2)</span><br><span class="line">      &#125;, 1000);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res &#x3D;&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">    &#x2F;&#x2F;then回调中也可以return一个值</span><br><span class="line">    return 3</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res &#x3D;&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>我们思考一下如何实现这种链式调用：</p>
<ol>
<li>显然<code>.then()</code>需要返回一个 Promise，这样才能找到 then 方法，所以我们会把 then 方法的返回值包装成 Promise。</li>
<li><code>.then()</code>的回调需要拿到上一个<code>.then()</code>的返回值</li>
<li><code>.then()</code>的回调需要顺序执行，以上面这段代码为例，虽然中间 return 了一个 Promise，但执行顺序仍要保证是 1-&gt;2-&gt;3。我们要等待当前 Promise 状态变更后，再执行下一个 then 收集的回调，这就要求我们对 then 的返回值分类讨论</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; then方法</span><br><span class="line">then(resolveFn, rejectFn) &#123;</span><br><span class="line">  &#x2F;&#x2F;return一个新的promise</span><br><span class="line">  return new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span><br><span class="line">    const fulfilledFn &#x3D; value &#x3D;&gt; &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        &#x2F;&#x2F;执行第一个(当前的)Promise的成功回调,并获取返回值</span><br><span class="line">        let x &#x3D; resolveFn(value)</span><br><span class="line">        &#x2F;&#x2F;分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span><br><span class="line">        &#x2F;&#x2F;这里resolve之后，就能被下一个.then()的回调获取到返回值，从而实现链式调用</span><br><span class="line">        x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">      &#125; catch (error) &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;把后续then收集的依赖都push进当前Promise的成功回调队列中(_rejectQueue), 这是为了保证顺序调用</span><br><span class="line">    this._resolveQueue.push(fulfilledFn)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;reject同理</span><br><span class="line">    const rejectedFn  &#x3D; error &#x3D;&gt; &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        let x &#x3D; rejectFn(error)</span><br><span class="line">        x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">      &#125; catch (error) &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    this._rejectQueue.push(rejectedFn)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们就能测试一下链式调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const p1 &#x3D; new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    resolve(1)</span><br><span class="line">  &#125;, 500);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1</span><br><span class="line">  .then(res &#x3D;&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">    return 2</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res &#x3D;&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">    return 3</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res &#x3D;&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出 1 2 3</span><br></pre></td></tr></table></figure>

<h2 id="4-值穿透-amp-状态已变更的情况"><a href="#4-值穿透-amp-状态已变更的情况" class="headerlink" title="4.值穿透 &amp; 状态已变更的情况"></a>4.值穿透 &amp; 状态已变更的情况</h2><p>我们已经初步完成了链式调用，但是对于 then() 方法，我们还要两个细节需要处理一下</p>
<ol>
<li><strong>值穿透</strong>：根据规范，如果 then() 接收的参数不是 function，那么我们应该忽略它。如果没有忽略，当 then()回调不为 function 时将会抛出异常，导致链式调用中断</li>
<li><strong>处理状态为 resolve/reject 的情况</strong>：其实我们上边 then() 的写法是对应状态为<code>padding</code>的情况，但是有些时候，resolve/reject 在 then() 之前就被执行（比如<code>Promise.resolve().then()</code>），如果这个时候还把 then()回调 push 进 resolve/reject 的执行队列里，那么回调将不会被执行，因此对于状态已经变为<code>fulfilled</code>或<code>rejected</code>的情况，我们直接执行 then 回调：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; then方法,接收一个成功的回调和一个失败的回调</span><br><span class="line">  then(resolveFn, rejectFn) &#123;</span><br><span class="line">    &#x2F;&#x2F; 根据规范，如果then的参数不是function，则我们需要忽略它, 让链式调用继续往下执行</span><br><span class="line">    typeof resolveFn !&#x3D;&#x3D; &#39;function&#39; ? resolveFn &#x3D; value &#x3D;&gt; value : null</span><br><span class="line">    typeof rejectFn !&#x3D;&#x3D; &#39;function&#39; ? rejectFn &#x3D; reason &#x3D;&gt; &#123;</span><br><span class="line">      throw new Error(reason instanceof Error? reason.message:reason);</span><br><span class="line">    &#125; : null</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; return一个新的promise</span><br><span class="line">    return new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span><br><span class="line">      const fulfilledFn &#x3D; value &#x3D;&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          &#x2F;&#x2F; 执行第一个(当前的)Promise的成功回调,并获取返回值</span><br><span class="line">          let x &#x3D; resolveFn(value)</span><br><span class="line">          &#x2F;&#x2F; 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span><br><span class="line">          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; reject同理</span><br><span class="line">      const rejectedFn  &#x3D; error &#x3D;&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          let x &#x3D; rejectFn(error)</span><br><span class="line">          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      switch (this._status) &#123;</span><br><span class="line">        &#x2F;&#x2F; 当状态为pending时,把then回调push进resolve&#x2F;reject执行队列,等待执行</span><br><span class="line">        case PENDING:</span><br><span class="line">          this._resolveQueue.push(fulfilledFn)</span><br><span class="line">          this._rejectQueue.push(rejectedFn)</span><br><span class="line">          break;</span><br><span class="line">        &#x2F;&#x2F; 当状态已经变为resolve&#x2F;reject时,直接执行then回调</span><br><span class="line">        case FULFILLED:</span><br><span class="line">          fulfilledFn(this._value)    &#x2F;&#x2F; this._value是上一个then回调return的值(见完整版代码)</span><br><span class="line">          break;</span><br><span class="line">        case REJECTED:</span><br><span class="line">          rejectedFn(this._value)</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-兼容同步任务"><a href="#5-兼容同步任务" class="headerlink" title="5.兼容同步任务"></a>5.兼容同步任务</h2><p>完成了 then 的链式调用以后，我们再处理一个前边的细节，然后放出完整代码。上文我们说过，Promise 的执行顺序是<code>new Promise -&gt; then()收集回调 -&gt; resolve/reject执行回调</code>，这一顺序是建立在<strong>executor 是异步任务</strong>的前提上的，如果 executor 是一个同步任务，那么顺序就会变成<code>new Promise -&gt; resolve/reject执行回调 -&gt; then()收集回调</code>，resolve 的执行跑到 then 之前去了，为了兼容这种情况，我们给<code>resolve/reject</code>执行回调的操作包一个 setTimeout，让它异步执行。</p>
<blockquote>
<p>这里插一句，有关这个 setTimeout，其实还有一番学问。虽然规范没有要求回调应该被放进宏任务队列还是微任务队列，但其实 Promise 的默认实现是放进了微任务队列，我们的实现（包括大多数 Promise 手动实现和 polyfill 的转化）都是使用 setTimeout 放入了宏任务队列（当然我们也可以用 MutationObserver 模拟微任务）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Promise&#x2F;A+规定的三种状态</span><br><span class="line">const PENDING &#x3D; &#39;pending&#39;</span><br><span class="line">const FULFILLED &#x3D; &#39;fulfilled&#39;</span><br><span class="line">const REJECTED &#x3D; &#39;rejected&#39;</span><br><span class="line"></span><br><span class="line">class MyPromise &#123;</span><br><span class="line">  &#x2F;&#x2F; 构造方法接收一个回调</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    this._status &#x3D; PENDING     &#x2F;&#x2F; Promise状态</span><br><span class="line">    this._value &#x3D; undefined    &#x2F;&#x2F; 储存then回调return的值</span><br><span class="line">    this._resolveQueue &#x3D; []    &#x2F;&#x2F; 成功队列, resolve时触发</span><br><span class="line">    this._rejectQueue &#x3D; []     &#x2F;&#x2F; 失败队列, reject时触发</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 由于resolve&#x2F;reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue</span><br><span class="line">    let _resolve &#x3D; (val) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F;把resolve执行回调的操作封装成一个函数,放进setTimeout里,以兼容executor是同步代码的情况</span><br><span class="line">      const run &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        if(this._status !&#x3D;&#x3D; PENDING) return   &#x2F;&#x2F; 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span><br><span class="line">        this._status &#x3D; FULFILLED              &#x2F;&#x2F; 变更状态</span><br><span class="line">        this._value &#x3D; val                     &#x2F;&#x2F; 储存当前value</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 这里之所以使用一个队列来储存回调,是为了实现规范要求的 &quot;then 方法可以被同一个 promise 调用多次&quot;</span><br><span class="line">        &#x2F;&#x2F; 如果使用一个变量而非队列来储存回调,那么即使多次p1.then()也只会执行一次回调</span><br><span class="line">        while(this._resolveQueue.length) &#123;</span><br><span class="line">          const callback &#x3D; this._resolveQueue.shift()</span><br><span class="line">          callback(val)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      setTimeout(run)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 实现同resolve</span><br><span class="line">    let _reject &#x3D; (val) &#x3D;&gt; &#123;</span><br><span class="line">      const run &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        if(this._status !&#x3D;&#x3D; PENDING) return   &#x2F;&#x2F; 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span><br><span class="line">        this._status &#x3D; REJECTED               &#x2F;&#x2F; 变更状态</span><br><span class="line">        this._value &#x3D; val                     &#x2F;&#x2F; 储存当前value</span><br><span class="line">        while(this._rejectQueue.length) &#123;</span><br><span class="line">          const callback &#x3D; this._rejectQueue.shift()</span><br><span class="line">          callback(val)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      setTimeout(run)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; new Promise()时立即执行executor,并传入resolve和reject</span><br><span class="line">    executor(_resolve, _reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; then方法,接收一个成功的回调和一个失败的回调</span><br><span class="line">  then(resolveFn, rejectFn) &#123;</span><br><span class="line">    &#x2F;&#x2F; 根据规范，如果then的参数不是function，则我们需要忽略它, 让链式调用继续往下执行</span><br><span class="line">    typeof resolveFn !&#x3D;&#x3D; &#39;function&#39; ? resolveFn &#x3D; value &#x3D;&gt; value : null</span><br><span class="line">    typeof rejectFn !&#x3D;&#x3D; &#39;function&#39; ? rejectFn &#x3D; reason &#x3D;&gt; &#123;</span><br><span class="line">      throw new Error(reason instanceof Error? reason.message:reason);</span><br><span class="line">    &#125; : null</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; return一个新的promise</span><br><span class="line">    return new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span><br><span class="line">      const fulfilledFn &#x3D; value &#x3D;&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          &#x2F;&#x2F; 执行第一个(当前的)Promise的成功回调,并获取返回值</span><br><span class="line">          let x &#x3D; resolveFn(value)</span><br><span class="line">          &#x2F;&#x2F; 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span><br><span class="line">          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; reject同理</span><br><span class="line">      const rejectedFn  &#x3D; error &#x3D;&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          let x &#x3D; rejectFn(error)</span><br><span class="line">          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      switch (this._status) &#123;</span><br><span class="line">        &#x2F;&#x2F; 当状态为pending时,把then回调push进resolve&#x2F;reject执行队列,等待执行</span><br><span class="line">        case PENDING:</span><br><span class="line">          this._resolveQueue.push(fulfilledFn)</span><br><span class="line">          this._rejectQueue.push(rejectedFn)</span><br><span class="line">          break;</span><br><span class="line">        &#x2F;&#x2F; 当状态已经变为resolve&#x2F;reject时,直接执行then回调</span><br><span class="line">        case FULFILLED:</span><br><span class="line">          fulfilledFn(this._value)    &#x2F;&#x2F; this._value是上一个then回调return的值(见完整版代码)</span><br><span class="line">          break;</span><br><span class="line">        case REJECTED:</span><br><span class="line">          rejectedFn(this._value)</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们可以测试一下这个 Promise：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const p1 &#x3D; new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(1)          &#x2F;&#x2F;同步executor测试</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1</span><br><span class="line">  .then(res &#x3D;&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">    return 2          &#x2F;&#x2F;链式调用测试</span><br><span class="line">  &#125;)</span><br><span class="line">  .then()             &#x2F;&#x2F;值穿透测试</span><br><span class="line">  .then(res &#x3D;&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">    return new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      resolve(3)      &#x2F;&#x2F;返回Promise测试</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res &#x3D;&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">    throw new Error(&#39;reject测试&#39;)   &#x2F;&#x2F;reject测试</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(() &#x3D;&gt; &#123;&#125;, err &#x3D;&gt; &#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F; 2</span><br><span class="line">&#x2F;&#x2F; 3</span><br><span class="line">&#x2F;&#x2F; Error: reject测试</span><br></pre></td></tr></table></figure>

<p>到这里，我们已经实现了 Promise 的主要功能<code>(｀∀´)Ψ</code>剩下的几个方法都非常简单，我们顺手收拾掉：</p>
<h2 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h2><blockquote>
<p><code>catch()方法</code>返回一个 Promise，并且处理拒绝的情况。它的行为与调用 Promise.prototype.then(undefined, onRejected) 相同。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;catch方法其实就是执行一下then的第二个回调</span><br><span class="line">catch(rejectFn) &#123;</span><br><span class="line">  return this.then(undefined, rejectFn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h2><blockquote>
<p><code>finally()方法</code>返回一个 Promise。在 promise 结束时，无论结果是 fulfilled 或者是 rejected，都会执行指定的回调函数。在 finally 之后，还可以继续 then。并且会将值原封不动的传递给后面的 then</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;finally方法</span><br><span class="line">finally(callback) &#123;</span><br><span class="line">  return this.then(</span><br><span class="line">    value &#x3D;&gt; MyPromise.resolve(callback()).then(() &#x3D;&gt; value),             &#x2F;&#x2F; MyPromise.resolve执行回调,并在then中return结果传递给后面的Promise</span><br><span class="line">    reason &#x3D;&gt; MyPromise.resolve(callback()).then(() &#x3D;&gt; &#123; throw reason &#125;)  &#x2F;&#x2F; reject同理</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS. 有同学问我<code>MyPromise.resolve(callback())</code>的意义，这里补充解释一下：这个写法其实涉及到一个<code>finally()</code>的使用细节，<strong>finally()如果 return 了一个 reject 状态的 Promise，将会改变当前 Promise 的状态</strong>，这个<code>MyPromise.resolve</code>就用于改变 Promise 状态，在 finally()没有返回 reject 态 Promise 或 throw 错误的情况下，去掉<code>MyPromise.resolve</code>也是一样的（欢迎大家向我提问，勘误的过程中也能很好地加深自己对 Promise 的理解，大家可以在各个交流群里直接@我）</p>
<blockquote>
<p>参考资料：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f0b94daf9bf7">对 Promise.prototype.finally() 的粗浅理解</a></p>
</blockquote>
<h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><blockquote>
<p><code>Promise.resolve(value)</code>方法返回一个以给定值解析后的 Promise 对象。如果该值为 promise，返回这个 promise；如果这个值是 thenable（即带有”then” 方法)），返回的 promise 会“跟随”这个 thenable 的对象，采用它的最终状态；否则返回的 promise 将以此值完成。此函数将类 promise 对象的多层嵌套展平。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;静态的resolve方法</span><br><span class="line">static resolve(value) &#123;</span><br><span class="line">  if(value instanceof MyPromise) return value &#x2F;&#x2F; 根据规范, 如果参数是Promise实例, 直接return这个实例</span><br><span class="line">  return new MyPromise(resolve &#x3D;&gt; resolve(value))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><blockquote>
<p><code>Promise.reject()</code>方法返回一个带有拒绝原因的 Promise 对象。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;静态的reject方法</span><br><span class="line">static reject(reason) &#123;</span><br><span class="line">  return new MyPromise((resolve, reject) &#x3D;&gt; reject(reason))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><blockquote>
<p><code>Promise.all(iterable)</code>方法返回一个 Promise 实例，此实例在 iterable 参数内所有的 promise 都“完成（resolved）”或参数中不包含 promise 时回调完成（resolve）；如果参数中 promise 有一个失败（rejected），此实例回调失败（reject），失败原因的是第一个失败 promise 的结果。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;静态的all方法</span><br><span class="line">static all(promiseArr) &#123;</span><br><span class="line">  let index &#x3D; 0</span><br><span class="line">  let result &#x3D; []</span><br><span class="line">  return new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    promiseArr.forEach((p, i) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F;Promise.resolve(p)用于处理传入值不为Promise的情况</span><br><span class="line">      MyPromise.resolve(p).then(</span><br><span class="line">        val &#x3D;&gt; &#123;</span><br><span class="line">          index++</span><br><span class="line">          result[i] &#x3D; val</span><br><span class="line">          &#x2F;&#x2F;所有then执行后, resolve结果</span><br><span class="line">          if(index &#x3D;&#x3D;&#x3D; promiseArr.length) &#123;</span><br><span class="line">            resolve(result)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        err &#x3D;&gt; &#123;</span><br><span class="line">          &#x2F;&#x2F;有一个Promise被reject时，MyPromise的状态变为reject</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><blockquote>
<p><code>Promise.race(iterable)</code>方法返回一个 promise，一旦迭代器中的某个 promise 解决或拒绝，返回的 promise 就会解决或拒绝。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static race(promiseArr) &#123;</span><br><span class="line">  return new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;同时执行Promise,如果有一个Promise的状态发生改变,就变更新MyPromise的状态</span><br><span class="line">    for (let p of promiseArr) &#123;</span><br><span class="line">      MyPromise.resolve(p).then(  &#x2F;&#x2F;Promise.resolve(p)用于处理传入值不为Promise的情况</span><br><span class="line">        value &#x3D;&gt; &#123;</span><br><span class="line">          resolve(value)        &#x2F;&#x2F;注意这个resolve是上边new MyPromise的</span><br><span class="line">        &#125;,</span><br><span class="line">        err &#x3D;&gt; &#123;</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Promise&#x2F;A+规定的三种状态</span><br><span class="line">const PENDING &#x3D; &#39;pending&#39;</span><br><span class="line">const FULFILLED &#x3D; &#39;fulfilled&#39;</span><br><span class="line">const REJECTED &#x3D; &#39;rejected&#39;</span><br><span class="line"></span><br><span class="line">class MyPromise &#123;</span><br><span class="line">  &#x2F;&#x2F; 构造方法接收一个回调</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    this._status &#x3D; PENDING     &#x2F;&#x2F; Promise状态</span><br><span class="line">    this._value &#x3D; undefined    &#x2F;&#x2F; 储存then回调return的值</span><br><span class="line">    this._resolveQueue &#x3D; []    &#x2F;&#x2F; 成功队列, resolve时触发</span><br><span class="line">    this._rejectQueue &#x3D; []     &#x2F;&#x2F; 失败队列, reject时触发</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 由于resolve&#x2F;reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue</span><br><span class="line">    let _resolve &#x3D; (val) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F;把resolve执行回调的操作封装成一个函数,放进setTimeout里,以兼容executor是同步代码的情况</span><br><span class="line">      const run &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        if(this._status !&#x3D;&#x3D; PENDING) return   &#x2F;&#x2F; 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span><br><span class="line">        this._status &#x3D; FULFILLED              &#x2F;&#x2F; 变更状态</span><br><span class="line">        this._value &#x3D; val                     &#x2F;&#x2F; 储存当前value</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 这里之所以使用一个队列来储存回调,是为了实现规范要求的 &quot;then 方法可以被同一个 promise 调用多次&quot;</span><br><span class="line">        &#x2F;&#x2F; 如果使用一个变量而非队列来储存回调,那么即使多次p1.then()也只会执行一次回调</span><br><span class="line">        while(this._resolveQueue.length) &#123;</span><br><span class="line">          const callback &#x3D; this._resolveQueue.shift()</span><br><span class="line">          callback(val)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      setTimeout(run)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 实现同resolve</span><br><span class="line">    let _reject &#x3D; (val) &#x3D;&gt; &#123;</span><br><span class="line">      const run &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        if(this._status !&#x3D;&#x3D; PENDING) return   &#x2F;&#x2F; 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span><br><span class="line">        this._status &#x3D; REJECTED               &#x2F;&#x2F; 变更状态</span><br><span class="line">        this._value &#x3D; val                     &#x2F;&#x2F; 储存当前value</span><br><span class="line">        while(this._rejectQueue.length) &#123;</span><br><span class="line">          const callback &#x3D; this._rejectQueue.shift()</span><br><span class="line">          callback(val)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      setTimeout(run)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; new Promise()时立即执行executor,并传入resolve和reject</span><br><span class="line">    executor(_resolve, _reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; then方法,接收一个成功的回调和一个失败的回调</span><br><span class="line">  then(resolveFn, rejectFn) &#123;</span><br><span class="line">    &#x2F;&#x2F; 根据规范，如果then的参数不是function，则我们需要忽略它, 让链式调用继续往下执行</span><br><span class="line">    typeof resolveFn !&#x3D;&#x3D; &#39;function&#39; ? resolveFn &#x3D; value &#x3D;&gt; value : null</span><br><span class="line">    typeof rejectFn !&#x3D;&#x3D; &#39;function&#39; ? rejectFn &#x3D; reason &#x3D;&gt; &#123;</span><br><span class="line">      throw new Error(reason instanceof Error? reason.message:reason);</span><br><span class="line">    &#125; : null</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; return一个新的promise</span><br><span class="line">    return new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span><br><span class="line">      const fulfilledFn &#x3D; value &#x3D;&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          &#x2F;&#x2F; 执行第一个(当前的)Promise的成功回调,并获取返回值</span><br><span class="line">          let x &#x3D; resolveFn(value)</span><br><span class="line">          &#x2F;&#x2F; 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span><br><span class="line">          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; reject同理</span><br><span class="line">      const rejectedFn  &#x3D; error &#x3D;&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          let x &#x3D; rejectFn(error)</span><br><span class="line">          x instanceof MyPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      switch (this._status) &#123;</span><br><span class="line">        &#x2F;&#x2F; 当状态为pending时,把then回调push进resolve&#x2F;reject执行队列,等待执行</span><br><span class="line">        case PENDING:</span><br><span class="line">          this._resolveQueue.push(fulfilledFn)</span><br><span class="line">          this._rejectQueue.push(rejectedFn)</span><br><span class="line">          break;</span><br><span class="line">        &#x2F;&#x2F; 当状态已经变为resolve&#x2F;reject时,直接执行then回调</span><br><span class="line">        case FULFILLED:</span><br><span class="line">          fulfilledFn(this._value)    &#x2F;&#x2F; this._value是上一个then回调return的值(见完整版代码)</span><br><span class="line">          break;</span><br><span class="line">        case REJECTED:</span><br><span class="line">          rejectedFn(this._value)</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;catch方法其实就是执行一下then的第二个回调</span><br><span class="line">  catch(rejectFn) &#123;</span><br><span class="line">    return this.then(undefined, rejectFn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;finally方法</span><br><span class="line">  finally(callback) &#123;</span><br><span class="line">    return this.then(</span><br><span class="line">      value &#x3D;&gt; MyPromise.resolve(callback()).then(() &#x3D;&gt; value),             &#x2F;&#x2F;执行回调,并returnvalue传递给后面的then</span><br><span class="line">      reason &#x3D;&gt; MyPromise.resolve(callback()).then(() &#x3D;&gt; &#123; throw reason &#125;)  &#x2F;&#x2F;reject同理</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;静态的resolve方法</span><br><span class="line">  static resolve(value) &#123;</span><br><span class="line">    if(value instanceof MyPromise) return value &#x2F;&#x2F;根据规范, 如果参数是Promise实例, 直接return这个实例</span><br><span class="line">    return new MyPromise(resolve &#x3D;&gt; resolve(value))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;静态的reject方法</span><br><span class="line">  static reject(reason) &#123;</span><br><span class="line">    return new MyPromise((resolve, reject) &#x3D;&gt; reject(reason))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;静态的all方法</span><br><span class="line">  static all(promiseArr) &#123;</span><br><span class="line">    let index &#x3D; 0</span><br><span class="line">    let result &#x3D; []</span><br><span class="line">    return new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      promiseArr.forEach((p, i) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F;Promise.resolve(p)用于处理传入值不为Promise的情况</span><br><span class="line">        MyPromise.resolve(p).then(</span><br><span class="line">          val &#x3D;&gt; &#123;</span><br><span class="line">            index++</span><br><span class="line">            result[i] &#x3D; val</span><br><span class="line">            if(index &#x3D;&#x3D;&#x3D; promiseArr.length) &#123;</span><br><span class="line">              resolve(result)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          err &#x3D;&gt; &#123;</span><br><span class="line">            reject(err)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;静态的race方法</span><br><span class="line">  static race(promiseArr) &#123;</span><br><span class="line">    return new MyPromise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F;同时执行Promise,如果有一个Promise的状态发生改变,就变更新MyPromise的状态</span><br><span class="line">      for (let p of promiseArr) &#123;</span><br><span class="line">        MyPromise.resolve(p).then(  &#x2F;&#x2F;Promise.resolve(p)用于处理传入值不为Promise的情况</span><br><span class="line">          value &#x3D;&gt; &#123;</span><br><span class="line">            resolve(value)        &#x2F;&#x2F;注意这个resolve是上边new MyPromise的</span><br><span class="line">          &#125;,</span><br><span class="line">          err &#x3D;&gt; &#123;</span><br><span class="line">            reject(err)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>洋洋洒洒 150 多行的代码，到这里，我们终于可以给 Promise 的实现做一个结尾了。我们从一个最简单的 Promise 使用实例开始，通过对调用流程的分析，根据观察者模式实现了 Promise 的大致骨架，然后依据 Promise/A+规范填充代码，重点实现了 then 的链式调用，最后完成了 Promise 的静态/实例方法。其实 Promise 实现在整体上并没有太复杂的思想，但我们日常使用的时候往往忽略了很多 Promise 细节，因而很难写出一个符合规范的 Promise 实现，源码的实现过程，其实也是对 Promise 使用细节重新学习的过程。</p>
<h1 id="async-await-实现"><a href="#async-await-实现" class="headerlink" title="async/await 实现"></a>async/await 实现</h1><p>虽然前边花了这么多篇幅讲 Promise 的实现，不过探索<code>async/await</code>暂停执行的机制才是我们的初衷，下面我们就来进入这一块的内容。同样地，开头我们点一下 async/await 的使用意义。 在多个回调依赖的场景中，尽管 Promise 通过链式调用取代了回调嵌套，但过多的链式调用可读性仍然不佳，流程控制也不方便，ES7 提出的 async 函数，终于让 JS 对于异步操作有了终极解决方案，简洁优美地解决了以上两个问题。</p>
<blockquote>
<p>设想一个这样的场景，异步任务 a-&gt;b-&gt;c 之间存在依赖关系，如果我们通过 then 链式调用来处理这些关系，可读性并不是很好，如果我们想控制其中某个过程，比如在某些条件下，b 不往下执行到 c，那么也不是很方便控制</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(a)</span><br><span class="line">  .then(b &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(c &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是如果通过 async/await 来实现这个场景，可读性和流程控制都会方便不少。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async () &#x3D;&gt; &#123;</span><br><span class="line">  const a &#x3D; await Promise.resolve(a);</span><br><span class="line">  const b &#x3D; await Promise.resolve(b);</span><br><span class="line">  const c &#x3D; await Promise.resolve(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们要如何实现一个 async/await 呢，首先我们要知道，<strong>async/await 实际上是对 Generator（生成器）的封装</strong>，是一个语法糖。由于 Generator 出现不久就被 async/await 取代了，很多同学对 Generator 比较陌生，因此我们先来看看 Generator 的用法：</p>
<blockquote>
<p>ES6 新引入了 Generator 函数，可以通过 yield 关键字，把函数的执行流挂起，通过 next()方法可以切换到下一个状态，为改变执行流程提供了可能，从而为异步编程提供解决方案。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function* myGenerator() &#123;</span><br><span class="line">  yield &#39;1&#39;</span><br><span class="line">  yield &#39;2&#39;</span><br><span class="line">  return &#39;3&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const gen &#x3D; myGenerator();  &#x2F;&#x2F; 获取迭代器</span><br><span class="line">gen.next()  &#x2F;&#x2F;&#123;value: &quot;1&quot;, done: false&#125;</span><br><span class="line">gen.next()  &#x2F;&#x2F;&#123;value: &quot;2&quot;, done: false&#125;</span><br><span class="line">gen.next()  &#x2F;&#x2F;&#123;value: &quot;3&quot;, done: true&#125;</span><br></pre></td></tr></table></figure>

<p>也可以通过给<code>next()</code>传参, 让 yield 具有返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function* myGenerator() &#123;</span><br><span class="line">  console.log(yield &#39;1&#39;)  &#x2F;&#x2F;test1</span><br><span class="line">  console.log(yield &#39;2&#39;)  &#x2F;&#x2F;test2</span><br><span class="line">  console.log(yield &#39;3&#39;)  &#x2F;&#x2F;test3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取迭代器</span><br><span class="line">const gen &#x3D; myGenerator();</span><br><span class="line"></span><br><span class="line">gen.next()</span><br><span class="line">gen.next(&#39;test1&#39;)</span><br><span class="line">gen.next(&#39;test2&#39;)</span><br><span class="line">gen.next(&#39;test3&#39;)</span><br></pre></td></tr></table></figure>

<p>我们看到 Generator 的用法，应该️会感到很熟悉，<code>*/yield</code>和<code>async/await</code>看起来其实已经很相似了，它们都提供了暂停执行的功能，但二者又有三点不同：</p>
<ul>
<li><code>async/await</code>自带执行器，不需要手动调用 next()就能自动执行下一步</li>
<li><code>async</code>函数返回值是 Promise 对象，而 Generator 返回的是生成器对象</li>
<li><code>await</code>能够返回 Promise 的 resolve/reject 的值</li>
</ul>
<p><strong>我们对 async/await 的实现，其实也就是对应以上三点封装 Generator</strong></p>
<h2 id="1-自动执行"><a href="#1-自动执行" class="headerlink" title="1.自动执行"></a>1.自动执行</h2><p>我们先来看一下，对于这样一个 Generator，手动执行是怎样一个流程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function* myGenerator() &#123;</span><br><span class="line">  yield Promise.resolve(1);</span><br><span class="line">  yield Promise.resolve(2);</span><br><span class="line">  yield Promise.resolve(3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 手动执行迭代器</span><br><span class="line">const gen &#x3D; myGenerator()</span><br><span class="line">gen.next().value.then(val &#x3D;&gt; &#123;</span><br><span class="line">  console.log(val)</span><br><span class="line">  gen.next().value.then(val &#x3D;&gt; &#123;</span><br><span class="line">    console.log(val)</span><br><span class="line">    gen.next().value.then(val &#x3D;&gt; &#123;</span><br><span class="line">      console.log(val)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出1 2 3</span><br></pre></td></tr></table></figure>

<p>我们也可以通过给<code>gen.next()</code>传值的方式，让 yield 能返回 resolve 的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function* myGenerator() &#123;</span><br><span class="line">  console.log(yield Promise.resolve(1))   &#x2F;&#x2F;1</span><br><span class="line">  console.log(yield Promise.resolve(2))   &#x2F;&#x2F;2</span><br><span class="line">  console.log(yield Promise.resolve(3))   &#x2F;&#x2F;3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 手动执行迭代器</span><br><span class="line">const gen &#x3D; myGenerator()</span><br><span class="line">gen.next().value.then(val &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; console.log(val)</span><br><span class="line">  gen.next(val).value.then(val &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; console.log(val)</span><br><span class="line">    gen.next(val).value.then(val &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; console.log(val)</span><br><span class="line">      gen.next(val)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>显然，手动执行的写法看起来既笨拙又丑陋，我们希望生成器函数能自动往下执行，且 yield 能返回 resolve 的值，基于这两个需求，我们进行一个基本的封装，这里<code>async/await</code>是关键字，不能重写，我们用函数来模拟：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function run(gen) &#123;</span><br><span class="line">  var g &#x3D; gen()                     &#x2F;&#x2F;由于每次gen()获取到的都是最新的迭代器,因此获取迭代器操作要放在_next()之前,否则会进入死循环</span><br><span class="line"></span><br><span class="line">  function _next(val) &#123;             &#x2F;&#x2F;封装一个方法, 递归执行g.next()</span><br><span class="line">    var res &#x3D; g.next(val)           &#x2F;&#x2F;获取迭代器对象，并返回resolve的值</span><br><span class="line">    if(res.done) return res.value   &#x2F;&#x2F;递归终止条件</span><br><span class="line">    res.value.then(val &#x3D;&gt; &#123;         &#x2F;&#x2F;Promise的then方法是实现自动迭代的前提</span><br><span class="line">      _next(val)                    &#x2F;&#x2F;等待Promise完成就自动执行下一个next，并传入resolve的值</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  _next()  &#x2F;&#x2F;第一次执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于我们之前的例子，我们就能这样执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function* myGenerator() &#123;</span><br><span class="line">  console.log(yield Promise.resolve(1))   &#x2F;&#x2F;1</span><br><span class="line">  console.log(yield Promise.resolve(2))   &#x2F;&#x2F;2</span><br><span class="line">  console.log(yield Promise.resolve(3))   &#x2F;&#x2F;3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(myGenerator)</span><br></pre></td></tr></table></figure>

<p>这样我们就初步实现了一个<code>async/await</code>。上边的代码只有五六行，但并不是一下就能看明白的，我们之前用了四个例子来做铺垫，也是为了让读者更好地理解这段代码。 简单来说，我们封装了一个 run 方法，run 方法里我们把执行下一步的操作封装成<code>_next()</code>，每次 Promise.then()的时候都去执行<code>_next()</code>，实现自动迭代的效果。在迭代的过程中，我们还把 resolve 的值传入<code>gen.next()</code>，使得 yield 得以返回 Promise 的 resolve 的值</p>
<blockquote>
<p>这里插一句，是不是只有<code>.then方法</code>这样的形式才能完成我们自动执行的功能呢？答案是否定的，yield 后边除了接 Promise，还可以接<code>thunk函数</code>，thunk 函数不是一个新东西，所谓 thunk 函数，就是<strong>单参的只接受回调的函数</strong>，详细介绍可以看<a target="_blank" rel="noopener" href="https://user-gold-cdn.xitu.io/2020/3/15/170dc5e88df6c208">阮一峰 Thunk 函数的含义和用法</a>，无论是 Promise 还是 thunk 函数，其核心都是通过<strong>传入回调</strong>的方式来实现 Generator 的自动执行。thunk 函数只作为一个拓展知识，理解有困难的同学也可以跳过这里，并不影响后续理解。</p>
</blockquote>
<h2 id="2-返回-Promise-amp-异常处理"><a href="#2-返回-Promise-amp-异常处理" class="headerlink" title="2.返回 Promise &amp; 异常处理"></a>2.返回 Promise &amp; 异常处理</h2><p>虽然我们实现了 Generator 的自动执行以及让 yield 返回 resolve 的值，但上边的代码还存在着几点问题：</p>
<ol>
<li><strong>需要兼容基本类型</strong>：这段代码能自动执行的前提是<code>yield</code>后面跟 Promise，为了兼容后面跟着基本类型值的情况，我们需要把 yield 跟的内容(<code>gen().next.value</code>)都用<code>Promise.resolve()</code>转化一遍</li>
<li><strong>缺少错误处理</strong>：上边代码里的 Promise 如果执行失败，就会导致后续执行直接中断，我们需要通过调用<code>Generator.prototype.throw()</code>，把错误抛出来，才能被外层的 try-catch 捕获到</li>
<li><strong>返回值是 Promise</strong>：<code>async/await</code>的返回值是一个 Promise，我们这里也需要保持一致，给返回值包一个 Promise</li>
</ol>
<p>我们改造一下 run 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function run(gen) &#123;</span><br><span class="line">  &#x2F;&#x2F;把返回值包装成promise</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    var g &#x3D; gen()</span><br><span class="line"></span><br><span class="line">    function _next(val) &#123;</span><br><span class="line">      &#x2F;&#x2F;错误处理</span><br><span class="line">      try &#123;</span><br><span class="line">        var res &#x3D; g.next(val)</span><br><span class="line">      &#125; catch(err) &#123;</span><br><span class="line">        return reject(err);</span><br><span class="line">      &#125;</span><br><span class="line">      if(res.done) &#123;</span><br><span class="line">        return resolve(res.value);</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F;res.value包装为promise，以兼容yield后面跟基本类型的情况</span><br><span class="line">      Promise.resolve(res.value).then(</span><br><span class="line">        val &#x3D;&gt; &#123;</span><br><span class="line">          _next(val);</span><br><span class="line">        &#125;,</span><br><span class="line">        err &#x3D;&gt; &#123;</span><br><span class="line">          &#x2F;&#x2F;抛出错误</span><br><span class="line">          g.throw(err)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    _next();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们可以测试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function* myGenerator() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    console.log(yield Promise.resolve(1))</span><br><span class="line">    console.log(yield 2)   &#x2F;&#x2F;2</span><br><span class="line">    console.log(yield Promise.reject(&#39;error&#39;))</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    console.log(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const result &#x3D; run(myGenerator)     &#x2F;&#x2F;result是一个Promise</span><br><span class="line">&#x2F;&#x2F;输出 1 2 error</span><br></pre></td></tr></table></figure>

<p>到这里，一个<code>async/await</code>的实现基本完成了。最后我们可以看一下 babel 对 async/await 的转换结果，其实整体的思路是一样的，但是写法稍有不同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;相当于我们的run()</span><br><span class="line">function _asyncToGenerator(fn) &#123;</span><br><span class="line">  &#x2F;&#x2F; return一个function，和async保持一致。我们的run直接执行了Generator，其实是不太规范的</span><br><span class="line">  return function() &#123;</span><br><span class="line">    var self &#x3D; this</span><br><span class="line">    var args &#x3D; arguments</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">      var gen &#x3D; fn.apply(self, args);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;相当于我们的_next()</span><br><span class="line">      function _next(value) &#123;</span><br><span class="line">        asyncGeneratorStep(gen, resolve, reject, _next, _throw, &#39;next&#39;, value);</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F;处理异常</span><br><span class="line">      function _throw(err) &#123;</span><br><span class="line">        asyncGeneratorStep(gen, resolve, reject, _next, _throw, &#39;throw&#39;, err);</span><br><span class="line">      &#125;</span><br><span class="line">      _next(undefined);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    var info &#x3D; gen[key](arg);</span><br><span class="line">    var value &#x3D; info.value;</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  if (info.done) &#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    Promise.resolve(value).then(_next, _throw);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const foo &#x3D; _asyncToGenerator(function* () &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    console.log(yield Promise.resolve(1))   &#x2F;&#x2F;1</span><br><span class="line">    console.log(yield 2)                    &#x2F;&#x2F;2</span><br><span class="line">    return &#39;3&#39;</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    console.log(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">foo().then(res &#x3D;&gt; &#123;</span><br><span class="line">  console.log(res)                          &#x2F;&#x2F;3</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>有关<code>async/await</code>的实现，到这里就告一段落了。但是直到结尾，我们也不知道 await 到底是如何暂停执行的，有关 await 暂停执行的秘密，我们还要到 Generator 的实现中去寻找答案</p>
<h1 id="Generator-实现"><a href="#Generator-实现" class="headerlink" title="Generator 实现"></a>Generator 实现</h1><p>我们从一个简单的 Generator 使用实例开始，一步步探究 Generator 的实现原理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function* foo() &#123;</span><br><span class="line">  yield &#39;result1&#39;</span><br><span class="line">  yield &#39;result2&#39;</span><br><span class="line">  yield &#39;result3&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const gen &#x3D; foo()</span><br><span class="line">console.log(gen.next().value)</span><br><span class="line">console.log(gen.next().value)</span><br><span class="line">console.log(gen.next().value)</span><br></pre></td></tr></table></figure>

<p>我们可以在<a target="_blank" rel="noopener" href="https://babeljs.io/repl/#?browsers=&build=&builtIns=false&spec=false&loose=false&code_lz=GYVwdgxgLglg9mAVAAmHOAKAlMg3gKGWQE8YBTAGwBNkByAJzIGcQKoBGWwk86uxlmwBMXIqUo0GzVlADMXAL7d8EBEyjIA5mTDIAvKnTYVauBTIA6CnE0ZtYC2DIAPKNgsA3AIYUQZLCZgTGaW1rb2ji5uWJ4-fgGqQSFWNnY6ka7u3r7-QA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=false&fileSize=false&timeTravel=false&sourceType=module&lineWrap=true&presets=es2015%2Creact%2Cstage-2&prettier=false&targets=&version=7.5.5&externalPlugins=">babel 官网</a>上在线转化这段代码，看看 ES5 环境下是如何实现 Generator 的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">var _marked &#x3D;</span><br><span class="line">&#x2F;*#__PURE__*&#x2F;</span><br><span class="line">regeneratorRuntime.mark(foo);</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">  return regeneratorRuntime.wrap(function foo$(_context) &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">      switch (_context.prev &#x3D; _context.next) &#123;</span><br><span class="line">        case 0:</span><br><span class="line">          _context.next &#x3D; 2;</span><br><span class="line">          return &#39;result1&#39;;</span><br><span class="line"></span><br><span class="line">        case 2:</span><br><span class="line">          _context.next &#x3D; 4;</span><br><span class="line">          return &#39;result2&#39;;</span><br><span class="line"></span><br><span class="line">        case 4:</span><br><span class="line">          _context.next &#x3D; 6;</span><br><span class="line">          return &#39;result3&#39;;</span><br><span class="line"></span><br><span class="line">        case 6:</span><br><span class="line">        case &quot;end&quot;:</span><br><span class="line">          return _context.stop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, _marked);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var gen &#x3D; foo();</span><br><span class="line">console.log(gen.next().value);</span><br><span class="line">console.log(gen.next().value);</span><br><span class="line">console.log(gen.next().value);</span><br></pre></td></tr></table></figure>

<p>代码咋一看不长，但如果仔细观察会发现有两个不认识的东西 —— <code>regeneratorRuntime.mark</code>和<code>regeneratorRuntime.wrap</code>，这两者其实是 regenerator-runtime 模块里的两个方法，regenerator-runtime 模块来自 facebook 的 regenerator 模块，完整代码在<a target="_blank" rel="noopener" href="https://github.com/facebook/regenerator/blob/master/packages/regenerator-runtime/runtime.js">runtime.js</a>，这个 runtime 有 700 多行…-_-||，因此我们不能全讲，不太重要的部分我们就简单地过一下，重点讲解暂停执行相关部分代码</p>
<blockquote>
<p>个人觉得啃源码的效果不是很好，建议读者拉到末尾先看结论和简略版实现，源码作为一个补充理解</p>
</blockquote>
<h2 id="regeneratorRuntime-mark"><a href="#regeneratorRuntime-mark" class="headerlink" title="regeneratorRuntime.mark()"></a>regeneratorRuntime.mark()</h2><p><code>regeneratorRuntime.mark(foo)</code>这个方法在第一行被调用，我们先看一下 runtime 里 mark()方法的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;runtime.js里的定义稍有不同，多了一些判断，以下是编译后的代码</span><br><span class="line">runtime.mark &#x3D; function(genFun) &#123;</span><br><span class="line">  genFun.__proto__ &#x3D; GeneratorFunctionPrototype;</span><br><span class="line">  genFun.prototype &#x3D; Object.create(Gp);</span><br><span class="line">  return genFun;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里边<code>GeneratorFunctionPrototype</code>和<code>Gp</code>我们都不认识，他们被定义在 runtime 里，不过没关系，我们只要知道<code>mark()方法</code>为生成器函数（foo）绑定了一系列原型就可以了，这里就简单地过了</p>
<h2 id="regeneratorRuntime-wrap"><a href="#regeneratorRuntime-wrap" class="headerlink" title="regeneratorRuntime.wrap()"></a>regeneratorRuntime.wrap()</h2><p>从上面 babel 转化的代码我们能看到，执行<code>foo()</code>，其实就是执行<code>wrap()</code>，那么这个方法起到什么作用呢，他想包装一个什么东西呢，我们先来看看 wrap 方法的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;runtime.js里的定义稍有不同，多了一些判断，以下是编译后的代码</span><br><span class="line">function wrap(innerFn, outerFn, self) &#123;</span><br><span class="line">  var generator &#x3D; Object.create(outerFn.prototype);</span><br><span class="line">  var context &#x3D; new Context([]);</span><br><span class="line">  generator._invoke &#x3D; makeInvokeMethod(innerFn, self, context);</span><br><span class="line"></span><br><span class="line">  return generator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>wrap 方法先是创建了一个 generator，并继承<code>outerFn.prototype</code>；然后 new 了一个<code>context对象</code>；<code>makeInvokeMethod方法</code>接收<code>innerFn(对应foo$)</code>、<code>context</code>和<code>this</code>，并把返回值挂到<code>generator._invoke</code>上；最后 return 了 generator。<strong>其实 wrap()相当于是给 generator 增加了一个_invoke 方法</strong></p>
<p>这段代码肯定让人产生很多疑问，outerFn.prototype 是什么，Context 又是什么，makeInvokeMethod 又做了哪些操作。下面我们就来一一解答：</p>
<blockquote>
<p><code>outerFn.prototype</code>其实就是<code>genFun.prototype</code>，</p>
</blockquote>
<p>这个我们结合一下上面的代码就能知道</p>
<blockquote>
<p><code>context</code>可以直接理解为这样一个全局对象，用于储存各种状态和上下文：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var ContinueSentinel &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">var context &#x3D; &#123;</span><br><span class="line">  done: false,</span><br><span class="line">  method: &quot;next&quot;,</span><br><span class="line">  next: 0,</span><br><span class="line">  prev: 0,</span><br><span class="line">  abrupt: function(type, arg) &#123;</span><br><span class="line">    var record &#x3D; &#123;&#125;;</span><br><span class="line">    record.type &#x3D; type;</span><br><span class="line">    record.arg &#x3D; arg;</span><br><span class="line"></span><br><span class="line">    return this.complete(record);</span><br><span class="line">  &#125;,</span><br><span class="line">  complete: function(record, afterLoc) &#123;</span><br><span class="line">    if (record.type &#x3D;&#x3D;&#x3D; &quot;return&quot;) &#123;</span><br><span class="line">      this.rval &#x3D; this.arg &#x3D; record.arg;</span><br><span class="line">      this.method &#x3D; &quot;return&quot;;</span><br><span class="line">      this.next &#x3D; &quot;end&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ContinueSentinel;</span><br><span class="line">  &#125;,</span><br><span class="line">  stop: function() &#123;</span><br><span class="line">    this.done &#x3D; true;</span><br><span class="line">    return this.rval;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>makeInvokeMethod</code>的定义如下，它 return 了一个<code>invoke方法</code>，invoke 用于判断当前状态和执行下一步，其实就是我们调用的<code>next()</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;以下是编译后的代码</span><br><span class="line">function makeInvokeMethod(innerFn, context) &#123;</span><br><span class="line">  &#x2F;&#x2F; 将状态置为start</span><br><span class="line">  var state &#x3D; &quot;start&quot;;</span><br><span class="line"></span><br><span class="line">  return function invoke(method, arg) &#123;</span><br><span class="line">    &#x2F;&#x2F; 已完成</span><br><span class="line">    if (state &#x3D;&#x3D;&#x3D; &quot;completed&quot;) &#123;</span><br><span class="line">      return &#123; value: undefined, done: true &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    context.method &#x3D; method;</span><br><span class="line">    context.arg &#x3D; arg;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 执行中</span><br><span class="line">    while (true) &#123;</span><br><span class="line">      state &#x3D; &quot;executing&quot;;</span><br><span class="line"></span><br><span class="line">      var record &#x3D; &#123;</span><br><span class="line">        type: &quot;normal&quot;,</span><br><span class="line">        arg: innerFn.call(self, context)    &#x2F;&#x2F; 执行下一步,并获取状态(其实就是switch里边return的值)</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      if (record.type &#x3D;&#x3D;&#x3D; &quot;normal&quot;) &#123;</span><br><span class="line">        &#x2F;&#x2F; 判断是否已经执行完成</span><br><span class="line">        state &#x3D; context.done ? &quot;completed&quot; : &quot;yield&quot;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; ContinueSentinel其实是一个空对象,record.arg &#x3D;&#x3D;&#x3D; &#123;&#125;则跳过return进入下一个循环</span><br><span class="line">        &#x2F;&#x2F; 什么时候record.arg会为空对象呢, 答案是没有后续yield语句或已经return的时候,也就是switch返回了空值的情况(跟着上面的switch走一下就知道了)</span><br><span class="line">        if (record.arg &#x3D;&#x3D;&#x3D; ContinueSentinel) &#123;</span><br><span class="line">          continue;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; next()的返回值</span><br><span class="line">        return &#123;</span><br><span class="line">          value: record.arg,</span><br><span class="line">          done: context.done</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么<code>generator._invoke</code>实际上就是<code>gen.next</code>呢，因为在 runtime 对于 next()的定义中，next()其实就 return 了_invoke 方法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Helper for defining the .next, .throw, and .return methods of the</span><br><span class="line">&#x2F;&#x2F; Iterator interface in terms of a single ._invoke method.</span><br><span class="line">function defineIteratorMethods(prototype) &#123;</span><br><span class="line">    [&quot;next&quot;, &quot;throw&quot;, &quot;return&quot;].forEach(function(method) &#123;</span><br><span class="line">      prototype[method] &#x3D; function(arg) &#123;</span><br><span class="line">        return this._invoke(method, arg);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defineIteratorMethods(Gp);</span><br></pre></td></tr></table></figure>

<h2 id="低配实现-amp-调用流程分析"><a href="#低配实现-amp-调用流程分析" class="headerlink" title="低配实现 &amp; 调用流程分析"></a>低配实现 &amp; 调用流程分析</h2><p>这么一遍源码下来，估计很多读者还是懵逼的，毕竟源码中纠集了很多概念和封装，一时半会不好完全理解，让我们跳出源码，实现一个简单的 Generator，然后再回过头看源码，会得到更清晰的认识</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 生成器函数根据yield语句将代码分割为switch-case块，后续通过切换_context.prev和_context.next来分别执行各个case</span><br><span class="line">function gen$(_context) &#123;</span><br><span class="line">  while (1) &#123;</span><br><span class="line">    switch (_context.prev &#x3D; _context.next) &#123;</span><br><span class="line">      case 0:</span><br><span class="line">        _context.next &#x3D; 2;</span><br><span class="line">        return &#39;result1&#39;;</span><br><span class="line"></span><br><span class="line">      case 2:</span><br><span class="line">        _context.next &#x3D; 4;</span><br><span class="line">        return &#39;result2&#39;;</span><br><span class="line"></span><br><span class="line">      case 4:</span><br><span class="line">        _context.next &#x3D; 6;</span><br><span class="line">        return &#39;result3&#39;;</span><br><span class="line"></span><br><span class="line">      case 6:</span><br><span class="line">      case &quot;end&quot;:</span><br><span class="line">        return _context.stop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 低配版context</span><br><span class="line">var context &#x3D; &#123;</span><br><span class="line">  next:0,</span><br><span class="line">  prev: 0,</span><br><span class="line">  done: false,</span><br><span class="line">  stop: function stop () &#123;</span><br><span class="line">    this.done &#x3D; true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 低配版invoke</span><br><span class="line">let gen &#x3D; function() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    next: function() &#123;</span><br><span class="line">      value &#x3D; context.done ? undefined: gen$(context)</span><br><span class="line">      done &#x3D; context.done</span><br><span class="line">      return &#123;</span><br><span class="line">        value,</span><br><span class="line">        done</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 测试使用</span><br><span class="line">var g &#x3D; gen()</span><br><span class="line">g.next()  &#x2F;&#x2F; &#123;value: &quot;result1&quot;, done: false&#125;</span><br><span class="line">g.next()  &#x2F;&#x2F; &#123;value: &quot;result2&quot;, done: false&#125;</span><br><span class="line">g.next()  &#x2F;&#x2F; &#123;value: &quot;result3&quot;, done: false&#125;</span><br><span class="line">g.next()  &#x2F;&#x2F; &#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码并不难理解，我们分析一下调用流程：</p>
<ol>
<li><p>我们定义的<code>function*</code>生成器函数被转化为以上代码</p>
</li>
<li><p>转化后的代码分为三大块：</p>
<ul>
<li><code>gen$(_context)</code>由 yield 分割生成器函数代码而来</li>
<li><code>context对象</code>用于储存函数执行上下文</li>
<li><code>invoke()方法</code>定义 next()，用于执行 gen$(_context)来跳到下一步</li>
</ul>
</li>
<li><p>当我们调用<code>g.next()</code>，就相当于调用<code>invoke()方法</code>，执行<code>gen$(_context)</code>，进入 switch 语句，switch 根据 context 的标识，执行对应的 case 块，return 对应结果</p>
</li>
<li><p>当生成器函数运行到末尾（没有下一个 yield 或已经 return），switch 匹配不到对应代码块，就会 return 空值，这时<code>g.next()</code>返回<code>&#123;value: undefined, done: true&#125;</code></p>
</li>
</ol>
<p>从中我们可以看出，<strong>Generator 实现的核心在于</strong><code>**上下文的保存**</code><strong>，函数并没有真的被挂起，每一次 yield，其实都执行了一遍传入的生成器函数，只是在这个过程中间用了一个 context 对象储存上下文，使得每次执行生成器函数的时候，都可以从上一个执行结果开始执行，看起来就像函数被挂起了一样</strong></p>
<h1 id="总结-amp-致谢"><a href="#总结-amp-致谢" class="headerlink" title="总结 &amp; 致谢"></a>总结 &amp; 致谢</h1><p>有关 Promise、async/await、Generator 的原理就实现到这里了，感谢大家能够跟我一起走完全程，不知不觉，我们花了近 9 千字来讲述有关异步编程的故事，异步编程的世界环环相扣，一开始，笔者只是出于对 await 挂起机制的好奇，后来，从一个 “await 是如何实现暂停执行” 的小问题，引出了对异步编程的一系列思考和实现原理。三者的实现，其实也是前端异步编程一步步演化推进的过程。</p>
<p>成文过程中得到很多大佬的帮助，这四篇参考文章都是我阅读了很多相关文章后精选的四篇，建议大家结合阅读，大佬们写的比我好很多，另外感谢冴羽大佬在 Generator 机制上给予的解惑~</p>
<blockquote>
<p>前端技匠：<a target="_blank" rel="noopener" href="https://juejin.im/post/6844903989083897870">各种源码实现，你想要的这里都有</a></p>
</blockquote>
<p>神三元：<a target="_blank" rel="noopener" href="https://juejin.im/post/6844903702457925640">我如何实现 Promise</a></p>
<p>winty：<a target="_blank" rel="noopener" href="https://juejin.im/post/6844903988584775693#heading-0">async/await 原理及执行顺序分析</a></p>
<p>冴羽：<a target="_blank" rel="noopener" href="https://juejin.im/post/6844903701908291592">ES6 系列之 Babel 将 Generator 编译成了什么样子</a></p>
<p><strong>最后卑微求个赞 Thanks♪(･ω･)ﾉ</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619261369471-9f4febb6-72fb-41b7-a3bb-60cfeb077c95.jpeg#clientId=u0787e3d2-71b0-4&from=drop&id=u5e819ff0&margin=%5Bobject%20Object%5D&name=2.jpg&originHeight=380&originWidth=714&originalType=binary&size=85453&status=done&style=none&taskId=ua85c3f64-ca03-48e4-bfca-25b503824f6" alt="2.jpg"></p>
<blockquote>
<p>往期文章</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/6844904036013965325">10 行代码看尽 redux 实现 —— 全面剖析 redux &amp; react-redux &amp; redux 中间件设计实现 | 8k 字</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/6844904006175686669">红黑树上红黑果，红黑树下你和我 —— 红黑树入门 | 6k 字</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/6844904000387563533">SSR 从入门到放弃 —— 深入 React 服务端渲染原理 | 1W 字</a>？</li>
</ol>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/23/yuque/%E5%8A%A8%E7%94%BB%E6%80%A7%E8%83%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/23/yuque/%E5%8A%A8%E7%94%BB%E6%80%A7%E8%83%BD/" class="post-title-link" itemprop="url">动画性能</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-23 13:33:32" itemprop="dateCreated datePublished" datetime="2021-04-23T13:33:32+08:00">2021-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 18:36:15" itemprop="dateModified" datetime="2021-04-29T18:36:15+08:00">2021-04-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>先总结几个要点<br><strong>精简 DOM，合理布局</strong><br><strong>使用 transform 代替 left、top 减少使用引起页面重排的属性</strong><br><strong>开启硬件加速</strong><br><strong>尽量避免浏览器创建不必要的图形层</strong><br><strong>尽量减少 js 动画，如需要，使用对性能友好的 requestAnimationFrame</strong><br><strong>使用 chrome performance 工具调试动画性能</strong></p>
<p>我们知道网页动画的每一帧都是一次重新渲染，每秒低于 24 镇的动画，人眼就能感受到停顿，每秒 30-60 帧才能比较流畅 浏览器会按照大多数显示器的刷新频率 60Hz 来刷新动画， 如果想达到 60FPS,就意味着每一帧的任务耗时不能高于 16 毫秒。</p>
<p>通过下图我们可以了解浏览器渲染每一帧的过程<br><img src="https://cdn.nlark.com/yuque/0/2021/webp/21377586/1619156045002-3bd51fc7-149d-4148-8cdb-8f69404dc3db.webp#clientId=u31f05833-5d5b-4&from=paste&height=343&id=u16107b32&margin=%5Bobject%20Object%5D&originHeight=343&originWidth=720&originalType=url&status=done&style=none&taskId=u333ca95c-b807-450e-8286-cfd761dd888&width=720"></p>
<ul>
<li>1.JavaScript。一般来说，我们会使用 JavaScript 来实现一些视觉变化的效果。比如用 jQuery 的 animate 函数做一个动画、对一个数据集进行排序或者往页面里添加一些 DOM 元素等。当然，除了 JavaScript，还有其他一些常用方法也可以实现视觉变化效果，比如：CSS Animations、Transitions 和 Web Animation API。</li>
<li>2.样式计算。此过程是根据匹配选择器（例如 .headline 或 .nav &gt; .nav__item）计算出哪些元素应用哪些 CSS 3. 规则的过程。从中知道规则之后，将应用规则并计算每个元素的最终样式。</li>
<li>3.布局。在知道对一个元素应用哪些规则之后，浏览器即可开始计算它要占据的空间大小及其在屏幕的位置。网页的布局模式意味着一个元素可能影响其他元素，例如 元素的宽度一般会影响其子元素的宽度以及树中各处的节点，因此对于浏览器来说，布局过程是经常发生的。</li>
<li>4.绘制。绘制是填充像素的过程。它涉及绘出文本、颜色、图像、边框和阴影，基本上包括元素的每个可视部分。绘制一般是在多个表面（通常称为层）上完成的。</li>
<li>5.合成。由于页面的各部分可能被绘制到多层，由此它们需要按正确顺序绘制到屏幕上，以便正确渲染页面。对于与另一元素重叠的元素来说，这点特别重要，因为一个错误可能使一个元素错误地出现在另一个元素的上层。</li>
<li>“生成布局”（flow）和”绘制”（paint）这两步，合称为”渲染”（render）。重新渲染就是需要重新生成布局和重新绘制。 有上述的渲染流水线我们可以得知重绘不一定需要重排，重排必然导致重绘</li>
<li>重排和重绘会不断触发，这是不可避免的。但是，它们非常耗费资源，是导致网页性能低下的根本原因。 提高网页性能，就是要降低”重排”和”重绘”的频率和成本，尽量少触发重新渲染。</li>
<li>重排还重绘会消耗大量的 CPU 和 GPU 资源，前端新能优化最主要的优化点就是尽量减少重绘和重排。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/21377586/1619156083886-901015cf-1400-451a-ba59-92d020065dcb.webp#clientId=u31f05833-5d5b-4&from=paste&height=343&id=u1605db33&margin=%5Bobject%20Object%5D&originHeight=343&originWidth=720&originalType=url&status=done&style=none&taskId=udccd0b91-b739-46c6-9380-cb2ecd9cfc4&width=720"></p>
<h1 id="影响网页渲染的因素"><a href="#影响网页渲染的因素" class="headerlink" title="影响网页渲染的因素"></a>影响网页渲染的因素</h1><p>其中最简单的，样式表越简单，重绘和重排越快，重绘和重排的 DOM 元素层级越高，成本就越高，所以我们在开发前端页面时就需要精简 DOM 元素，合理布局。<br>另外 Table 元素的重排和重绘成本要高于 div，所以我们提倡使用 div+css 布局，尽量避免使用 table 布局。<br>还有其他对渲染性能有影响的操作，比如：</p>
<ul>
<li>DOM 元素读写分离</li>
<li>让进行大量动画的元素脱离文档流，减少重排开销</li>
<li>通过改变元素的 class 或 csstext 一次性的更改样式</li>
<li>缓存 DOM 元素的位置信息，避免不必要的属性读取</li>
<li>尽量使用离线 DOM</li>
<li>使用 css3 transform 优化动画性能</li>
</ul>
<h1 id="使用-css3-transform"><a href="#使用-css3-transform" class="headerlink" title="使用 css3 transform"></a>使用 css3 transform</h1><p>该 CSS 属性可以旋转，缩放，倾斜，或者上传给定的元素。这是通过修改 CSS 可视格式模型的坐标空间来实现的。<br>如果该属性的值不是 none，则会创建一个堆叠上下文。在这种情况下，该对象将充当 position: fixed 的包含块（所以 position: fixed 的元素将会被他覆盖）。</p>
<p><strong>css3 transform 的执行效率</strong><br>我们通过一个例子来解释为什么 transform 的动画执行效果更佳。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 对应图<span class="number">1</span>-- &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">transition</span>: height <span class="number">1s</span> linear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 对应图<span class="number">2</span> -- &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">transition</span>: transform <span class="number">1s</span> linear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个从 height: 100px 到 height: 200px 的 动画按照下面的流程图来执行各种操作 橙色方框的操作比较耗时，绿色方框的操作比较快速<br><img src="https://cdn.nlark.com/yuque/0/2021/webp/21377586/1619156167485-d5405de1-1137-43f6-a0fb-4f771e179840.webp#clientId=u31f05833-5d5b-4&from=paste&height=1025&id=uc382e09a&margin=%5Bobject%20Object%5D&originHeight=1025&originWidth=455&originalType=url&status=done&style=none&taskId=u1c0285ca-7c7f-4067-8a14-431f977d49d&width=455"><br><img src="https://cdn.nlark.com/yuque/0/2021/webp/21377586/1619156180032-59cfbfa7-4237-41ed-8435-2d49044fabfe.webp#clientId=u31f05833-5d5b-4&from=paste&height=844&id=udfd3f826&margin=%5Bobject%20Object%5D&originHeight=844&originWidth=510&originalType=url&status=done&style=none&taskId=u9a529281-896c-46be-9a13-9eaeec7a309&width=510"><br>因为每一帧的变化浏览器都在进行布局、绘制、把新的位图交给 GPU 内存，但是在将位图加载到 GPU 内存中的操作是个相对耗时的操作。<br>GPU 在如下方面很快：</p>
<ul>
<li>绘制位图到屏幕上</li>
<li>可不断的绘制相同的位图</li>
<li>将同一位图进行位移、旋转、缩放</li>
</ul>
<p>我们看使用了 transform 属性的动画执行过程（图二），这个无疑是效率最优的执行方式。</p>
<h1 id="层的引入（参考-无线性能优化：Composite）"><a href="#层的引入（参考-无线性能优化：Composite）" class="headerlink" title="层的引入（参考-无线性能优化：Composite）"></a>层的引入（<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://taobaofed.org/blog/2016/04/25/performance-composite/">参考-无线性能优化：Composite</a>）</h1><p>页面一旦在装入并解析完成后，就会表示为许多 Web 开发者所熟悉的结构：DOM。然而，在页面的渲染过程中，浏览器还具有一系列并不直接暴露给开发者的页面中间表示方式。这些表示方式中最重要的结构就是层。<br>在 Chrome 中实际上有几种不同类型的层：掌管 DOM 子树的渲染层（RenderLayer）以及掌管渲染层子树的图形层（GraphicsLayer），某些特殊的渲染层会被认为是合成层（Compositing Layers，合成层拥有单独的 GraphicsLayer。<br>拥有单独 GraphicsLayer 的层，都会将位图存储在共享内存中，作为纹理上传到 GPU 中，最后由 GPU 将多个位图进行合成，然后 draw 到屏幕上。<br>什么渲染层会提升为合成层？Chrome 在这方面采用的规则仍在随着时间推移逐渐发展变化，但在目前下面这些因素都会引起 Chrome 创建层：</p>
<ul>
<li>进行 3D 或者透视变换的 CSS 属性</li>
<li>使用硬件加速视频解码的<video>元素</li>
<li>具有 3D（WebGL）上下文或者硬件加速的 2D 上下文的<canvas>元素</li>
<li>组合型插件（即 Flash）</li>
<li>具有有 CSS 透明度动画或者使用动画式 Webkit 变换的元素</li>
<li>具有硬件加速的 CSS 滤镜的元素</li>
<li>子元素中存在具有组合层的元素的元素（换句话说，就是存在具有自己的层的子元素的元素）</li>
<li>同级元素中有 Z 索引比其小的元素，而且该 Z 索引比较小的元素具有组合层（换句话说就是在组合层之上进行渲染的元素）</li>
</ul>
<p>提升为合成层简单说来有以下几点好处</p>
<ul>
<li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快</li>
<li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</li>
<li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li>
</ul>
<p>合成层的好处是不会影响到其他元素的绘制，因此，为了减少动画元素对其他元素的影响，从而减少 paint，我们需要把动画效果中的元素提升为合成层。<br>提升合成层的最好方式是使用 CSS 的 will-change 属性。从上一节合成层产生原因中，可以知道 will-change 设置为 opacity、transform、top、left、bottom、right 可以将元素提升为合成层。<br>对于那些目前还不支持 will-change 属性的浏览器，目前常用的是使用一个 3D transform 属性来强制提升为合成层：transofrm: translateZ(0)<br>通常情况下开启硬件加速会提高动画的流畅性，但是过多的合成层也会造成性能瓶颈，过多的合成层会占用大量的内存空间，<br>对于合成层占用内存的问题，这里有两个 demo 进行了验证。<br><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://taobaofed.github.io/demo/performance-composite-demo/memory/multi-layers-expect.html">demo 1</a> 和 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://taobaofed.github.io/demo/performance-composite-demo/memory/multi-layers.html">demo 2</a> 中，会创建 2000 个同样的 div 元素，不同的是 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://taobaofed.github.io/demo/performance-composite-demo/memory/multi-layers.html">demo 2</a> 中的元素通过 will-change 都提升为了合成层，而两个 demo 页面的内存消耗却有很明显的差别。<br><img src="https://cdn.nlark.com/yuque/0/2021/webp/21377586/1619156221113-60d5de53-69da-44b1-8baa-f44ed8ba14a2.webp#clientId=u31f05833-5d5b-4&from=paste&height=436&id=u51e4f365&margin=%5Bobject%20Object%5D&originHeight=485&originWidth=947&originalType=url&status=done&style=none&taskId=u740ae6c5-5d30-4705-a621-dd62062dcc7&width=851.5"></p>
<h1 id="网页动画的渲染"><a href="#网页动画的渲染" class="headerlink" title="网页动画的渲染"></a>网页动画的渲染</h1><p>有一些 JavaScript 方法可以调节重新渲染，大幅提高网页性能。<br>其中最重要的，就是 window.requestAnimationFrame() 方法。它可以将某些代码放到下一次重新渲染时执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.requestAnimationFrame(fn);</span><br></pre></td></tr></table></figure>

<p>****window.requestIdleCallback()****也可以用来调节重新渲染。它指定只有当一帧的末尾有空闲时间，才会执行回调函数。只有当前帧的运行时间小于 16.66ms 时，函数 fn 才会执行。否则，就推迟到下一帧，如果下一帧也没有空闲时间，就推迟到下下一帧，以此类推</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestIdleCallback(fn);</span><br></pre></td></tr></table></figure>

<p>它还可以接受第二个参数，表示指定的毫秒数。如果在指定 的这段时间之内，每一帧都没有空闲时间，那么函数 fn 将会强制执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestIdleCallback(fn, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure>

<h1 id="Chrome-Devtool-Performance"><a href="#Chrome-Devtool-Performance" class="headerlink" title="Chrome Devtool Performance"></a>Chrome Devtool Performance</h1><p>怎么去分析页面运行时的性能表现，Chrome Devtool Performance 是一个很好的选择。这里请大家参考这篇文章<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://zhuanlan.zhihu.com/p/29879682">全新 Chrome Devtool Performance 使用指南</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Adam Blog</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">64</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Adam Blog</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
