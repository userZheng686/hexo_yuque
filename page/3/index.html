<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Adam">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Adam">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Adam Blog">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Adam</title>
  <meta name="referrer" content="no-referrer" />
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Adam</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/23/yuque/%E5%8A%A8%E7%94%BB%E6%80%A7%E8%83%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/23/yuque/%E5%8A%A8%E7%94%BB%E6%80%A7%E8%83%BD/" class="post-title-link" itemprop="url">动画性能</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-23 13:33:32" itemprop="dateCreated datePublished" datetime="2021-04-23T13:33:32+08:00">2021-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-02 20:01:29" itemprop="dateModified" datetime="2021-05-02T20:01:29+08:00">2021-05-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>先总结几个要点<br><strong>精简 DOM，合理布局</strong><br><strong>使用 transform 代替 left、top 减少使用引起页面重排的属性</strong><br><strong>开启硬件加速</strong><br><strong>尽量避免浏览器创建不必要的图形层</strong><br><strong>尽量减少 js 动画，如需要，使用对性能友好的 requestAnimationFrame</strong><br><strong>使用 chrome performance 工具调试动画性能</strong></p>
<p>我们知道网页动画的每一帧都是一次重新渲染，每秒低于 24 镇的动画，人眼就能感受到停顿，每秒 30-60 帧才能比较流畅 浏览器会按照大多数显示器的刷新频率 60Hz 来刷新动画， 如果想达到 60FPS,就意味着每一帧的任务耗时不能高于 16 毫秒。</p>
<p>通过下图我们可以了解浏览器渲染每一帧的过程<br><img src="https://cdn.nlark.com/yuque/0/2021/webp/21377586/1619156045002-3bd51fc7-149d-4148-8cdb-8f69404dc3db.webp#clientId=u31f05833-5d5b-4&from=paste&height=343&id=u16107b32&margin=%5Bobject%20Object%5D&originHeight=343&originWidth=720&originalType=url&status=done&style=none&taskId=u333ca95c-b807-450e-8286-cfd761dd888&width=720"></p>
<ul>
<li>1.JavaScript。一般来说，我们会使用 JavaScript 来实现一些视觉变化的效果。比如用 jQuery 的 animate 函数做一个动画、对一个数据集进行排序或者往页面里添加一些 DOM 元素等。当然，除了 JavaScript，还有其他一些常用方法也可以实现视觉变化效果，比如：CSS Animations、Transitions 和 Web Animation API。</li>
<li>2.样式计算。此过程是根据匹配选择器（例如 .headline 或 .nav &gt; .nav__item）计算出哪些元素应用哪些 CSS 3. 规则的过程。从中知道规则之后，将应用规则并计算每个元素的最终样式。</li>
<li>3.布局。在知道对一个元素应用哪些规则之后，浏览器即可开始计算它要占据的空间大小及其在屏幕的位置。网页的布局模式意味着一个元素可能影响其他元素，例如 元素的宽度一般会影响其子元素的宽度以及树中各处的节点，因此对于浏览器来说，布局过程是经常发生的。</li>
<li>4.绘制。绘制是填充像素的过程。它涉及绘出文本、颜色、图像、边框和阴影，基本上包括元素的每个可视部分。绘制一般是在多个表面（通常称为层）上完成的。</li>
<li>5.合成。由于页面的各部分可能被绘制到多层，由此它们需要按正确顺序绘制到屏幕上，以便正确渲染页面。对于与另一元素重叠的元素来说，这点特别重要，因为一个错误可能使一个元素错误地出现在另一个元素的上层。</li>
<li>“生成布局”（flow）和”绘制”（paint）这两步，合称为”渲染”（render）。重新渲染就是需要重新生成布局和重新绘制。 有上述的渲染流水线我们可以得知重绘不一定需要重排，重排必然导致重绘</li>
<li>重排和重绘会不断触发，这是不可避免的。但是，它们非常耗费资源，是导致网页性能低下的根本原因。 提高网页性能，就是要降低”重排”和”重绘”的频率和成本，尽量少触发重新渲染。</li>
<li>重排还重绘会消耗大量的 CPU 和 GPU 资源，前端新能优化最主要的优化点就是尽量减少重绘和重排。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/21377586/1619156083886-901015cf-1400-451a-ba59-92d020065dcb.webp#clientId=u31f05833-5d5b-4&from=paste&height=343&id=u1605db33&margin=%5Bobject%20Object%5D&originHeight=343&originWidth=720&originalType=url&status=done&style=none&taskId=udccd0b91-b739-46c6-9380-cb2ecd9cfc4&width=720"></p>
<h1 id="影响网页渲染的因素"><a href="#影响网页渲染的因素" class="headerlink" title="影响网页渲染的因素"></a>影响网页渲染的因素</h1><p>其中最简单的，样式表越简单，重绘和重排越快，重绘和重排的 DOM 元素层级越高，成本就越高，所以我们在开发前端页面时就需要精简 DOM 元素，合理布局。<br>另外 Table 元素的重排和重绘成本要高于 div，所以我们提倡使用 div+css 布局，尽量避免使用 table 布局。<br>还有其他对渲染性能有影响的操作，比如：</p>
<ul>
<li>DOM 元素读写分离</li>
<li>让进行大量动画的元素脱离文档流，减少重排开销</li>
<li>通过改变元素的 class 或 csstext 一次性的更改样式</li>
<li>缓存 DOM 元素的位置信息，避免不必要的属性读取</li>
<li>尽量使用离线 DOM</li>
<li>使用 css3 transform 优化动画性能</li>
</ul>
<h1 id="使用-css3-transform"><a href="#使用-css3-transform" class="headerlink" title="使用 css3 transform"></a>使用 css3 transform</h1><p>该 CSS 属性可以旋转，缩放，倾斜，或者上传给定的元素。这是通过修改 CSS 可视格式模型的坐标空间来实现的。<br>如果该属性的值不是 none，则会创建一个堆叠上下文。在这种情况下，该对象将充当 position: fixed 的包含块（所以 position: fixed 的元素将会被他覆盖）。</p>
<p><strong>css3 transform 的执行效率</strong><br>我们通过一个例子来解释为什么 transform 的动画执行效果更佳。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 对应图<span class="number">1</span>-- &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">transition</span>: height <span class="number">1s</span> linear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 对应图<span class="number">2</span> -- &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">transition</span>: transform <span class="number">1s</span> linear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个从 height: 100px 到 height: 200px 的 动画按照下面的流程图来执行各种操作 橙色方框的操作比较耗时，绿色方框的操作比较快速<br><img src="https://cdn.nlark.com/yuque/0/2021/webp/21377586/1619156167485-d5405de1-1137-43f6-a0fb-4f771e179840.webp#clientId=u31f05833-5d5b-4&from=paste&height=1025&id=uc382e09a&margin=%5Bobject%20Object%5D&originHeight=1025&originWidth=455&originalType=url&status=done&style=none&taskId=u1c0285ca-7c7f-4067-8a14-431f977d49d&width=455"><br><img src="https://cdn.nlark.com/yuque/0/2021/webp/21377586/1619156180032-59cfbfa7-4237-41ed-8435-2d49044fabfe.webp#clientId=u31f05833-5d5b-4&from=paste&height=844&id=udfd3f826&margin=%5Bobject%20Object%5D&originHeight=844&originWidth=510&originalType=url&status=done&style=none&taskId=u9a529281-896c-46be-9a13-9eaeec7a309&width=510"><br>因为每一帧的变化浏览器都在进行布局、绘制、把新的位图交给 GPU 内存，但是在将位图加载到 GPU 内存中的操作是个相对耗时的操作。<br>GPU 在如下方面很快：</p>
<ul>
<li>绘制位图到屏幕上</li>
<li>可不断的绘制相同的位图</li>
<li>将同一位图进行位移、旋转、缩放</li>
</ul>
<p>我们看使用了 transform 属性的动画执行过程（图二），这个无疑是效率最优的执行方式。</p>
<h1 id="层的引入（参考-无线性能优化：Composite）"><a href="#层的引入（参考-无线性能优化：Composite）" class="headerlink" title="层的引入（参考-无线性能优化：Composite）"></a>层的引入（<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://taobaofed.org/blog/2016/04/25/performance-composite/">参考-无线性能优化：Composite</a>）</h1><p>页面一旦在装入并解析完成后，就会表示为许多 Web 开发者所熟悉的结构：DOM。然而，在页面的渲染过程中，浏览器还具有一系列并不直接暴露给开发者的页面中间表示方式。这些表示方式中最重要的结构就是层。<br>在 Chrome 中实际上有几种不同类型的层：掌管 DOM 子树的渲染层（RenderLayer）以及掌管渲染层子树的图形层（GraphicsLayer），某些特殊的渲染层会被认为是合成层（Compositing Layers，合成层拥有单独的 GraphicsLayer。<br>拥有单独 GraphicsLayer 的层，都会将位图存储在共享内存中，作为纹理上传到 GPU 中，最后由 GPU 将多个位图进行合成，然后 draw 到屏幕上。<br>什么渲染层会提升为合成层？Chrome 在这方面采用的规则仍在随着时间推移逐渐发展变化，但在目前下面这些因素都会引起 Chrome 创建层：</p>
<ul>
<li>进行 3D 或者透视变换的 CSS 属性</li>
<li>使用硬件加速视频解码的<video>元素</li>
<li>具有 3D（WebGL）上下文或者硬件加速的 2D 上下文的<canvas>元素</li>
<li>组合型插件（即 Flash）</li>
<li>具有有 CSS 透明度动画或者使用动画式 Webkit 变换的元素</li>
<li>具有硬件加速的 CSS 滤镜的元素</li>
<li>子元素中存在具有组合层的元素的元素（换句话说，就是存在具有自己的层的子元素的元素）</li>
<li>同级元素中有 Z 索引比其小的元素，而且该 Z 索引比较小的元素具有组合层（换句话说就是在组合层之上进行渲染的元素）</li>
</ul>
<p>提升为合成层简单说来有以下几点好处</p>
<ul>
<li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快</li>
<li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</li>
<li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li>
</ul>
<p>合成层的好处是不会影响到其他元素的绘制，因此，为了减少动画元素对其他元素的影响，从而减少 paint，我们需要把动画效果中的元素提升为合成层。<br>提升合成层的最好方式是使用 CSS 的 will-change 属性。从上一节合成层产生原因中，可以知道 will-change 设置为 opacity、transform、top、left、bottom、right 可以将元素提升为合成层。<br>对于那些目前还不支持 will-change 属性的浏览器，目前常用的是使用一个 3D transform 属性来强制提升为合成层：transofrm: translateZ(0)<br>通常情况下开启硬件加速会提高动画的流畅性，但是过多的合成层也会造成性能瓶颈，过多的合成层会占用大量的内存空间，<br>对于合成层占用内存的问题，这里有两个 demo 进行了验证。<br><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://taobaofed.github.io/demo/performance-composite-demo/memory/multi-layers-expect.html">demo 1</a> 和 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://taobaofed.github.io/demo/performance-composite-demo/memory/multi-layers.html">demo 2</a> 中，会创建 2000 个同样的 div 元素，不同的是 <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://taobaofed.github.io/demo/performance-composite-demo/memory/multi-layers.html">demo 2</a> 中的元素通过 will-change 都提升为了合成层，而两个 demo 页面的内存消耗却有很明显的差别。<br><img src="https://cdn.nlark.com/yuque/0/2021/webp/21377586/1619156221113-60d5de53-69da-44b1-8baa-f44ed8ba14a2.webp#clientId=u31f05833-5d5b-4&from=paste&height=436&id=u51e4f365&margin=%5Bobject%20Object%5D&originHeight=485&originWidth=947&originalType=url&status=done&style=none&taskId=u740ae6c5-5d30-4705-a621-dd62062dcc7&width=851.5"></p>
<h1 id="网页动画的渲染"><a href="#网页动画的渲染" class="headerlink" title="网页动画的渲染"></a>网页动画的渲染</h1><p>有一些 JavaScript 方法可以调节重新渲染，大幅提高网页性能。<br>其中最重要的，就是 window.requestAnimationFrame() 方法。它可以将某些代码放到下一次重新渲染时执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.requestAnimationFrame(fn);</span><br></pre></td></tr></table></figure>

<p>****window.requestIdleCallback()****也可以用来调节重新渲染。它指定只有当一帧的末尾有空闲时间，才会执行回调函数。只有当前帧的运行时间小于 16.66ms 时，函数 fn 才会执行。否则，就推迟到下一帧，如果下一帧也没有空闲时间，就推迟到下下一帧，以此类推</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestIdleCallback(fn);</span><br></pre></td></tr></table></figure>

<p>它还可以接受第二个参数，表示指定的毫秒数。如果在指定 的这段时间之内，每一帧都没有空闲时间，那么函数 fn 将会强制执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestIdleCallback(fn, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure>

<h1 id="Chrome-Devtool-Performance"><a href="#Chrome-Devtool-Performance" class="headerlink" title="Chrome Devtool Performance"></a>Chrome Devtool Performance</h1><p>怎么去分析页面运行时的性能表现，Chrome Devtool Performance 是一个很好的选择。这里请大家参考这篇文章<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://zhuanlan.zhihu.com/p/29879682">全新 Chrome Devtool Performance 使用指南</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/23/yuque/%E5%A4%A7%E9%87%8F%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/23/yuque/%E5%A4%A7%E9%87%8F%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">大量图片加载优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-23 12:51:07" itemprop="dateCreated datePublished" datetime="2021-04-23T12:51:07+08:00">2021-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-02 20:01:29" itemprop="dateModified" datetime="2021-05-02T20:01:29+08:00">2021-05-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>饿了么 App 中新零售项目主要是以图片展示为主，引导用户点击轮播广告栏或者店铺列表进入指定的商品页面，因此页面中包含了大量图片，如搜索框下面的轮播广告栏、中部的促销栏以及底部的店铺列表，这些区域中都有大量的展示图片。因此图片的加载速率直接影响页面的加载速度。下面将从图片加载存在的问题和原因、解决方案两个方面来阐述如何优化新零售图片的加载。<br>本文所有数据及图片都是通过<strong>Charles</strong>模拟 256 kbps ISDN/DSL 网络环境获取到的。在本案例中只考虑位图，因此文本中提及的图片都是指位图而非矢量图。</p>
<h2 id="图片加载存在的问题和原因"><a href="#图片加载存在的问题和原因" class="headerlink" title="图片加载存在的问题和原因"></a><strong>图片加载存在的问题和原因</strong></h2><p><strong>问题一</strong>：启动页面时加载过多图片<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619153486011-145891ec-7533-447d-b37b-6f016bcf2b43.jpeg#clientId=uc716cf97-bcfe-4&from=paste&height=629&id=ub4ea3c13&margin=%5Bobject%20Object%5D&originHeight=629&originWidth=720&originalType=url&status=done&style=none&taskId=ud5c99b57-f1f0-4c88-add8-1a4d8e4cc19&width=720"><br><strong>图 1</strong>： 新零售图片请求瀑布图<br><strong>问题原因分析：</strong>如上图所示，页面启动时加载了大约 49 张图片（具体图片数量会根据后端返回数据而变化），而这些图片请求几乎是并发的，在 Chrome 浏览器，对于同一个域名，最多支持 6 个请求的并发，其他的请求将会推入到队列中等待或者停滞不前，直到六个请求之一完成后，队列中新的请求才会发出。上面的瀑布图中，在绿色的标记框中，我们看到不同长度的白色横柱，这些都是请求的图片资源排队等待时间。</p>
<p><strong>问题二</strong>：部分图片体积过大<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619153789647-3253d48a-a3bc-4500-b720-6d185883da54.jpeg#clientId=uc716cf97-bcfe-4&from=paste&height=397&id=ufd4c09a4&margin=%5Bobject%20Object%5D&originHeight=498&originWidth=1050&originalType=url&status=done&style=none&taskId=u2e8adb8b-92bb-4682-85af-359c994c07d&width=836"><br><strong>图 2.<strong>顶部轮播图中的一张图片加载图<br><strong>问题原因分析：</strong>如图 1，红框中是搜索框下部的轮播广告中的一张图片，通过图 2 可以看到，该图片主要耗时在 Conent Download 阶段。在下载阶段耗时 13.50s。而该请求的总共时间也就 13.78s。产生该问题的原因从图 1 也能看出一些端倪，该图片体积 76.2KB，</strong>图片体积过大</strong>，直接导致了下载图片时间过长。</p>
<h2 id="前端解决方案"><a href="#前端解决方案" class="headerlink" title="前端解决方案"></a><strong>前端解决方案</strong></h2><p><strong>针对问题一的解决方案</strong><br>由于新零售首页展示展示大量图片，其实在这大约 49 张图片中，大部分图片都不是首屏所需的，因此可以延迟首屏不需要的图片加载，而优先加载首屏所需图片。这儿<strong>首屏</strong>的含义是指打开新零售首页首先进入屏幕视窗内的区域范围。<br>判断图片是否是首屏内图片，首先想到的肯定是通过 getBoundingClientRect 方法，获取到图片的位置信息，判断其是否在 viewport 内部。可能的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inViewport = <span class="function">(<span class="params">el</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> rect = el.getBoundingClientRect();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    rect.top &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">    rect.bottom &lt; <span class="built_in">window</span>.innerHeight &amp;&amp;</span><br><span class="line">    rect.left &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">    rect.right &lt; <span class="built_in">window</span>.innerWidth</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是在项目中，我们并没有采用该方案来判断是否在首屏，其原因在于，只有当 DOM 元素插入到 DOM 树中，并且页面进行重排和重绘后，我们才能够知道该元素是否在首屏中。在项目中我们使用了<a href="https://link.zhihu.com/?target=https://github.com/ElemeFE/vue-img">v-img</a>指令（新零售项目使用该指令对图片进行加载、并且将 hash 转换成 Url。项目已开源，在符合需求前提下欢迎使用），在 Vue 指令中包含两个钩子函数 bind 和 inserted。官网对这两个钩子函数进行如下解释：</p>
<ul>
<li>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</li>
<li>inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</li>
</ul>
<p>由上面解释可知，我们只能够在 inserted 钩子函数中才能够获取到元素的位置，并且判断其是否在首屏中。在新零售项目中，经过笔者测试，这两个钩子函数的触发时差大约是 200ms，因此如果在 inserted 钩子函数内再去加载图片就会比在 bind 钩子函数中加载晚大约 200ms，在 4G 网络环境下，200ms 对于很多图片来说已经足够用来加载了，因此我们最终放弃了在 inserted 钩子函数中加载首屏图片的方案。</p>
<p><strong>如果元素没有插入到 DOM 树中并渲染，怎么能够判断其是否在首屏中呢？</strong></p>
<blockquote>
<img v-img="{ hash: 'xxx', defer: true }">
</blockquote>
<p>项目中使用了一种比较笨的方式来判断哪些是首屏图片，新零售页面布局是确定的，轮播广告栏下面是促销栏、再下面是店铺列表，这些组件的高度也都相对固定，因此这些组件是否在首屏中其实我们是事先知道的。因此在实际使用<a href="https://link.zhihu.com/?target=https://github.com/ElemeFE/vue-img">v-img</a>指令的时候，通过传 defer 配置项来告诉 v-img 哪些图片需要提前加载，哪些图片等待提前加载的图片加载完毕后再加载。这样我们就能够在 bind 钩子函数中加载优先加载的图片了。比如说，轮播组件图片、促销组件图片、前两个店铺中的展示图片需要先加载，除此以外的其他图片，需等待首屏图片完全加载后再进行请求加载。实际实现代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = []; <span class="comment">// 用来存储优先加载的图片</span></span><br><span class="line">Vue.directive(<span class="string">&quot;img&quot;</span>, &#123;</span><br><span class="line">  <span class="function"><span class="title">bind</span>(<span class="params">el, binding, vnode</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> &#123; defer &#125; = binding.value;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (!defer) &#123;</span><br><span class="line">      promises.push(update(el, binding, vnode));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">inserted</span>(<span class="params">el, binding, vnode</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; defer &#125; = binding.value;</span><br><span class="line">    <span class="keyword">if</span> (!defer) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (inViewport(el)) &#123;</span><br><span class="line">      promises.push(update(el, binding, vnode));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Vue.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">Promise</span>.all(promises)</span><br><span class="line">          .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            promises.length = <span class="number">0</span>;</span><br><span class="line">            update(el, binding, vnode);</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>首先通过声明一个数组 promises 用于存储优先加载的图片，在 bind 钩子函数内部，如果 defer 配置项为 false，说明不延时加载，那么就在 bind 钩子函数内部加载该图片，且将返回的 promise 推入到 promises 数组中。在 inserted 钩子函数内，对于延迟加载的图片（defer 为 true），但是其又在首屏内，那么也有优先加载权，在 inseted 钩子函数调用时就对其加载。而对于非首屏且延迟加载的图片等待 promises 数组内部所有的图片都加载完成后才加载。当然在实际代码中还会考虑容错机制，比如上面某张图片加载失败、或者加载时间太长等。因此我们可以配置一个最大等待时间。<br>优化后的图片加载瀑布图如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619154236444-47386cf6-0b09-40ee-b395-4b4d4584cba4.jpeg#clientId=uc716cf97-bcfe-4&from=paste&height=732&id=ue2cc6cb2&margin=%5Bobject%20Object%5D&originHeight=732&originWidth=720&originalType=url&status=done&style=none&taskId=u778a9e8a-2981-4ffa-9a6c-4dc6e9d9663&width=720"><br><strong>图 3</strong>. 图片按需加载的瀑布图<br>如上图所示，下面红框的图片不是首屏图片，因此进行了延迟加载。可以看出，其是在上面所有图片（包括上面的红框中耗时最长的那张图）加载完成之后进行加载的。这样减少了首屏加载时的网络消耗，提升了图片下载速度。<br><strong>优化前后对比</strong><br>通过上面的优化方案，在预设的网络环境下（参见文末注），分别对优化前和优化后进行了 5 次平行清空缓存加载，平均数据如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619154254755-bcd04db3-16bf-4846-8819-9e80588679bf.jpeg#clientId=uc716cf97-bcfe-4&from=paste&height=130&id=u00930861&margin=%5Bobject%20Object%5D&originHeight=130&originWidth=720&originalType=url&status=done&style=none&taskId=uac8e2e49-a999-4b0e-9e3c-e6b7b96b23c&width=720"><br>通过上面表格可以看出，DOMContentLoaded 和 Loaded 并没有多大参考价值，首屏的完整展现所需要的时间依然由加载最慢（一般都是体积最大那张图片）的图片决定，也就是上表的 Max_size_image 决定，上表可以看出，优化后比优化前最大体积图片的加载时间缩短了<strong>5.74s</strong>。提速了整整**41.41%**。加载最慢的图片加载速度的变化也很好的反应了首屏时间的变化。<br>当然上面的数据也不能够完全反应线上场景，毕竟测试的时间点及后端数据都有所不同。我们也不能够在同一时间点、同一网络环境下对优化前、优化后进行同时数据采集。<br><strong>针对问题一还有些后续的解决方案：</strong></p>
<ul>
<li>在 HTTP/1.0 和 HTTP/1.1 协议下，由于 Chrome 只支持同域同时发送 6 个并发请求，可以进行域名切分，来提升并发的请求数量，或者使用 HTTP/2 协议。</li>
</ul>
<p><strong>针对问题二的解决方案</strong><br><strong>图片体积过大，导致下载时间过长。</strong>在保证清晰度的前提下尽量使用体积较小的图片。而一张图片的体积由两个因素决定，该图片总的像素数目和编码单位像素所需的字节数。因此一张图片的文件大小就等于图片总像素数目乘以编码单位像素所需字节数，也就是如下等式：<br>FileSize = Total Number Pixels _ Bytes of Encode single Pixels<br>举个例子：<br>一张 100px _ 100px 像素的图片，其包含该 100 _ 100 = 10000 个像素点，而每个像素点通过 RGBA 颜色值进行存储，R\G\B\A 每个色道都有 0~255 个取值，也就是 2^8 = 256。正好是 8 位 1byte。而每个像素点有四个色道，每个像素点需要 4bytes。因此该图片体积为：10000 _ 4bytes = 40000bytes = 39KB。<br>有了上面的背景知识后，我们就知道怎么去优化一张图片了，无非就两个方向：</p>
<ul>
<li>一方面是减少单位像素所需的字节数</li>
<li>另一方面是减少一张图片总的像素个数</li>
</ul>
<p><strong>单位像素优化</strong>：单位像素的优化也有两个方向，一个方向是「有损」的删除一些像素数据，另一个方面是做一些「无损」的图片像素压缩。正如上面例子所说，RGBA 颜色值可以表示 256^4 种颜色，这是一个很大的数字，往往我们不需要这么多颜色值，因此我们是否可以减少色板中的颜色种类呢？这样表示单位像素的字节数就减少了。而「无损」压缩是通过一些算法，存储像素数据不变的前提下，尽量减少图片存储体积。比如一张图片中的某一个像素点和其周围的像素点很接近，比如一张蓝天的图片，因此我们可以存储两个像素点颜色值的差值（当然实际算法中可能不止考虑两个像素点也许更多），这样既保证了像素数据的「无损」，同时也减少了存储体积。不过也增加了图片解压缩的开销。<br>针对单位像素的优化，衍生出了不同的图片格式，jpeg、png、gif、webp。不同的图片格式都有自己的减少单位像素体积的算法。同时也有各自的优势和劣势，比如 jpeg 和 png 不支持动画效果，jpeg 图片体积小但是不支持透明度等。因此项目在选择图片格式上的策略就是，在满足自己需求的前提下选择体积最小的图片格式，新零售项目中已经统一使用的 WebP 格式，和 jpeg 格式相比，其体积更减少 30%，同时还支持动画和透明度。<br><strong>图片像素总数优化</strong>：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619154330747-73f2544a-2ed5-4ff1-9ee2-ed1ad86eb358.png#clientId=uc716cf97-bcfe-4&from=paste&height=116&id=ude860fbe&margin=%5Bobject%20Object%5D&originHeight=116&originWidth=331&originalType=url&status=done&style=none&taskId=u4ee0138b-0e4d-4eef-9734-d1d71cddb27&width=331"><br><strong>图 4</strong>：图片加载尺寸和实际渲染尺寸对比<br>上图是新零售类目页在 Chrome 浏览器中的 iPhone 6 模拟器加载后的轮播展示的图片之一，展示的图片是 750 _ 188 像素，但是图片的实际尺寸为 1440 _ 360 像素，也就是说我们根本不需要这么大的图片，大图片不仅造成了图片加载的时长增加（后面会有数据说明），同时由于图片尺寸需要缩小增加 CPU 的负担。<br>上文中已经提及，项目中我们使用的 v-img 指令来加载项目中的所需图片，如果我们能够根据设备的尺寸来加载不同尺寸（像素总数不同）的图片，也就是说在保证图片清晰度的前提下，尽量使用体积小的图片，问题就迎刃而解了。项目中我们使用的是七牛的图片服务，<a href="https://link.zhihu.com/?target=https://developer.qiniu.com/dora/manual/1270/the-advanced-treatment-of-images-imagemogr2">七牛图片服务</a>提供了图片格式转换、按尺寸裁剪等图片处理功能。只需要对 v-img 指令添加图片宽、高的配置，那么我们是不是可以对不同的设备加载不同尺寸的图片呢？<br>项目中我们使用的<a href="https://link.zhihu.com/?target=https://github.com/amfe/lib-flexible">lib-flexible</a>来对不同的移动端设备进行适配，lib-flexible 库在我们页面的 html 元素添加了两个属性，data-dpr 和 style。这儿我们主要会用到 style 中的 font-size 值，在一定的设备范围内其正好是 html 元素宽度的十分之一（具体原理参见：<a href="https://link.zhihu.com/?target=http://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html">使用 Flexible 实现手淘 H5 页面的终端适配</a>），也就是说我们可以通过 style 属性大概获取到设备的宽度。同时设计稿又是以 iPhone6 为基础进行设计的，也就是设计稿是宽度为 750px 的设计图，这样在设计图中的图片大小我们也就能够转换成其他设备中所需的图片大小了。<br>举个例子：<br>设计稿中一张宽 200px 的图片，其对应的 iPhone 6 设备的宽度为 750px。我们通过 html 元素的 style 属性计算出 iPhone6 plus 的宽度为 1242px。这样也就能够计算中 iPhone6 plus 所需图片尺寸。计算如下：<br>200 * 1242 / 750 = 331.2px<br>实现代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resize = <span class="function">(<span class="params">size</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> viewWidth;</span><br><span class="line">  <span class="keyword">const</span> dpr = <span class="built_in">window</span>.devicePixelRatio;</span><br><span class="line">  <span class="keyword">const</span> html = <span class="built_in">document</span>.documentElement;</span><br><span class="line">  <span class="keyword">const</span> dataDpr = html.getAttribute(<span class="string">&quot;data-dpr&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> ratio = dataDpr ? dpr / dataDpr : dpr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    viewWidth = +(html.getAttribute(<span class="string">&quot;style&quot;</span>).match(<span class="regexp">/(\d+)/</span>) || [])[<span class="number">1</span>];</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">const</span> w = html.offsetWidth;</span><br><span class="line">    <span class="keyword">if</span> (w / dpr &gt; <span class="number">540</span>) &#123;</span><br><span class="line">      viewWidth = (<span class="number">540</span> * dpr) / <span class="number">10</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      viewWidth = w / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  viewWidth = viewWidth * ratio;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Number</span>(viewWidth) &gt;= <span class="number">0</span> &amp;&amp; <span class="keyword">typeof</span> viewWidth === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (size * viewWidth) / <span class="number">75</span>; <span class="comment">// 75 is the 1/10 iphone6 deivce width pixel</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面 resize 方法用于将配置的宽、高值转换为实际所需的图片尺寸，也就是说，size 参数是 iphone 6 设计稿中的尺寸，resize 的返回值就是当前设备所需的尺寸，再把该尺寸配置到图片服务器的传参中，这样我们就能够获取到按设备裁剪后的图片了。<br><strong>优化前后效果对比</strong>，有了上面的基础，我们在 Chrome 中的不同的移动端模拟器上进行了实验，我们对新零售类目页中的一张体积最大的广告图片在不同设备中的加载进行了数据统计（平行三次清空缓存加载），为什么选择体积最大的图片，上文也已经说过，其决定了首屏展现所需的时间。<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619154382774-f516ce8a-aed1-4a7f-9653-22d2d2a9df0f.jpeg#clientId=uc716cf97-bcfe-4&from=paste&height=285&id=u71f6c189&margin=%5Bobject%20Object%5D&originHeight=285&originWidth=720&originalType=url&status=done&style=none&taskId=ud752b764-d81b-44c4-8e9b-89083237490&width=720"><br>上表格中，除去最后一行是未优化的加载数据，从上到下，设备屏幕尺寸逐渐变大，加载的图片尺寸也从 23.2kb 增加到 65.5kb。而加载时间和下载时长也跟随着图片体积的加大而增加，下面的折线图更能够反应图片尺寸、加载时长、下载时长之间的正相关关系。TTFB（从发送请求到接收到第一个字节所需时长）却和图片大小没有明显的正相关关系，可能对于图片服务器在裁剪上述不同尺寸的图片所需时长差异不大。<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619154382719-89420942-d084-4bd2-b8ea-ea9fb2fc338c.jpeg#clientId=uc716cf97-bcfe-4&from=paste&height=300&id=ufa56ddca&margin=%5Bobject%20Object%5D&originHeight=300&originWidth=720&originalType=url&status=done&style=none&taskId=u92216d5c-ddd9-4719-87ef-028fcbc54d1&width=720"><br><strong>图 5</strong>：不同设备中对同一张图片进行加载，文件大小、加载和下载时长的折线变化<br>由上折线图我们还能看到，对于小屏幕设备的效果尤为明显，在不优化下，iPhone5 中图片的加载需要 14.85s，而优化后，加载时长缩短到了 3.90s。加载时长整整缩短了**73.73%<strong>。而对于大屏幕的 iPhone6 plus 也有</strong>26.00%<strong>时长优化。<br>当然上面的数据是建立在 256 kbps ISDN/DSL 的网络环境下的，该低速网络环境下，图片的加载时间主要是由于下载时间决定的，因此通过优化图片体积能够达到很好的效果。在 4G（Charles 模拟）环境下，iPhone5 中的优化效果就会有些折扣，加载时长缩短</strong>69.15%**。其实也很容易想到，在高速的网络环境下，TTFB 对加载时长的影响会比低速网络环境下影响要大一些。</p>
<h2 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a><strong>最后总结</strong></h2><p>通过上面的研究及数据结果表明，新零售图片加载缓慢的优化策略：</p>
<ul>
<li>首屏图片优先加载，等首屏图片加载完全后再去加载非首屏图片。</li>
<li>对大部分图片，特别是轮播广告中的图片进行按设备尺寸裁剪，减少图片体积，减少网络开销，加快下载速率。</li>
</ul>
<p>本文中没有过多的讨论代码实现细节，而是把重点放在了图片加载缓慢的原因分析，以及优化前后效果对比的数据分析上，如果想看更多代码细节，请移步<a href="https://link.zhihu.com/?target=https://github.com/ElemeFE/vue-img">vue-img</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/23/yuque/%E7%99%BD%E5%B1%8F%E6%97%B6%E9%97%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/23/yuque/%E7%99%BD%E5%B1%8F%E6%97%B6%E9%97%B4/" class="post-title-link" itemprop="url">白屏时间</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-23 12:22:29" itemprop="dateCreated datePublished" datetime="2021-04-23T12:22:29+08:00">2021-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-02 20:01:29" itemprop="dateModified" datetime="2021-05-02T20:01:29+08:00">2021-05-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该篇文章会为您分享在前端性能优化中非常重要的一环-白屏时间，将从白屏时间的概念、重要性以及白屏的过程一一进行阐述，同时提供性能优化的策略与实践。</p>
<h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p>白屏时间：即用户点击一个链接或打开浏览器输入 URL 地址后，从屏幕空白到显示第一个画面的时间。<br>白屏时间的长短将直接影响用户对该网站的第一印象。</p>
<h2 id="二、白屏时间的重要性"><a href="#二、白屏时间的重要性" class="headerlink" title="二、白屏时间的重要性"></a>二、白屏时间的重要性</h2><p>当用户点开一个链接或者是直接在浏览器中输入 URL 开始进行访问时，就开始等待页面的展示。页面渲染的时间越短，用户等待的时间就越短，用户感知到页面的速度就越快。这样可以极大的提升用户的体验，减少用户的跳出，提升页面的留存率。<br>打开一个页面就像你的女票召唤你一样，你出现的越迅速，女票肯定会愈加欣喜！反之，你千呼万唤始出来，那么你的女票很可能又要抛弃你了(为什么要对你说又呢? …)</p>
<h2 id="三、白屏是一个怎样的过程呢？"><a href="#三、白屏是一个怎样的过程呢？" class="headerlink" title="三、白屏是一个怎样的过程呢？"></a>三、白屏是一个怎样的过程呢？</h2><p>让我们一起来揭秘：从打开一个页面，到页面的画面展示经历了怎样的过程！</p>
<h3 id="1-DNS-Lookup"><a href="#1-DNS-Lookup" class="headerlink" title="1. DNS Lookup"></a>1. DNS Lookup</h3><p>DNS Lookup 即浏览器从 DNS 服务器中进行域名查询。<br>浏览器会先对页面进行<a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/cns?from=10680">域名解析</a>，获取到服务器的 IP 地址后，进而和服务器进行通信。<br>Tips: 通常在整个加载页面的过程中，浏览器会多次进行 DNS Lookup，包括页面本身的域名查询以及在解析 HTML 页面时加载的 JS、CSS、Image、Video 等资源产生的域名查询。</p>
<h3 id="2-建立-TCP-请求连接"><a href="#2-建立-TCP-请求连接" class="headerlink" title="2. 建立 TCP 请求连接"></a>2. 建立 TCP 请求连接</h3><p>浏览器和服务端 TCP 请求建立的过程，是基于 TCP/IP，该协议由网络层的 IP 和传输层的 TCP 组成。IP 是每一台互联网设备在互联网中的唯一地址。<br>TCP 通过三次握手建立连接，并提供可靠的数据传输服务。</p>
<h3 id="3-服务端请求处理响应"><a href="#3-服务端请求处理响应" class="headerlink" title="3. 服务端请求处理响应"></a>3. 服务端请求处理响应</h3><p>在 TCP 连接建立后，Web 服务器接受请求，开始进行处理，同时浏览器端开始等待服务器的处理响应。<br>Web 服务器根据请求类型的不同，进行相应的处理。静态资源如图片、CSS 文件、静态 HTML 直接进行响应；如其他注册的请求转发给相应的应用服务器，进行如数据处理、缓存中取数据，将数据按照约定好的格式响应给浏览器。<br>在大型应用中，通常为分布式服务架构，应用服务器的处理有可能经过很多个系统的中间件，最终获取到需要的数据</p>
<h3 id="4-客户端下载、解析、渲染显示页面"><a href="#4-客户端下载、解析、渲染显示页面" class="headerlink" title="4. 客户端下载、解析、渲染显示页面"></a>4. 客户端下载、解析、渲染显示页面</h3><p>在服务器返回数据后，客户端浏览器接收数据，进行 HTML 下载、解析、渲染显示。</p>
<ul>
<li>a. 如果是 Gzip 包，则先解压为 HTML</li>
<li>b. 解析 HTML 的头部代码，下载头部代码中的样式资源文件或脚本资源文件</li>
<li>c. 解析 HTML 代码和样式文件代码，构建 HTML 的 DOM 树以及与 CSS 相关的 CSSOM 树</li>
<li>d. 通过遍历 DOM 树和 CSSOM 树，浏览器依次计算每个节点的大小、坐标、颜色等样式，构造渲染树</li>
<li>e. 根据渲染树完成绘制过程</li>
</ul>
<p>浏览器下载 HTML 后，首先解析头部代码，进行样式表下载，然后继续向下解析 HTML 代码，构建 DOM 树，同时进行样式下载。当 DOM 树构建完成后，立即开始构造 CSSOM 树。理想情况下，样式表下载速度够快，DOM 树和 CSSOM 树进入一个并行的过程，当两棵树构建完毕，构建渲染树，然后进行绘制。<br>Tips:浏览器安全解析策略对解析 HTML 造成的影响：</p>
<ul>
<li>当解析 HTML 时遇到内联 JS 代码，会阻塞 DOM 树的构建</li>
<li>特别悲惨的情况： 当 CSS 样式文件没有下载完成时，浏览器解析 HTML 遇到了内联 JS 代码，此时！！！根据浏览器的安全解析策略，浏览器暂停 JS 脚本执行，暂停 HTML 解析。直到 CSS 文件下载完成，完成 CSSOM 树构建，重新恢复原来的解析。<br>一定要合理放置 JS 代码！！！</li>
</ul>
<h2 id="四、白屏-性能优化"><a href="#四、白屏-性能优化" class="headerlink" title="四、白屏-性能优化"></a>四、白屏-性能优化</h2><p>至此，我们已经了解了从浏览器在打开一个链接开始，到屏幕展示的过程-白屏时间的历程，那这对每个环节中发生的事情，我们可以有针对性的进行相关的优化。</p>
<h3 id="1-DNS-解析优化"><a href="#1-DNS-解析优化" class="headerlink" title="1. DNS 解析优化"></a>1. DNS 解析优化</h3><p>针对 DNS Lookup 环节，我们可以针对性的进行 DNS 解析优化。</p>
<ul>
<li>DNS 缓存优化</li>
<li>DNS 预加载策略</li>
<li>稳定可靠的 DNS 服务器</li>
</ul>
<h3 id="2-TCP-网络链路优化"><a href="#2-TCP-网络链路优化" class="headerlink" title="2. TCP 网络链路优化"></a>2. TCP 网络链路优化</h3><p>针对网络链路的优化，好像除了花钱没有什么更好的方式！</p>
<h3 id="3-服务端处理优化"><a href="#3-服务端处理优化" class="headerlink" title="3. 服务端处理优化"></a>3. 服务端处理优化</h3><p>服务端的处理优化，是一个非常庞大的话题，会涉及到如<a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/crs?from=10680">Redis</a>缓存、数据库存储优化或是系统内的各种中间件以及 Gzip 压缩等…</p>
<h3 id="4-浏览器下载、解析、渲染页面优化"><a href="#4-浏览器下载、解析、渲染页面优化" class="headerlink" title="4. 浏览器下载、解析、渲染页面优化"></a>4. 浏览器下载、解析、渲染页面优化</h3><p>根据浏览器对页面的下载、解析、渲染过程，可以考虑一下的优化处理：</p>
<ul>
<li>尽可能的精简 HTML 的代码和结构</li>
<li>尽可能的优化 CSS 文件和结构</li>
<li>一定要合理的放置 JS 代码，尽量不要使用内联的 JS 代码</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/23/yuque/%E9%87%8D%E6%8E%92%E5%92%8C%E9%87%8D%E7%BB%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/23/yuque/%E9%87%8D%E6%8E%92%E5%92%8C%E9%87%8D%E7%BB%98/" class="post-title-link" itemprop="url">重排和重绘</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-23 12:12:22" itemprop="dateCreated datePublished" datetime="2021-04-23T12:12:22+08:00">2021-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-02 20:01:29" itemprop="dateModified" datetime="2021-05-02T20:01:29+08:00">2021-05-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>本文首发于我的个人网站：<a target="_blank" rel="noopener" href="https://litgod.net/">litgod.net</a></p>
</blockquote>
<p>之前面试的大佬问我关于重排重绘的原理和具体操作，一下子把我问蒙了。回家便默默地把问题记下来，仔细总结……在阅读了一些文章后，自己也有了一定的理解，所以分享给大家。希望大家也能耐心把这篇文章看完，认真思考，彻底掌握这个知识点！</p>
<h2 id="页面生成的过程："><a href="#页面生成的过程：" class="headerlink" title="页面生成的过程："></a>页面生成的过程：</h2><p>1.HTML 被 HTML 解析器解析成 DOM 树；</p>
<p>2.CSS 被 CSS 解析器解析成 CSSOM 树；</p>
<p>3.结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment；</p>
<p>4.生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点；</p>
<p>5.将布局绘制(paint)在屏幕上，显示出整个页面。</p>
<p>第四步和第五步是最耗时的部分，这两步合起来，就是我们通常所说的渲染。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619151461786-9b1a1f67-2d18-41da-a534-6348a8210d4c.png#clientId=u94e07666-41db-4&from=drop&id=udd3e394b&margin=%5Bobject%20Object%5D&name=1.png&originHeight=313&originWidth=800&originalType=binary&size=42085&status=done&style=none&taskId=u4de619f6-97ac-4982-99da-91a5b369896" alt="1.png"></p>
<h2 id="渲染："><a href="#渲染：" class="headerlink" title="渲染："></a>渲染：</h2><p>在页面的生命周期中，**网页生成的时候，至少会渲染一次。在用户访问的过程中，还会不断触发重排(reflow)和重绘(repaint)**，不管页面发生了重绘还是重排，都会影响性能，最可怕的是重排，会使我们付出高额的性能代价，所以我们应尽量避免。</p>
<h2 id="重排比重绘大："><a href="#重排比重绘大：" class="headerlink" title="重排比重绘大："></a>重排比重绘大：</h2><p>大，在这个语境里的意思是：谁能影响谁？</p>
<ul>
<li>重绘：某些元素的外观被改变，例如：元素的填充颜色</li>
<li>重排：重新生成布局，重新排列元素。</li>
</ul>
<p>就如上面的概念一样，单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分。比如改变元素高度，这个元素乃至周边 dom 都需要重新绘制。</p>
<p>也就是说：<strong>重绘不一定导致重排，但重排一定会导致重绘</strong>。</p>
<h2 id="重排-reflow-："><a href="#重排-reflow-：" class="headerlink" title="重排(reflow)："></a>重排(reflow)：</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>当 DOM 的变化影响了元素的几何信息(元素的的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。</p>
<p>重排也叫回流，简单的说就是重新生成布局，重新排列元素。</p>
<h3 id="下面情况会发生重排："><a href="#下面情况会发生重排：" class="headerlink" title="下面情况会发生重排："></a>下面情况会发生重排：</h3><ul>
<li>页面初始渲染，这是开销最大的一次重排</li>
<li>添加/删除可见的 DOM 元素</li>
<li>改变元素位置</li>
<li>改变元素尺寸，比如边距、填充、边框、宽度和高度等</li>
<li>改变元素内容，比如文字数量，图片大小等</li>
<li>改变元素字体大小</li>
<li>改变浏览器窗口尺寸，比如 resize 事件发生时</li>
<li>激活 CSS 伪类（例如：<code>:hover</code>）</li>
<li>设置 style 属性的值，因为通过设置 style 属性改变结点样式的话，每一次设置都会触发一次 reflow</li>
<li>查询某些属性或调用某些计算方法：offsetWidth、offsetHeight 等，除此之外，当我们调用 <code>getComputedStyle</code>方法，或者 IE 里的 <code>currentStyle</code> 时，也会触发重排，原理是一样的，都为求一个“即时性”和“准确性”。<table>
<thead>
<tr>
<th>常见引起重排属性和方法</th>
<th>–</th>
<th>–</th>
<th>–</th>
</tr>
</thead>
<tbody><tr>
<td>width</td>
<td>height</td>
<td>margin</td>
<td>padding</td>
</tr>
<tr>
<td>display</td>
<td>border-width</td>
<td>border</td>
<td>position</td>
</tr>
<tr>
<td>overflow</td>
<td>font-size</td>
<td>vertical-align</td>
<td>min-height</td>
</tr>
<tr>
<td>clientWidth</td>
<td>clientHeight</td>
<td>clientTop</td>
<td>clientLeft</td>
</tr>
<tr>
<td>offsetWudth</td>
<td>offsetHeight</td>
<td>offsetTop</td>
<td>offsetLeft</td>
</tr>
<tr>
<td>scrollWidth</td>
<td>scrollHeight</td>
<td>scrollTop</td>
<td>scrollLeft</td>
</tr>
<tr>
<td>scrollIntoView()</td>
<td>scrollTo()</td>
<td>getComputedStyle()</td>
<td></td>
</tr>
<tr>
<td>getBoundingClientRect()</td>
<td>scrollIntoViewIfNeeded()</td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="重排影响的范围："><a href="#重排影响的范围：" class="headerlink" title="重排影响的范围："></a>重排影响的范围：</h3><p>由于浏览器渲染界面是基于流失布局模型的，所以触发重排时会对周围 DOM 重新排列，影响的范围有两种：</p>
<ul>
<li>全局范围：从根节点 html 开始对整个渲染树进行重新布局。</li>
<li>局部范围：对渲染树的某部分或某一个渲染对象进行重新布局</li>
</ul>
<p><strong>全局范围重排：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;hello&quot;&gt;</span><br><span class="line">    &lt;h4&gt;hello&lt;&#x2F;h4&gt;</span><br><span class="line">    &lt;p&gt;&lt;strong&gt;Name:&lt;&#x2F;strong&gt;BDing&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;h5&gt;male&lt;&#x2F;h5&gt;</span><br><span class="line">    &lt;ol&gt;</span><br><span class="line">      &lt;li&gt;coding&lt;&#x2F;li&gt;</span><br><span class="line">      &lt;li&gt;loving&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ol&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<p>当 p 节点上发生 reflow 时，hello 和 body 也会重新渲染，甚至 h5 和 ol 都会收到影响。</p>
<p><strong>局部范围重排：</strong></p>
<p>用局部布局来解释这种现象：把一个 dom 的宽高之类的几何信息定死，然后在 dom 内部触发重排，就只会重新渲染该 dom 内部的元素，而不会影响到外界。</p>
<h2 id="重绘-Repaints"><a href="#重绘-Repaints" class="headerlink" title="重绘(Repaints):"></a>重绘(Repaints):</h2><h3 id="概念：-1"><a href="#概念：-1" class="headerlink" title="概念："></a>概念：</h3><p>当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。</p>
<h3 id="常见的引起重绘的属性："><a href="#常见的引起重绘的属性：" class="headerlink" title="常见的引起重绘的属性："></a>常见的引起重绘的属性：</h3><table>
<thead>
<tr>
<th>属性：</th>
<th>–</th>
<th>–</th>
<th>–</th>
</tr>
</thead>
<tbody><tr>
<td>color</td>
<td>border-style</td>
<td>visibility</td>
<td>background</td>
</tr>
<tr>
<td>text-decoration</td>
<td>background-image</td>
<td>background-position</td>
<td>background-repeat</td>
</tr>
<tr>
<td>outline-color</td>
<td>outline</td>
<td>outline-style</td>
<td>border-radius</td>
</tr>
<tr>
<td>outline-width</td>
<td>box-shadow</td>
<td>background-size</td>
<td></td>
</tr>
</tbody></table>
<h2 id="重排优化建议："><a href="#重排优化建议：" class="headerlink" title="重排优化建议："></a>重排优化建议：</h2><p>重排的代价是高昂的，会破坏用户体验，并且让 UI 展示非常迟缓。通过减少重排的负面影响来提高用户体验的最简单方式就是尽可能的减少重排次数，重排范围。下面是一些行之有效的建议，大家可以用来参考。</p>
<h3 id="减少重排范围"><a href="#减少重排范围" class="headerlink" title="减少重排范围"></a>减少重排范围</h3><p>我们应该尽量以局部布局的形式组织 html 结构，尽可能小的影响重排的范围。</p>
<ul>
<li>尽可能在低层级的 DOM 节点上，而不是像上述全局范围的示例代码一样，如果你要改变 p 的样式，class 就不要加在 div 上，通过父元素去影响子元素不好。</li>
<li>不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局。那么在不得已使用 table 的场合，可以设置 table-layout:auto;或者是 table-layout:fixed 这样可以让 table 一行一行的渲染，这种做法也是为了限制 reflow 的影响范围。</li>
</ul>
<h3 id="减少重排次数"><a href="#减少重排次数" class="headerlink" title="减少重排次数"></a>减少重排次数</h3><h4 id="1-样式集中改变"><a href="#1-样式集中改变" class="headerlink" title="1.样式集中改变"></a>1.样式集中改变</h4><p>不要频繁的操作样式，对于一个静态页面来说，明智且可维护的做法是更改类名而不是修改样式，对于动态改变的样式来说，相较每次微小修改都直接触及元素，更好的办法是统一在 <code>cssText</code> 变量中编辑。虽然现在大部分现代浏览器都会有 <code>Flush</code> 队列进行渲染队列优化，但是有些老版本的浏览器比如 IE6 的效率依然低下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; bad</span><br><span class="line">var left &#x3D; 10;</span><br><span class="line">var top &#x3D; 10;</span><br><span class="line">el.style.left &#x3D; left + &quot;px&quot;;</span><br><span class="line">el.style.top &#x3D; top + &quot;px&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当top和left的值是动态计算而成时...</span><br><span class="line">&#x2F;&#x2F; better</span><br><span class="line">el.style.cssText +&#x3D; &quot;; left: &quot; + left + &quot;px; top: &quot; + top + &quot;px;&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; better</span><br><span class="line">el.className +&#x3D; &quot; className&quot;;</span><br></pre></td></tr></table></figure>

<h4 id="2-分离读写操作"><a href="#2-分离读写操作" class="headerlink" title="2.分离读写操作"></a>2.分离读写操作</h4><p>DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; bad 强制刷新 触发四次重排+重绘</span><br><span class="line">div.style.left &#x3D; div.offsetLeft + 1 + &#39;px&#39;;</span><br><span class="line">div.style.top &#x3D; div.offsetTop + 1 + &#39;px&#39;;</span><br><span class="line">div.style.right &#x3D; div.offsetRight + 1 + &#39;px&#39;;</span><br><span class="line">div.style.bottom &#x3D; div.offsetBottom + 1 + &#39;px&#39;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; good 缓存布局信息 相当于读写分离 触发一次重排+重绘</span><br><span class="line">var curLeft &#x3D; div.offsetLeft;</span><br><span class="line">var curTop &#x3D; div.offsetTop;</span><br><span class="line">var curRight &#x3D; div.offsetRight;</span><br><span class="line">var curBottom &#x3D; div.offsetBottom;</span><br><span class="line"></span><br><span class="line">div.style.left &#x3D; curLeft + 1 + &#39;px&#39;;</span><br><span class="line">div.style.top &#x3D; curTop + 1 + &#39;px&#39;;</span><br><span class="line">div.style.right &#x3D; curRight + 1 + &#39;px&#39;;</span><br><span class="line">div.style.bottom &#x3D; curBottom + 1 + &#39;px&#39;;</span><br></pre></td></tr></table></figure>

<p>原来的操作会导致四次重排，读写分离之后实际上只触发了一次重排，这都得益于浏览器的渲染队列机制：</p>
<blockquote>
<p>当我们修改了元素的几何属性，导致浏览器触发重排或重绘时。它会把该操作放进渲染队列，等到队列中的操作到了一定的数量或者到了一定的时间间隔时，浏览器就会批量执行这些操作。</p>
</blockquote>
<h4 id="3-将-DOM-离线"><a href="#3-将-DOM-离线" class="headerlink" title="3.将 DOM 离线"></a>3.将 DOM 离线</h4><p>“离线”意味着不在当前的 DOM 树中做修改，我们可以这样做：</p>
<ul>
<li>使用 display:none</li>
</ul>
<p>一旦我们给元素设置 <code>display:none</code> 时（只有一次重排重绘），元素便不会再存在在渲染树中，相当于将其从页面上“拿掉”，我们之后的操作将不会触发重排和重绘，添加足够多的变更后，通过 <code>display</code>属性显示（另一次重排重绘）。通过这种方式即使大量变更也只触发两次重排。另外，<code>visibility : hidden</code> 的元素只对重绘有影响，不影响重排。</p>
<ul>
<li>通过 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment">documentFragment</a> 创建一个 <code>dom</code> 碎片,在它上面批量操作 <code>dom</code>，操作完成之后，再添加到文档中，这样只会触发一次重排。</li>
<li>复制节点，在副本上工作，然后替换它！</li>
</ul>
<h4 id="4-使用-absolute-或-fixed-脱离文档流"><a href="#4-使用-absolute-或-fixed-脱离文档流" class="headerlink" title="4.使用 absolute 或 fixed 脱离文档流"></a>4.使用 absolute 或 fixed 脱离文档流</h4><p>使用绝对定位会使的该元素单独成为渲染树中 <code>body</code> 的一个子元素，重排开销比较小，不会对其它节点造成太多影响。当你在这些节点上放置这个元素时，一些其它在这个区域内的节点可能需要重绘，但是不需要重排。</p>
<h4 id="5-优化动画"><a href="#5-优化动画" class="headerlink" title="5.优化动画"></a>5.优化动画</h4><ul>
<li><p>可以把动画效果应用到 <code>position</code>属性为 <code>absolute</code> 或 <code>fixed</code> 的元素上，这样对其他元素影响较小。<br>动画效果还应牺牲一些平滑，来换取速度，这中间的度自己衡量： 比如实现一个动画，以 1 个像素为单位移动这样最平滑，但是 Layout 就会过于频繁，大量消耗 CPU 资源，如果以 3 个像素为单位移动则会好很多</p>
</li>
<li><p>启用 GPU 加速 <code>GPU</code> 硬件加速是指应用 <code>GPU</code> 的图形性能对浏览器中的一些图形操作交给 <code>GPU</code> 来完成，因为 <code>GPU</code> 是专门为处理图形而设计，所以它在速度和能耗上更有效率。<br><code>GPU</code> 加速通常包括以下几个部分：Canvas2D，布局合成, CSS3 转换（transitions），CSS3 3D 变换（transforms），WebGL 和视频(video)。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">* 根据上面的结论</span><br><span class="line">* 将 2d transform 换成 3d</span><br><span class="line">* 就可以强制开启 GPU 加速</span><br><span class="line">* 提高动画性能</span><br><span class="line">*&#x2F;</span><br><span class="line">div &#123;</span><br><span class="line">  transform: translate3d(10px, 10px, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何在浏览器中查看页面渲染时间"><a href="#如何在浏览器中查看页面渲染时间" class="headerlink" title="如何在浏览器中查看页面渲染时间"></a>如何在浏览器中查看页面渲染时间</h2><p>1.打开开发者工具：点击 Performance 左侧有个小圆点 点击刷新页面会录制整个页面加载出来 时间的分配情况。如下图</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619151494645-c4bd51a8-0e69-4887-a6bf-c7f909c9bb6f.png#clientId=u94e07666-41db-4&from=drop&id=u03928006&margin=%5Bobject%20Object%5D&name=2.png&originHeight=829&originWidth=680&originalType=binary&size=147234&status=done&style=none&taskId=u0b1eddf4-9c59-4f4c-a2a6-80a7f6195e0" alt="2.png"></p>
<ul>
<li>蓝色: 网络通信和 HTML 解析</li>
<li>黄色: JavaScript 执行</li>
<li>紫色: 样式计算和布局，即重排</li>
<li>绿色: 重绘</li>
</ul>
<p>哪种色块比较多，就说明性能耗费在那里。色块越长，问题越大。</p>
<p>2.点击 Event Log：单独勾选 Loading 项会显示 html 和 css 加载时间。如下图：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619151540816-61f9df67-3054-4b8e-a2e7-da929d01eb77.png#clientId=u94e07666-41db-4&from=drop&id=u59c3d491&margin=%5Bobject%20Object%5D&name=3.png&originHeight=621&originWidth=675&originalType=binary&size=118065&status=done&style=none&taskId=u6ead564e-4a04-47ed-b5da-5ff10cdf20d" alt="3.png"></p>
<p>3.解析完 DOM+CSSOM 之后会生成一个渲染树 Render Tree，就是 DOM 和 CSSOM 的一一对应关系。</p>
<p>4.通过渲染树中在屏幕上“画”出的所有节点，称为渲染。</p>
<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><ul>
<li>渲染的三个阶段 Layout，Paint，Composite Layers。 Layout：重排，又叫回流。 Paint:重绘，重排重绘这些步骤都是在 CPU 中发生的。 Compostite Layers：CPU 把生成的 BitMap（位图）传输到 GPU，渲染到屏幕。</li>
<li>CSS3 就是在 GPU 发生的：Transform Opacity。在 GPU 发生的属性比较高效。所以 CSS3 性能比较高。</li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>非常感谢你看完了这篇很长的文章，也希望大家能重视重排的这些问题，在我们平时的开发中，也需要有意识的规避这些问题，才能让我们写出来的代码更规范！</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000017491520">掌握浏览器重绘(repaint)重排(reflow))-前端进阶</a></p>
<p><a target="_blank" rel="noopener" href="https://csstriggers.com/">csstriggers</a></p>
<p><a target="_blank" rel="noopener" href="https://efe.baidu.com/blog/hardware-accelerated-css-the-nice-vs-the-naughty/">CSS 硬件加速的好与坏</a></p>
<p>欢迎大家关注我的公众号，一起研究前端技术，期待与你共同进步。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/21377586/1619151550276-0ea0bf43-ec4c-4ce2-880a-8c726fd04a0b.jpeg#clientId=u94e07666-41db-4&from=drop&id=u5ca8fd73&margin=%5Bobject%20Object%5D&name=4.jpg&originHeight=649&originWidth=1500&originalType=binary&size=306289&status=done&style=none&taskId=u8098271c-bb28-4ba5-9b04-4c5316ef2bf" alt="4.jpg"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/23/yuque/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/23/yuque/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5/" class="post-title-link" itemprop="url">性能优化手段</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-23 12:09:55" itemprop="dateCreated datePublished" datetime="2021-04-23T12:09:55+08:00">2021-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-02 20:01:29" itemprop="dateModified" datetime="2021-05-02T20:01:29+08:00">2021-05-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619151042204-47a6c0b4-9803-47d8-8c30-4250196c6c45.png#clientId=u36fa501e-dc3b-4&from=paste&height=2948&id=u21574d4d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=2948&originWidth=1063&originalType=binary&size=251688&status=done&style=none&taskId=uc2d5a027-1c85-4cf1-b38e-b8a955834e2&width=1063" alt="image.png"><br><a target="_blank" rel="noopener" href="https://alienzhou.com/projects/fe-performance-journey/#%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9F">性能优化网站</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/23/yuque/RAIL%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/23/yuque/RAIL%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">RAIL模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-23 12:03:14" itemprop="dateCreated datePublished" datetime="2021-04-23T12:03:14+08:00">2021-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-02 20:01:29" itemprop="dateModified" datetime="2021-05-02T20:01:29+08:00">2021-05-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>RAIL 是一个以用户为中心的性能模型，它把用户的体验拆分成几个关键点（例如，tap，scroll，load），并且帮你定义好了每一个的性能指标。</p>
<p>有以下四个方面：</p>
<ul>
<li>Response</li>
<li>Animation</li>
<li>Idle</li>
<li>Load</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619150771872-117600c0-b2a9-43ed-a90b-b8247570bdff.png#clientId=ub5665ef9-7048-4&from=drop&id=u486a7804&margin=%5Bobject%20Object%5D&name=1.png&originHeight=504&originWidth=1390&originalType=binary&size=53426&status=done&style=none&taskId=u9d743441-e052-4807-8e12-3db9d757539" alt="1.png"></p>
<h2 id="聚焦用户"><a href="#聚焦用户" class="headerlink" title="聚焦用户"></a>聚焦用户</h2><p>以下是用户对性能延迟的感知：</p>
<table>
<thead>
<tr>
<th>延迟时间</th>
<th>用户感知</th>
</tr>
</thead>
<tbody><tr>
<td>0-16ms</td>
<td>很流畅</td>
</tr>
<tr>
<td>0-100ms</td>
<td>基本流畅</td>
</tr>
<tr>
<td>100-1000ms</td>
<td>感觉到网站上有一些加载任务</td>
</tr>
<tr>
<td>1000ms or more</td>
<td>失去耐心了</td>
</tr>
<tr>
<td>10000ms or more</td>
<td>直接离开，不会再访问了</td>
</tr>
</tbody></table>
<h2 id="Response-事件处理最好在-50ms-内完成"><a href="#Response-事件处理最好在-50ms-内完成" class="headerlink" title="Response: 事件处理最好在 50ms 内完成"></a>Response: 事件处理最好在 50ms 内完成</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul>
<li>用户的输入到响应的时间不超过 100ms，给用户的感受是瞬间就完成了。</li>
</ul>
<h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><ul>
<li>事件处理函数在 50ms 内完成，考虑到 idle task 的情况，事件会排队，等待时间大概在 50ms。适用于 click，toggle，starting animations 等，不适用于 drag 和 scroll。</li>
<li>复杂的 js 计算尽可能放在后台，如 web worker，避免对用户输入造成阻塞</li>
<li>超过 50ms 的响应，一定要提供反馈，比如倒计时，进度百分比等。</li>
</ul>
<blockquote>
<p>idle task：除了要处理输入事件，浏览器还有其它任务要做，这些任务会占用部分时间，一般情况会花费 50ms 的时间，输入事件的响应则排在其后。</p>
</blockquote>
<p>下图是 idle task 对 input response 的影响：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619150777984-c9507c61-f117-4ce2-923a-8ee977344b57.png#clientId=ub5665ef9-7048-4&from=drop&id=u97430f32&margin=%5Bobject%20Object%5D&name=2.png&originHeight=1200&originWidth=2400&originalType=binary&size=235602&status=done&style=none&taskId=u4b853e52-ee45-4c14-8c7f-bdb6320bad2" alt="2.png"></p>
<h2 id="Animation-在-10ms-内产生一帧"><a href="#Animation-在-10ms-内产生一帧" class="headerlink" title="Animation: 在 10ms 内产生一帧"></a>Animation: 在 10ms 内产生一帧</h2><h3 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h3><ul>
<li>产生每一帧的时间不要超过 10ms，为了保证浏览器 60 帧，每一帧的时间在 16ms 左右，但浏览器需要用 6ms 来渲染每一帧。</li>
<li>旨在视觉上的平滑。用户对帧率变化感知很敏感。</li>
</ul>
<h3 id="优化方案-1"><a href="#优化方案-1" class="headerlink" title="优化方案"></a>优化方案</h3><ul>
<li>在一些高压点上，比如动画，不要去挑战 cpu，尽可能地少做事，如：取 offset，设置 style 等操作。尽可能地保证 60 帧的体验。</li>
<li>在渲染性能上，针对不同的动画做一些特定优化</li>
</ul>
<blockquote>
<p>动画不只是 UI 的视觉效果，以下行为都属于</p>
</blockquote>
<blockquote>
<ul>
<li>视觉动画，如渐隐渐显，tweens，loading 等</li>
<li>滚动，包含弹性滚动，松开手指后，滚动会持续一段距离</li>
<li>拖拽，缩放，经常伴随着用户行为</li>
</ul>
</blockquote>
<h2 id="Idle-最大化空闲时间"><a href="#Idle-最大化空闲时间" class="headerlink" title="Idle: 最大化空闲时间"></a>Idle: 最大化空闲时间</h2><h3 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h3><ul>
<li>最大化空闲时间，以增大 50ms 内响应用户输入的几率</li>
</ul>
<h3 id="优化方案-2"><a href="#优化方案-2" class="headerlink" title="优化方案"></a>优化方案</h3><ul>
<li>用空闲时间来完成一些延后的工作，如先加载页面可见的部分，然后利用空闲时间加载剩余部分，此处可以使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback">requestIdleCallback API</a></li>
<li>在空闲时间内执行的任务尽量控制在 50ms 以内，如果更长的话，会影响 input handle 的 pending 时间</li>
<li>如果用户在空闲时间任务进行时进行交互，必须以此为最高优先级，并暂停空闲时间的任务</li>
</ul>
<h2 id="Load-传输内容到页面可交互的时间不超过-5-秒"><a href="#Load-传输内容到页面可交互的时间不超过-5-秒" class="headerlink" title="Load: 传输内容到页面可交互的时间不超过 5 秒"></a>Load: 传输内容到页面可交互的时间不超过 5 秒</h2><p>如果页面加载比较慢，用户的交点可能会离开。加载很快的页面，用户平均停留时间会变长，跳出率会更低，也就有更高的广告查看率</p>
<h3 id="目标-3"><a href="#目标-3" class="headerlink" title="目标"></a>目标</h3><ul>
<li>优化加载速度，可以根据设备、网络等条件。目前，比较好的一个方式是，让你的页面在一个中配的 3G 网络手机上打开时间不超过 5 秒</li>
<li>对于第二次打开，尽量不超过 2 秒</li>
</ul>
<h3 id="优化方案-3"><a href="#优化方案-3" class="headerlink" title="优化方案"></a>优化方案</h3><ul>
<li>在手机设备上测试加载性能，选用中配的 3G 网络（400kb/s，400ms RTT），可以使用 <a target="_blank" rel="noopener" href="https://www.webpagetest.org/easy">WebPageTest</a> 来测试</li>
<li>要注意的是，即使用户的网络是 4G，但因为丢包或者网络波动，可能会比预期的更慢</li>
<li><a target="_blank" rel="noopener" href="https://web.dev/render-blocking-resources/">禁用渲染阻塞的资源，延后加载</a></li>
<li>可以采用 <a target="_blank" rel="noopener" href="https://web.dev/native-lazy-loading/">lazy load</a>，<a target="_blank" rel="noopener" href="https://web.dev/reduce-javascript-payloads-with-code-splitting/">code-splitting</a> 等 <a target="_blank" rel="noopener" href="https://web.dev/fast/">其他优化</a> 手段，让第一次加载的资源更少</li>
</ul>
<h2 id="分析-RAIL-用的工具"><a href="#分析-RAIL-用的工具" class="headerlink" title="分析 RAIL 用的工具"></a>分析 RAIL 用的工具</h2><ul>
<li><a target="_blank" rel="noopener" href="https://developers.google.com/web/tools/chrome-devtools">Chrome DevTools</a></li>
<li><a target="_blank" rel="noopener" href="https://web.dev/measure/">Lighthouse</a></li>
<li><a target="_blank" rel="noopener" href="https://webpagetest.org/easy">WebPageTest</a></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>RAIL 是一个旅程，为了提升用户在网站的交互体验而不断探索。你需要去理解用户如何感知你的站点，这样才能设置最佳的性能目标</p>
<ul>
<li>聚焦用户</li>
<li>100ms 内响应用户的输入</li>
<li>10ms 内产生 1 帧，在滚动或者动画执行时</li>
<li>最大化主线程的空闲时间</li>
<li>5s 内让网页变得可交互</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://web.dev/rail/">https://web.dev/rail/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/23/yuque/this%E6%8C%87%E5%90%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/23/yuque/this%E6%8C%87%E5%90%91/" class="post-title-link" itemprop="url">this指向</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-23 11:13:15" itemprop="dateCreated datePublished" datetime="2021-04-23T11:13:15+08:00">2021-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-02 20:01:29" itemprop="dateModified" datetime="2021-05-02T20:01:29+08:00">2021-05-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>其实 JS 中的 this 是一个非常简单的东西，只需要理解它的执行规则就 OK。<br>在这里不想像其他博客一样展示太多的代码例子弄得天花乱坠， 反而不易理解。<br>call/apply/bind 可以显示绑定, 这里就不说了。<br>主要这些场隐式绑定的场景讨论:</p>
<ol>
<li>全局上下文</li>
<li>直接调用函数</li>
<li>对象.方法的形式调用</li>
<li>DOM 事件绑定(特殊)</li>
<li>new 构造函数绑定</li>
<li>箭头函数</li>
</ol>
<h2 id="1-全局上下文"><a href="#1-全局上下文" class="headerlink" title="1. 全局上下文"></a>1. 全局上下文</h2><p>全局上下文默认 this 指向 window, 严格模式下指向 undefined。</p>
<h2 id="2-直接调用函数"><a href="#2-直接调用函数" class="headerlink" title="2. 直接调用函数"></a>2. 直接调用函数</h2><p>比如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> func = obj.a;</span><br><span class="line">func();</span><br></pre></td></tr></table></figure>

<p>这种情况是直接调用。this 相当于全局上下文的情况。</p>
<h2 id="3-对象-方法的形式调用"><a href="#3-对象-方法的形式调用" class="headerlink" title="3. 对象.方法的形式调用"></a>3. 对象.方法的形式调用</h2><p>还是刚刚的例子，我如果这样写:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.a();</span><br></pre></td></tr></table></figure>

<p>这就是对象.方法的情况，this 指向这个对象</p>
<h2 id="4-DOM-事件绑定"><a href="#4-DOM-事件绑定" class="headerlink" title="4. DOM 事件绑定"></a>4. DOM 事件绑定</h2><p>onclick 和 addEventerListener 中 this 默认指向绑定事件的元素。<br>IE 比较奇异，使用 attachEvent，里面的 this 默认指向 window。</p>
<h2 id="5-new-构造函数"><a href="#5-new-构造函数" class="headerlink" title="5. new+构造函数"></a>5. new+构造函数</h2><p>此时构造函数中的 this 指向实例对象。</p>
<h2 id="6-箭头函数？"><a href="#6-箭头函数？" class="headerlink" title="6. 箭头函数？"></a>6. 箭头函数？</h2><p>箭头函数没有 this, 因此也不能绑定。里面的 this 会指向当前最近的非箭头函数的 this，找不到就是 window(严格模式是 undefined)。比如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">do</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.a(); <span class="comment">// 找到最近的非箭头函数a，a现在绑定着obj, 因此箭头函数中的this是obj</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>优先级: new &gt; call、apply、bind &gt; 对象.方法 &gt; 直接调用。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/23/yuque/%E6%B5%AE%E5%8A%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/23/yuque/%E6%B5%AE%E5%8A%A8/" class="post-title-link" itemprop="url">浮动</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-23 11:01:11" itemprop="dateCreated datePublished" datetime="2021-04-23T11:01:11+08:00">2021-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-02 20:01:29" itemprop="dateModified" datetime="2021-05-02T20:01:29+08:00">2021-05-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>页面布局是 CSS 的一个重点应用，例如：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619146953214-6eed72b4-4298-495c-a102-898368d09ad4.png#clientId=u3dd556fe-de2a-4&from=paste&height=352&id=u855d221f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=352&originWidth=403&originalType=binary&size=18863&status=done&style=none&taskId=u9200601b-2bf4-48f6-9483-45483faad6f&width=403" alt="image.png"><br>而实现页面布局主要应用到两种方法，一种是<strong>CSS 浮动</strong>，一种是<strong>Flexbox</strong>（IE9 以上），本文主要讲的是 CSS 浮动，下一篇文章将阐述 Flexbox。</p>
<h2 id="浮动元素"><a href="#浮动元素" class="headerlink" title="浮动元素"></a>浮动元素</h2><p><strong>什么是浮动元素：</strong>浮动元素同时处于常规流内和流外的元素。其中块级元素认为浮动元素不存在，而浮动元素会影响行内元素的布局，浮动元素会通过影响行内元素间接影响了包含块的布局。<br><strong>常规流：</strong>页面上从左往右，从上往下排列的元素流，就是常规流<strong>脱离常规流：</strong>绝对定位，fixed 定位的元素有自己固定的位置，脱离了常规流<strong>包含块：</strong>一个元素离它最近的块级元素是它的包含块<br>下面详细描述以上的内容，举个?：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Bin<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    .border &#123;</span><br><span class="line"><span class="css">      <span class="attribute">border</span>: <span class="number">2px</span> solid;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .common-div &#123;</span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">160px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: red;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .float-red &#123;</span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: <span class="number">#fcc</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">float</span>: left;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .float-blue &#123;</span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: <span class="number">#09c</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">float</span>: left;</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;border&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;float-red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;common-div&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;float-blue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod</span><br><span class="line">      tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim</span><br><span class="line">      veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea</span><br><span class="line">      commodo consequat. Duis aute irure dolor in reprehenderit in voluptate</span><br><span class="line">      velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat</span><br><span class="line">      cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id</span><br><span class="line">      est laborum.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面这段代码显示的样子如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619147229902-4673d52d-70f9-478e-adea-7b20d3d8950e.png#clientId=u3dd556fe-de2a-4&from=paste&height=195&id=uc054066a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=195&originWidth=732&originalType=binary&size=83482&status=done&style=none&taskId=udf3b458b-8f49-4e66-89a6-76fa62b2260&width=732" alt="image.png"></p>
<ul>
<li>块级元素认为浮动元素不存在：红色的块级元素没有受到粉色浮动元素的影响，还展示在左上角的位置，但是被粉色元素盖住了左边的部分</li>
<li>浮动元素会影响行内元素：文字部分被蓝色浮动元素影响，空出了蓝色浮动元素的部分</li>
<li>浮动元素会间接影响了包含块的布局：浮动元素影响了文字部分吗，使之多出了一行，文字部分撑高了最外面的 border 框，所以间接影响了包含块的布局。</li>
</ul>
<p>其中，<strong>浮动元素的摆放</strong>会遵循如下的规则：</p>
<ul>
<li>尽量靠上</li>
<li>尽量靠左</li>
<li>尽量一个挨着一个</li>
<li>不能超出包含块，除非元素比包含块更宽</li>
<li>不能超过所在行的最高点</li>
<li>不能超过它前面浮动元素的最高点</li>
<li>行内元素绕着浮动元素摆放：左浮动元素的右边和右浮动元素的左边会出浮动元素</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>浮动元素并不能撑起包含块，这和我们的预期并不相符。通过以下的办法可以将包含块撑开，称之为<strong>闭合浮动</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619147337086-bbbe8792-e580-421d-9bb2-ec0b637fa630.png#clientId=u3dd556fe-de2a-4&from=paste&height=227&id=u37fc5218&margin=%5Bobject%20Object%5D&name=image.png&originHeight=227&originWidth=732&originalType=binary&size=4433&status=done&style=none&taskId=u99d50c93-721b-4ea8-8032-35592e09c65&width=732" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619147351522-7de19830-7fd5-46ca-8c78-4deb7fad9719.png#clientId=u3dd556fe-de2a-4&from=paste&height=226&id=ud232f1d9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=226&originWidth=732&originalType=binary&size=5293&status=done&style=none&taskId=ubee4f117-405f-4bea-bf75-279079dc0ab&width=732" alt="image.png"></p>
<h3 id="闭合浮动的方法："><a href="#闭合浮动的方法：" class="headerlink" title="闭合浮动的方法："></a>闭合浮动的方法：</h3><ul>
<li>**BFC:**1) 包含块设置 overflow:hidden 或者 2)包含块设置 display:table-cell/table/flex…</li>
</ul>
<blockquote>
<p><strong>BFC：块级格式化上下文。它是一个独立的渲染区域，只有 Block-level box 参与， 它规定了内部的块级元素如何布局，并且与这个区域外部毫不相干。</strong>只要<strong>符合以下的条件就是 BFC:</strong></p>
<ol>
<li>根元素</li>
<li>float 属性不为 none</li>
<li>position 为 absolute 或 fixed</li>
<li>display 为 inline-block, table-cell, table-caption, flex, inline-flex</li>
<li>overflow 不为 visible</li>
</ol>
</blockquote>
<p>相应的背景文档可以参阅：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html">《BFC 的神奇原理》</a></p>
<ul>
<li><strong>伪元素</strong>：</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>clear:both;意味着块级元素的左边和右边都不能有浮动元素。在包含块的末尾建立了一个内容为空的伪元素，并设置 clear:both，使这个元素位于所有的浮动元素之后，从而撑开了包含块的高。</p>
</blockquote>
<ul>
<li><strong>包含块自己也浮动</strong></li>
</ul>
<p>这个方法也是 w3c 使用的方法。不过，下一个元素会受到这个浮动元素的影响。为了解决这个问题，有些人选择对布局中的所有东西进行浮动，然后使用适当的有意义的元素（常常是站点的页脚）对这些浮动进行清理。这有助于减少或消除不必要的标记。<br>相应的背景文档：<a target="_blank" rel="noopener" href="http://www.w3school.com.cn/css/css_positioning_floating.asp">《W3C CSS 浮动》</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/23/yuque/%E5%B1%85%E4%B8%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/23/yuque/%E5%B1%85%E4%B8%AD/" class="post-title-link" itemprop="url">居中</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-23 00:50:15" itemprop="dateCreated datePublished" datetime="2021-04-23T00:50:15+08:00">2021-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-02 20:01:29" itemprop="dateModified" datetime="2021-05-02T20:01:29+08:00">2021-05-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="使-div-水平垂直居中"><a href="#使-div-水平垂直居中" class="headerlink" title="使 div 水平垂直居中"></a>使 div 水平垂直居中</h2><h3 id="1-flex-布局实现-（元素已知宽度）"><a href="#1-flex-布局实现-（元素已知宽度）" class="headerlink" title="1. flex 布局实现 （元素已知宽度）"></a>1. flex 布局实现 （元素已知宽度）</h3><p>效果图：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619146489383-dabd2076-1f04-4e82-81e3-d86d1d22eafb.png#clientId=u1943cb8a-69e5-4&from=drop&height=383&id=u363d0ddb&margin=%5Bobject%20Object%5D&name=1.png&originHeight=383&originWidth=386&originalType=binary&size=3576&status=done&style=none&taskId=uc34a2d5e-e2c5-41bd-b804-d7e156eb83a&width=386" alt="1.png"></p>
<p>内部 div 要有宽度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CSS 代码:</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .box&#123;</span><br><span class="line">        width: 300px;</span><br><span class="line">        height: 300px;</span><br><span class="line">        background-color: #ccc;</span><br><span class="line">        display: flex;</span><br><span class="line">        display: -webkit-flex;</span><br><span class="line">        justify-content: center;</span><br><span class="line">        align-items: center;</span><br><span class="line">    &#125;</span><br><span class="line">    .box .a&#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background-color: blue;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">HTML 代码：</span><br><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;a&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-position-（元素已知宽度）"><a href="#2-position-（元素已知宽度）" class="headerlink" title="2. position （元素已知宽度）"></a>2. position （元素已知宽度）</h3><p>父元素设置为：position: relative;</p>
<p>子元素设置为：position: absolute;</p>
<p>距上 50%，据左 50%，然后减去元素自身宽度的一半距离就可以实现</p>
<p>效果图：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619146703137-b0763b8f-94bb-406d-97c8-b6c1e4314c40.png#clientId=u1943cb8a-69e5-4&from=drop&height=387&id=u2049101e&margin=%5Bobject%20Object%5D&name=2.png&originHeight=387&originWidth=388&originalType=binary&size=3643&status=done&style=none&taskId=uf4db9e4e-1137-4b7f-8dad-b432a4ba36d&width=388" alt="2.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">CSS代码：</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .box&#123;</span><br><span class="line">        width: 300px;</span><br><span class="line">        height: 300px;</span><br><span class="line">        background-color: red;</span><br><span class="line">        position: relative;</span><br><span class="line">    &#125;</span><br><span class="line">    .box .a&#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background-color: blue;</span><br><span class="line">        position: absolute;</span><br><span class="line">        left: 50%;</span><br><span class="line">        top: 50%;</span><br><span class="line">        margin: -50px 0 0 -50px;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">HTML 代码：</span><br><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;a&quot;&gt;love&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-position-transform-（元素未知宽度）"><a href="#3-position-transform-（元素未知宽度）" class="headerlink" title="3. position transform （元素未知宽度）"></a>3. position transform （元素未知宽度）</h3><p>如果元素未知宽度，只需将上面例子中的 <code>margin: -50px 0 0 -50px;</code>替换为：<code>**transform: translate(-50%,-50%);**</code></p>
<p>效果图：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619146710342-80aa21c0-0c3d-4f5d-9f94-08aaabb7c981.png#clientId=u1943cb8a-69e5-4&from=drop&id=ubda98303&margin=%5Bobject%20Object%5D&name=3.png&originHeight=388&originWidth=390&originalType=binary&size=3061&status=done&style=none&taskId=u9cf78fcd-6b8f-42ca-96f3-93594b69ff2" alt="3.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CSS 代码：</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .box&#123;</span><br><span class="line">        width: 300px;</span><br><span class="line">        height: 300px;</span><br><span class="line">        background-color: red;</span><br><span class="line">        position: relative;</span><br><span class="line">    &#125;</span><br><span class="line">    .box .a&#123;</span><br><span class="line">        background-color: blue;</span><br><span class="line">        position: absolute;</span><br><span class="line">        top: 50%;</span><br><span class="line">        left: 50%;</span><br><span class="line">        transform: translate(-50%, -50%);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4-position（元素已知宽度）（left，right，top，bottom-为-0，maigin：auto-）"><a href="#4-position（元素已知宽度）（left，right，top，bottom-为-0，maigin：auto-）" class="headerlink" title="4. position（元素已知宽度）（left，right，top，bottom 为 0，maigin：auto ）"></a>4. position（元素已知宽度）（left，right，top，bottom 为 0，maigin：auto ）</h3><p>效果图：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619146715247-987c1c49-5d53-464e-b8b1-67c5ebaf4017.png#clientId=u1943cb8a-69e5-4&from=drop&id=ud37941b7&margin=%5Bobject%20Object%5D&name=4.png&originHeight=379&originWidth=381&originalType=binary&size=3339&status=done&style=none&taskId=ud7db8148-4b76-4e28-83f5-8b0f7f3a754" alt="4.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">CSS 代码：</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .box&#123;</span><br><span class="line">        width: 300px;</span><br><span class="line">        height: 300px;</span><br><span class="line">        background-color: red;</span><br><span class="line">        position: relative;</span><br><span class="line">    &#125;</span><br><span class="line">    .box .a&#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background-color: blue;</span><br><span class="line">        position: absolute;</span><br><span class="line">        top: 0;</span><br><span class="line">        bottom: 0;</span><br><span class="line">        left: 0;</span><br><span class="line">        right: 0;</span><br><span class="line">        margin: auto;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">HTML 代码：</span><br><span class="line"> &lt;div class&#x3D;&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;a&quot;&gt;love&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="★-第四种情况方案中，如果子元素不设置宽度和高度，将会铺满整个父级（应用：模态框）"><a href="#★-第四种情况方案中，如果子元素不设置宽度和高度，将会铺满整个父级（应用：模态框）" class="headerlink" title="★ 第四种情况方案中，如果子元素不设置宽度和高度，将会铺满整个父级（应用：模态框）"></a>★ 第四种情况方案中，如果子元素不设置宽度和高度，将会铺满整个父级（应用：模态框）</h3><p>效果图：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619146723119-e126b7f1-ae6e-4c5d-b0ea-5ffebbde520b.png#clientId=u1943cb8a-69e5-4&from=drop&id=u7e7631e4&margin=%5Bobject%20Object%5D&name=5.png&originHeight=385&originWidth=383&originalType=binary&size=2233&status=done&style=none&taskId=u1f75ae94-26cd-41fd-abd5-029063df33b" alt="5.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">CSS 代码：</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .box&#123;</span><br><span class="line">        width: 300px;</span><br><span class="line">        height: 300px;</span><br><span class="line">        background-color: red;</span><br><span class="line">        position: relative;</span><br><span class="line">    &#125;</span><br><span class="line">    .box .a&#123;</span><br><span class="line">        &#x2F;* 如果不设置宽高，将铺满整个父级*&#x2F;</span><br><span class="line">        background-color: pink;</span><br><span class="line">        position: absolute;</span><br><span class="line">        left: 0;</span><br><span class="line">        right: 0;</span><br><span class="line">        top: 0;</span><br><span class="line">        bottom: 0;</span><br><span class="line">        margin: auto;</span><br><span class="line">        text-align: center;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">HTML:</span><br><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;a&quot;&gt;love&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="5-table-cell-布局实现"><a href="#5-table-cell-布局实现" class="headerlink" title="5. table-cell 布局实现"></a>5. table-cell 布局实现</h3><p>table 实现垂直居中，子集元素可以是块元素，也可以不是块元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CSS：</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .box&#123;</span><br><span class="line">        width: 300px;</span><br><span class="line">        height: 300px;</span><br><span class="line">        background-color: red;</span><br><span class="line">        display: table-cell;</span><br><span class="line">        vertical-align: middle;</span><br><span class="line">    &#125;</span><br><span class="line">    .box .a&#123;</span><br><span class="line">        margin-left: 100px;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background-color: blue;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;a&quot;&gt;love&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<h2 id="使内容（文字，图片）水平垂直居中（table-cell-布局）"><a href="#使内容（文字，图片）水平垂直居中（table-cell-布局）" class="headerlink" title="使内容（文字，图片）水平垂直居中（table-cell 布局）"></a>使内容（文字，图片）水平垂直居中（table-cell 布局）</h2><p>行元素 text-align ：center；</p>
<p>块元素 ：margin ：0 auto；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">text-align : center  给元素的父级加，可以使文本或者行级元素(例如：图片)水平居中</span><br><span class="line">line-height : 值为元素的高度，可以使元素的文本内容垂直居中</span><br><span class="line">margin: 0 auto 使用条件：父级元素宽度可有可无，子级元素必须使块元素，而且要有宽度（否则继承父级）</span><br></pre></td></tr></table></figure>

<p><code>display：table-cell</code> 会使元素表现的类似一个表格中的单元格 td，利用这个特性可以实现文字的垂直居中效果。同时它也会破坏一些 CSS 属性，使用 table-cell 时最好不要与 float 以及 position: absolute 一起使用，设置了 table-cell 的元素对高度和宽度高度敏感，对 margin 值无反应，可以响 padding 的设置，表现几乎类似一个 td 元素。</p>
<p>小结：</p>
<ol>
<li><p>不要与 float：left， position : absolute， 一起使用</p>
</li>
<li><p>可以实现大小不固定元素的垂直居中</p>
</li>
<li><p>margin 设置无效，响应 padding 设置</p>
</li>
<li><p>对高度和宽度高度敏感</p>
</li>
<li><p>不要对 display：table-cell 使用百分比设置宽度和高度</p>
</li>
</ol>
<h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h3><h3 id="1-使文字水平垂直居中"><a href="#1-使文字水平垂直居中" class="headerlink" title="1. 使文字水平垂直居中"></a>1. 使文字水平垂直居中</h3><p>效果图：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619146730971-89bcdf26-3547-4a3d-9cc3-2673a82d9439.png#clientId=u1943cb8a-69e5-4&from=drop&id=uef0b35ec&margin=%5Bobject%20Object%5D&name=6.png&originHeight=381&originWidth=383&originalType=binary&size=3066&status=done&style=none&taskId=u1bbc8b83-a76f-476b-b72f-50989af3026" alt="6.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CSS 代码：</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .box&#123;</span><br><span class="line">        width: 300px;</span><br><span class="line">        height: 300px;</span><br><span class="line">        background-color: red;</span><br><span class="line">        display: table-cell;</span><br><span class="line">        text-align: center;&#x2F;*使元素水平居中 *&#x2F;</span><br><span class="line">        vertical-align: middle;&#x2F;*使元素垂直居中 *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">HTML 代码：</span><br><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;love&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>给父级设置 display : table，子集设置 display：tablecell ，子集会充满全屏</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619146739628-200a0b17-947b-4200-80ae-7f48517d1006.png#clientId=u1943cb8a-69e5-4&from=drop&id=udb323d0b&margin=%5Bobject%20Object%5D&name=7.png&originHeight=387&originWidth=384&originalType=binary&size=2833&status=done&style=none&taskId=ub1d9b6dc-817e-4786-a20d-534bd5b6eeb" alt="7.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CSS 代码：</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .box&#123;</span><br><span class="line">        width: 300px;</span><br><span class="line">        height: 300px;</span><br><span class="line">        background-color: red;</span><br><span class="line">        display: table;</span><br><span class="line">    &#125;</span><br><span class="line">    .box .a&#123;</span><br><span class="line">        display: table-cell;</span><br><span class="line">        vertical-align: middle;</span><br><span class="line">        text-align: center;</span><br><span class="line">        background-color: blue;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">HTML ：</span><br><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;a&quot;&gt;love&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-图片水平垂直居中"><a href="#2-图片水平垂直居中" class="headerlink" title="2. 图片水平垂直居中"></a>2. 图片水平垂直居中</h3><p>效果图：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619146745642-78df967f-a0a4-42b0-831a-7168154d7358.png#clientId=u1943cb8a-69e5-4&from=drop&id=u4c238944&margin=%5Bobject%20Object%5D&name=8.png&originHeight=384&originWidth=389&originalType=binary&size=34468&status=done&style=none&taskId=u9143a9de-a281-49df-98fd-3be4d19a41d" alt="8.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    .box&#123;</span><br><span class="line">        width: 300px;</span><br><span class="line">        height: 300px;</span><br><span class="line">        background-color: skyblue;</span><br><span class="line">        display: table-cell;</span><br><span class="line">        text-align: center;</span><br><span class="line">        vertical-align: middle;</span><br><span class="line">    &#125;</span><br><span class="line">    img&#123;</span><br><span class="line">        &#x2F;* 设置成块元素后，text-align：center 就会失效 *&#x2F;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">HTML：</span><br><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;1.jpg&quot; alt&#x3D;&quot;&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>中间的图片会随着外层容器的大小而自动水平垂直居中，其实原理和文字水平垂直居中一模一样</p>
<h3 id="3-元素两端垂直对齐"><a href="#3-元素两端垂直对齐" class="headerlink" title="3. 元素两端垂直对齐"></a>3. 元素两端垂直对齐</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">CSS 代码：</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    *&#123;</span><br><span class="line">        padding: 0;</span><br><span class="line">        margin: 0;</span><br><span class="line">    &#125;</span><br><span class="line">    .box&#123;</span><br><span class="line">        display: table;</span><br><span class="line">        width: 90%;</span><br><span class="line">        margin: 10px  auto;</span><br><span class="line">        padding: 10px;</span><br><span class="line">        border: 1px solid green;</span><br><span class="line">        height: 100px;</span><br><span class="line">    &#125;</span><br><span class="line">    .left,.right&#123;</span><br><span class="line">        display: table-cell;</span><br><span class="line">        width: 20%;</span><br><span class="line">        border: 1px solid red;</span><br><span class="line">    &#125;</span><br><span class="line">    .center&#123;</span><br><span class="line">        &#x2F;* padding-top: 10px; *&#x2F;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background-color: green;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">HTML：</span><br><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;left&quot;&gt;</span><br><span class="line">        &lt;p&gt;我是左边&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;center&quot;&gt;</span><br><span class="line">        &lt;p&gt;我是中间&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;right&quot;&gt;</span><br><span class="line">        &lt;p&gt;我是右边&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>效果：<img src="https://cdn.nlark.com/yuque/0/2021/png/21377586/1619146755174-14790b24-3a33-481b-8e5d-57f769eb50cf.png#clientId=u1943cb8a-69e5-4&from=drop&id=u6260be18&margin=%5Bobject%20Object%5D&name=9.png&originHeight=769&originWidth=1886&originalType=binary&size=51074&status=done&style=none&taskId=ub6d67e66-1825-45bd-a167-0cd508b34f4" alt="9.png"></p>
<p>其中 center 的顶部没有与左右两侧对齐，原因是 left 中的<br>有一个 margin-top ， 而表格布局中默认是文字顶部对齐的，所以 center 会向下移动到首行文字基线对齐，解决办法是为   center 添加与左右两侧中 margin-top 较大者等值的 padding-top 即可。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/22/yuque/css%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/22/yuque/css%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">css性能优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-22 23:02:27" itemprop="dateCreated datePublished" datetime="2021-04-22T23:02:27+08:00">2021-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-02 20:01:30" itemprop="dateModified" datetime="2021-05-02T20:01:30+08:00">2021-05-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>本文作者：<a target="_blank" rel="noopener" href="http://verymuch.site/">高峰</a>，360 奇舞团前端工程师，W3C 性能工作组成员，同时参与 WOT 工作组的学习。</p>
</blockquote>
<p>我们都知道对于网站来说，性能至关重要，CSS 作为页面渲染和内容展现的重要环节，影响着用户对整个网站的第一体验。因此，与其相关的性能优化是不容忽视的。</p>
<p>对于性能优化我们常常在项目完成时才去考虑，经常被推迟到项目的末期，甚至到暴露出严重的性能问题时才进行性能优化，相信大多数人对此深有体会。</p>
<p>笔者认为，为了更多地避免这一情况，首先要重视起性能优化相关的工作，将其贯穿到整个产品设计与开发中。其次，就是了解性能相关的内容，在项目开发过程中，自然而然地进行性能优化。最后，也是最最重要的，那就是从现在开始实施优化。</p>
<p>推荐大家阅读下奇舞周刊之前推的<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/C2Zx3KPNPkgj-aHnOY43Iw">《嗨，送你一张 Web 性能优化地图》</a>1 这篇文章，能够帮助大家对性能优化需要做的事以及需要考虑的问题形成一个整体的概念。</p>
<p>本文将会详细介绍 CSS 性能优化相关的技巧，笔者将它们分为<strong>实践型</strong>和<strong>建议型</strong>两类，共 8 个小技巧。实践型技巧能够快速地应用在项目中，能够很好地提升性能，也是笔者经常使用的，建议大家尽快在项目中实践。建议型技巧中，有的可能对性能影响并不显著，有的平时大家也并不会那么用，所以笔者不会着重讲述，读者们可以根据自身情况了解一下即可。</p>
<p>在正式开始之前，需要大家对于<a target="_blank" rel="noopener" href="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/">浏览器的工作原理</a>2 有些一定的了解，需要的小伙伴可以先简单了解下。</p>
<p>下面我们开始介绍<strong>实践型的 4 个优化技巧</strong>，先从首屏关键 CSS 开始。</p>
<h2 id="1-内联首屏关键-CSS（Critical-CSS）"><a href="#1-内联首屏关键-CSS（Critical-CSS）" class="headerlink" title="1. 内联首屏关键 CSS（Critical CSS）"></a>1. 内联首屏关键 CSS（Critical CSS）</h2><p>性能优化中有一个重要的指标——<strong>首次有效绘制</strong>（First Meaningful Paint，简称 FMP）即指页面的首要内容（primary content）出现在屏幕上的时间。这一指标影响用户看到页面前所需等待的时间，而<strong>内联首屏关键 CSS（即 Critical CSS，可以称之为首屏关键 CSS）</strong>能减少这一时间。</p>
<p>大家应该都习惯于通过 link 标签引用外部 CSS 文件。但需要知道的是，将 CSS 直接内联到 HTML 文档中能使 CSS 更快速地下载。而使用外部 CSS 文件时，需要在 HTML 文档下载完成后才知道所要引用的 CSS 文件，然后才下载它们。所以说，<strong>内联 CSS 能够使浏览器开始页面渲染的时间提前</strong>，因为在 HTML 下载完成之后就能渲染了。</p>
<p>既然内联 CSS 能够使页面渲染的开始时间提前，那么是否可以内联所有的 CSS 呢？答案显然是否定的，这种方式并不适用于内联较大的 CSS 文件。因为<a target="_blank" rel="noopener" href="https://tylercipriani.com/blog/2016/09/25/the-14kb-in-the-tcp-initial-window/">初始拥塞窗口</a>3 存在限制（TCP 相关概念，通常是 14.6kB，压缩后大小），如果内联 CSS 后的文件超出了这一限制，系统就需要在服务器和浏览器之间进行更多次的往返，这样并不能提前页面渲染时间。因此，我们应当<strong>只将渲染首屏内容所需的关键 CSS 内联到 HTML 中</strong>。</p>
<p>既然已经知道内联首屏关键 CSS 能够优化性能了，那下一步就是如何确定首屏关键 CSS 了。显然，我们不需要手动确定哪些内容是首屏关键 CSS。Github 上有一个项目<a target="_blank" rel="noopener" href="https://github.com/filamentgroup/criticalCSS">Critical CSS</a>4，可以将属于首屏的关键样式提取出来，大家可以看一下该项目，结合自己的构建工具进行使用。当然为了保证正确，大家最好再亲自确认下提取出的内容是否有缺失。</p>
<p>不过内联 CSS 有一个缺点，内联之后的 CSS 不会进行缓存，每次都会重新下载。不过如上所说，如果我们将内联后的文件大小控制在了 14.6kb 以内，这似乎并不是什么大问题。</p>
<p>如上，我们已经介绍了为什么要内联关键 CSS 以及如何内联，那么剩下的 CSS 我们怎么处理好呢？建议使用外部 CSS 引入剩余 CSS，这样能够启用缓存，除此之外还可以异步加载它们。</p>
<h2 id="2-异步加载-CSS"><a href="#2-异步加载-CSS" class="headerlink" title="2. 异步加载 CSS"></a>2. 异步加载 CSS</h2><p>CSS 会阻塞渲染，在 CSS 文件请求、下载、解析完成之前，浏览器将不会渲染任何已处理的内容。有时，这种阻塞是必须的，因为我们并不希望在所需的 CSS 加载之前，浏览器就开始渲染页面。那么将首屏关键 CSS 内联后，剩余的 CSS 内容的阻塞渲染就不是必需的了，可以使用外部 CSS，并且异步加载。</p>
<p>那么如何实现 CSS 的异步加载呢？有以下四种方式可以实现浏览器异步加载 CSS。</p>
<p>第一种方式是使用 JavaScript 动态创建样式表 link 元素，并插入到 DOM 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建link标签</span><br><span class="line">const myCSS &#x3D; document.createElement( &quot;link&quot; );</span><br><span class="line">myCSS.rel &#x3D; &quot;stylesheet&quot;;</span><br><span class="line">myCSS.href &#x3D; &quot;mystyles.css&quot;;</span><br><span class="line">&#x2F;&#x2F; 插入到header的最后位置</span><br><span class="line">document.head.insertBefore( myCSS, document.head.childNodes[ document.head.childNodes.length - 1 ].nextSibling );</span><br></pre></td></tr></table></figure>

<p>第二种方式是将 link 元素的<code>media</code>属性设置为用户浏览器不匹配的媒体类型（或媒体查询），如<code>media=&quot;print&quot;</code>，甚至可以是完全不存在的类型<code>media=&quot;noexist&quot;</code>。对浏览器来说，如果样式表不适用于当前媒体类型，其优先级会被放低，会在不阻塞页面渲染的情况下再进行下载。</p>
<p>当然，这么做只是为了实现 CSS 的异步加载，别忘了在文件加载完成之后，将<code>media</code>的值设为<code>screen</code>或<code>all</code>，从而让浏览器开始解析 CSS。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;mystyles.css&quot; media&#x3D;&quot;noexist&quot; onload&#x3D;&quot;this.media&#x3D;&#39;all&#39;&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>与第二种方式相似，我们还可以通过<code>rel</code>属性将<code>link</code>元素标记为<code>alternate</code>可选样式表，也能实现浏览器异步加载。同样别忘了加载完成之后，将<code>rel</code>改回去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel&#x3D;&quot;alternate stylesheet&quot; href&#x3D;&quot;mystyles.css&quot; onload&#x3D;&quot;this.rel&#x3D;&#39;stylesheet&#39;&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>上述的三种方法都较为古老。现在，<a target="_blank" rel="noopener" href="https://www.w3.org/TR/preload/">rel=”preload”</a>5 这一 Web 标准指出了如何异步加载资源，包括 CSS 类资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel&#x3D;&quot;preload&quot; href&#x3D;&quot;mystyles.css&quot; as&#x3D;&quot;style&quot; onload&#x3D;&quot;this.rel&#x3D;&#39;stylesheet&#39;&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>注意，<code>as</code>是必须的。忽略<code>as</code>属性，或者错误的<code>as</code>属性会使<code>preload</code>等同于<code>XHR</code>请求，浏览器不知道加载的是什么内容，因此此类资源加载优先级会非常低。<code>as</code>的可选值可以参考上述标准文档。</p>
<p>看起来，<code>rel=&quot;preload&quot;</code>的用法和上面两种没什么区别，都是通过更改某些属性，使得浏览器异步加载 CSS 文件但不解析，直到加载完成并将修改还原，然后开始解析。</p>
<p>但是它们之间其实有一个很重要的不同点，那就是<strong>使用 preload，比使用不匹配的</strong><code>**media**</code><strong>方法能够更早地开始加载 CSS</strong>。所以尽管这一标准的支持度还不完善，仍建议优先使用该方法。</p>
<p>该标准现在已经是候选标准，相信浏览器会逐渐支持该标准。在各浏览器的支持度如下图所示。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/21377586/1619103795934-1e5e7efa-a532-4436-a122-df52040a6183.webp#clientId=ueedfa31e-e32c-4&from=paste&height=424&id=uec2f5cd9&margin=%5Bobject%20Object%5D&originHeight=672&originWidth=1280&originalType=url&status=done&style=none&taskId=ua4e9f7be-b930-401d-b197-f62254715b8&width=807"></p>
<p>从上图可以看出这一方法在现在的浏览器中支持度不算乐观，不过我们可以通过<a target="_blank" rel="noopener" href="https://github.com/filamentgroup/loadCSS/tree/v2.0.1#loadcss">loadCSS</a>6 进行 polyfill，所以支持不支持，这都不是事儿。</p>
<h2 id="3-文件压缩"><a href="#3-文件压缩" class="headerlink" title="3. 文件压缩"></a>3. 文件压缩</h2><p>性能优化时有一个最容易想到，也最常使用的方法，那就是文件压缩，这一方案往往效果显著。</p>
<p>文件的大小会直接影响浏览器的加载速度，这一点在网络较差时表现地尤为明显。相信大家都早已习惯对 CSS 进行压缩，现在的构建工具，如 webpack、gulp/grunt、rollup 等也都支持 CSS 压缩功能。压缩后的文件能够明显减小，可以大大降低了浏览器的加载时间。</p>
<h2 id="4-去除无用-CSS"><a href="#4-去除无用-CSS" class="headerlink" title="4. 去除无用 CSS"></a>4. 去除无用 CSS</h2><p>虽然文件压缩能够降低文件大小。但 CSS 文件压缩通常只会去除无用的空格，这样就限制了 CSS 文件的压缩比例。那是否还有其他手段来精简 CSS 呢？答案显然是肯定的，如果压缩后的文件仍然超出了预期的大小，我们可以试着<strong>找到并删除代码中无用的 CSS</strong>。</p>
<p>一般情况下，会存在这两种无用的 CSS 代码：一种是不同元素或者其他情况下的重复代码，一种是整个页面内没有生效的 CSS 代码。对于前者，在编写的代码时候，我们应该尽可能地提取公共类，减少重复。对于后者，在不同开发者进行代码维护的过程中，总会产生不再使用的 CSS 的代码，当然一个人编写时也有可能出现这一问题。而这些无用的 CSS 代码不仅会增加浏览器的下载量，还会增加浏览器的解析时间，这对性能来说是很大的消耗。所以我们需要找到并去除这些无用代码。</p>
<p>当然，如果手动删除这些无用 CSS 是很低效的。我们可以借助<a target="_blank" rel="noopener" href="https://github.com/uncss/uncss">Uncss</a>7 库来进行。Uncss 可以用来移除样式表中的无用 CSS，并且支持多文件和 JavaScript 注入的 CSS。</p>
<p>前面已经说完了实践型的 4 个优化技巧，下面我们介绍下<strong>建议型的 4 个技巧</strong>。</p>
<h2 id="1-有选择地使用选择器"><a href="#1-有选择地使用选择器" class="headerlink" title="1. 有选择地使用选择器"></a>1. 有选择地使用选择器</h2><p>大多数朋友应该都知道<strong>CSS 选择器的匹配是从右向左进行的</strong>，这一策略导致了不同种类的选择器之间的性能也存在差异。相比于<code>#markdown-content-h3</code>，显然使用<code>#markdown .content h3</code>时，浏览器生成渲染树（render-tree）所要花费的时间更多。因为后者需要先找到 DOM 中的所有<code>h3</code>元素，再过滤掉祖先元素不是<code>.content</code>的，最后过滤掉<code>.content</code>的祖先不是<code>#markdown</code>的。试想，如果嵌套的层级更多，页面中的元素更多，那么匹配所要花费的时间代价自然更高。</p>
<p><strong>不过现代浏览器在这一方面做了很多优化，不同选择器的性能差别并不明显，甚至可以说差别甚微。此外不同选择器在</strong><a target="_blank" rel="noopener" href="https://benfrain.com/css-performance-revisited-selectors-bloat-expensive-styles/#h-H1_1"><strong>不同浏览器中的性能表现</strong></a><strong>8 也不完全统一，在编写 CSS 的时候无法兼顾每种浏览器</strong>。鉴于这两点原因，我们在使用选择器时，只需要记住以下几点，其他的可以全凭喜好。</p>
<ol>
<li><strong>保持简单，不要使用嵌套过多过于复杂的选择器。</strong></li>
<li><strong>通配符和属性选择器效率最低，需要匹配的元素最多，尽量避免使用。</strong></li>
<li><strong>不要使用类选择器和 ID 选择器修饰元素标签，如</strong><code>**h3#markdown-content**</code><strong>，这样多此一举，还会降低效率。</strong></li>
<li><strong>不要为了追求速度而放弃可读性与可维护性。</strong></li>
</ol>
<p>如果大家对于上面这几点还存在疑问，笔者建议大家选择以下几种 CSS 方法论之一（<a target="_blank" rel="noopener" href="https://en.bem.info/methodology/quick-start/">BEM</a>9，<a target="_blank" rel="noopener" href="http://oocss.org/">OOCSS</a>10，<a target="_blank" rel="noopener" href="https://github.com/suitcss/suit/blob/master/doc/naming-conventions.md">SUIT</a>11，<a target="_blank" rel="noopener" href="https://smacss.com/">SMACSS</a>12，<a target="_blank" rel="noopener" href="https://www.xfive.co/blog/itcss-scalable-maintainable-css-architecture/">ITCSS</a>13，<a target="_blank" rel="noopener" href="http://ecss.io/">Enduring CSS</a>14 等）作为 CSS 编写规范。使用统一的方法论能够帮助大家形成统一的风格，减少命名冲突，也能避免上述的问题，总之好处多多，如果你还没有使用，就赶快用起来吧。</p>
<blockquote>
</blockquote>
<blockquote>
</blockquote>
<h3 id="Tips：为什么-CSS-选择器是从右向左匹配的？"><a href="#Tips：为什么-CSS-选择器是从右向左匹配的？" class="headerlink" title="Tips：为什么 CSS 选择器是从右向左匹配的？"></a>Tips：为什么 CSS 选择器是从右向左匹配的？</h3><blockquote>
</blockquote>
<blockquote>
<p>CSS 中更多的选择器是不会匹配的，所以在考虑性能问题时，需要考虑的是如何在选择器不匹配时提升效率。从右向左匹配就是为了达成这一目的的，通过这一策略能够使得 CSS 选择器在不匹配的时候效率更高。这样想来，在匹配时多耗费一些性能也能够想的通了。</p>
</blockquote>
<h2 id="2-减少使用昂贵的属性"><a href="#2-减少使用昂贵的属性" class="headerlink" title="2. 减少使用昂贵的属性"></a>2. 减少使用昂贵的属性</h2><p>在浏览器绘制屏幕时，<strong>所有需要浏览器进行操作或计算的属性相对而言都需要花费更大的代价</strong>。当页面发生重绘时，它们会降低浏览器的渲染性能。所以在编写 CSS 时，我们应该尽量减少使用昂贵属性，如<code>box-shadow</code>/<code>border-radius</code>/<code>filter</code>/透明度/<code>:nth-child</code>等。</p>
<p>当然，并不是让大家不要使用这些属性，因为这些应该都是我们经常使用的属性。之所以提这一点，是让大家对此有一个了解。当有两种方案可以选择的时候，可以优先选择没有昂贵属性或昂贵属性更少的方案，如果每次都这样的选择，网站的性能会在不知不觉中得到一定的提升。</p>
<h2 id="3-优化重排与重绘"><a href="#3-优化重排与重绘" class="headerlink" title="3. 优化重排与重绘"></a>3. 优化重排与重绘</h2><p>在网站的使用过程中，某些操作会导致样式的改变，这时浏览器需要检测这些改变并重新渲染，其中有些操作所耗费的性能更多。我们都知道，当 FPS 为 60 时，用户使用网站时才会感到流畅。这也就是说，我们需要在 16.67ms 内完成每次渲染相关的所有操作，所以我们要尽量减少耗费更多的操作。</p>
<h3 id="3-1-减少重排"><a href="#3-1-减少重排" class="headerlink" title="3.1 减少重排"></a>3.1 减少重排</h3><p>重排会导致浏览器重新计算整个文档，重新构建渲染树，这一过程会降低浏览器的渲染速度。如下所示，有很多操作会触发重排，我们应该避免频繁触发这些操作。</p>
<ol>
<li>改变<code>font-size</code>和<code>font-family</code></li>
<li>改变元素的内外边距</li>
<li>通过 JS 改变 CSS 类</li>
<li>通过 JS 获取 DOM 元素的位置相关属性（如 width/height/left 等）</li>
<li>CSS 伪类激活</li>
<li>滚动滚动条或者改变窗口大小</li>
</ol>
<p>此外，我们还可以通过<a target="_blank" rel="noopener" href="https://csstriggers.com/">CSS Trigger</a>15 查询哪些属性会触发重排与重绘。</p>
<p>值得一提的是，某些 CSS 属性具有更好的重排性能。如使用<code>Flex</code>时，比使用<code>inline-block</code>和<code>float</code>时重排更快，所以在布局时可以优先考虑<code>Flex</code>。</p>
<h3 id="3-2-避免不必要的重绘"><a href="#3-2-避免不必要的重绘" class="headerlink" title="3.2 避免不必要的重绘"></a>3.2 避免不必要的重绘</h3><p>当元素的外观（如 color，background，visibility 等属性）发生改变时，会触发重绘。在网站的使用过程中，<strong>重绘是无法避免的</strong>。不过，浏览器对此做了优化，它会将多次的重排、重绘操作合并为一次执行。不过我们仍需要<strong>避免不必要的重绘</strong>，如页面滚动时触发的 hover 事件，可以在滚动的时候禁用 hover 事件，这样页面在滚动时会更加流畅。</p>
<p>此外，我们编写的 CSS 中动画相关的代码越来越多，我们已经习惯于使用动画来提升用户体验。我们在编写动画时，也应当参考上述内容，减少重绘重排的触发。除此之外我们还可以通过<a target="_blank" rel="noopener" href="https://www.sitepoint.com/introduction-to-hardware-acceleration-css-animations/">硬件加速</a>16 和<a target="_blank" rel="noopener" href="https://drafts.csswg.org/css-will-change/">will-change</a>17 来提升动画性能，本文不对此展开详细介绍，感兴趣的小伙伴可以点击链接进行查看。</p>
<p>最后需要注意的是，用户的设备可能并没有想象中的那么好，至少不会有我们的开发机器那么好。我们可以借助 Chrome 的开发者工具进行 CPU 降速，然后再进行相关的测试，降速方法如下图所示。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/21377586/1619103814193-4014d5ef-05ac-4229-9ec6-b66aba280a83.webp#clientId=ueedfa31e-e32c-4&from=paste&height=120&id=u7438009e&margin=%5Bobject%20Object%5D&originHeight=120&originWidth=612&originalType=url&status=done&style=none&taskId=u954f7140-b2bc-4ca8-9409-a3d525f1ff5&width=612"></p>
<p>如果需要在移动端访问的，最好将速度限制更低，因为移动端的性能往往更差。</p>
<h2 id="4-不要使用-import"><a href="#4-不要使用-import" class="headerlink" title="4. 不要使用@import "></a>4. 不要使用<a href="/import">@import </a></h2><p>最后提一下，不要使用@import 引入 CSS，相信大家也很少使用。</p>
<p>不建议使用@import 主要有以下两点原因。</p>
<p>首先，使用@import 引入 CSS 会影响浏览器的并行下载。使用@import 引用的 CSS 文件只有在引用它的那个 css 文件被下载、解析之后，浏览器才会知道还有另外一个 css 需要下载，这时才去下载，然后下载后开始解析、构建 render tree 等一系列操作。这就导致浏览器无法并行下载所需的样式文件。</p>
<p>其次，多个@import 会导致下载顺序紊乱。在 IE 中，@import 会引发资源文件的下载顺序被打乱，即<strong>排列在@import 后面的 js 文件先于@import 下载，并且打乱甚至破坏@import 自身的并行下载</strong>。</p>
<p>所以不要使用这一方法，使用 link 标签就行了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们介绍完了 CSS 性能优化的 4 个实践型技巧和 4 个建议型技巧，在了解这些技巧之后，CSS 的性能优化从现在就可以开始了。不要犹豫了，尽快开始吧。</p>
<h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>特别感谢@anjia(安佳)、@刘宇晨、@hxl(黄小璐)、@刘观宇的辛苦审校，感谢你们对于文章结构和内容提出的宝贵建议。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><blockquote>
</blockquote>
<blockquote>
<ol>
<li><a target="_blank" rel="noopener" href="https://css-tricks.com/efficiently-rendering-css/#article-header-id-4">Efficiently Rendering CSS</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.nextzy.me/how-to-write-css-for-a-great-performance-web-application-edf75bb8a8cc">How to write CSS for a great performance web application</a></li>
<li><a target="_blank" rel="noopener" href="https://benfrain.com/css-performance-revisited-selectors-bloat-expensive-styles/">CSS performance revisited: selectors, bloat and expensive styles</a></li>
<li><a target="_blank" rel="noopener" href="https://www.html5rocks.com/en/tutorials/speed/unnecessary-paints/">Avoiding Unnecessary Paints</a></li>
<li><a target="_blank" rel="noopener" href="https://www.sitepoint.com/five-css-performance-tools-speed-website/">Five CSS Performance Tools to Speed up Your Website</a></li>
<li><a target="_blank" rel="noopener" href="https://www.sitepoint.com/how-and-why-you-should-inline-your-critical-css/">How and Why You Should Inline Your Critical CSS</a></li>
<li><a target="_blank" rel="noopener" href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-blocking-css?hl=zh-cn">Render blocking css</a></li>
<li><a target="_blank" rel="noopener" href="https://www.filamentgroup.com/lab/async-css.html">Modern Asynchronous CSS Loading</a></li>
<li><a target="_blank" rel="noopener" href="https://www.w3.org/TR/preload/">Preload</a></li>
</ol>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Adam Blog</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">65</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Adam Blog</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
