<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="#HTTP3.0 和 QUIC 协议那些事 HTTP3.0 和 QUIC 协议那些事 写在前面  如果你的 App，在不需要任何修改的情况下就能提升 15% 以上的访问速度。特别是弱网络的时候能够提升 20% 以上的访问速度。 如果你的 App，在频繁切换 4G 和 WIFI 网络的情况下，不会断线，不需要重连，用户无任何感知。如果你的 App，既需要 TLS 的安全，也想实现 HTTP2 多路复">
<meta property="og:type" content="article">
<meta property="og:title" content="HTTP3.0和QUIC协议那些事">
<meta property="og:url" content="http://example.com/2021/04/25/yuque/HTTP3.0%E5%92%8CQUIC%E5%8D%8F%E8%AE%AE%E9%82%A3%E4%BA%9B%E4%BA%8B/index.html">
<meta property="og:site_name" content="Adam">
<meta property="og:description" content="#HTTP3.0 和 QUIC 协议那些事 HTTP3.0 和 QUIC 协议那些事 写在前面  如果你的 App，在不需要任何修改的情况下就能提升 15% 以上的访问速度。特别是弱网络的时候能够提升 20% 以上的访问速度。 如果你的 App，在频繁切换 4G 和 WIFI 网络的情况下，不会断线，不需要重连，用户无任何感知。如果你的 App，既需要 TLS 的安全，也想实现 HTTP2 多路复">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200922123003302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=BHt2w&originHeight=962&originWidth=828&originalType=binary&status=done&style=none">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200922123253603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=tAooz&originHeight=748&originWidth=1080&originalType=binary&status=done&style=none">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200922123855517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=tDBTF&originHeight=378&originWidth=548&originalType=binary&status=done&style=none">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200922124004308.png#pic_center#id=NQ3nM&originHeight=133&originWidth=308&originalType=binary&status=done&style=none">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200922124129106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#height=306&id=lfjni&originHeight=306&originWidth=357&originalType=binary&status=done&style=none&width=357">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200922124303607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=nq4cr&originHeight=305&originWidth=778&originalType=binary&status=done&style=none">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200922124452630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=oAWYE&originHeight=444&originWidth=812&originalType=binary&status=done&style=none">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200922135620387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=ptWhT&originHeight=377&originWidth=1011&originalType=binary&status=done&style=none">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200922135807354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=B4UBy&originHeight=692&originWidth=1080&originalType=binary&status=done&style=none">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200922124623833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=AsS3u&originHeight=226&originWidth=372&originalType=binary&status=done&style=none">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200922124649743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=hg0Cd&originHeight=239&originWidth=579&originalType=binary&status=done&style=none">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200922132748609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=oQp0N&originHeight=530&originWidth=1080&originalType=binary&status=done&style=none">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200922124817379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=pqC6c&originHeight=530&originWidth=748&originalType=binary&status=done&style=none">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200922125205577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=Vl5eN&originHeight=1020&originWidth=1356&originalType=binary&status=done&style=none">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200922125320566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=kzbFK&originHeight=1030&originWidth=1080&originalType=binary&status=done&style=none">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200922125908240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=NuSZa&originHeight=232&originWidth=1224&originalType=binary&status=done&style=none">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200922125953787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=ZYRgn&originHeight=722&originWidth=1080&originalType=binary&status=done&style=none">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200922130333415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=SOMdm&originHeight=723&originWidth=1080&originalType=binary&status=done&style=none">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200922133727910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=eVtip&originHeight=473&originWidth=1080&originalType=binary&status=done&style=none">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200922133916874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=UF0FI&originHeight=427&originWidth=1080&originalType=binary&status=done&style=none">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200922134146426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=ZMt3g&originHeight=312&originWidth=1080&originalType=binary&status=done&style=none">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200922134723577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=BEhaw&originHeight=816&originWidth=1080&originalType=binary&status=done&style=none">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200922134807851.png#pic_center#id=KPX6u&originHeight=41&originWidth=301&originalType=binary&status=done&style=none">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200922134824234.png#pic_center#id=k1B88&originHeight=41&originWidth=367&originalType=binary&status=done&style=none">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200922134848538.png#pic_center#id=JDhGD&originHeight=67&originWidth=301&originalType=binary&status=done&style=none">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200922135106709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=Lk09m&originHeight=442&originWidth=1080&originalType=binary&status=done&style=none">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200922135129300.png#pic_center#id=wNSZL&originHeight=37&originWidth=431&originalType=binary&status=done&style=none">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200922135146282.png#pic_center#id=fmXEv&originHeight=37&originWidth=610&originalType=binary&status=done&style=none">
<meta property="article:published_time" content="2021-04-25T09:04:07.000Z">
<meta property="article:modified_time" content="2021-05-02T12:01:28.385Z">
<meta property="article:author" content="Adam Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20200922123003302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=BHt2w&originHeight=962&originWidth=828&originalType=binary&status=done&style=none">

<link rel="canonical" href="http://example.com/2021/04/25/yuque/HTTP3.0%E5%92%8CQUIC%E5%8D%8F%E8%AE%AE%E9%82%A3%E4%BA%9B%E4%BA%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>HTTP3.0和QUIC协议那些事 | Adam</title>
  <meta name="referrer" content="no-referrer" />
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Adam</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/25/yuque/HTTP3.0%E5%92%8CQUIC%E5%8D%8F%E8%AE%AE%E9%82%A3%E4%BA%9B%E4%BA%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Adam Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Adam">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          HTTP3.0和QUIC协议那些事
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-25 17:04:07" itemprop="dateCreated datePublished" datetime="2021-04-25T17:04:07+08:00">2021-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-02 20:01:28" itemprop="dateModified" datetime="2021-05-02T20:01:28+08:00">2021-05-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>#HTTP3.0 和 QUIC 协议那些事</p>
<h1 id="HTTP3-0-和-QUIC-协议那些事"><a href="#HTTP3-0-和-QUIC-协议那些事" class="headerlink" title="HTTP3.0 和 QUIC 协议那些事"></a>HTTP3.0 和 QUIC 协议那些事</h1><ul>
<li>写在前面<blockquote>
<ul>
<li>如果你的 App，在不需要任何修改的情况下就能提升 15% 以上的访问速度。特别是弱网络的时候能够提升 20% 以上的访问速度。</li>
<li>如果你的 App，在频繁切换 4G 和 WIFI 网络的情况下，不会断线，不需要重连，用户无任何感知。如果你的 App，既需要 TLS 的安全，也想实现 HTTP2 多路复用的强大。</li>
<li>如果你刚刚才听说 HTTP2 是下一代互联网协议，如果你刚刚才关注到 TLS1.3 是一个革命性具有里程碑意义的协议，但是这两个协议却一直在被另一个更新兴的协议所影响和挑战。</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="一、HTTP2-0-和-HTTP3-0"><a href="#一、HTTP2-0-和-HTTP3-0" class="headerlink" title="一、HTTP2.0 和 HTTP3.0"></a>一、HTTP2.0 和 HTTP3.0</h2><blockquote>
<p>科技永不止步 -   我们都知道互联网中业务是不断迭代前进的，像 HTTP 这种重要的网络协议也是如此，新版本是对旧版本的扬弃。</p>
</blockquote>
<h3 id="1-1-HTTP2-0-和-TCP-的爱恨纠葛"><a href="#1-1-HTTP2-0-和-TCP-的爱恨纠葛" class="headerlink" title="1.1 HTTP2.0 和 TCP 的爱恨纠葛"></a>1.1 HTTP2.0 和 TCP 的爱恨纠葛</h3><p><code>**HTTP2.0**</code><strong>是 2015 年推出的，还是比较年轻的，</strong><code>**其重要的二进制分帧协议、多路复用、头部压缩、服务端推送等**</code><strong>重要优化使 HTTP 协议真正上了一个新台阶。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200922123003302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=BHt2w&originHeight=962&originWidth=828&originalType=binary&status=done&style=none"></p>
<blockquote>
<p>像谷歌这种重要的公司并没有满足于此，而且想继续提升 HTTP 的性能，花最少的时间和资源获取极致体验。<br>那么肯定要问 HTTP2.0 虽然性能已经不错了，还有什么不足吗？ <code>建立连接时间长(本质上是TCP的问题) ,队头阻塞问题</code> &gt; <code>移动互联网领域表现不佳(弱网环境</code>) …</p>
</blockquote>
<ul>
<li><strong>熟悉 HTTP2.0 协议的同学应该知道，这些缺点基本都是由于 TCP 协议引起的，水能载舟亦能覆舟，其实 TCP 也很无辜呀！</strong></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200922123253603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=tAooz&originHeight=748&originWidth=1080&originalType=binary&status=done&style=none"></p>
<ul>
<li><code>**在我们眼里，TCP是面向连接、可靠的传输层协议，当前几乎所有重要的协议和应用都是基于TCP来实现的。**</code></li>
<li><strong>网络环境的改变速度很快，但是 TCP 协议相对缓慢，正是这种矛盾促使谷歌做出了一个看似出乎意料的决定-</strong><code>**基于UDP来开发新一代HTTP协议**</code><strong>。</strong></li>
</ul>
<h3 id="1-2-谷歌为什么选择-UDP"><a href="#1-2-谷歌为什么选择-UDP" class="headerlink" title="1.2 谷歌为什么选择 UDP"></a>1.2 谷歌为什么选择 UDP</h3><p>上面提到，谷歌选择 UDP 是看似出乎意料的，仔细想一想其实很有道理。</p>
<p>我们单纯地看看 TCP 协议的不足和 UDP 的一些优点：</p>
<ul>
<li>基于 TCP 开发的设备和协议非常多，兼容困难</li>
<li>TCP 协议栈是 Linux 内部的重要部分，修改和升级成本很大</li>
<li>UDP 本身是无连接的、没有建链和拆链成本</li>
<li>UDP 的数据包无队头阻塞问题</li>
<li>UDP 改造成本小</li>
</ul>
<p>从上面的对比可以知道，<code>谷歌要想从TCP上进行改造升级绝非易事，但是UDP虽然没有TCP为了保证可靠连接而引发的问题，但是UDP本身不可靠，又不能直接用</code></p>
<p><img src="https://img-blog.csdnimg.cn/20200922123855517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=tDBTF&originHeight=378&originWidth=548&originalType=binary&status=done&style=none"></p>
<blockquote>
<p>综合而知，谷歌决定在 UDP 基础上改造一个具备 TCP 协议优点的新协议也就顺理成章了，这个新协议就是 QUIC 协议。</p>
</blockquote>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>1.3 QUIC 协议和 HTTP3.0</p>
<p>QUIC 其实是 Quick UDP Internet Connections 的缩写，直译为快速 UDP 互联网连接。</p>
<p><img src="https://img-blog.csdnimg.cn/20200922124004308.png#pic_center#id=NQ3nM&originHeight=133&originWidth=308&originalType=binary&status=done&style=none"></p>
<p>我们来看看维基百科对于 QUIC 协议的一些介绍：</p>
<blockquote>
<p>QUIC 协议最初由 Google 的 Jim Roskind 设计，实施并于 2012 年部署，在 2013 年随着实验的扩大而公开宣布，并向 IETF 进行了描述。<br>QUIC 提高了当前正在使用 TCP 的面向连接的 Web 应用程序的性能。它在两个端点之间使用用户数据报协议（UDP）建立多个复用连接来实现此目的。<br>QUIC 的次要目标包括减少连接和传输延迟，在每个方向进行带宽估计以避免拥塞。它还将拥塞控制算法移动到用户空间，而不是内核空间，此外使用前向纠错（FEC）进行扩展，以在出现错误时进一步提高性能。</p>
</blockquote>
<ul>
<li><strong>HTTP3.0 又称为 HTTP Over QUIC，其弃用 TCP 协议，改为使用基于 UDP 协议的 QUIC 协议来实现。</strong> <img src="https://img-blog.csdnimg.cn/20200922124129106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#height=306&id=lfjni&originHeight=306&originWidth=357&originalType=binary&status=done&style=none&width=357"></li>
</ul>
<h2 id="二、QUIC-详解"><a href="#二、QUIC-详解" class="headerlink" title="二、QUIC 详解"></a>二、QUIC 详解</h2><p>择其善者而从之，其不善者而改之。</p>
<ul>
<li><code>**HTTP3.0既然选择了QUIC协议，也就意味着HTTP3.0基本继承了HTTP2.0的强大功能，并且进一步解决了HTTP2.0存在的一些问题，同时必然引入了新的问题**</code></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200922124303607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=nq4cr&originHeight=305&originWidth=778&originalType=binary&status=done&style=none"> QUIC 协议必须要实现 HTTP2.0 在 TCP 协议上的重要功能，同时解决遗留问题，我们来看看 QUIC 是如何实现的。</p>
<h3 id="2-1-队头阻塞问题"><a href="#2-1-队头阻塞问题" class="headerlink" title="2.1 队头阻塞问题"></a>2.1 队头阻塞问题</h3><ul>
<li><p><code>**队头阻塞 Head-of-line blocking（缩写为HOL blocking）是计算机网络中是一种性能受限的现象**</code><strong>，通俗来说就是：</strong><code>**一个数据包影响了一堆数据包，它不来大家都走不了**</code><strong>。</strong></p>
</li>
<li><p><code>队头阻塞问题可能存在于HTTP层和TCP层，在HTTP1.x时两个层次都存在该问题</code>。 <img src="https://img-blog.csdnimg.cn/20200922124452630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=oAWYE&originHeight=444&originWidth=812&originalType=binary&status=done&style=none"></p>
</li>
<li><p><code>**HTTP2.0协议的多路复用机制解决了HTTP层的队头阻塞问题，但是在TCP层仍然存在队头阻塞问题。**</code></p>
</li>
<li><p><code>**TCP协议在收到数据包之后，这部分数据可能是乱序到达的，但是TCP必须将所有数据收集排序整合后给上层使用，如果其中某个包丢失了，就必须等待重传，从而出现某个丢包数据阻塞整个连接的数据使用。**</code></p>
</li>
<li><p>多路复用是 HTTP2 最强大的特性 ，能够将多条请求在一条 TCP 连接上同时发出去。但也恶化了 TCP 的一个问题，队头阻塞 ，如下图示： <img src="https://img-blog.csdnimg.cn/20200922135620387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=ptWhT&originHeight=377&originWidth=1011&originalType=binary&status=done&style=none"></p>
</li>
<li><p><strong>HTTP2 在一个 TCP 连接上同时发送 4 个 Stream。其中 Stream1 已经正确到达，并被应用层读取</strong>。</p>
</li>
<li><p><code>但是 Stream2 的第三个 tcp segment 丢失了，TCP 为了保证数据的可靠性，需要发送端重传第 3 个 segment 才能通知应用层读取接下去的数据，虽然这个时候 Stream3 和 Stream4 的全部数据已经到达了接收端，但都被阻塞住了</code>。</p>
</li>
<li><p><code>不仅如此，由于 HTTP2 强制使用 TLS，还存在一个 TLS 协议层面的队头阻塞</code> <img src="https://img-blog.csdnimg.cn/20200922135807354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=B4UBy&originHeight=692&originWidth=1080&originalType=binary&status=done&style=none"></p>
</li>
<li><p><strong>QUIC 的多路复用和 HTTP2 类似。</strong><code>**在一条 QUIC 连接上可以并发发送多个 HTTP 请求 (stream)**</code><strong>。但是 QUIC 的多路复用相比 HTTP2 有一个很大的优势</strong>。</p>
</li>
<li><p><code>**QUIC 一个连接上的多个 stream 之间没有依赖。这样假如 stream2 丢了一个 udp packet，也只会影响 stream2 的处理。不会影响 stream2 之前及之后的 stream 的处理**</code><strong>。</strong> -   这也就在很大程度上缓解甚至消除了队头阻塞的影响。</p>
</li>
<li><p><strong>QUIC 协议是基于 UDP 协议实现的，</strong><code>**在一条链接上可以有多个流，流与流之间是互不影响的，当一个流出现丢包影响范围非常小，从而解决队头阻塞**</code><strong>问题</strong></p>
</li>
</ul>
<h3 id="2-2-0RTT-建链"><a href="#2-2-0RTT-建链" class="headerlink" title="2.2 0RTT 建链"></a>2.2 0RTT 建链</h3><ul>
<li><code>**衡量网络建链的常用指标是RTT Round-Trip Time，也就是数据包一来一回的时间消耗。**</code> <img src="https://img-blog.csdnimg.cn/20200922124623833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=AsS3u&originHeight=226&originWidth=372&originalType=binary&status=done&style=none"></li>
<li><code>**RTT包括三部分：往返传播时延、网络设备内排队时延、应用程序数据处理时延。**</code> <img src="https://img-blog.csdnimg.cn/20200922124649743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=hg0Cd&originHeight=239&originWidth=579&originalType=binary&status=done&style=none"></li>
<li><strong>一般来说 HTTPS 协议要建立完整链接包括:TCP 握手和 TLS 握手，总计需要至少 2-3 个 RTT，普通的 HTTP 协议也需要至少 1 个 RTT 才可以完成握手。</strong></li>
<li><strong>然而，</strong><code>**QUIC协议可以实现在第一个包就可以包含有效的应用数据，从而实现0RTT，但这也是有条件**</code><strong>的。</strong> - 0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势。那什么是 0RTT 建连呢？这里面有两层含义。</li>
<li><code>传输层 0RTT 就能建立连接</code></li>
<li><code>加密层 0RTT 就能建立加密连接</code> <img src="https://img-blog.csdnimg.cn/20200922132748609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=oQp0N&originHeight=530&originWidth=1080&originalType=binary&status=done&style=none"></li>
</ul>
<blockquote>
<ul>
<li>比如上图左边是 HTTPS 的一次完全握手的建连过程，需要 3 个 RTT。就算是 Session Resumption，也需要至少 2 个 RTT。</li>
<li>而 QUIC 呢？由于建立在 UDP 的基础上，同时又实现了 0RTT 的安全握手，所以在大部分情况下，只需要 0 个 RTT 就能实现数据发送，在实现前向加密 的基础上，并且 0RTT 的成功率相比 TLS 的 Sesison Ticket 要高很多。</li>
</ul>
</blockquote>
<ul>
<li>简单来说，<code>基于TCP协议和TLS协议的HTTP2.0在真正发送数据包之前需要花费一些时间来完成握手和加密协商，完成之后才可以真正传输业务数据</code>。</li>
<li><strong>但是 QUIC 则第一个数据包就可以发业务数据，从而在连接延时有很大优势，可以节约数百毫秒的时间。</strong></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200922124817379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=pqC6c&originHeight=530&originWidth=748&originalType=binary&status=done&style=none"></p>
<ul>
<li><strong>QUIC 的 0RTT 也是需要条件的，</strong><code>**对于第一次交互的客户端和服务端0RTT也是做不到的**</code><strong>，毕竟双方完全陌生。</strong>- <strong>因此，QUIC 协议可以分为首次连接和非首次连接，两种情况进行讨论。</strong></li>
</ul>
<h4 id="2-2-1-首次连接和非首次连接"><a href="#2-2-1-首次连接和非首次连接" class="headerlink" title="2.2.1 首次连接和非首次连接"></a>2.2.1 首次连接和非首次连接</h4><ul>
<li><code>**使用QUIC协议的客户端和服务端要使用1RTT进行密钥交换，使用的交换算法是DH(Diffie-Hellman)迪菲-赫尔曼算法。**</code></li>
</ul>
<h4 id="2-2-2-首次连接"><a href="#2-2-2-首次连接" class="headerlink" title="2.2.2 首次连接"></a>2.2.2 首次连接</h4><ul>
<li>简单来说一下，<code>**首次连接时客户端和服务端的密钥协商和数据传输过程**</code>，其中涉及了 DH 算法的基本过程： <img src="https://img-blog.csdnimg.cn/20200922125205577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=Vl5eN&originHeight=1020&originWidth=1356&originalType=binary&status=done&style=none"> <img src="https://img-blog.csdnimg.cn/20200922125320566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=kzbFK&originHeight=1030&originWidth=1080&originalType=binary&status=done&style=none"></li>
</ul>
<h4 id="2-2-3-非首次连接"><a href="#2-2-3-非首次连接" class="headerlink" title="2.2.3 非首次连接"></a>2.2.3 非首次连接</h4><ul>
<li><code>**前面提到客户端和服务端首次连接时服务端传递了config包，里面包含了服务端公钥和两个随机数，客户端会将config存储下来，后续再连接时可以直接使用，从而跳过这个1RTT，实现0RTT的业务数据交互**</code><strong>。</strong>- <code>**客户端保存config是有时间期限的，在config失效之后仍然需要进行首次连接时的密钥交换。**</code></li>
</ul>
<h3 id="2-3-前向安全问题"><a href="#2-3-前向安全问题" class="headerlink" title="2.3 前向安全问题"></a>2.3 前向安全问题</h3><p>前向安全是密码学领域的专业术语，看下百度上的解释：</p>
<blockquote>
<ul>
<li><code>前向安全或前向保密Forward Secrecy是密码学中通讯协议的安全属性，指的是长期使用的主密钥泄漏不会导致过去的会话密钥泄漏</code>。</li>
<li><code>前向安全能够保护过去进行的通讯不受密码或密钥在未来暴露的威胁，如果系统具有前向安全性，就可以保证在主密钥泄露时历史通讯的安全，即使系统遭到主动攻击也是如此</code></li>
</ul>
</blockquote>
<p><strong>通俗来说，</strong><code>**前向安全指的是密钥泄漏也不会让之前加密的数据被泄漏，影响的只有当前，对之前的数据无影响**</code><strong>。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200922125908240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=NuSZa&originHeight=232&originWidth=1224&originalType=binary&status=done&style=none"> <img src="https://img-blog.csdnimg.cn/20200922125953787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=ZYRgn&originHeight=722&originWidth=1080&originalType=binary&status=done&style=none"></p>
<h3 id="2-4-前向纠错"><a href="#2-4-前向纠错" class="headerlink" title="2.4 前向纠错"></a>2.4 前向纠错</h3><p>前向纠错是通信领域的术语，看下百科的解释：</p>
<ul>
<li>前向纠错也叫前向纠错码 Forward Error Correction 简称 FEC;<code>是增加数据通讯可信度的方法，在单向通讯信道中，一旦错误被发现，其接收器将无权再请求传输</code>。- FEC 是利用数据进行传输冗余信息的方法，当传输中出现错误，将允许接收器再建数据。</li>
<li>听这段描述就是做校验的，看看 QUIC 协议是如何实现的：</li>
<li><code>**QUIC每发送一组数据就对这组数据进行异或运算，并将结果作为一个FEC包发送出去，接收方收到这一组数据后根据数据包和FEC包即可进行校验和纠错**</code>。</li>
</ul>
<h3 id="2-5-连接迁移"><a href="#2-5-连接迁移" class="headerlink" title="2.5 连接迁移"></a>2.5 连接迁移</h3><p>网络切换几乎无时无刻不在发生。</p>
<ul>
<li><code>TCP协议使用五元组来表示一条唯一的连接，当我们从4G环境切换到wifi环境时，手机的IP地址就会发生变化，这时必须创建新的TCP连接才能继续传输数据</code>。</li>
<li><strong>QUIC 协议基于 UDP 实现摒弃了五元组的概念，使用 64 位的随机数作为连接的 ID，并使用该 ID 表示连接。</strong></li>
<li><code>基于QUIC协议之下，我们在日常wifi和4G切换时，或者不同基站之间切换都不会重连，从而提高业务层的体验。</code></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200922130333415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=SOMdm&originHeight=723&originWidth=1080&originalType=binary&status=done&style=none"></p>
<h3 id="2-6-改进的拥塞控制"><a href="#2-6-改进的拥塞控制" class="headerlink" title="2.6 改进的拥塞控制"></a>2.6 改进的拥塞控制</h3><ul>
<li><code>**TCP 的拥塞控制实际上包含了四个算法：慢启动，拥塞避免，快速重传，快速恢复**</code> -  QUIC 协议当前默认使用了 TCP 协议的 Cubic 拥塞控制算法 ，同时也支持 CubicBytes, Reno, RenoBytes, BBR, PCC 等拥塞控制算法。</li>
<li><code>从拥塞算法本身来看，QUIC 只是按照 TCP 协议重新实现了一遍</code>，那么 QUIC 协议到底改进在哪些方面呢？主要有如下几点：</li>
</ul>
<h4 id="2-6-1-可插拔"><a href="#2-6-1-可插拔" class="headerlink" title="2.6.1 可插拔"></a>2.6.1 可插拔</h4><p>什么叫可插拔呢？<code>就是能够非常灵活地生效，变更和停止</code>,体现在如下方面：</p>
<ul>
<li><code>**应用程序层面就能实现不同的拥塞控制算法，不需要操作系统，不需要内核支持**</code><strong>。这是一个飞跃，因为</strong><code>**传统的 TCP 拥塞控制，必须要端到端的网络协议栈支持，才能实现控制效果**</code><strong>。而内核和操作系统的部署成本非常高，升级周期很长，这在产品快速迭代，网络爆炸式增长的今天，显然有点满足不了需求。</strong></li>
<li><strong>即使是单个应用程序的不同连接也能支持配置不同的拥塞控制。就算是一台服务器，接入的用户网络环境也千差万别，结合大数据及人工智能处理，我们能为各个用户提供不同的但又更加精准更加有效的拥塞控制。比如 BBR 适合，Cubic 适合。</strong></li>
<li><code>**应用程序不需要停机和升级就能实现拥塞控制的变更**</code><strong>，我们在服务端只需要修改一下配置，reload 一下，</strong><code>**完全不需要停止服务就能实现拥塞控制的切换**</code><strong>。STGW 在配置层面进行了优化，我们可以针对不同业务，不同网络制式，甚至不同的 RTT，使用不同的拥塞控制算法。</strong></li>
</ul>
<h4 id="2-6-2-单调递增的-Packet-Number"><a href="#2-6-2-单调递增的-Packet-Number" class="headerlink" title="2.6.2 单调递增的 Packet Number"></a>2.6.2 单调递增的 Packet Number</h4><ul>
<li><code>**TCP 为了保证可靠性，使用了基于字节序号的 Sequence Number 及 Ack 来确认消息的有序到达。**</code></li>
<li><code>**QUIC**</code>** 同样是一个可靠的协议，它**<code>**使用 Packet Number 代替了 TCP 的 sequence number，并且每个 Packet Number 都严格递增**</code><strong>，也就是说</strong><code>**就算 Packet N 丢失了，重传的 Packet N 的 Packet Number 已经不是 N，而是一个比 N 大的值**</code><strong>。</strong></li>
<li><strong>而 TCP 呢，重传 segment 的 sequence number 和原始的 segment 的 Sequence Number 保持不变，也正是由于这个特性，引入了 Tcp 重传的歧义问题</strong></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200922133727910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=eVtip&originHeight=473&originWidth=1080&originalType=binary&status=done&style=none"></p>
<ul>
<li><strong>如上图所示，超时事件 RTO 发生后，</strong><code>**客户端发起重传**</code><strong>，然后接收到了 Ack 数据。</strong><code>**由于序列号一样，这个 Ack 数据到底是原始请求的响应还是重传请求的响应呢？不好判断**</code><strong>。</strong></li>
<li>如果<code>算成原始请求的响应，但实际上是重传请求的响应（上图左），会导致采样 RTT 变大。如果算成重传请求的响应，但实际上是原始请求的响应，又很容易导致采样 RTT 过小</code>。</li>
<li><code>**由于 Quic 重传的 Packet 和原始 Packet 的 Pakcet Number 是严格递增的，所以很容易就解决了这个问题。**</code></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200922133916874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=UF0FI&originHeight=427&originWidth=1080&originalType=binary&status=done&style=none"></p>
<ul>
<li><code>如上图所示，RTO 发生后，根据重传的 Packet Number 就能确定精确的 RTT 计算。如果 Ack 的 Packet Number 是 N+M，就根据重传请求计算采样 RTT。如果 Ack 的 Pakcet Number 是 N，就根据原始请求的时间计算采样 RTT，没有歧义性</code>。</li>
<li><strong>但是单纯依靠严格递增的 Packet Number 肯定是无法保证数据的顺序性和可靠性。QUIC 又引入了一个 <strong><code>**Stream Offset**</code></strong> 的概念。</strong></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200922134146426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=ZMt3g&originHeight=312&originWidth=1080&originalType=binary&status=done&style=none"></p>
<ul>
<li>即<code>一个 Stream 可以经过多个 Packet 传输，Packet Number 严格递增，没有依赖</code>。<blockquote>
<ul>
<li>Packet 里的 Payload 如果是 Stream 的话，就需要依靠 Stream 的 Offset 来保证应用数据的顺序。</li>
<li>如图所示，发送端先后发送了 Pakcet N 和 Pakcet N+1，Stream 的 Offset 分别是 x 和 x+y。</li>
<li>假设 Packet N 丢失了，发起重传，重传的 Packet Number 是 N+2，但是它的 Stream 的 Offset 依然是 x，这样就算 Packet N + 2 是后到的，依然可以将 Stream x 和 Stream x+y 按照顺序组织起来，交给应用程序处理。</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="2-6-3-不允许-Reneging"><a href="#2-6-3-不允许-Reneging" class="headerlink" title="2.6.3 不允许 Reneging"></a>2.6.3 不允许 Reneging</h4><ul>
<li><code>**什么叫 Reneging 呢？就是接收方丢弃已经接收并且上报给 SACK 选项的内容 。TCP 协议不鼓励这种行为，但是协议层面允许这样的行为。主要是考虑到服务器资源有限，比如 Buffer 溢出，内存不够等情况。**</code></li>
<li><strong>Reneging 对数据重传会产生很大的干扰。因为 Sack 都已经表明接收到了，但是接收端事实上丢弃了该数据</strong>。</li>
<li><code>QUIC 在协议层面禁止 Reneging，一个 Packet 只要被 Ack，就认为它一定被正确接收，减少了这种干扰</code>。</li>
</ul>
<h4 id="2-6-4-更多的-Ack-块"><a href="#2-6-4-更多的-Ack-块" class="headerlink" title="2.6.4 更多的 Ack 块"></a>2.6.4 更多的 Ack 块</h4><ul>
<li><strong>TCP 的 Sack 选项能够告诉发送方已经接收到的连续 Segment 的范围，方便发送方进行选择性重传。</strong> -   <code>由于 TCP 头部最大只有 60 个字节，标准头部占用了 20 字节，所以 Tcp Option 最大长度只有 40 字节，再加上 Tcp Timestamp option 占用了 10 个字节 ，所以留给 Sack 选项的只有 30 个字节</code>。</li>
<li><strong>每一个 Sack Block 的长度是 8 个，加上 Sack Option 头部 2 个字节，也就意味着 Tcp Sack Option 最大只能提供 3 个 Block</strong>。</li>
<li><code>但是 Quic Ack Frame 可以同时提供 256 个 Ack Block，在丢包率比较高的网络下，更多的 Sack Block 可以提升网络的恢复速度，减少重传量</code>。</li>
</ul>
<h4 id="2-6-5-Ack-Delay-时间"><a href="#2-6-5-Ack-Delay-时间" class="headerlink" title="2.6.5 Ack Delay 时间"></a>2.6.5 Ack Delay 时间</h4><ul>
<li><code>**Tcp 的 Timestamp 选项存在一个问题 ，它只是回显了发送方的时间戳，但是没有计算接收端接收到 segment 到发送 Ack 该 segment 的时间。这个时间可以简称为 Ack Delay。**</code></li>
<li>这样就会导致 RTT 计算误差。如下图：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200922134723577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=BEhaw&originHeight=816&originWidth=1080&originalType=binary&status=done&style=none"></p>
<ul>
<li>可以认为 TCP 的 RTT 计算： <img src="https://img-blog.csdnimg.cn/20200922134807851.png#pic_center#id=KPX6u&originHeight=41&originWidth=301&originalType=binary&status=done&style=none"></li>
<li>而 Quic 计算如下： <img src="https://img-blog.csdnimg.cn/20200922134824234.png#pic_center#id=k1B88&originHeight=41&originWidth=367&originalType=binary&status=done&style=none"></li>
</ul>
<blockquote>
<ul>
<li>当然 RTT 的具体计算没有这么简单，需要采样，参考历史数值进行平滑计算，参考如下公式:</li>
</ul>
</blockquote>
<blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200922134848538.png#pic_center#id=JDhGD&originHeight=67&originWidth=301&originalType=binary&status=done&style=none"></p>
</blockquote>
<h4 id="2-6-6-基于-stream-和-connecton-级别的流量控制"><a href="#2-6-6-基于-stream-和-connecton-级别的流量控制" class="headerlink" title="2.6.6 基于 stream 和 connecton 级别的流量控制"></a>2.6.6 基于 stream 和 connecton 级别的流量控制</h4><ul>
<li>QUIC 的流量控制 类似 HTTP2，<code>即在 Connection 和 Stream 级别提供了两种流量控制</code>。为什么需要两类流量控制呢？主要是因为 QUIC 支持多路复用。</li>
<li>Stream 可以认为就是一条 HTTP 请求。</li>
<li>Connection 可以类比一条 TCP 连接。</li>
<li><strong>多路复用意味着在一条 Connetion 上会同时存在多条 Stream。既需要对单个 Stream 进行控制，又需要针对所有 Stream 进行总体控制。</strong></li>
</ul>
<p>QUIC 实现流量控制的原理比较简单：</p>
<ul>
<li><code>通过 window_update 帧告诉对端自己可以接收的字节数，这样发送方就不会发送超过这个数量的数据</code>。- <strong>通过 BlockFrame 告诉对端由于流量控制被阻塞了，无法发送数据</strong>。</li>
<li><code>QUIC 的流量控制和 TCP 有点区别，TCP 为了保证可靠性，窗口左边沿向右滑动时的长度取决于已经确认的字节数。如果中间出现丢包，就算接收到了更大序号的 Segment，窗口也无法超过这个序列号</code>。</li>
<li><strong>但 QUIC 不同，就算此前有些 packet 没有接收到，它的滑动只取决于接收到的最大偏移字节数。</strong></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200922135106709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvbGZHdWlEYW8=,size_16,color_FFFFFF,t_70#pic_center#id=Lk09m&originHeight=442&originWidth=1080&originalType=binary&status=done&style=none"></p>
<ul>
<li>针对 Stream：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200922135129300.png#pic_center#id=wNSZL&originHeight=37&originWidth=431&originalType=binary&status=done&style=none"><br>针对 Connection：<br><img src="https://img-blog.csdnimg.cn/20200922135146282.png#pic_center#id=fmXEv&originHeight=37&originWidth=610&originalType=binary&status=done&style=none"><br>同样地，STGW 也在连接和 Stream 级别设置了不同的窗口数。</p>
<p>最重要的是，我们可以在内存不足或者上游处理性能出现问题时，通过流量控制来限制传输速率，保障服务可用性。</p>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>QUIC 协议 存在的意义在于解决 TCP 协议的一些无法解决的痛点</p>
<ul>
<li><code>多次握手</code>：TCP 协议需要三次握手建立连接，而如果需要 TLS 证书的交换，那么则需要更多次的握手才能建立可靠连接，这在如今长肥网络的趋势下是一个巨大的痛点</li>
<li><code>队头阻塞</code>：TCP 协议下，如果出现丢包，则一条连接将一直被阻塞等待该包的重传，即使后来的数据包可以被缓存，但也无法被递交给应用层去处理。</li>
<li><code>无法判断一个 ACK 是重传包的 ACK 还是原本包的 ACK</code>：比如 一个包 seq=1, 超时重传的包同样是 seq=1，这样在收到一个 ack=1 之后，我们无法判断这个 ack 是对之前的包的 ack 还是对重传包的 ack，这会导致我们对 RTT 的估计出现误差，无法提供更准确的拥塞控制</li>
<li><code>无法进行连接迁移</code>：<strong>一条连接由一个四元组标识，在当今移动互联网的时代，如果一台手机从一个 wifi 环境切换到另一个 wifi 环境，ip 发生变化，那么连接必须重新建立，inflight 的包全部丢失。</strong></li>
</ul>
<p>现在我们给出一个 QUIC 协议的 Overview</p>
<ul>
<li><code>更好的连接建立方式</code></li>
<li><code>更好的拥塞控制</code></li>
<li><code>没有队头阻塞的多路复用</code></li>
<li><code>前向纠错</code></li>
<li><code>连接迁移</code></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/04/25/yuque/HTTP2.0/" rel="prev" title="HTTP2.0">
      <i class="fa fa-chevron-left"></i> HTTP2.0
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/04/25/yuque/websocket%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%8A%A5%E6%96%87%E5%88%86%E6%9E%90/" rel="next" title="websocket协议详解及报文分析">
      websocket协议详解及报文分析 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#HTTP3-0-%E5%92%8C-QUIC-%E5%8D%8F%E8%AE%AE%E9%82%A3%E4%BA%9B%E4%BA%8B"><span class="nav-number">1.</span> <span class="nav-text">HTTP3.0 和 QUIC 协议那些事</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81HTTP2-0-%E5%92%8C-HTTP3-0"><span class="nav-number">1.1.</span> <span class="nav-text">一、HTTP2.0 和 HTTP3.0</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-HTTP2-0-%E5%92%8C-TCP-%E7%9A%84%E7%88%B1%E6%81%A8%E7%BA%A0%E8%91%9B"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1 HTTP2.0 和 TCP 的爱恨纠葛</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E8%B0%B7%E6%AD%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9-UDP"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2 谷歌为什么选择 UDP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.1.3.</span> <span class="nav-text"></span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81QUIC-%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.2.</span> <span class="nav-text">二、QUIC 详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E%E9%97%AE%E9%A2%98"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1 队头阻塞问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-0RTT-%E5%BB%BA%E9%93%BE"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 0RTT 建链</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-%E9%A6%96%E6%AC%A1%E8%BF%9E%E6%8E%A5%E5%92%8C%E9%9D%9E%E9%A6%96%E6%AC%A1%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">2.2.1 首次连接和非首次连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-%E9%A6%96%E6%AC%A1%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">2.2.2 首次连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-%E9%9D%9E%E9%A6%96%E6%AC%A1%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">2.2.3 非首次连接</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E5%89%8D%E5%90%91%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3 前向安全问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E5%89%8D%E5%90%91%E7%BA%A0%E9%94%99"><span class="nav-number">1.2.4.</span> <span class="nav-text">2.4 前向纠错</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E8%BF%9E%E6%8E%A5%E8%BF%81%E7%A7%BB"><span class="nav-number">1.2.5.</span> <span class="nav-text">2.5 连接迁移</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-%E6%94%B9%E8%BF%9B%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">1.2.6.</span> <span class="nav-text">2.6 改进的拥塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-1-%E5%8F%AF%E6%8F%92%E6%8B%94"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">2.6.1 可插拔</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-2-%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84-Packet-Number"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">2.6.2 单调递增的 Packet Number</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-3-%E4%B8%8D%E5%85%81%E8%AE%B8-Reneging"><span class="nav-number">1.2.6.3.</span> <span class="nav-text">2.6.3 不允许 Reneging</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-4-%E6%9B%B4%E5%A4%9A%E7%9A%84-Ack-%E5%9D%97"><span class="nav-number">1.2.6.4.</span> <span class="nav-text">2.6.4 更多的 Ack 块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-5-Ack-Delay-%E6%97%B6%E9%97%B4"><span class="nav-number">1.2.6.5.</span> <span class="nav-text">2.6.5 Ack Delay 时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-6-%E5%9F%BA%E4%BA%8E-stream-%E5%92%8C-connecton-%E7%BA%A7%E5%88%AB%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-number">1.2.6.6.</span> <span class="nav-text">2.6.6 基于 stream 和 connecton 级别的流量控制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93"><span class="nav-number">1.3.</span> <span class="nav-text">三、总结</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Adam Blog</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">65</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Adam Blog</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
